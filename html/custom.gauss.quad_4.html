<div class="container">

<table style="width: 100%;"><tr>
<td>moments</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Moments Computed in Multiple Precision Using the Package Rmpfr</h2>

<h3>Description</h3>

<p>This module computes the <code>r</code>'th moment
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{\infty} x^r f(x) dx,</code>
</p>

<p>where <code class="reqn">f</code> is the weight function (specified by the list <code>which.f</code>), for any nonnegative integer <code>r</code> using <code>nbits</code> bits of precision for its computation, via the <code>R</code> package <code>Rmpfr</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">moments(which.f, r, nbits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>which.f</code></td>
<td>
<p>a list specifying the nonnegative integrable
weight function <code class="reqn">f</code>, with the following 3 components:
(i)  name (in the form of a character string),
(ii) support specified by a 2-vector of the endpoints of the interval,
(iii)  parameter vector when <code class="reqn">f</code> belongs to a family of
weight functions and is specified by the value of this
parameter vector (if <code class="reqn">f</code> is already fully specified
then the parameter vector is set to <code>NULL</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>nonnegative integer, specifying that it is the <code>r</code>'th moment for the weight function <code class="reqn">f</code> that is to be computed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbits</code></td>
<td>
<p>number of bits in the multiple precision numbers used by the <code>R</code> package <code>Rmpfr</code>
to carry out the computation of the <code>r</code>'th moment</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose, for example, that we wish to find the Gauss quadrature nodes and weights
for the weight function <code class="reqn">f</code> that is the probability density function of a random
variable with the same distribution as <code class="reqn">R/m^{1/2}</code> where <code class="reqn">R</code> has a
<code class="reqn">\chi_m</code> distribution (i.e. <code class="reqn">R^2</code> has a <code class="reqn">\chi_m^2</code> distribution).
In this case, the <code>r</code>'th moment is
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{\infty} x^r f(x) dx
    = \left(\frac{2}{m} \right)^{r/2}
    \frac{\Gamma((r+m)/2)}{\Gamma(m/2)},</code>
</p>

<p>which can be computed to an arbitrary number of bits of precision
<code>nbits</code> using the <code>R</code> package <code>Rmpfr</code>.
In this case, we specify this weight function <code class="reqn">f</code> by first
assigning the value of <code>m</code> and then using the <code>R</code> command
</p>
<p><code>which.f &lt;- list(name="scaled.chi.pdf", support=c(0, Inf), parameters=m)</code>
</p>
<p>The code within the function <code>moments</code> used to compute the
<code class="reqn">r</code>'th moment, to an arbitrary number of bits of precision
<code>nbits</code> using the package <code>Rmpfr</code>, is listed in the
Examples section.
</p>


<h3>Value</h3>

<p>The <code>r</code>'th moment with number of bits of precision
<code>nbits</code> used in its computation, via the <code>R</code> package <code>Rmpfr</code>
</p>


<h3>See Also</h3>

<p><code>custom</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The code for the function moments must include a section
# that computes the r th moment to an arbitrary number of bits
# of precision nbits using the R package Rmpfr for the particular
# weight function f of interest.
# Suppose that the weight function f is the probability density
# function of a random variable with the same probability
# distribution as R divided by the square root of m, where R has a
# chi distribution with m degrees of freedom.
# The code for the function moments includes the following:
#
#    if (which.f$name == "scaled.chi.pdf"){
#    m &lt;- which.f$parameters
#    if (r == 0){
#    return(mpfr(1, nbits))
#    }
#    mp.2 &lt;- mpfr(2, nbits)
#    mp.r &lt;- mpfr(r, nbits)
#    mp.m &lt;- mpfr(m, nbits)
#    term1 &lt;- (mp.r/ mp.2) * log(mp.2 / mp.m)
#    term2 &lt;- lgamma((mp.r + mp.m) / mp.2)
#    term3 &lt;- lgamma(mp.m / mp.2)
#    return(exp(term1 + term2 - term3))
#    }

</code></pre>


</div>