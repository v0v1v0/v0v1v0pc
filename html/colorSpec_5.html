<div class="container">

<table style="width: 100%;"><tr>
<td>actinometric</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>convert a colorSpec object to be actinometric</h2>

<h3>Description</h3>

<p>Convert a radiometric <b>colorSpec</b> object to have
quantity that is actinometric (number of photons).
Test an object for whether it is actinometric.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'colorSpec'
actinometric( x, multiplier=1, warn=FALSE )

## S3 method for class 'colorSpec'
is.actinometric( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiplier</code></td>
<td>
<p>a scalar which is multiplied by the output, and intended for unit conversion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>if <code>TRUE</code> and a conversion actually takes place, the a <code>WARN</code> message is issued.
This makes the user aware of the conversion, so units can be verified.  This can be useful when <code>actinometric()</code> is called from another <b>colorSpec</b> function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the <code>quantity</code> of <code>x</code> does not start with <code>'energy'</code>
then the quantity is not radiometric and so <code>x</code> is returned unchanged.
Otherwise <code>x</code> is radiometric (energy-based), and must be converted.
</p>
<p>If <code>type(x)</code> is <code>'light'</code> then
the most common radiometric energy unit is joule.<br>
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> Q = E * \lambda * 10^6 / (N_A * h * c)</code>
</p>

<p>wher <code class="reqn">Q</code> is the photon count,
<code class="reqn">E</code> is the energy of the photons,
<code class="reqn">N_A</code> is Avogadro's constant,
<code class="reqn">h</code> is Planck's constant, <code class="reqn">c</code> is the speed of light,
and <code class="reqn">\lambda</code> is the wavelength.
The output unit of photon count is
(<code class="reqn">\mu</code>mole of photons) = (<code class="reqn">6.02214 * 10^{17}</code> photons).
If a different unit for <code>Q</code> is desired, 
then the output should be scaled appropriately.
For example, if the desired unit of photon count is exaphotons,
then set <code>multiplier=0.602214</code>.
</p>
<p>If the <code>quantity(x)</code> is <code>'energy-&gt;electrical'</code>,
then the most common radiometric unit of responsivity to light
is coulombs/joule (C/J) or  amps/watt (A/W).
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> QE = R_e * ((h * c)/e) / \lambda </code>
</p>

<p>where <code class="reqn">QE</code> is the quantum efficiency,
<code class="reqn">R_e</code> is the energy-based responsivity,
and <code class="reqn">e</code> is the charge of an electron (in C).<br>
If the unit of <code>x</code> is not C/J, 
then <code>multiplier</code> should be set appropriately.
</p>
<p>If the <code>quantity(x)</code> is 
<code>'energy-&gt;neural'</code> or  <code>'energy-&gt;action'</code>,
the most common radiometric unit of energy is joule (J).
</p>
<p>The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> R_p = R_e  * 10^{-6} * ( N_A * h * c) / \lambda </code>
</p>

<p>where <code class="reqn">R_p</code> is the photon-based responsivity,
and <code class="reqn">R_e</code> is the energy-based responsivity,
The output unit of photon count is
(<code class="reqn">\mu</code>mole of photons) = (<code class="reqn">6.02214 * 10^{17}</code> photons).
This essentially the reciprocal of the first conversion equation.
</p>
<p>The argument <code>multiplier</code> is applied to the right side of all the above
conversion equations.
</p>


<h3>Value</h3>

<p><code>actinometric()</code> returns a <b>colorSpec</b> object
with <code>quantity</code> that is
actinometric (photon-based) and not radiometric (energy-based).
If <code>type(x)</code> is a material type
(<code>'material'</code> or <code>'responsivity.material'</code>)
then <code>x</code> is returned unchanged.
</p>
<p>If <code>quantity(x)</code> starts with <code>'photons'</code>,
then <code>is.actinometric()</code> returns <code>TRUE</code>, and otherwise <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>To log the executed conversion equation,
execute <code>cs.options(loglevel='INFO')</code>.
</p>


<h3>Source</h3>

<p>Wikipedia.
<b>Photon counting</b>.
<a href="https://en.wikipedia.org/wiki/Photon_counting">https://en.wikipedia.org/wiki/Photon_counting</a>
</p>


<h3>See Also</h3>

<p><code>quantity</code>, 
<code>type</code>,
<code>cs.options</code>,
<code>radiometric</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">colSums( solar.irradiance ) # step size is 1nm, from 280 to 1000 nm. organized as a matrix
# AirMass.0  GlobalTilt AirMass.1.5 
#  944.5458    740.3220    649.7749  # irradiance, watts*m^{-2}


colSums( actinometric(solar.irradiance) )
# AirMass.0  GlobalTilt AirMass.1.5 
#  4886.920    3947.761    3522.149  # photon irradiance, (umoles of photons)*sec^{-1}*m^{-2}

colSums( actinometric(solar.irradiance,multiplier=0.602214) )
# AirMass.0  GlobalTilt AirMass.1.5 
#  2942.972    2377.397    2121.088  # photon irradiance, exaphotons*sec^{-1}*m^{-2}

</code></pre>


</div>