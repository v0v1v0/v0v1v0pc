<div class="container">

<table style="width: 100%;"><tr>
<td>cvwavelet.after.impute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-Validation Wavelet Shrinkage after imputation</h2>

<h3>Description</h3>

<p>This function performs level-dependent cross-validation wavelet shrinkage 
given the cross-validation scheme and imputation values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cvwavelet.after.impute(y, ywd, yimpute,
    cv.index, cv.optlevel, cv.tol=0.1^3, cv.maxiter=100,
    filter.number=10, family="DaubLeAsymm", thresh.type="soft", ll=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ywd</code></td>
<td>
<p>DWT object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yimpute</code></td>
<td>
<p>imputed values according to cross-validation scheme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.index</code></td>
<td>
<p>test dataset index according to cross-validation scheme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.optlevel</code></td>
<td>
<p>thresholding levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.tol</code></td>
<td>
<p>tolerance for cross-validation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.maxiter</code></td>
<td>
<p>maximum iteration for cross-validation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.number</code></td>
<td>
<p>specifies the smoothness of wavelet in the decomposition (argument of WaveThresh)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>specifies the family of wavelets “DaubExPhase" or “DaubLeAsymm" (argument of WaveThresh)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh.type</code></td>
<td>
<p>specifies the type of thresholding “hard" or “soft" (argument of WaveThresh)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll</code></td>
<td>
<p>specifies the lowest level to be thresholded</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculating the threshold values and reconstructing noisy data <code class="reqn">y</code>, given the index of each testdata,
imputed values according to cross-validation scheme and discrete wavelet transform of <code class="reqn">y</code>.
</p>


<h3>Value</h3>

<p>Reconstruction and thresholding values by level-dependent cross-validation
</p>
<table>
<tr style="vertical-align: top;">
<td><code>yc</code></td>
<td>
<p>reconstruction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvthresh</code></td>
<td>
<p>thresholding values by level-dependent cross-validation</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>cvwavelet</code>, <code>cvtype</code>, <code>cvimpute.by.wavelet</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(ipd)
y &lt;- as.numeric(ipd); n &lt;- length(y); nlevel &lt;- log2(n)

set.seed(1)
cv.index &lt;- cvtype(n=n, cv.bsize=2, cv.kfold=4, cv.random=TRUE)$cv.index
yimpute &lt;- cvimpute.by.wavelet(y=y, impute.index=cv.index)$yimpute

ywd &lt;- wd(y)

#out &lt;- cvwavelet.after.impute(y=y, ywd=ywd, yimpute=yimpute,
#cv.index=cv.index, cv.optlevel=c(3:(nlevel-1)))

#ts.plot(ts(out$yc, start=1229.98, deltat=0.02, frequency=50),
#   main="Level-dependent Cross Validation", xlab = "Seconds", ylab="")

##### Specifying thresholding structure
# cv.optlevel &lt;- c(3) # Threshold (level 3 to finest level) at the same time.
# cv.optlevel &lt;- c(3, 5) # Threshold two groups of resolution levels,
                         # (level 3, 4) and  (level 5 to finest level).
# cv.optlevel &lt;- c(3,4,5,6,7,8) # Threshold each resolution level 3 to 8.
</code></pre>


</div>