<div class="container">

<table style="width: 100%;"><tr>
<td>quick-conversion</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quick Data Conversion</h2>

<h3>Description</h3>

<p>Fast, flexible and precise conversion of common data objects, without method dispatch and extensive checks:
</p>

<ul>
<li> <p><code>qDF</code>, <code>qDT</code> and <code>qTBL</code> convert vectors, matrices, higher-dimensional arrays and suitable lists to data frame, <em>data.table</em> and <em>tibble</em>, respectively.
</p>
</li>
<li> <p><code>qM</code> converts vectors, higher-dimensional arrays, data frames and suitable lists to matrix.
</p>
</li>
<li> <p><code>mctl</code> and <code>mrtl</code> column- or row-wise convert a matrix to list, data frame or <em>data.table</em>. They are used internally by <code>qDF/qDT/qTBL</code>, <code>dapply</code>, <code>BY</code>, etc...
</p>
</li>
<li> <p><code>qF</code> converts atomic vectors to factor (documented on a separate page).
</p>
</li>
<li> <p><code>as_numeric_factor</code>, <code>as_integer_factor</code>, and <code>as_character_factor</code> convert factors, or all factor columns in a data frame / list, to character or numeric (by converting the levels).
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R"># Converting between matrices, data frames / tables / tibbles

 qDF(X, row.names.col = FALSE, keep.attr = FALSE, class = "data.frame")
 qDT(X, row.names.col = FALSE, keep.attr = FALSE, class = c("data.table", "data.frame"))
qTBL(X, row.names.col = FALSE, keep.attr = FALSE, class = c("tbl_df","tbl","data.frame"))
  qM(X, row.names.col = NULL , keep.attr = FALSE, class = NULL, sep = ".")

# Programmer functions: matrix rows or columns to list / DF / DT - fully in C++

mctl(X, names = FALSE, return = "list")
mrtl(X, names = FALSE, return = "list")

# Converting factors or factor columns

  as_numeric_factor(X, keep.attr = TRUE)
  as_integer_factor(X, keep.attr = TRUE)
as_character_factor(X, keep.attr = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a vector, factor, matrix, higher-dimensional array, data frame or list. <code>mctl</code> and <code>mrtl</code> only accept matrices, <code>as_numeric_factor</code>, <code>as_integer_factor</code> and <code>as_character_factor</code> only accept factors, data frames or lists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names.col</code></td>
<td>
<p>can be used to add an column saving names or row.names when converting objects to data frame using <code>qDF/qDT/qTBL</code>. <code>TRUE</code> will add a column <code>"row.names"</code>, or you can supply a name e.g. <code>row.names.col = "variable"</code>. With <code>qM</code>, the argument has the opposite meaning, and can be used to select one or more columns in a data frame/list which will be used to create the rownames of the matrix e.g. <code>qM(iris, row.names.col = "Species")</code>. In this case the column(s) can be specified using names, indices, a logical vector or a selector function. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.attr</code></td>
<td>
<p>logical. <code>FALSE</code> (default) yields a <em>hard</em> / <em>thorough</em> object conversion: All unnecessary attributes are removed from the object yielding a plain matrix / data.frame / <em>data.table</em>. <code>FALSE</code> yields a <em>soft</em> / <em>minimal</em> object conversion: Only the attributes 'names', 'row.names', 'dim', 'dimnames' and 'levels' are modified in the conversion. Other attributes are preserved. See also <code>class</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>if a vector of classes is passed here, the converted object will be assigned these classes. If <code>NULL</code> is passed, the default classes are assigned: <code>qM</code> assigns no class, <code>qDF</code> a class <code>"data.frame"</code>, and <code>qDT</code> a class <code>c("data.table", "data.frame")</code>. If <code>keep.attr = TRUE</code> and <code>class = NULL</code> and the object already inherits the default classes, further inherited classes are preserved. See Details and the Example. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>character. Separator used for interacting multiple variables selected through <code>row.names.col</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>logical. Should the list be named using row/column names from the matrix?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p>an integer or string specifying what to return. The options are:
</p>

<table>
<tr>
<td style="text-align: left;">
<em> Int. </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> String </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
<td style="text-align: left;">
                 1 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "list"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> returns a plain list </td>
</tr>
<tr>
<td style="text-align: left;">
                 2 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "data.frame" </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> returns a plain data.frame </td>
</tr>
<tr>
<td style="text-align: left;">
                 3 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "data.table"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> returns a plain <em>data.table</em> </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Object conversions using these functions are maximally efficient and involve 3 consecutive steps: (1) Converting the storage mode / dimensions / data of the object, (2) converting / modifying the attributes and (3) modifying the class of the object:
</p>
<p>(1) is determined by the choice of function and the optional <code>row.names.col</code> argument. Higher-dimensional arrays are converted by expanding the second dimension (adding columns, same as <code>as.matrix, as.data.frame, as.data.table</code>).
</p>
<p>(2) is determined by the <code>keep.attr</code> argument: <code>keep.attr = TRUE</code> seeks to preserve the attributes of the object. Its effect is like copying <code>attributes(converted) &lt;- attributes(original)</code>, and then modifying the <code>"dim", "dimnames", "names", "row.names"</code> and <code>"levels"</code> attributes as necessitated by the conversion task. <code>keep.attr = FALSE</code> only converts / assigns / removes these attributes and drops all others.
</p>
<p>(3) is determined by the <code>class</code> argument: Setting <code>class = "myclass"</code> will yield a converted object of class <code>"myclass"</code>, with any other / prior classes being removed by this replacement. Setting <code>class = NULL</code> does NOT mean that a class <code>NULL</code> is assigned (which would remove the class attribute), but rather that the default classes are assigned: <code>qM</code> assigns no class, <code>qDF</code> a class <code>"data.frame"</code>, and <code>qDT</code> a class <code>c("data.table", "data.frame")</code>. At this point there is an interaction with <code>keep.attr</code>: If <code>keep.attr = TRUE</code> and <code>class = NULL</code> and the object converted already inherits the respective default classes, then any other inherited classes will also be preserved (with <code>qM(x, keep.attr = TRUE, class = NULL)</code> any class will be preserved if <code>is.matrix(x)</code> evaluates to <code>TRUE</code>.)
</p>
<p>The default <code>keep.attr = FALSE</code> ensures <em>hard</em> conversions so that all unnecessary attributes are dropped. Furthermore in <code>qDF/qDT/qTBL</code> the default classes were explicitly assigned. This is to ensure that the default methods apply, even if the user chooses to preserve further attributes. For <code>qM</code> a more lenient default setup was chosen to enable the full preservation of time series matrices with <code>keep.attr = TRUE</code>. If the user wants to keep attributes attached to a matrix but make sure that all default methods work properly, either one of <code>qM(x, keep.attr = TRUE, class = "matrix")</code> or <code>unclass(qM(x, keep.attr = TRUE))</code> should be employed.
</p>


<h3>Value</h3>

<p><code>qDF</code> - returns a data.frame<br><code>qDT</code> - returns a <em>data.table</em><br><code>qTBL</code> - returns a <em>tibble</em><br><code>qM</code> - returns a matrix<br><code>mctl</code>, <code>mrtl</code> - return a list, data frame or <em>data.table</em> <br><code>qF</code> - returns a factor<br><code>as_numeric_factor</code> - returns X with factors converted to numeric (double) variables<br><code>as_integer_factor</code> - returns X with factors converted to integer variables<br><code>as_character_factor</code> - returns X with factors converted to character variables
</p>


<h3>See Also</h3>

<p><code>qF</code>, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Basic Examples
mtcarsM &lt;- qM(mtcars)                   # Matrix from data.frame
mtcarsDT &lt;- qDT(mtcarsM)                # data.table from matrix columns
mtcarsTBL &lt;- qTBL(mtcarsM)              # tibble from matrix columns
head(mrtl(mtcarsM, TRUE, "data.frame")) # data.frame from matrix rows, etc..
head(qDF(mtcarsM, "cars"))              # Adding a row.names column when converting from matrix
head(qDT(mtcars, "cars"))               # Saving row.names when converting data frame to data.table
head(qM(iris, "Species"))               # Examples converting data to matrix, saving information
head(qM(GGDC10S, is.character))         # as rownames
head(qM(gv(GGDC10S, -(2:3)), 1:3, sep = "-")) # plm-style rownames

# mrtl() and mctl() are very useful for iteration over matrices
# Think of a coordninates matrix e.g. from sf::st_coordinates()
coord &lt;- matrix(rnorm(10), ncol = 2, dimnames = list(NULL, c("X", "Y")))
# Then we can
for (d in mrtl(coord)) {
  cat("lon =", d[1], ", lat =", d[2], fill = TRUE)
  # do something complicated ...
}
rm(coord)

## Factors
cylF &lt;- qF(mtcars$cyl)                  # Factor from atomic vector
cylF

# Factor to numeric conversions
identical(mtcars,  as_numeric_factor(dapply(mtcars, qF)))


</code></pre>


</div>