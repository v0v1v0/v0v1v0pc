<div class="container">

<table style="width: 100%;"><tr>
<td>emle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum Likelihood Estimators for (Nested) Archimedean Copulas</h2>

<h3>Description</h3>

<p>Compute (simulated) maximum likelihood estimators for (nested)
Archimedean copulas.
</p>


<h3>Usage</h3>

<pre><code class="language-R">emle(u, cop, n.MC=0, optimizer="optimize", method,
     interval=initOpt(cop@copula@name),
     start=list(theta=initOpt(cop@copula@name, interval=FALSE, u=u)),
     ...)
.emle(u, cop, n.MC=0,
      interval=initOpt(cop@copula@name), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula, with <code class="reqn">n</code> the sample size
and <code class="reqn">d</code> the dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p><code>outer_nacopula</code> to be estimated
(currently only non-nested, that is,
Archimedean copulas are admitted).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.MC</code></td>
<td>
<p><code>integer</code>, if positive, <em>simulated</em> maximum
likelihood estimation (SMLE) is used with sample size equal to
<code>n.MC</code>; otherwise (<code>n.MC=0</code>), MLE.  In SMLE, the <code class="reqn">d</code>th
generator derivative and thus the copula density is evaluated via
(Monte Carlo) simulation, whereas MLE uses the explicit formulas for
the generator derivatives; see the details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>a string or <code>NULL</code>, indicating the optimizer to
be used, where <code>NULL</code> means to use <code>optim</code> via the
standard <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>mle()</code> from (base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>) package <span class="pkg">stats4</span>,
whereas the default, <code>"optimize"</code> uses <code>optimize</code> via
the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>mle2()</code> from package <a href="https://CRAN.R-project.org/package=bbmle"><span class="pkg">bbmle</span></a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>only when <code>optimizer</code> is <code>NULL</code> or
<code>"optim"</code>, the method to be used for <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in
Hofert et al. (2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p><code>list</code> of initial values, passed through.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to <code>optimize</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Exact formulas for the generator derivatives were derived in Hofert
et al. (2012).  Based on these formulas one can compute the
(log-)densities of the Archimedean copulas.  Note that for some
densities, the formulas are numerically highly non-trivial to compute
and considerable efforts were put in to make the computations
numerically feasible even in large dimensions (see the source code of
the Gumbel copula, for example).  Both MLE and SMLE showed good
performance in the simulation study conducted by Hofert et
al. (2013) including the challenging 100-dimensional case.
Alternative estimators (see also <code>enacopula</code>) often used
because of their numerical feasibility, might break down in much
smaller dimensions.
</p>
<p>Note: SMLE for Clayton currently faces serious numerical issues and is
due to further research.  This is only interesting from a theoretical point
of view, since the exact derivatives are known and numerically non-critical
to evaluate.
</p>


<h3>Value</h3>


<dl>
<dt>emle</dt>
<dd>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object of class <code>"mle2"</code> (and
thus useful for obtaining confidence intervals) with the
(simulated) maximum likelihood estimator.</p>
</dd>
<dt>.emle</dt>
<dd>
<p><code>list</code> as returned by
<code>optimize()</code> including the maximum likelihood
estimator (does not confidence intervals but is typically faster).</p>
</dd>
</dl>
<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133–150.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em> <b>154</b>(1), 25–63.
</p>


<h3>See Also</h3>

<p><code>mle2</code> from package <span class="pkg">bbmle</span> and
<code>mle</code> from <span class="pkg">stats4</span> on which <code>mle2</code> is
modeled. <code>enacopula</code> (wrapper for different estimators).
<code>demo(opC-demo)</code> and <code>demo(GIG-demo)</code> for
examples of two-parameter families.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;-  20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n,cop)

## Estimation
system.time(efm &lt;- emle(U, cop))
summary(efm) # using bblme's 'mle2' method

## Profile likelihood plot [using S4 methods from bbmle/stats4] :
pfm &lt;- profile(efm)
ci  &lt;- confint(pfm, level=0.95)
ci
stopifnot(ci[1] &lt;= theta, theta &lt;= ci[2])
plot(pfm)               # |z| against theta, |z| = sqrt(deviance)
plot(pfm, absVal=FALSE, #  z  against theta
     show.points=TRUE) # showing how it's interpolated
## and show the true theta:
abline(v=theta, col="lightgray", lwd=2, lty=2)
axis(1, pos = 0, at=theta, label=quote(theta[0]))

## Plot of the log-likelihood, MLE  and  conf.int.:
logL &lt;- function(x) -efm@minuslogl(x)
       # == -sum(copGumbel@dacopula(U, theta=x, log=TRUE))
logL. &lt;- Vectorize(logL)
I &lt;- c(cop@copula@iTau(0.1), cop@copula@iTau(0.4))
curve(logL., from=I[1], to=I[2], xlab=quote(theta),
      ylab="log-likelihood",
      main="log-likelihood for Gumbel")
abline(v = c(theta, efm@coef), col="magenta", lwd=2, lty=2)
axis(1, at=c(theta, efm@coef), padj = c(-0.5, -0.8), hadj = -0.2,
     col.axis="magenta", label= expression(theta[0], hat(theta)[n]))
abline(v=ci, col="gray30", lwd=2, lty=3)
text(ci[2], extendrange(par("usr")[3:4], f= -.04)[1],
     "95% conf. int.", col="gray30", adj = -0.1)
</code></pre>


</div>