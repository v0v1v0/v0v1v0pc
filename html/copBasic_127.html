<div class="container">

<table style="width: 100%;"><tr>
<td>rhoCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Spearman Rho of a Copula</h2>

<h3>Description</h3>

<p>Compute the measure of association known as the <em>Spearman Rho</em> <code class="reqn">\rho_\mathbf{C}</code> of a copula according to Nelsen (2006, pp. 167–170, 189, 208) by
</p>
<p style="text-align: center;"><code class="reqn">\rho_\mathbf{C} = 12\int\!\!\int_{\mathcal{I}^2} \mathbf{C}(u,v)\, \mathrm{d}u\mathrm{d}v - 3\mbox{,}</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">\rho_\mathbf{C} = 12\int\!\!\int_{\mathcal{I}^2} [\mathbf{C}(u,v) - uv]\, \mathrm{d}u\mathrm{d}v\mbox{,}</code>
</p>

<p>where the later equation is implemented by <code>rhoCOP</code> as the default method (<code>method="default"</code>). This equation, here having <code class="reqn">p = 1</code> and <code class="reqn">k_p(1) = 12</code>, is generalized under <code>hoefCOP</code>. The absence of the <code class="reqn">12</code> in the above equation makes it equal to the covariance defined by the <em>Hoeffding Identity</em> (Joe, 2014, p. 54):
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{cov}(U, V) = \int\!\!\int_{\mathcal{I}^2} [\mathbf{C}(u,v) - uv]\, \mathrm{d}u\mathrm{d}v\mbox{ or}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{cov}(U, V) = \int\!\!\int_{\mathcal{I}^2} [\hat{\mathbf{C}}(u,v) - uv]\, \mathrm{d}u\mathrm{d}v\mbox{, which is}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{cov}(U, V) = \int\!\!\int_{\mathcal{I}^2} [u+v-1+\mathbf{C}(1-u,1-v) - uv]\, \mathrm{d}u\mathrm{d}v\mbox{.}</code>
</p>

<p>Depending on copula family (Joe, 2014, pp. 56 and 267), the alternative formulation for <code class="reqn">\rho_\mathbf{C}</code> could be used
</p>
<p style="text-align: center;"><code class="reqn">\rho_\mathbf{C} = 3 - 12\int\!\!\int_{\mathcal{I}^2} u \frac{\delta\mathbf{C}(u,v)}{\delta u} \, \mathrm{d}u\mathrm{d}v = 3 - 12\int\!\!\int_{\mathcal{I}^2} v\frac{\delta\mathbf{C}(u,v)}{\delta v} \, \mathrm{d}u\mathrm{d}v\mbox{,}</code>
</p>

<p>where the first integral form corresponds to Joe (2014, eq. 248, p. 56) and is the <code>method="joe21"</code>, and the second integral form is the <code>method="joe12"</code>.
</p>
<p>The integral
</p>
<p style="text-align: center;"><code class="reqn">\int\!\!\int_{\mathcal{I}^2} \mathbf{C}(u,v)\,\mathrm{d}u\mathrm{d}v\mbox{,}</code>
</p>

<p>represents the “volume under the graph of the copula and over the unit square” (Nelsen, 2006, p. 170) and therefore <code class="reqn">\rho_\mathbf{C}</code> is simple a rescaled volume under the copula. The second equation for <code class="reqn">\rho_\mathbf{C}</code> expresses the “average distance” between the joint distribution and statistical <em>independence</em> <code class="reqn">\mathbf{\Pi} = uv</code>. Nelsen (2006, pp. 175–176) shows that the following relation between <code class="reqn">\rho_\mathbf{C}</code> and <code class="reqn">\tau_\mathbf{C}</code> (<code>tauCOP</code>) exists
</p>
<p style="text-align: center;"><code class="reqn">-1 \le 3\tau - 2\rho \le 1\mbox{.}</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">rhoCOP(cop=NULL, para=NULL, method=c("default", "joe21", "joe12"),
                            as.sample=FALSE, brute=FALSE, delta=0.002, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The form of integration used to compute (see above);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.sample</code></td>
<td>
<p>A logical controlling whether an optional <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> in <code>para</code> is used to compute the <code class="reqn">\hat\rho</code> by dispatch to <code>cor()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> with <code>method = "spearman"</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brute</code></td>
<td>
<p>Should brute force be used instead of two nested <code>integrate()</code> functions in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> to perform the double integration;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The <code class="reqn">\mathrm{d}u</code> and <code class="reqn">\mathrm{d}v</code> for the brute force integration using <code>brute</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The value for <code class="reqn">\rho_\mathbf{C}</code> is returned.
</p>


<h3>Note</h3>

<p>Technically, Nelsen (2006) also shows that these definitions are a form of call to a <em>concordance function</em> <code class="reqn">\mathcal{Q}(\mathbf{C}_1,\mathbf{C}_2)</code> of two copulas that involve <code class="reqn">\mathbf{C}_1{=}\mathbf{C}(u,v)</code> and <code class="reqn">\mathbf{C}_2{=}\mathbf{\Pi}</code>. As such in order to keep <code>rhoCOP</code> a small function when <code>brute=TRUE</code>, <code class="reqn">\rho_\mathbf{C}</code> is computed by a special call to <code>tauCOP</code>, which by itself and although titled for computation of <em>Kendall Tau</em>, does support the concordance function <code class="reqn">\mathcal{Q}(\mathbf{C}_1, \mathbf{C}_2)</code> [see Nelsen (2006, pp. 158–159)] when given two different copulas and respective parameters as arguments. The well-known <em>Pearson correlation coefficient</em> equals Spearman rho value if random variables <code class="reqn">X</code> and <code class="reqn">Y</code> are both uniformly distributed on <code class="reqn">[0,1]</code>.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>blomCOP</code>, <code>footCOP</code>, <code>giniCOP</code>,
<code>hoefCOP</code>, <code>tauCOP</code>,  <code>wolfCOP</code>,
<code>joeskewCOP</code>, <code>uvlmoms</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">rhoCOP(cop=PSP)             # 0.4784176
## Not run: 
rhoCOP(cop=PSP, brute=TRUE) # 0.4684063
# CPU heavy example showing that the dual-integration (fast) results in
# a Spearman Rho that mimics a sample version
do_rho &lt;- function(n) {
   uv &lt;- simCOP(n=n, cop=PSP, ploton=FALSE, points=FALSE)
   return(cor(uv$U, uv$V, method="spearman"))
}
rhos &lt;- replicate(100, do_rho(1000))
rho_sample &lt;- mean(rhos); print(rho_sample) # 0.472661
## End(Not run)

## Not run: 
para &lt;- list(cop1=PLACKETTcop,  cop2=PLACKETTcop,
             para1=0.00395,    para2=4.67,     alpha=0.9392, beta=0.5699)
rhoCOP(cop=composite2COP, para=para) # -0.5924796

para &lt;- list(cop1=PLACKETTcop,  cop2=PLACKETTcop,
             para1=0.14147,    para2=20.96,    alpha=0.0411, beta=0.6873)
rhoCOP(cop=composite2COP, para=para) # 0.2818874

para &lt;- list(cop1=PLACKETTcop,  cop2=PLACKETTcop,
             para1=0.10137,     para2=4492.87, alpha=0.0063, beta=0.0167)
rhoCOP(cop=composite2COP, para=para)             # 0.9812919
rhoCOP(cop=composite2COP, para=para, brute=TRUE) # 0.9752155
## End(Not run)

## Not run: 
# This is the same composited copula used in a highly asymmetric multi-modal
# plotting example under densityCOPplot(). Let us use that copula as a means to
# check on the Spearman Rho from the alternative formulations from Joe (2014).
para &lt;- list(alpha=0.15, beta=0.90, kappa=0.06, gamma=0.96,
             cop1=GHcop, cop2=PLACKETTcop, para1=5.5, para2=0.07)
"rhoCOPbyJoe21" &lt;- function(cop=NULL, para=NULL, ...) { # Joe (2014, eq. 2.48)
   myint &lt;- NULL
   try(myint &lt;- integrate(function(u) {
       sapply(u,function(u) { integrate(function(v) {
       u * derCOP( u, v, cop=cop, para=para, ...)},  0, 1)$value })}, 0, 1))
   ifelse(is.null(myint), return(NA), return(3 - 12*myint$value))
}
"rhoCOPbyJoe12" &lt;- function(cop=NULL, para=NULL, ...) { # Not in Joe (2014)
   myint &lt;- NULL
   try(myint &lt;- integrate(function(u) {
       sapply(u,function(u) { integrate(function(v) {
       v * derCOP2( u, v, cop=cop, para=para, ...)}, 0, 1)$value })}, 0, 1))
   ifelse(is.null(myint), return(NA), return(3 - 12*myint$value))
}
rhoCOP(       cop=composite2COP, para=para) # 0.1031758
rhoCOPbyJoe21(cop=composite2COP, para=para) # 0.1031803
rhoCOPbyJoe12(cop=composite2COP, para=para) # 0.1031532
## End(Not run)
</code></pre>


</div>