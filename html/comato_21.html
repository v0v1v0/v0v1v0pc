<div class="container">

<table style="width: 100%;"><tr>
<td>landscape</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregating the maps of a conceptmaps object into a concept landscape</h2>

<h3>Description</h3>

<p><code>landscape</code> transforms a set of concept maps into a concept landscape using one of several possible methods.
Depending on the value of <code>result</code> and accumulation or amalgamation is performed on the concept map data. The amalgamation
forms a weighted graph based on the unified set of concepts. An accumulation transforms each concept map into a vector and
returns a matrix of these vectors. Using <code>FUN</code> the process of transformation can be influenced in both cases.
</p>


<h3>Usage</h3>

<pre><code class="language-R">landscape(maps, result = c("graph", "matrix"), mode, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>Either "graph" or "matrix" defines the return type and the method of aggregation. An amalgamation results in a weighted graph and
an accumulation results a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>If <code>result</code> is "graph", it can be either "directed" or "undirected" deciding how the graph should be formed. 
First, a weight matrix is formed from the set of concept maps. If <code>FUN</code> is NULL, the weights simply reflect the number of maps in which 
a given edge is present. Otherwise, <code>FUN</code> must be a function that accepts three parameters and returns a numeric value. For the first parameter
the current conceptmap object will be passed and for the second and third parameters the start and end concepts of an edge is passed.
The return value of the function will then be added to the weight matrix. If <code>result</code> is "matrix", it can be one of "graph.sim", "concept.vector", "edge.vector" or "custom". "graph.sim" return the graph similarity matrix,
"concept.vector" and "edge.vector" return the concept matrix or edge matrix respectively. Finally, "custom" can be used for arbitrary
transformations: For each map, the function passed to <code>FUN</code> and the resulting vector is forming a row of the returned matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>If <code>result</code> is "matrix" and <code>mode</code> is "custom", a function with one parameter of type conecptmap must be given that is 
called for each of the consituent maps. The function must return a numeric vector of equal length for all maps of a conceptmaps object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Depending on <code>result</code> either an igraph object or a numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))

landscape(cms, result="graph", mode="undirected")

landscape(cms, result="matrix", mode="concept.vector")
</code></pre>


</div>