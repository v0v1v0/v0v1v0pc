<div class="container">

<table style="width: 100%;"><tr>
<td>weighting-functions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighting Functions for Spatial Eigenvector Map</h2>

<h3>Description</h3>

<p>A set of common distance weighting functions to calculate spatial eignevector
maps using function <code>eigenmap</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wf.sqrd(d)

wf.RBF(d, wpar = 1)

wf.PCNM(d, boundaries, wpar = 4)

wf.binary(d, boundaries)

wf.Drayf1(d, boundaries)

wf.Drayf2(d, boundaries, wpar = 1)

wf.Drayf3(d, boundaries, wpar = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>A triangular ('dist-class') or rectangular geographic
distance matrix produced by <code>dist</code>, <code>Euclid</code>, or
<code>geodesics</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wpar</code></td>
<td>
<p>Where applicable, a parameter controlling the shape of the
spatial weighting function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundaries</code></td>
<td>
<p>Where applicable, a two-element numeric vector containing
the lower and upper threshold values used to obtain the connectivity matrix.
(see details).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are meant primarily to be called within functions
<code>eigenmap</code> and <code>eigenmap.score</code>. In
<code>eigenmap</code>, argument <code>d</code> is a lower-triangular
'dist-class' object and the resulting lower-triangular weight matrix
is used in calculating the spatial eigenvector map. In
<code>eigenmap.score</code>, <code>d</code> is a rectangular matrix of the
distances between a set of arbitrary locations (rows) and reference locations
(columns; the locations for which the the spatial eigenvector map has been
built and the resulting rectangular weight matrix is used to calculate
spatial eigenfunction values. These values allow one to use the spatial
information of a data set for making predictions at arbitrary values.
</p>
<p>'Wf.sqrd' (default value) consists in taking w[i,j] = -0.5*d[i,j] and does
not involve any truncation.
</p>
<p>'Wf.RBF' consists in taking <code>w[i,j] = exp(-wpar*d[i,j]^2)</code> and
does not involve any truncation, where <code>wpar</code> is a non-zero real
positive value (default: 1).
</p>
<p>'Wf.binary' the spatial weighting matrix is simply the connectivity
matrix.
</p>
<p>'Wf.PCNM' is <code>a[i,j] = 1 - (d[i,j] / (wpar*boundaries[2]))^2</code>, where
<code>wpar</code> is a non-zero real positive value (default: 4).
</p>
<p>'Wf.Drayf1' is <code>a[i,j] = 1 - (d[i,j] / dmax)</code> where <code>d_max</code> is the
distance between the two most distant locations in the set.
</p>
<p>'Wf.Drayf2' is <code>a[i,j] = 1 - (d[i,j] / dmax)^wpar</code>, where <code>wpar</code> is
a non-zero real positive value (default: 1).
</p>
<p>'Wf.Drayf3' is <code>a[i,j] = 1 / d[i,j]^wpar</code>, where <code>wpar</code> is a
non-zero real positive value (default: 1).
</p>
<p>Functions <code>Wf.Drayf1</code>, <code>Wf.Drayf2</code>, and <code>Wf.Drayf3</code> were
proposed by Dray et al. (2006) and function <code>PCNM</code> was proposed by
Legendre and Legendre (2012).
</p>
<p>The <code>Wf.sqrd</code> weighting approach is equivalent to submitting the
elementwise square-root of the distance matrix to a principal coordinate
analysis. It was proposed by Diniz-Filho et al. (2013) and is equivalent, for
evenly spaced transect or surfaces (square or rectangle), to using the basis
functions of type II discrete cosine basis transforms; a fact that has gone
unnoticed by Diniz-Filho et al. (2013).
</p>
<p>The radial basis function (RBF) is a widespread kernel method involving sets
of real-valued functions whose values depend on the distance between any
given input coordinate and a set of fixed points (a single fixed point for
each function). It is implemented using function <code>Wf.RBF</code> using all the
sampling points as the fixed points.
</p>
<p>When calculating the connectivity matrix, pairs of location whose distance to
one another are between the boundary values (argument <code>bounraries</code>) are
considered as neighbours (<code>b[i,j]=1</code>) whereas values located below the
minimum and above the maximum are considered as equivalent or distant,
respectively (<code>b[i,j]=0</code> in both cases).
</p>
<p>User may implement custom weighting functions. These functions must at the
very least have an argument <code>d</code>, and can be given arguments
<code>boundaries</code> and <code>wpar</code>. Argument <code>wpar</code> may be a vector with
any number of elements. They should be added to the R-code file
(weighting-functions.R). User-provided weighting functions with an argument
<code>wpar</code> must come with a valid default value for that parameter since
<code>eigenmap</code> may internally call it without a formal value.
</p>


<h3>Value</h3>

<p>A 'dist-class' object when argument <code>d</code> is a
'dist-class' object or a rectangular matrix when argument <code>d</code> is
a rectangular matrix, either one with the weights as its values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>wf.sqrd()</code>: Principal coordinates of the square-root distance matrix (Diniz-Filho et al.
2013).
</p>
</li>
<li> <p><code>wf.RBF()</code>: Radial basis functions with the observations as the kernels.
</p>
</li>
<li> <p><code>wf.PCNM()</code>: Borcard &amp; Legendre's (2002) principal coordinates of the neighbour matrix
approach.
</p>
</li>
<li> <p><code>wf.binary()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections without continuous weighting of the neighbours).
</p>
</li>
<li> <p><code>wf.Drayf1()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections with continuous weighting of the neighbours: f1).
</p>
</li>
<li> <p><code>wf.Drayf2()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections with continuous weighting of the neighbours: f2).
</p>
</li>
<li> <p><code>wf.Drayf3()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections with continuous weighting of the neighbours: f3).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Borcard, D. and Legendre, P. 2002. All-scale spatial analysis of ecological
data by means of principal coordinates of neighbour matrices. Ecol. Model.
153: 51-68
</p>
<p>Diniz-Filho, J. A. F.; Diniz, J. V. B. P. L.; Rangel, T. F.; Soares, T. F.;
de Campos Telles, M. P.; Garcia Collevatti, R. and Bini, L. M. 2013. A new
eigenfunction spatial analysis describing population genetic structure.
Genetica 141:479-489.
</p>
<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English edition.
Elsevier Science B.V., Amsterdam, The Netherlands.
</p>


<h3>Examples</h3>

<pre><code class="language-R">locations &lt;- c(1,2,4,7,10,14,17,21)
D &lt;- dist(locations)
wf.sqrd(D)
wf.RBF(D, wpar = 0.1)
wf.binary(D, c(0,5))
wf.PCNM(D, c(0,5))
wf.Drayf1(D, c(0,5))
wf.Drayf2(D, c(0,5), 0.5)
wf.Drayf3(D, c(0,5), 0.5)

emap &lt;- eigenmap(D, locations, wf.Drayf2, c(0,5), 0.5)
emap

emap &lt;- eigenmap(D, locations, wf.Drayf3, c(0,5), 0.25)
emap

emap &lt;- eigenmap(D, locations, wf.RBF, wpar = 0.1)
emap

</code></pre>


</div>