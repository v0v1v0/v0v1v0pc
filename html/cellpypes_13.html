<div class="container">

<table style="width: 100%;"><tr>
<td>pseudobulk_id</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate unique IDs to identify your pseudobulks.</h2>

<h3>Description</h3>

<p>This function generates unique IDs that are valid colnames as well.
Use these IDs in function pseudobulk.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pseudobulk_id(factor_df)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>factor_df</code></td>
<td>
<p>Data frame where each column helps to identify a pseudobulk.
Each row in factor_df corresponds to a single cell in your raw count matrix.
Typical columns of factor_df are for example patient, treatment and cell type â€“ anything
that uniquely identifies a replicate.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Wraps make.names to generate syntactically valid IDs.
Use these IDs in the pseudobulk function.
Note that this function combines all columns in factor_df, so only include
the columns that uniquely identify replicates.
Cells from the same experimental unit
</p>


<h3>Value</h3>

<p>Factor with syntactically valid and unique IDs.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create pseudobulk counts and coldata for DESeq2: 
coldata &lt;- data.frame(
  celltype = rep(c("X+Y-", "X+Y+", "X-Y+", "X-Y-"),
                 each = nrow(simulated_umis$embed)/4), # 4 cell types
  patient  = c("3", "500.", "*5", "/")
)
coldata$pseudobulk_id &lt;- pseudobulk_id(coldata)
counts &lt;- pseudobulk(simulated_umis$raw, coldata$pseudobulk_id)
# Use counts/coldata as input for DESeqDataSetFromMatrix (DESeq2).
</code></pre>


</div>