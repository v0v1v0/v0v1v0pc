<div class="container">

<table style="width: 100%;"><tr>
<td>fcumsum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast (Grouped, Ordered) Cumulative Sum for Matrix-Like Objects
</h2>

<h3>Description</h3>

<p><code>fcumsum</code> is a generic function that computes the (column-wise) cumulative sum of <code>x</code>, (optionally) grouped by <code>g</code> and/or ordered by <code>o</code>. Several options to deal with missing values are provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fcumsum(x, ...)

## Default S3 method:
fcumsum(x, g = NULL, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE, ...)

## S3 method for class 'matrix'
fcumsum(x, g = NULL, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE, ...)

## S3 method for class 'data.frame'
fcumsum(x, g = NULL, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fcumsum(x, na.rm = .op[["na.rm"]], fill = FALSE, shift = "time", ...)

## S3 method for class 'pdata.frame'
fcumsum(x, na.rm = .op[["na.rm"]], fill = FALSE, shift = "time", ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fcumsum(x, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE,
        keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a factor, <code>GRP</code> object, or atomic vector / list of vectors (internally grouped with <code>group</code>) used to group <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o</code></td>
<td>
<p>a vector or list of vectors providing the order in which the elements of <code>x</code> are cumulatively summed. Will be passed to <code>radixorderv</code> unless <code>check.o = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>if <code>na.rm = TRUE</code>, setting <code>fill = TRUE</code> will overwrite missing values with the previous value of the cumulative sum, starting from 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.o</code></td>
<td>
<p>logical. Programmers option: <code>FALSE</code> prevents passing <code>o</code> to <code>radixorderv</code>, requiring <code>o</code> to be a valid ordering vector that is integer typed with each element in the range <code>[1, length(x)]</code>. This gives some extra speed, but will terminate R if any element of <code>o</code> is too large or too small. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> or <code>"row"</code>. See <code>flag</code> for details. The argument here does not control 'shifting' of data but rather the order in which elements are summed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.ids</code></td>
<td>
<p><em>pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all grouping variables and variables passed to <code>o</code>). <em>Note</em>: For grouped / panel data frames identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>na.rm = FALSE</code>, <code>fcumsum</code> works like <code>cumsum</code> and propagates missing values. The default <code>na.rm = TRUE</code> skips missing values and computes the cumulative sum on the non-missing values. Missing values are kept. If <code>fill = TRUE</code>, missing values are replaced with the previous value of the cumulative sum (starting from 0), computed on the non-missing values.
</p>
<p>By default the cumulative sum is computed in the order in which elements appear in <code>x</code>. If <code>o</code> is provided, the cumulative sum is computed in the order given by <code>radixorderv(o)</code>, without the need to first sort <code>x</code>. This applies as well if groups are used (<code>g</code>), in which case the cumulative sum is computed separately in each group.
</p>
<p>The <em>pseries</em> and <em>pdata.frame</em> methods assume that the last factor in the index is the time-variable and the rest are grouping variables. The time-variable is passed to <code>radixorderv</code> and used for ordered computation, so that cumulative sums are accurately computed regardless of whether the panel-data is ordered or balanced.
</p>
<p><code>fcumsum</code> explicitly supports integers. Integers in R are bounded at bounded at +-2,147,483,647, and an integer overflow error will be provided if the cumulative sum (within any group) exceeds +-2,147,483,647. In that case data should be converted to double beforehand.
</p>


<h3>Value</h3>

<p>the cumulative sum of values in <code>x</code>, (optionally) grouped by <code>g</code> and/or ordered by <code>o</code>. See Details and Examples.
</p>


<h3>See Also</h3>

<p><code>fdiff</code>, <code>fgrowth</code>, Time Series and Panel Series, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Non-grouped
fcumsum(AirPassengers)
head(fcumsum(EuStockMarkets))
fcumsum(mtcars)

# Non-grouped but ordered
o &lt;- order(rnorm(nrow(EuStockMarkets)))
all.equal(copyAttrib(fcumsum(EuStockMarkets[o, ], o = o)[order(o), ], EuStockMarkets),
          fcumsum(EuStockMarkets))

## Grouped
head(with(wlddev, fcumsum(PCGDP, iso3c)))

## Grouped and ordered
head(with(wlddev, fcumsum(PCGDP, iso3c, year)))
head(with(wlddev, fcumsum(PCGDP, iso3c, year, fill = TRUE)))
</code></pre>


</div>