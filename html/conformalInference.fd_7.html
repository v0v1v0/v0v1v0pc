<div class="container">

<table style="width: 100%;"><tr>
<td>conformal.fun.msplit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional Multi Split Conformal Prediction Regions</h2>

<h3>Description</h3>

<p>Compute prediction regions using functional multi split conformal inference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">conformal.fun.msplit(
  x,
  t_x,
  y,
  t_y,
  x0,
  train.fun,
  predict.fun,
  alpha = 0.1,
  split = NULL,
  seed = FALSE,
  randomized = FALSE,
  seed.rand = FALSE,
  verbose = FALSE,
  rho = NULL,
  s.type = "alpha-max",
  B = 50,
  lambda = 0,
  tau = 0.08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The input variable, a list of n elements. Each element is composed by a list
of p vectors(with variable length, since the evaluation grid may change).
If x is NULL, the function will sample it from a gaussian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_x</code></td>
<td>
<p>The grid points for the evaluation of function x. It is a list of vectors.
If the x data type is "fData" or "mfData" is must be NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response variable. It is either, as with x, a list of list of
vectors or an fda object (of type fd, fData, mfData).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_y</code></td>
<td>
<p>The grid points for the evaluation of function y_val. It is a list of vectors.
If the y_val data type is "fData" or "mfData" is must be NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>The new points to evaluate, a list of n0 elements. Each element is composed
by a list of p vectors(with variable length).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train.fun</code></td>
<td>
<p>A function to perform model training, i.e., to produce an
estimator of E(Y|X), the conditional expectation of the response variable
Y given features X. Its input arguments should be x: list of features,
and y: list of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
responses at new feature values. Its input arguments should be out: output
produced by train.fun, and newx: feature values at which we want to make
predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Miscoverage level for the prediction intervals, i.e., intervals
with coverage 1-alpha are formed. Default for alpha is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>Indices that define the data-split to be used (i.e., the indices
define the first half of the data-split, on which the model is trained).
Default is NULL, in which case the split is chosen randomly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Integer to be passed to set.seed before defining the random
data-split to be used. Default is FALSE, which effectively sets no seed.
If both split and seed are passed, the former takes priority and the latter
is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomized</code></td>
<td>
<p>Should the randomized approach be used? Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed.rand</code></td>
<td>
<p>The seed for the randomized version of the conformal.split.fun.
Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Should intermediate progress be printed out? Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Vector containing the split proportion between
training and calibration set.
It has B components. Default is 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.type</code></td>
<td>
<p>The type of modulation function.
Currently we have 3 options: "identity","st-dev","alpha-max".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Number of repetitions. Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Smoothing parameter. Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>It is a smoothing parameter:
tau=1-1/B  Bonferroni intersection method
tau=0 unadjusted intersection
Default is 0.05, a value selected through sensitivity analysis .</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The work is an extension of the univariate approach to Multi Split
conformal inference to a multivariate functional context, exploiting the concept of
depth measures.
</p>
<p>This function is based on the package future.apply to
perform parallelisation. If this package is not installed, then the function
will abort.
</p>


<h3>Value</h3>

<p>A list containing lo, up, tn. lo and up are lists of length n0,
containing lists of length p, with vectors of lower and upper bounds.
tn is the list of the grid evaluations.
</p>


<h3>References</h3>

<p>"Multi Split Conformal Prediction" by Solari, Djordjilovic (2021) is
the baseline for the univariate case.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(roahd)

N = 10
P= 5
grid = seq( 0, 1, length.out = P )
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )
values = generate_gauss_fdata( N,
                                      centerline = sin( 2 * pi * grid ),
                                      Cov = C )
fD = fData( grid, values )
x0=list(as.list(grid))
fun=mean_lists()
rrr&lt;-conformal.fun.msplit(x=NULL,t_x=NULL, y=fD,t_y=NULL, x0=list(x0[[1]]),
                          fun$train.fun, fun$predict.fun,alpha=0.2,
                          split=NULL, seed=FALSE, randomized=FALSE,seed.rand=FALSE,
                          verbose=FALSE, rho=NULL,B=2,lambda=0)


</code></pre>


</div>