<div class="container">

<table style="width: 100%;"><tr>
<td>cnlt.biv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Performs 'nondecimated' complex-valued wavelet lifting for bivariate time series analysis
</h2>

<h3>Description</h3>

<p>The forward complex-valued lifting transform for decomposing a signal of interest is dependent on the trajectory (lifting order) used in the forward lifting transform.
This procedure uses trajectory bootstrapping to provide (complex-valued) time-scale information at all times and scales for bivariate series
</p>


<h3>Usage</h3>

<pre><code class="language-R">cnlt.biv(x1, x2 = NULL, f1, f2, P = 100, nkeep = 2, use.same.trajectories = FALSE, 
verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>An optional vector of grid values corresponding to <span class="env">f2</span>. Can be of any length, not necessarily equally spaced.  If not specified (<code>NULL</code>), then the same grid is used for <code>f2</code> as <code>f1</code>, i.e. <span class="env">x1</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f1</code></td>
<td>
<p>A vector of function values of the first component of a bivariate series, corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f2</code></td>
<td>
<p>A vector of function values of the second component of a bivariate series, corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>Number of trajectories to be used in the nondecimated lifting transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nkeep</code></td>
<td>
<p>Number of scaling points we want at the end of the transform. The usual choice is <code>nkeep</code>=2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.same.trajectories</code></td>
<td>
<p>A boolean variable indicating whether the same set of trajectories should be used for both components of the bivariate signal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Indicates whether useful messages should be printed to the console during the procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other arguments to be passed to <code>fwtnppermC</code>, see the function documentation for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Essentially, this function applies the forward complex wavelet lifting transform <code>fwtnppermC</code> <span class="env">P</span> times on both (<span class="env">x</span>,<span class="env">f1</span>) and (<span class="env">x</span>,<span class="env">f2</span>), each with a different random lifting
trajectory.  This results in <span class="env">P</span> sets of complex-valued detail coefficients, along with their associated scales.  This information is stored in order to compute the
cross-periodograms for the bivariate series (<span class="env">x</span>,<span class="env">f1</span>,<span class="env">f2</span>).  The “degree of asymmetry" in the prediction is also recorded.
This is the ratio between the maximum distance to the removed point to one of its neighbours and the minimum distance from the removed point to one of its neighbours,
see Chapter 5.3 in Sanderson (2010) for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>cnlt</code> (subclasses <code>biv</code> and either <code>SG</code> or <code>DG</code>).<br>
If both components have the same grid (subclass <code>SG</code>), a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>The sampling grid corresponding to <span class="env">f1</span> used for the decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>The sampling grid corresponding to <span class="env">f2</span> used for the decomposition.  If the object is of subclass <code>SG</code>, <code>x1</code> is the same as <code>x2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>det1</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to detail coefficients associated to point <code>x_i</code> and <span class="env">f1</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>det2</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to detail coefficients associated to point <code>x_i</code> and <span class="env">f2</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lre</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the scales (integrals) when lifting point <code>x_i</code> and <span class="env">f1</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lreA</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the degree of asymmetry of the neighbourhood used in the prediction step of point <code>x_i</code>, see description above.</p>
</td>
</tr>
</table>
<p>If both components have different sampling grids, the additional following list components are returned:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>lre2</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the scales (integrals) when lifting point <code>x_i2</code> and <span class="env">f2</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lreA2</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the degree of asymmetry of the neighbourhood used in the prediction step of point <code>x_i2</code> with <span class="env">f2</span>, see description above.</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>Using a large number of trajectories for long datasets could take a long time!</p>


<h3>Author(s)</h3>

<p>Matt Nunes, Jean Hamilton
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br><br>
Sanderson, J. (2010) Wavelet methods for time series with bivariate observations and irregular sampling grids. PhD Thesis, University of Bristol, UK.<br><br>
For the real-valued equivalent procedure, see also<br>
Knight, M. I., Nunes, M. A. and Nason, G. P. (2012) Spectral Estimation for Locally Stationary Time Series with Missing Observations. <em>Stat. Comput.</em>
<b>22</b> (4), 877–895.
</p>


<h3>See Also</h3>

<p><code>fwtnppermC</code>,
<code>link{cnlt.univ}</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# a bivariate series example with same grids

# simulate data, e.g. two sinusoids
dat &lt;- seq(from=1, to=3, by=0.1)
x1 &lt;- cumsum(sample(dat, 200, TRUE))

y1 &lt;-sin(2*pi*(1/25)*x1) + sin(2*pi*(1/50)*x1)+ 1*sin(2*pi*(1/10)*x1)+ rnorm(length(x1), 0,0.2)
y3 &lt;- c(sin(2*pi*(1/25)*x1[1:100]),sin(2*pi*(1/25)*x1[97:196]))+ rnorm(length(x1), 0,0.1)

## Not run: 
y1y3.dec&lt;-cnlt.biv(x1, f1=y1, f2=y3, P = 500)

# the complex detail coefficients corresponding to the first timepoint are:

y1y3.dec$det1[[1]]


## End(Not run)

# a bivariate series example with different grids

# load some data in

data(Baidu)
data(Google)

## Not run: 
BaiGoo&lt;-cnlt.biv(Baidu$Seconds[1:100], Google$Seconds[1:100], Baidu$Return[1:100], 
Google$Return[1:100], P = 500)

# now look at some of the coefficients from the decomposition
# (the complex detail coefficients corresponding to the first timepoint:

BaiGoo$det1[[1]]
BaiGoo$det2[[1]]

## End(Not run)

</code></pre>


</div>