<div class="container">

<table style="width: 100%;"><tr>
<td>cna</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform Coincidence Analysis</h2>

<h3>Description</h3>

<p>The <code>cna</code> function performs Coincidence Analysis to identify atomic solution formulas (asf) consisting of minimally necessary
disjunctions of minimally sufficient conditions of all outcomes in the data
and combines the recovered asf to complex solution formulas (csf) representing multi-outcome structures, e.g. common-cause and/or
causal chain structures. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cna(x, type, ordering = NULL, strict = FALSE, outcome = TRUE, exclude = character(0),
    con = 1, cov = 1, con.msc = con,
    notcols = NULL, rm.const.factors = FALSE, rm.dup.factors = FALSE,  
    maxstep = c(3, 4, 10), inus.only = only.minimal.msc &amp;&amp; only.minimal.asf, 
    only.minimal.msc = TRUE,  only.minimal.asf = TRUE, 
    maxSol = 1e6, suff.only = FALSE, 
    what = if (suff.only) "m" else "ac", cutoff = 0.5, 
    border = c("up", "down", "drop"), details = FALSE, 
    acyclic.only = FALSE, cycle.type = c("factor", "value"), 
    asf.selection = c("cs", "fs", "none"), verbose = FALSE)

## S3 method for class 'cna'
print(x, what = x$what, digits = 3, nsolutions = 5, 
      details = x$details, show.cases = NULL, inus.only = x$inus.only, 
      acyclic.only = x$acyclic.only, cycle.type = x$cycle.type, 
      verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Data frame or <code>configTable</code> (as output by <code>configTable</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordering</code></td>
<td>
<p>Character string or list of character vectors specifying the causal ordering of
the factors in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>Logical; if <code>TRUE</code>, factors on the same level of the causal
ordering are <em>not</em> potential causes of each other; if <code>FALSE</code> (default), factors on the same level <em>are</em> potential causes of each other.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>
<p>Character vector specifying one or several factor values that are to be considered as potential outcome(s). For crisp- and fuzzy-set data, factor values are expressed by upper and lower cases, for multi-value data, they are expressed by the "factor=value" notation.  
Defaults to <code>outcome = TRUE</code>, which means that all factor values in <code>x</code> are considered as potential outcomes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Character vector specifying factor values to be excluded as possible causes of certain outcomes. For instance, <code>exclude = "A,c-&gt;B"</code> determines that A and c are not considered as potential causes of B.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con</code></td>
<td>
<p>Numeric scalar between 0 and 1 to set the minimum consistency threshold every minimally sufficient condition (msc), atomic solution formula (asf), and complex solution formula (csf) must satisfy. (See also the argument <code>con.msc</code> below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>Numeric scalar between 0 and 1 to set the minimum coverage threshold every asf and csf must satisfy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.msc</code></td>
<td>
<p>Numeric scalar between 0 and 1 to set the minimum consistency threshold every msc must satisfy. Overrides <code>con</code> for msc and, thereby, allows for imposing a consistency threshold on msc that differs from the threshold <code>con</code> imposes on asf and csf. Defaults to <code>con</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxstep</code></td>
<td>
<p>Vector of three integers; the first specifies the maximum number of conjuncts in each disjunct of an asf, the second specifies the maximum number of disjuncts in an asf, the third specifies the maximum <em>complexity</em> of an asf. The complexity of an asf is 
the total number of exogenous factor values in the asf. Default: <code>c(3,4,10)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inus.only</code></td>
<td>
<p>Either <code>TRUE</code>/<code>FALSE</code> or a character string with possible values "implication" or "equivalence". The strings can be abbreviated. If <code>TRUE</code>, only disjunctive normal forms that are free of redundancies are retained as asf (see also <code>is.inus</code>). <br> Defaults to <code>only.minimal.msc &amp;&amp; only.minimal.asf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.minimal.msc</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), only minimal conjunctions are retained as msc. If <code>FALSE</code>, sufficient conjunctions are not required to be minimal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.minimal.asf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), only minimal disjunctions are retained as asf. If <code>FALSE</code>, necessary disjunctions are not required to be minimal. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxSol</code></td>
<td>
<p>Maximum number of asf calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suff.only</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the function only searches for msc and not for asf and csf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notcols</code></td>
<td>
<p>Character vector of factors to be negated in <code>x</code>. If <code>notcols = "all"</code>, all factors in <code>x</code> are negated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.const.factors, rm.dup.factors</code></td>
<td>
<p>Logical; if <code>TRUE</code>, factors with constant values are removed and all but the first of a set of duplicated factors are removed. These parameters are passed to <code>configTable</code>. <b>Note:</b> The default value has changed from <code>TRUE</code> to <code>FALSE</code> in the package's version 3.5.4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>Character string specifying what to print; <code>"t"</code> for the configuration table, <code>"m"</code> for msc, <code>"a"</code> for asf, <code>"c"</code> for csf, and <code>"all"</code> for all. Defaults to <code>"ac"</code> if <code>suff.only = FALSE</code>, and to <code>"m"</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>Minimum membership score required for a factor to count as instantiated in the data and to be integrated in the analysis. Value in the unit interval [0,1]. The default cutoff is 0.5. Only meaningful if <code>type = "fs"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border</code></td>
<td>
<p>Character string specifying whether factors with membership scores equal to <code>cutoff</code> are rounded up (<code>"up"</code>), rounded down (<code>"down"</code>) or dropped from the analysis (<code>"drop"</code>). Only meaningful if <code>type = "fs"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>Either <code>TRUE</code>/<code>FALSE</code> or a character vector with possible elements <code>"exhaustiveness"</code>, <code>"faithfulness"</code>, <code>"coherence"</code>, <code>"redundant"</code>, <code>"cyclic"</code>. The strings can be abbreviated, e.g.  <code>"e"</code> or <code>"exh"</code> for <code>"exhaustiveness"</code>, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acyclic.only</code></td>
<td>
<p>Logical; if <code>TRUE</code>, csf featuring a cyclic substructure are not returned. <code>FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycle.type</code></td>
<td>
<p>Character string specifying what type of cycles to be detected: <code>"factor"</code> (the default) or <code>"value"</code> (cf. <code>cyclic</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asf.selection</code></td>
<td>
<p>Character string specifying how to select asfs based on outcome variation in configurations incompatible with a model. <code>asf.selection = "cs"</code> (default): selection based on variation at the 0.5 anchor; <code>asf.selection = "fs"</code>: selection based on variation in the fuzzy-set value; <code>asf.selection = "none"</code>: no selection based on outcome variation in incompatible configurations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, some details on the csf building process are printed during the execution of the <code>cna</code> function. <code>FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to print in consistency, coverage, exhaustiveness, faithfulness, and coherence scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsolutions</code></td>
<td>
<p>Maximum number of msc, asf, and csf to print. Alternatively, <code>nsolutions = "all"</code> will print all solutions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the <code>configTable</code>'s attribute “cases”
is printed. <br> See <code>print.configTable</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>In <code>print.cna</code>: arguments passed to other <code>print</code>-methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <strong>first input <code>x</code></strong> of the <code>cna</code> function is a data frame or a configuration table. To ensure that no misinterpretations of returned asf and csf can occur, users are advised to use only upper case letters as factor (column) names. Column names may contain numbers, but the first sign in a column name must be a letter. Only ASCII signs should be used for column and row names.
</p>
<p>The argument <code>type</code> allows for specifying the <b>type of data</b> <code>x</code> contains. As of package version 3.2, that argument has the default value <code>"auto"</code> inducing automatic detection of the data type. But the user can still manually set the data type. Data that feature factors taking values 1 or 0 only are called <em>crisp-set</em>, which can be indicated by <code>type = "cs"</code>. If the data contain at least one factor that takes more than two values, e.g. {1,2,3}, the data count as <em>multi-value</em>: <code>type = "mv"</code>. Data featuring at least one factor taking real values from the interval [0,1] count as <em>fuzzy-set</em>: <code>type = "fs"</code>. (Note that mixing multi-value and fuzzy-set factors in one analysis is not supported). 
</p>
<p>A data frame or configuration table <code>x</code> is the only mandatory input of the <code>cna</code> function. In particular, <code>cna</code> does not need an input specifying which factor(s) in <code>x</code> are endogenous, it tries to infer that from the data. But if it is known prior to the analysis what factors have values that can figure as outcomes, an <strong>outcome specification</strong> can be given to <code>cna</code> via the argument <code>outcome</code>, which takes as input a character vector identifying one or several factor values  as potential outcome(s). For <code>"cs"</code> and <code>"fs"</code> data, outcomes are expressed by upper and lower cases (e.g. <code>outcome = c("A", "b")</code>). If factor names have multiple letters, any upper case letter is interpreted as 1, and the absence of upper case letters as 0 (i.e. <code>outcome = c("coLd", "shiver")</code> is interpreted as <code>COLD=1</code> and <code>SHIVER=0</code>).  For <code>"mv"</code> data, factor values are assigned by the “factor=value” notation (e.g. <code>outcome = c("A=1","B=3")</code>). Defaults to <code>outcome = TRUE</code>, which means that all factor values in <code>x</code> are potential outcomes.
</p>
<p>When the data <code>x</code> contain multiple potential outcomes, it may moreover be known, prior to the analysis, that these outcomes have a certain <strong>causal ordering</strong>, meaning that some of them are causally upstream of the others. Such information can be given to <code>cna</code> by means of the argument <code>ordering</code>, which takes either a character string or a list of character vectors as value.
For example,  <code>ordering = "A, B &lt; C"</code> or, equivalently, <code>ordering = list(c("A",</code> <code> "B"), "C")</code> determines that factor C is causally located <em>downstream</em> of factors A and B, meaning that <em>no values</em> of C are potential causes of values of A and B. In consequence, <code>cna</code> only checks whether values of A and B can be modeled as causes of values of C; the test for a causal dependency in the other direction is skipped.
An <code>ordering</code> does not need to explicitly mention all factors in <code>x</code>. If only a subset of the factors are included in the <code>ordering</code>, the non-included factors are entailed to be upstream of the included ones. Hence, <code>ordering = "C"</code> means that C is located downstream of all other factors in <code>x</code>.
</p>
<p>The argument <code>strict</code> determines whether the elements of one level in an ordering can be causally related or not. For example, if <code>ordering = "A, B &lt; C"</code> and <code>strict = TRUE</code>, then the values of A and B—which are on the same level of the ordering—are excluded to be causally related and <code>cna</code> skips corresponding tests. By contrast, if <code>ordering = "A, B &lt; C"</code> and <code>strict = FALSE</code>, then <code>cna</code> also searches for dependencies among the values of A and B. The default is <code>strict</code> <code> = FALSE</code>. 
</p>
<p>An <code>ordering</code> excludes <em>all</em> values of a factor as potential causes of an outcome. But a user may only be in a position to exclude <em>some</em> (not all) values as potential causes. Such information can be given to <code>cna</code> through the argument <strong><code>exclude</code></strong>, which can be assigned a vector of character strings featuring the factor values to be excluded as causes to the left of the "<code>-&gt;</code>" sign and the corresponding outcomes on the right. For example, <code>exclude = "A=1,C=3 -&gt; B=1"</code> determines that the value 1 of factor A and the value 3 of factor C are excluded as  causes of the value 1 of factor B. Factor values can be excluded as potential causes of multiple outcomes as follows: <code>exclude = c("A,c -&gt; B", "b,H -&gt; D")</code>. For <code>"cs"</code> and <code>"fs"</code> data, upper case letters are interpreted as 1, lower case letters as 0. If factor names have multiple letters, any upper case letter is interpreted as 1, and the absence of upper case letters as 0. For <code>"mv"</code> data, the "factor=value" notation is required. 
To exclude <em>all</em> values of a factor as potential causes of an outcome or to exclude a factor value as potential cause of <em>all</em> values of some endogenous factor, a "<code>*</code>" can be appended to the corresponding factor name; for example: <code>exclude = "A* -&gt; B"</code> or <code>exclude = "A=1,C=3 -&gt; B*"</code>.
The <code>exclude</code> argument can be used both independently of and in conjunction with <code>outcome</code> and  <code>ordering</code>, but if assignments to <code>outcome</code> and <code>ordering</code> contradict assignments to <code>exclude</code>, the latter are ignored. If <code>exclude</code> is assigned values of factors that do not appear in the data <code>x</code>, an error is returned.
</p>
<p>If no outcomes are specified and no causal ordering is provided, all factor values in <code>x</code> are treated as potential outcomes; more specifically, in case of <code>"cs"</code> and <code>"fs"</code> data, <code>cna</code> tests for all factors whether their presence (i.e. them taking the value 1) can be modeled as an outcome, and in case of  <code>"mv"</code> data, <code>cna</code> tests for all factors whether any of their possible values can be modeled as an outcome. That is done by searching for redundancy-free Boolean functions (in disjunctive normal form) that account for the behavior of an outcome in accordance with <code>exclude</code> and <code>cna</code>'s core model fit parameters of <b>consistency and coverage</b> (for details see the <span class="pkg">cna</span> package vignette or Ragin 2006). First, <code>cna</code> identifies all minimally sufficient conditions (msc) that meet the threshold given by the consistency threshold <code>con.msc</code> (resp. <code>con</code>, if <code>con.msc = con</code>) for each potential outcome in <code>x</code>. Then, these msc are disjunctively combined to minimally
necessary conditions that meet the coverage threshold given by <code>cov</code> such that the whole disjunction meets the solution consistency threshold given by <code>con</code>. The resulting expressions are the atomic solution formulas (asf) for every factor value that can be modeled as outcome. The default value for <code>con.msc</code>, <code>con</code>, and <code>cov</code> is 1. 
</p>
<p>The <code>cna</code> function builds its models in four stages using a <strong><em>bottom-up search algorithm</em></strong> (see Baumgartner and Ambuehl 2020). 
</p>

<dl>
<dt>First stage</dt>
<dd>
<p>On the basis of <code>outcome</code> and <code>ordering</code>, the algorithm builds a set of potential outcomes <strong>O</strong> from the factors in <code>x</code>; and on the basis of <code>ordering</code> and <code>exclude</code>, it assigns a set of potential causes to each potential outcome. At the default values of <code>outcome</code>, <code>ordering</code>, and <code>exclude</code>, all factor values in <code>x</code> are treated as potential outcomes and  as potential causes.</p>
</dd>
<dt>Second stage</dt>
<dd>
<p>The algorithm checks whether single factor values, e.g. A, b, C, (where "A" stands for "A=1" and "b" for "B=0") or D=3, E=2, etc., (whose membership scores, in case of <code>"fs"</code> data, meet <code>cutoff</code> in at least one case) are sufficient for a potential outcome in <strong>O</strong> (where a factor value counts as sufficient iff it meets the threshold given by <code>con.msc</code>). Next, conjuncts of two factor values, e.g. A*b, A*C, D=3*E=2 etc., (whose membership scores, in case of <code>"fs"</code> data, meet <code>cutoff</code> in at least one case) are tested for sufficiency. Then, conjuncts of three factors, and so on. Whenever a conjunction (or a single factor value) is found to be sufficient, all supersets of that conjunction contain redundancies and are, thus, not considered for the further analysis. The result is a set of msc for every potential outcome in <strong>O</strong>. To recover certain target structures from noisy data, it may be useful to allow <code>cna</code> to also consider sufficient conditions for further analysis that are not minimal. This can be accomplished by setting <code>only.minimal.msc</code> to <code>FALSE</code>. A concrete example illustrating the utility of <code>only.minimal.msc</code> is provided in the “Examples” section below. (The ordinary user is advised not to change the default value of this argument.)</p>
</dd> 
<dt>Third stage</dt>
<dd>
<p>Minimally necessary disjunctions are built for each potential outcome in <strong>O</strong> by first testing whether single msc are necessary, then disjunctions of two msc, then of three, etc. (where a disjunction of msc counts as necessary iff it meets the threshold given by <code>cov</code>). Whenever a disjunction of msc (or a single msc) is found to be necessary, all supersets of that disjunction contain redundancies and are, thus, excluded from the further analysis. Finally, all and only those disjunctions of msc that meet both <code>cov</code> and <code>con</code> are issued as redundancy-free <strong>atomic solution formulas</strong> (asf). To recover certain target structures from noisy data, it may be useful to allow <code>cna</code> to also consider necessary conditions for further analysis that are not minimal. This can be accomplished by setting <code>only.minimal.asf</code> to <code>FALSE</code>, in which case <em>all</em> disjunctions of msc reaching the con and cov thresholds will be returned. (The ordinary user is advised not to change the default value of this argument.)  
</p>
<p>As the combinatorial search space for asf is potentially too large to be exhaustively scanned in reasonable time, the argument <b><code>maxstep</code></b> allows for setting an upper bound for the complexity of the generated asf. <code>maxstep</code> takes a vector of three integers <code>c(i, j, k)</code> as input, entailing that the generated asf have maximally <code>j</code> disjuncts with maximally <code>i</code> conjuncts each and a total of maximally <code>k</code> factor values (<code>k</code> is the maximal complexity). The default is <code>maxstep = c(3, 4, 10)</code>.
</p>
<p>Note that when the data feature noise due to uncontrolled background influences the default <code>con</code> and <code>cov</code> thresholds of 1 will often not yield any asf. In such cases, <code>con</code> and <code>cov</code> may be set to values different from 1. <code>con</code> and <code>cov</code> should neither be set too high, in order to avoid overfitting, nor too low, in order to avoid underfitting. The <strong>overfitting danger</strong> is severe in causal modeling with CNA (and configurational causal modeling more generally). For a discussion of this problem see Parkkinen and Baumgartner (2023), who also introduce a procedure for robustness assessment that explores all threshold settings in a given interval—in an attempt to reduce both over- and underfitting. See also the R package <a href="https://CRAN.R-project.org/package=frscore"><span class="pkg">frscore</span></a>. </p>
</dd>
<dt>Fourth stage</dt>
<dd>
<p>If <code>cna</code> finds asf, it builds <strong>complex solution formulas</strong> (csf) from those asf. This is done in a stepwise manner as follows. First, all logically possible conjunctions featuring one asf of every outcome are built. Second, if <code>inus.only = TRUE</code>, the solutions resulting from step 1 are freed of structural redundancies (cf. Baumgartner and Falk 2023), and  tautologous and contradictory solutions as well as solutions with partial structural redundancies and constant factors are eliminated (cf. <code>is.inus</code>). [Note: as of package version 3.6.0, the "implication" definition of partial structural redundancy is used, see <code>is.inus</code> for details.] Third, if <code>acyclic.only = TRUE</code>, solutions with cyclic substructures are eliminated. Fourth, for those solutions that were modified in the previous steps, consistency and coverage are re-calculated and solutions that no longer reach <code>con</code> or <code>cov</code> are eliminated. The remaining solutions are returned as csf. (See also <code>csf</code>.)</p>
</dd> 
</dl>
<p>If <code>verbose</code> is set to its non-default value <code>TRUE</code>, some information about the progression of the algorithm is returned to the console during the execution of the <code>cna</code> function. The execution can easily be interrupted by ESC at all stages.
</p>
<p>The <b>default output</b> of <code>cna</code> lists asf and csf, ordered by complexity and the product of consistency and coverage. It provides the consistency and coverage scores of each solution, a complexity score, which corresponds to the number of exogenous factor values in a solution, and a column “<code>inus</code>” indicating whether a solution has INUS form, meaning whether it is redundancy-free as required by the <em>INUS-theory</em> of causation (Mackie 1974, ch. 3; Baumgartner and Falk 2023). If <code>inus.only = TRUE</code>, all solutions automatically have INUS form, but if <code>only.minimal.msc</code> or 
<code>only.minimal.asf</code> are set to <code>FALSE</code>, non-INUS solutions may also be returned. 
</p>
<p>Apart from the standard solution attributes, <code>cna</code> can calculate a number of  <b>further solution attributes</b>: <code>exhaustiveness</code>, <code>faithfulness</code>, <code>coherence</code>, <code>redundant</code>, and <code>cyclic</code> all of which are recovered by setting <code>details</code> to its non-default value <code>TRUE</code> or to a character vector specifying the attributes to be calculated. 
These attributes require explication (see also <code>vignette("cna")</code>):
</p>

<ul>
<li> <p><code>exhaustiveness</code> and <code>faithfulness</code> are two measures of model fit that quantify the degree of correspondence between the configurations that are, in principle, compatible with a solution and the configurations contained in the data from which that solution is derived. 
</p>
  
<ul>
<li> <p><code>exhaustiveness</code> amounts to the ratio of the number of configurations in the data that are compatible with a solution to the number of configurations in total that are compatible with a solution.
</p>
</li>
<li> <p><code>faithfulness</code> amounts to the ratio of the number of configurations in the data that are compatible with a solution to the total number of configurations in the data.
</p>
</li>
</ul>
</li>
<li>  <p><code>coherence</code> measures the degree to which the asf combined in a csf cohere, i.e. are instantiated together in the data rather than independently of one another. For more details see <code>coherence</code>. 
</p>
</li>
<li> <p><code>redundant</code> determines whether a csf contains structurally redundant proper parts. A csf with <code>redundant = TRUE</code> should not be causally interpreted. If <code>inus.only = TRUE</code>, all csf are free of structural redundancies.  For more details see <code>redundant</code>. 
</p>
</li>
<li> <p><code>cyclic</code> determines whether a csf contains a cyclic substructure. For more details see <code>cyclic</code>.
</p>
</li>
</ul>
<p>The argument <code>notcols</code> is used to calculate asf and csf
for <b>negative outcomes</b> in data of <code>type</code> <code>"cs"</code> and <code>"fs"</code> (in <code>"mv"</code> data <code>notcols</code> has no meaningful interpretation and, correspondingly, issues an error message). If <code>notcols = "all"</code>, all factors in <code>x</code> are negated,
i.e. their membership scores i are replaced by 1-i. If <code>notcols</code> is given a character vector 
of factors in <code>x</code>, only the factors in that vector are negated. For example, <code>notcols = c("A", "B")</code>
determines that only factors A and B are negated. The default is no negations, i.e. <code>notcols = NULL</code>.
</p>
<p><code>suff.only</code> is applicable whenever a complete <code>cna</code> analysis cannot be performed for reasons of computational complexity. In such a case, <code>suff.only = TRUE</code> forces <code>cna</code> to stop the analysis after the identification of msc, which will normally yield results even in cases when a complete analysis does not terminate. In that manner, it is possible to shed at least some light on the dependencies among the factors in <code>x</code>, in spite of an incomputable solution space.
</p>
<p><code>rm.const.factors</code> and <code>rm.dup.factors</code> are used to determine the handling of <b>constant factors</b>, i.e. factors with constant values in all cases (rows) in <code>x</code>, and of <b>duplicated factors</b>, i.e. factors that take identical value distributions in all cases in <code>x</code>. As of package version 3.5.4, the default is <code>FALSE</code> for both <code>rm.const.factors</code> and <code>rm.dup.factors</code>. See <code>configTable</code> for more details.
</p>
<p>If the data <code>x</code> feature noise, it can happen that all variation of an outcome occurs in noisy configurations in <code>x</code>. In such cases, there may be asfs that meet chosen consistency and coverage thresholds (lower than 1) such that the corresponding outcome only varies in configurations that are incompatible with the strict crisp-set or fuzzy-set necessity and sufficiency relations expressed by those very asfs. In the default setting <code>"cs"</code> of the argument <code>asf.selection</code> (introduced in version 3.5.0 of the <span class="pkg">cna</span> package), an asf is only returned if the outcome takes a value above and below the 0.5 anchor in the configurations compatible with the strict crisp-set necessity and sufficiency relations expressed by that asf. At <code>asf.selection = "fs"</code>, an asf is only returned if the outcome takes different values in the configurations compatible with the strict fuzzy-set necessity and sufficiency relations expressed by that asf. At <code>asf.selection = "none"</code>, asfs are returned even if outcome variation only occurs in noisy configurations, which was the default behavior of <code>cna</code> prior to version 3.5.0. (For more details, see examples below.)
</p>
<p>The argument <code>what</code> can be specified both for the <code>cna</code> and the <code>print()</code>
function. It regulates what items of the output of <code>cna</code> are printed. If
<code>what</code> is given the value “<code>t</code>”, the configuration table is printed; if
it is given an “<code>m</code>”, the msc are printed; if it is given an “<code>a</code>”, the asf are printed; if it is given a “<code>c</code>”, the csf are printed.
<code>what = "all"</code> or <code>what = "tmac"</code> determine that all output items are
printed. Note that <code>what</code> has no effect on the computations that are performed when executing <code>cna</code>; it only determines how the result is printed.
The default output of <code>cna</code> is <code>what = "ac"</code>. It first returns an implemented ordering or outcome specification. Second, the top 5 asf and, third, the top 5 csf are reported, along with an indication of how many solutions in total exist. To print all msc, asf, and csf, the corresponding functions in <code>condTbl</code> should be used. 
In case of <code>suff.only = TRUE</code>, <code>what</code> defaults to <code>"m"</code>. msc are printed with an attribute <code>minimal</code> specifying whether a sufficient condition is minimal as required by the INUS-theory of causation. If <code>inus.only = TRUE</code>, all msc are minimal by default. 
</p>
<p><code>cna</code> only includes factor configurations in the analysis that are actually instantiated in the data. The argument <code>cutoff</code> determines the minimum membership score required for a factor or a combination of factors to count as instantiated. It takes values in the unit interval [0,1] with a default of 0.5. <code>border</code> specifies whether configurations with membership scores equal to <code>cutoff</code> are rounded up (<code>border = "up"</code>), which is the default, rounded down (<code>border = "down"</code>), or dropped from the analysis (<code>border = "drop"</code>).
</p>
<p>The arguments <code>digits</code>, <code>nsolutions</code>, and <code>show.cases</code> apply to the <strong><code>print()</code> method</strong>, which takes an object of class “cna” as first input. <code>digits</code> determines how many digits of consistency, coverage, coherence, exhaustiveness, and faithfulness scores
are printed, while <code>nsolutions</code> fixes the number of conditions and solutions
to print. <code>nsolutions</code> applies separately to minimally sufficient conditions,
atomic solution formulas, and complex solution formulas. <code>nsolutions = "all"</code> recovers all minimally sufficient conditions, atomic and complex solution formulas. <code>show.cases</code> is applicable if the <code>what</code> argument is given the value “<code>t</code>”. In that case, <code>show.cases = TRUE</code> yields a configuration table featuring a “cases” column, which assigns cases to configurations.
</p>
<p>The option “spaces” controls how the conditions are rendered. The current setting is queried by typing <code>getOption("spaces")</code>. The option specifies characters that will be printed with a space before and after them. The default is <code>c("&lt;-&gt;","-&gt;","+")</code>. A more compact output is obtained with <code>option(spaces = NULL)</code>. 
</p>


<h3>Value</h3>

<p><code>cna</code> returns an object of class “cna”, which amounts to a list with the following elements:
</p>

<table>
<tr>
<td style="text-align: right;">
<code>call</code>: </td>
<td style="text-align: left;"> the executed function call</td>
</tr>
<tr>
<td style="text-align: right;">
<code>x</code>:</td>
<td style="text-align: left;"> the processed data frame or configuration table, as input to <code>cna</code>
</td>
</tr>
<tr>
<td style="text-align: right;">
<code>ordering</code> </td>
<td style="text-align: left;"> the ordering imposed on the factors in the configuration table (if not <code>NULL</code>)</td>
</tr>
<tr>
<td style="text-align: right;"> 
<code>notcols</code> </td>
<td style="text-align: left;"> the names of negated outcome factors (if not <code>NULL</code>)</td>
</tr>
<tr>
<td style="text-align: right;"> 
<code>configTable</code>: </td>
<td style="text-align: left;"> the object of class “configTable”</td>
</tr>
<tr>
<td style="text-align: right;">
<code>solution</code>: </td>
<td style="text-align: left;"> the solution object, which itself is composed of lists exhibiting msc, asf,</td>
</tr>
<tr>
<td style="text-align: right;"></td>
<td style="text-align: left;"> and csf for all factors in <code>x</code>
</td>
</tr>
<tr>
<td style="text-align: right;">
<code>what</code>:</td>
<td style="text-align: left;"> the values given to the <code>what</code> argument</td>
</tr>
<tr>
<td style="text-align: right;">
<code>details</code>:</td>
<td style="text-align: left;"> the calculated solution attributes</td>
</tr>
<tr>
<td style="text-align: right;">
<code>...</code>:</td>
<td style="text-align: left;"> plus additional list elements reporting the values given to the parameters <code>con</code>,</td>
</tr>
<tr>
<td style="text-align: right;">
</td>
<td style="text-align: left;"> <code>cov</code>, <code>con.msc</code>, <code>inus.only</code>, <code>acyclic.only</code>, and <code>cycle.type</code>. 
  </td>
</tr>
</table>
<h3>Note</h3>

<p>In the first example described below (in <em>Examples</em>), the two resulting complex solution formulas represent a common cause structure and a causal chain, respectively. The common cause structure is graphically depicted in figure (a) below, the causal chain in figure (b).
</p>
<p><img src="../help/figures/structures.png" alt="Causal Structures"></p>


<h3>References</h3>

<p>Aleman, Jose. 2009. “The Politics of Tripartite Cooperation in New Democracies: A Multi-level Analysis.” <em>International Political Science Review</em> 30 (2):141-162.
</p>
<p>Basurto, Xavier. 2013. “Linking Multi-Level Governance to Local Common-Pool 
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from 
Twenty Years of Biodiversity Conservation in Costa Rica.” <em>Global Environmental Change</em> 23(3):573-87.
</p>
<p>Baumgartner, Michael. 2009a. “Inferring Causal Complexity.”
<em>Sociological Methods &amp; Research</em> 38(1):71-101.
</p>
<p>Baumgartner, Michael and Mathias Ambuehl. 2020. “Causal Modeling with Multi-Value and Fuzzy-Set Coincidence Analysis.” <em>Political Science Research and Methods</em>. 8:526–542.
</p>
<p>Baumgartner, Michael and Christoph Falk. 2023. “Boolean Difference-Making: A Modern Regularity Theory of Causation”. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>
<p>Hartmann, Christof, and Joerg Kemmerzell. 2010. “Understanding Variations 
in Party Bans in Africa.” <em>Democratization</em> 17(4):642-65.
</p>
<p>Krook, Mona Lena. 2010.
“Women's Representation in Parliament: A Qualitative Comparative Analysis.”
<em>Political Studies</em> 58(5):886-908.
</p>
<p>Mackie, John L. 1974. <em>The Cement of the Universe: A Study of Causation.</em> Oxford: Oxford University Press.
</p>
<p>Parkkinen, Veli-Pekka and Michael Baumgartner. 2023. “Robustness and Model Selection in Configurational Causal Modeling”, <em>Sociological Methods &amp; Research</em>,  52(1), 176-208.
</p>
<p>Ragin, Charles C. 2006. “Set Relations in Social Research: Evaluating Their Consistency and Coverage”. <em>Political Analysis</em> 14(3):291-310.
</p>
<p>Wollebaek, Dag. 2010.
“Volatility and Growth in Populations of Rural Associations.”
<em>Rural Sociology</em> 75:144-166.
</p>


<h3>See Also</h3>

<p><code>configTable</code>, <code>condition</code>, <code>cyclic</code>, <code>condTbl</code>, <code>selectCases</code>, <code>makeFuzzy</code>, <code>some</code>,  <code>coherence</code>,<br><code>minimalizeCsf</code>, <code>randomConds</code>, <code>is.submodel</code>,  <code>is.inus</code>,  <code>redundant</code>, <code>full.ct</code>, <code>shortcuts</code>, <code>d.educate</code>,<br><code>d.women</code>, <code>d.pban</code>, <code>d.autonomy</code>, <code>d.highdim</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Ideal crisp-set data from Baumgartner (2009a) on education levels in western democracies
# ----------------------------------------------------------------------------------------
# Exhaustive CNA without constraints on the search space; print atomic and complex 
# solution formulas (default output).
cna.educate &lt;- cna(d.educate)
cna.educate
# The two resulting complex solution formulas represent a common cause structure 
# and a causal chain, respectively. The common cause structure is graphically depicted 
# in (Note, figure (a)), the causal chain in (Note, figure (b)).

# Print only complex solution formulas.
print(cna.educate, what = "c")

# Print only atomic solution formulas.
print(cna.educate, what = "a")

# Print only minimally sufficient conditions.
print(cna.educate, what = "m")

# Print only the configuration table.
print(cna.educate, what = "t")

# CNA with negations of the factors E and L.
cna(d.educate, notcols = c("E","L"))
# The same by use of the outcome argument.
cna(d.educate, outcome = c("e","l"))

# CNA with negations of all factors.
cna(d.educate, notcols = "all")

# Print msc, asf, and csf with all solution attributes.
cna(d.educate, what = "mac", details = TRUE)

# Add only the non-standard solution attributes "exhaustiveness" and  "faithfulness".
cna(d.educate, details = c("e", "f"))

# Print solutions without spaces before and after "+".
options(spaces = c("&lt;-&gt;", "-&gt;" ))
cna(d.educate, details = c("e", "f"))

# Print solutions with spaces before and after "*".
options(spaces = c("&lt;-&gt;", "-&gt;", "*" ))
cna(d.educate, details = c("e", "f"))

# Restore the default of the option "spaces".
options(spaces = c("&lt;-&gt;", "-&gt;", "+"))



# Crisp-set data from Krook (2010) on representation of women in western-democratic parliaments
# ------------------------------------------------------------------------------------------
# This example shows that CNA can distinguish exogenous and endogenous factors in the data.
# Without being told which factor is the outcome, CNA reproduces the original QCA 
# of Krook (2010).
ana1 &lt;- cna(d.women, details = c("e", "f"))
ana1

# The two resulting asf only reach an exhaustiveness score of 0.438, meaning that
# not all configurations that are compatible with the asf are contained in the data
# "d.women". Here is how to extract the configurations that are compatible with 
# the first asf but are not contained in "d.women".
library(dplyr)
setdiff(ct2df(selectCases(asf(ana1)$condition[1], full.ct(d.women))),
        d.women)


# Highly ambiguous crisp-set data from Wollebaek (2010) on very high volatility of 
# grassroots associations in Norway
# --------------------------------------------------------------------------------
# csCNA with ordering from Wollebaek (2010) [Beware: due to massive ambiguities, this analysis
# will take about 20 seconds to compute.]
cna(d.volatile, ordering = "VO2", maxstep = c(6, 6, 16))
              
# Using suff.only, CNA can be forced to abandon the analysis after minimization of sufficient 
# conditions. [This analysis terminates quickly.]
cna(d.volatile, ordering = "VO2", maxstep = c(6, 6, 16), suff.only = TRUE)

# Similarly, by using the default maxstep, CNA can be forced to only search for asf and csf
# with reduced complexity.
cna(d.volatile, ordering = "VO2")

# ordering = "VO2" only excludes that the values of VO2 are causes of the values
# of the other factors in d.volatile, but cna() still tries to model other factor 
# values as outcomes. The following call determines that only VO2 is a possible 
# outcome. (This call terminates quickly.)
cna(d.volatile, outcome = "VO2")

# We can even increase maxstep.
cna(d.volatile, outcome = "VO2", maxstep=c(4,4,16))

# If it is known that, say, el and od cannot be causes of VO2, we can exclude this.
cna(d.volatile, outcome = "VO2", maxstep=c(4,4,16), exclude = "el, od -&gt; VO2")

# The verbose argument returns information during the execution of cna().
cna(d.volatile, ordering = "VO2", verbose = TRUE)


# Multi-value data from Hartmann &amp; Kemmerzell (2010) on party bans in Africa
# ---------------------------------------------------------------------------
# mvCNA with an outcome specification taken from Hartmann &amp; Kemmerzell 
# (2010); coverage cutoff at 0.95 (consistency cutoff at 1), maxstep at c(6, 6, 10).
cna.pban &lt;- cna(d.pban, outcome = "PB=1", cov = .95, maxstep = c(6, 6, 10), 
                  what = "all")
cna.pban

# The previous function call yields a total of 14 asf and csf, only 5 of which are 
# printed in the default output. Here is how to extract all 14 asf and csf.
asf(cna.pban)
csf(cna.pban)

# [Note that all of these 14 causal models reach better consistency and 
# coverage scores than the one model Hartmann &amp; Kemmerzell (2010) present in their paper, 
# which they generated using the TOSMANA software, version 1.3. 
# T=0 + T=1 + C=2 + T=1*V=0 + T=2*V=0 &lt;-&gt; PB=1]
condTbl("T=0 + T=1 + C=2 + T=1*V=0 + T=2*V=0 &lt;-&gt; PB = 1", d.pban)

# Extract all minimally sufficient conditions.
msc(cna.pban)

# Alternatively, all msc, asf, and csf can be recovered by means of the nsolutions
# argument of the print function.
print(cna.pban, nsolutions = "all")

# Print the configuration table with the "cases" column.
print(cna.pban, what = "t", show.cases = TRUE)

# Build solution formulas with maximally 4 disjuncts.
cna(d.pban, outcome = "PB=1", cov = .95, maxstep = c(4, 4, 10))

# Only print 2 digits of consistency and coverage scores.
print(cna.pban, digits = 2)

# Build all but print only two msc for each factor and two asf and csf.
print(cna(d.pban, outcome = "PB=1", cov = .95,
      maxstep = c(6, 6, 10), what = "all"), nsolutions = 2)

# Lowering the consistency instead of the coverage threshold yields further models with
# excellent fit scores; print only asf.
cna(d.pban, outcome = "PB=1", con = .93, what = "a", maxstep = c(6, 6, 10))

# Lowering both consistency and coverage. 
cna(d.pban, outcome = "PB=1", con = .9, cov =.9, maxstep = c(6, 6, 10))

# Lowering both consistency and coverage and excluding F=0 as potential cause of PB=1.
cna(d.pban, outcome = "PB=1", con = .9, cov =.9, maxstep = c(6, 6, 10), 
    exclude = "F=0 -&gt; PB=1")
      
# Specifying an outcome is unnecessary for d.pban. PB=1 is the only 
# factor value in those data that could possibly be an outcome.
cna(d.pban, con=.9, cov = .9, maxstep = c(6, 6, 10))


# Fuzzy-set data from Basurto (2013) on autonomy of biodiversity institutions in Costa Rica
# ---------------------------------------------------------------------------------------
# Basurto investigates two outcomes: emergence of local autonomy and endurance thereof. The 
# data for the first outcome are contained in rows 1-14 of d.autonomy, the data for the second
# outcome in rows 15-30. For each outcome, the author distinguishes between local ("EM",  
# "SP", "CO"), national ("CI", "PO") and international ("RE", "CN", "DE") conditions. Here,   
# we first apply fsCNA to replicate the analysis for the local conditions of the endurance of 
# local autonomy.
dat1 &lt;- d.autonomy[15:30, c("AU","EM","SP","CO")]
cna(dat1, ordering = "AU", strict = TRUE, con = .9, cov = .9)

# The fsCNA model has significantly better consistency (and equal coverage) scores than the 
# model presented by Basurto (p. 580): SP*EM + CO &lt;-&gt; AU, which he generated using the 
# fs/QCA software.
condition("SP*EM + CO &lt;-&gt; AU", dat1) # both EM and CO are redundant to account for AU

# If we allow for dependencies among the conditions by setting strict = FALSE, CNA reveals 
# that SP is a common cause of both AU and EM.
cna(dat1, ordering = "AU", strict = FALSE, con = .9, cov = .9)

# Here is the analysis for the international conditions of autonomy endurance, which
# yields the same model as the one presented by Basurto (plus one model Basurto does not mention).
dat2 &lt;- d.autonomy[15:30, c("AU","RE", "CN", "DE")]
cna(dat2, ordering = "AU", con = .9, con.msc = .85, cov = .85)

# But there are other models (here printed with all solution attributes)
# that fare equally well.
cna(dat2, ordering = "AU", con = .85, cov = .9, details = TRUE)

# Finally, here is an analysis of the whole dataset, showing that across the whole period 
# 1986-2006, the best causal model of local autonomy (AU) renders that outcome dependent
# only on local direct spending (SP).
cna(d.autonomy, outcome = "AU", con = .85, cov = .9, 
      maxstep = c(5, 5, 11), details = TRUE)

# Also build non-INUS solutions.
asf(cna(d.autonomy, outcome = "AU", con = .85, cov = .9, 
      maxstep = c(5, 5, 11), details = TRUE, inus.only = FALSE))
      
      
# High-dimensional data
# ---------------------
# As of package version 3.1, cna's handling of data with more than 20 factors
# has been improved. Here's an analysis of the data d.highdim with 50 factors, massive 
# fragmentation, and 20% noise. (Takes about 15 seconds to compute.)
head(d.highdim)
cna(d.highdim,  outcome = c("V13", "V11"), con = .8, cov = .8)

# By lowering maxstep, computation time can be reduced to less than 1 second
# (at the cost of an incomplete solution).
cna(d.highdim,  outcome = c("V13", "V11"), con = .8, cov = .8,
  maxstep = c(2,3,10))      


# Highly ambiguous artificial data to illustrate exhaustiveness and acyclic.only
# ------------------------------------------------------------------------------
mycond &lt;- "(D + C*f &lt;-&gt; A)*(C*d + c*D &lt;-&gt; B)*(B*d + D*f &lt;-&gt; C)*(c*B + B*f &lt;-&gt; E)"
dat1 &lt;- selectCases(mycond)
ana1 &lt;- cna(dat1, details = c("e","cy"))
# There exist almost 2M csf. This is how to build the first 1076 of them, with 
# additional messages about the csf building process.
first.csf &lt;- csf(ana1, verbose = TRUE)
first.csf
# Most of these csf are compatible with more configurations than are contained in 
# dat1. Only 193 csf in first.csf are perfectly exhaustive (i.e. all compatible 
# configurations are contained in dat1).
subset(first.csf, exhaustiveness == 1)

# 1020 of the csf in first.csf contain cyclic substructures.
subset(first.csf, cyclic == TRUE)

# Here's how to only build acyclic csf.
ana2 &lt;- cna(dat1, details = c("e","cy"), acyclic.only = TRUE)
csf(ana2, verbose = TRUE)


# Illustration of only.minimal.msc = FALSE
# ----------------------------------------
# Simulate noisy data on the causal structure "a*B*d + A*c*D &lt;-&gt; E"
set.seed(1324557857)
mydata &lt;- allCombs(rep(2, 5)) - 1
dat1 &lt;- makeFuzzy(mydata, fuzzvalues = seq(0, 0.5, 0.01))
dat1 &lt;- ct2df(selectCases1("a*B*d + A*c*D &lt;-&gt; E", con = .8, cov = .8, dat1))

# In dat1, "a*B*d + A*c*D &lt;-&gt; E" has the following con and cov scores.
as.condTbl(condition("a*B*d + A*c*D &lt;-&gt; E", dat1))

# The standard algorithm of CNA will, however, not find this structure with
# con = cov = 0.8 because one of the disjuncts (a*B*d) does not meet the con
# threshold.
as.condTbl(condition(c("a*B*d &lt;-&gt; E", "A*c*D &lt;-&gt; E"), dat1))
cna(dat1, outcome = "E", con = .8, cov = .8)

# With the argument con.msc we can lower the con threshold for msc, but this does not
# recover "a*B*d + A*c*D &lt;-&gt; E" either.
cna2 &lt;- cna(dat1, outcome = "E", con = .8, cov = .8, con.msc = .78)
cna2
msc(cna2)

# The reason is that "A*c -&gt; E" and "c*D -&gt; E" now also meet the con.msc threshold and,
# therefore,  "A*c*D -&gt; E" is not contained in the msc---because of violated minimality.
# In a situation like this, lifting the minimality requirement via 
# only.minimal.msc = FALSE allows CNA to find the intended target.
cna(dat1, outcome = "E", con = .8, cov = .8, con.msc = .78,
      only.minimal.msc = FALSE)


# Overriding automatic detection of the data type
# ------------------------------------------------
# The type argument allows for manually setting the data type.
# If "cs" data are treated as "mv" data, cna() automatically builds models for all values
# of outcome factors, i.e. both positive and negated outcomes.
cna(d.educate, type = "mv")
# Treating "cs" data as "fs".
cna(d.women, type = "fs")

# Not all manual settings are admissible. 
try(cna(d.autonomy, outcome = "AU", con = .8, cov = .8, type = "mv" ))

# Shortcut functions from previous versions of the package continue to work 
# (see ?shortcuts).
fscna(d.autonomy, outcome = "AU", con = .8, cov = .8)
mvcna(d.pban, outcome = "PB=1", con = .8)


# Illustration of asf.selection
# -----------------------------
# Consider the following data set:
d1 &lt;- data.frame(X1 = c(1, 0, 1),
                 X2 = c(0, 1, 0), 
                 Y = c(1, 1, 0))
ct1 &lt;- configTable(d1, frequency = c(10, 10, 1))

# Both of the following are asfs reaching con=0.95 and cov=1.
condition(c("X1+X2&lt;-&gt;Y", "x1+x2&lt;-&gt;Y"), ct1)

# Up to version 3.4.0 of the cna package, these two asfs were inferred from 
# ct1 by cna(). But the outcome Y is constant in ct1, except for a variation in 
# the third row, which is incompatible with X1+X2&lt;-&gt;Y and x1+x2&lt;-&gt;Y. Subject to  
# both of these models, the third row of ct1 is a noisy configuration. Inferring
# difference-making models that are incapable of accounting for the only difference
# in the outcome in the data is inadequate. (Thanks to Luna De Souter for 
# pointing out this problem.) Hence, as of version 3.5.0, asfs whose outcome only
# varies in configurations incompatible with the strict crisp-set necessity 
# or sufficiency relations expressed by those asfs are not returned anymore.

cna(ct1, outcome = "Y", con = 0.9)

# The old behavior of cna() can be obtained by setting the argument asf.selection
# to its non-default value "none".

cna(ct1, outcome = "Y", con = 0.9, asf.selection = "none")

# Analysis of fuzzy-set data from Aleman (2009).
cna(d.pacts, con = .9, cov = .85)
cna(d.pacts, con = .9, cov = .85, asf.selection = "none")
# In the default setting, cna() does not return any model for d.pacts because
# the outcome takes a value &gt;0.5 in every single case, meaning it does not change
# between presence and absence. No difference-making model should be inferred from
# such data. 
# The implications of asf.selection can also be traced by
# the verbose argument:

cna(d.pacts, con = .9, cov = .85, verbose = TRUE)

</code></pre>


</div>