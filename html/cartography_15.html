<div class="container">

<table style="width: 100%;"><tr>
<td>getBreaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Classification</h2>

<h3>Description</h3>

<p>A function to classify continuous variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getBreaks(v, nclass = NULL, method = "quantile", k = 1, middle = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a vector of numeric values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclass</code></td>
<td>
<p>a number of classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a classification method; one of "fixed", "sd", "equal", "pretty", "quantile",
"kmeans", "hclust", "bclust", "fisher", "jenks", "dpih", "q6", "geom", "arith", "em" or "msd" (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of standard deviation for "msd" method (see Details)..</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>middle</code></td>
<td>
<p>creation of a central class for "msd" method (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments of <code>classIntervals</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>"fixed", "sd", "equal", "pretty", "quantile", "kmeans", "hclust",
"bclust", "fisher", "jenks" and "dpih" are <code>classIntervals</code>
methods. You may need to pass additional arguments for some of them.<br><br>
Jenks ("jenks" method) and Fisher-Jenks ("fisher" method) algorithms are based on the same principle and give 
quite similar results but Fisher-Jenks is much faster. <br><br>
The "q6" method uses the following <code>quantile</code> probabilities: 0, 0.05, 0.275, 0.5, 0.725, 0.95, 1.<br><br>   
The "geom" method is based on a geometric progression along the variable values.<br><br>
The "arith" method is based on an arithmetic progression along the variable values.<br><br>
The "em" method is based on nested averages computation.<br><br> 
The "msd" method is based on the mean and the standard deviation of a numeric vector. 
The <code>nclass</code> parameter is not relevant, use <code>k</code> and <code>middle</code> instead. <code>k</code> indicates 
the extent of each class in share of standard deviation. If <code>middle=TRUE</code> then 
the mean value is the center of a class else the mean is a break value.
</p>


<h3>Value</h3>

<p>A numeric vector of breaks
</p>


<h3>Note</h3>

<p>This function is mainly a wrapper of <code>classIntervals</code> + 
"arith", "em", "q6", "geom" and "msd" methods.
</p>


<h3>See Also</h3>

<p>classIntervals
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sf)
mtq &lt;- st_read(system.file("gpkg/mtq.gpkg", package="cartography"))
var &lt;- mtq$MED
# Histogram
hist(var, probability = TRUE, breaks = 20)
rug(var)
moy &lt;- mean(var)
med &lt;- median(var)
abline(v = moy, col = "red", lwd = 3)
abline(v = med, col = "blue", lwd = 3)

# Quantile intervals
breaks &lt;- getBreaks(v = var, nclass = 6, method = "quantile")
hist(var, probability = TRUE, breaks = breaks, col = "#F0D9F9")
rug(var)
med &lt;- median(var)
abline(v = med, col = "blue", lwd = 3)

# Pretty breaks
breaks &lt;- getBreaks(v = var, nclass = 4, method = "pretty")
hist(var, probability = TRUE, breaks = breaks, col = "#F0D9F9", axes = FALSE)
rug(var)
axis(1, at = breaks)
axis(2)
abline(v = med, col = "blue", lwd = 6)

# kmeans method
breaks &lt;- getBreaks(v = var, nclass = 4, method = "kmeans")
hist(var, probability = TRUE, breaks = breaks, col = "#F0D9F9")
rug(var)
abline(v = med, col = "blue", lwd = 6)

# Geometric intervals
breaks &lt;- getBreaks(v = var, nclass = 8, method = "geom")
hist(var, probability = TRUE, breaks = breaks, col = "#F0D9F9")
rug(var)

# Mean and standard deviation (msd)
breaks &lt;- getBreaks(v = var, method = "msd", k = 1, middle = TRUE)
hist(var, probability = TRUE, breaks = breaks, col = "#F0D9F9")
rug(var)
moy &lt;- mean(var)
sd &lt;- sd(var)
abline(v = moy, col = "red", lwd = 3)
abline(v = moy + 0.5 * sd, col = "blue", lwd = 3)
abline(v = moy - 0.5 * sd, col = "blue", lwd = 3)
</code></pre>


</div>