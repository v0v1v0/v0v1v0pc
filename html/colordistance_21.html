<div class="container">

<table style="width: 100%;"><tr>
<td>normalizeRGB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Normalize pixel RGB ratios</h2>

<h3>Description</h3>

<p>Converts clusters from raw channel intensity to their fraction of the
intensity for that cluster
</p>


<h3>Usage</h3>

<pre><code class="language-R">normalizeRGB(extractClustersObject)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>extractClustersObject</code></td>
<td>
<p>A list of color clusters such as those returned
by <code>extractClusters</code> or <code>getHistList</code>. List must
contain identically sized dataframes with color coordinates (R, G, B or H,
S, V) as the first three columns.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>A list of the same size and structure as the input list, but with the
cluster normalized as described.
</p>


<h3>Note</h3>

<p>This is a useful option if your images have a lot of variation in lighting,
but obviously comes at the cost of reducing variation (if darker and lighter
colors are meaningful sources of variation in the dataset).
</p>
<p>For example, a bright yellow (R=1, G=1, B=0) and a darker yellow (R=0.8,
G=0.8, B=0) both have 50% red, 50% green, and 0% blue, so their normalized
values would be equivalent.
</p>
<p>A similar but less harsh alternative would be to use HSV rather than RGB for
pixel binning and color similarity clustering by setting <code>hsv=T</code> in
clustering functions and specifying a low number of 'value' bins (e.g.
<code>bins=c(8, 8, 2)</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R">cluster.list &lt;- colordistance::getKMeansList(c(system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance"), lower=rep(0.8, 3),
upper=rep(1, 3)))
cluster.list &lt;- colordistance::extractClusters(cluster.list)
colordistance:::normalizeRGB(cluster.list)
</code></pre>


</div>