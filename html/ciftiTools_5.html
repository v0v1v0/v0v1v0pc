<div class="container">

<table style="width: 100%;"><tr>
<td>apply_parc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply function over locations in each parcel</h2>

<h3>Description</h3>

<p>Apply a function across all locations in each parcel, for a pair of data and
parcellation <code>"xifti"</code> objects that are in registration with one
another. By default, the mean value in each parcel is calculated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">apply_parc(
  xii,
  parc,
  FUN = mean,
  mwall_value = NA,
  return_as = c("matrix", "xifti"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xii</code></td>
<td>
<p>The <code>"xifti"</code> data to apply the function over, within each
parcel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parc</code></td>
<td>
<p>The <code>"xifti"</code> "dlabel" parcellation. Each parcel is defined
by a unique key in the label table. If there are multiple columns, only the
first column will be used. Alternatively, <code>parc</code> can just be a vector
of keys whose length is the number of data locations in <code>"xii"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function that takes as input an <code class="reqn">M \times N</code> matrix (<code class="reqn">M</code>
locations in a given parcel, and <code class="reqn">N</code> measurements/columns in <code>xii</code>)
and outputs a constant-sized (<code class="reqn">Q</code>) numeric vector. Default: <code>mean</code>.
</p>
<p>Use <code>colMeans</code> to obtain the average timeseries of each parcel, such as
in order to compute functional connectivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mwall_value</code></td>
<td>
<p>If there is a medial wall in <code>xii</code>, what should value
should medial wall locations be replaced with prior to calculation?
Default: <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_as</code></td>
<td>
<p><code>"matrix"</code> (default) where each row corresponds to a
parcel, or a <code>"xifti"</code> object where each location's value is the value
of its corresponding parcel?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>FUN</code>, e.g. <code>na.rm=TRUE</code>.
Ignored if <code>FUN=="quick_mean"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code class="reqn">P \times Q</code> matrix, where <code class="reqn">P</code> is the number of parcels and
<code class="reqn">Q</code> is the length of the output of <code>FUN</code>. (For <code>mean</code>,
<code class="reqn">Q = 1</code>).
</p>


<h3>See Also</h3>

<p>Other parcellation-related: 
<code>load_parc()</code>,
<code>load_sub_parc()</code>,
<code>parc_add_subcortex()</code>,
<code>parc_borders()</code>,
<code>parc_vals_to_xifti()</code>
</p>
<p>Other manipulating xifti: 
<code>add_surf()</code>,
<code>apply_xifti()</code>,
<code>combine_xifti()</code>,
<code>convert_to_dlabel()</code>,
<code>merge_xifti()</code>,
<code>move_to_mwall()</code>,
<code>move_to_submask()</code>,
<code>newdata_xifti()</code>,
<code>remap_cifti()</code>,
<code>remove_xifti()</code>,
<code>resample_cifti()</code>,
<code>resample_cifti_from_template()</code>,
<code>scale_xifti()</code>,
<code>select_xifti()</code>,
<code>set_names_xifti()</code>,
<code>smooth_cifti()</code>,
<code>transform_xifti()</code>
</p>


</div>