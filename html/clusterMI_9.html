<div class="container">

<table style="width: 100%;"><tr>
<td>clusterMI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster analysis and pooling after multiple imputation</h2>

<h3>Description</h3>

<p>From a list of imputed datasets <code>clusterMI</code> performs cluster analysis on each imputed data set, estimates the instability of each partition using bootstrap (following Fang, Y. and Wang, J., 2012 &lt;doi:10.1016/j.csda.2011.09.003&gt;) and pools results as proposed in Audigier and Niang (2022) &lt;doi:10.1007/s11634-022-00519-1&gt;.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clusterMI(
  output,
  method.clustering = "kmeans",
  method.consensus = "NMF",
  scaling = TRUE,
  nb.clust = NULL,
  Cboot = 50,
  method.hclust = "average",
  method.dist = "euclidean",
  modelNames = NULL,
  modelName.hc = "VVV",
  nstart.kmeans = 100,
  iter.max.kmeans = 10,
  m.cmeans = 2,
  samples.clara = 500,
  nnodes = 1,
  instability = TRUE,
  verbose = TRUE,
  nmf.threshold = 10^(-5),
  nmf.nstart = 100,
  nmf.early_stop_iter = 10,
  nmf.initializer = "random",
  nmf.batch_size = NULL,
  nmf.iter.max = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>an output from the imputedata function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.clustering</code></td>
<td>
<p>a single string specifying the clustering algorithm used ("kmeans", "pam", "clara", "hclust" or "mixture","cmeans")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.consensus</code></td>
<td>
<p>a single string specifying the consensus method used to pool the contributory partitions ("NMF" or "CSPA")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>boolean. If TRUE, variables are scaled. Default value is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.clust</code></td>
<td>
<p>an integer specifying the number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cboot</code></td>
<td>
<p>an integer specifying the number of bootstrap replications. Default value is 50</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.hclust</code></td>
<td>
<p>character string defining the clustering method for hierarchical clustering (required only if method.clustering = "hclust")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.dist</code></td>
<td>
<p>character string defining the method use for computing dissimilarity matrices in hierarchical clustering (required only if method.clustering = "hclust")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelNames</code></td>
<td>
<p>character string indicating the models to be fitted in the EM phase of clustering (required only if method.clustering = "mixture"). By default modelNames = NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelName.hc</code></td>
<td>
<p>A character string indicating the model to be used in model-based agglomerative hierarchical clustering.(required only if method.clustering = "mixture"). By default modelNames.hc = "VVV".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart.kmeans</code></td>
<td>
<p>how many random sets should be chosen for kmeans initalization. Default value is 100 (required only if method.clustering = "kmeans")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max.kmeans</code></td>
<td>
<p>how many iterations should be chosen for kmeans. Default value is 10 (required only if method.clustering = "kmeans")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.cmeans</code></td>
<td>
<p>degree of fuzzification in cmeans clustering. By default m.cmeans = 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samples.clara</code></td>
<td>
<p>number of samples to be drawn from the dataset when performing clustering using clara algorithm. Default value is 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnodes</code></td>
<td>
<p>number of CPU cores for parallel computing. By default, nnodes = 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>instability</code></td>
<td>
<p>a boolean indicating if cluster instability must be computed. Default value is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a boolean. If TRUE, a message is printed at each step. Default value is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmf.threshold</code></td>
<td>
<p>Default value is 10^(-5),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmf.nstart</code></td>
<td>
<p>Default value is 100,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmf.early_stop_iter</code></td>
<td>
<p>Default value is 10,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmf.initializer</code></td>
<td>
<p>Default value is 'random',</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmf.batch_size</code></td>
<td>
<p>Default value is 20,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmf.iter.max</code></td>
<td>
<p>Default value is 50</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>clusterMI</code> performs cluster analysis (according to the <code>method.clustering</code> argument) and pooling after multiple imputation. For achieving this goal, the <code>clusterMI</code> function uses as an input an output from the <code>imputedata</code> function and then
</p>

<ol>
<li>
<p> applies the cluster analysis method on each imputed data set
</p>
</li>
<li>
<p> pools contributory partitions using non-negative matrix factorization
</p>
</li>
<li>
<p> computes the instability of each partition by bootstrap
</p>
</li>
<li>
<p> computes the total instability
</p>
</li>
</ol>
<p>Step 1 can be tuned by specifying the cluster analysis method used (<code>method.clustering</code> argument).
If <code>method.clustering = "kmeans"</code> or <code>"pam"</code>, then the number of clusters can be specified by tuning the <code>nb.clust</code> argument. By default, the same number as the one used for imputation is used.
The number of random initializations can also be tuned through the <code>nstart.kmeans</code> argument.
If <code>method.clustering = "hclust"</code> (hierarchical clustering), the method used can be specified (see <code>hclust</code>). By default <code>"average"</code> is used. Furthermore, the number of clusters can be specified, but it can also be automatically chosen if <code>nb.clust</code> &lt; 0.
If <code>method.clustering = "mixture"</code> (model-based clustering using gaussian mixture models), the model to be fitted can be tuned by modifying the <code>modelNames</code> argument (see <code>Mclust</code>).
If <code>method.clustering = "cmeans"</code> (clustering using the fuzzy c-means algorithm), then the fuzziness parameter can be modfied by tuning the<code>m.cmeans</code> argument. By default, <code>m.cmeans = 2</code>.
</p>
<p>Step 2 performs consensus clustering by Non-Negative Matrix Factorization, following Li and Ding (2007) &lt;doi:10.1109/ICDM.2007.98&gt;.
</p>
<p>Step 3 applies the <code>nselectboot</code> function on each imputed data set and returns the instability of each cluster obtained at step 1. The method is based on bootstrap sampling, followong Fang, Y. and Wang, J. (2012) &lt;doi:10.1016/j.csda.2011.09.003&gt;. The number of iterations can be tuned using the <code>Cboot</code> argument.
</p>
<p>Step 4 averages the previous instability measures given a within instability (<code>Ubar</code>), computes a between instability (<code>B</code>) and a total instability (<code>T</code> = B + Ubar). See Audigier and Niang (2022) &lt;doi:10.1007/s11634-022-00519-1&gt; for details.
</p>
<p>All steps can be performed in parallel by specifying the number of CPU cores (<code>nnodes</code> argument). Steps 3 and 4 are more time consuming. To compute only steps 1 and 2 use <code>instability = FALSE</code>.
</p>


<h3>Value</h3>

<p>A list with three objects
</p>
<table>
<tr style="vertical-align: top;">
<td><code>part</code></td>
<td>
<p>the consensus partition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>instability</code></td>
<td>
<p>a list of four objects: <code>U</code> the within instability measure for each imputed data set, <code>Ubar</code> the associated average, <code>B</code> the between instability measure, <code>Tot</code> the total instability measure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matching call</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Audigier, V. and Niang, N. (2022) Clustering with missing data: which equivalent for Rubin's rules? Advances in Data Analysis and Classification &lt;doi:10.1007/s11634-022-00519-1&gt;
</p>
<p>Fang, Y. and Wang, J. (2012) Selection of the number of clusters via the bootstrap method. Computational Statistics and Data Analysis, 56, 468-477. &lt;doi:10.1016/j.csda.2011.09.003&gt;
</p>
<p>T. Li, C. Ding, and M. I. Jordan (2007) Solving consensus and semi-supervised clustering problems using nonnegative matrix factorization.  In Proceedings of the 2007 Seventh IEEE International Conference on Data Mining, ICDM'07, page 577-582, USA. IEEE Computer Society. &lt;doi:10.1109/ICDM.2007.98&gt;
</p>


<h3>See Also</h3>

<p><code>hclust</code>, <code>nselectboot</code>, <code>Mclust</code>, <code>imputedata</code>, <code>cmeans</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(wine)

require(parallel)
set.seed(123456)
ref &lt;- wine$cult
nb.clust &lt;- 3
m &lt;- 5 # number of imputed data sets. Should be larger in practice
wine.na &lt;- wine
wine.na$cult &lt;- NULL
wine.na &lt;- prodna(wine.na)

#imputation
res.imp &lt;- imputedata(data.na = wine.na, nb.clust = nb.clust, m = m)

#analysis by kmeans and pooling
nnodes &lt;- 2 # parallel::detectCores()
res.pool &lt;- clusterMI(res.imp, nnodes = nnodes)

res.pool$instability
table(ref, res.pool$part)

</code></pre>


</div>