<div class="container">

<table style="width: 100%;"><tr>
<td>cgam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constrained Generalized Additive Model Fitting</h2>

<h3>Description</h3>

<p>The partial linear generalized additive model is fitted using the method of maximum likelihood, where shape or order restrictions can be imposed on the non-parametrically modelled predictors with optional smoothing, and no restrictions are imposed on the optional parametrically modelled covariate. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cgam(formula, cic = FALSE, nsim = 100, family = gaussian, cpar = 1.5, 
	data = NULL, weights = NULL, sc_x = FALSE, sc_y = FALSE, pnt = TRUE, 
	pen = 0, var.est = NULL, gcv = FALSE, pvf = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>A formula object which gives a symbolic description of the model to be fitted. It has the form "response ~ predictor". The response is a vector of length <code class="reqn">n</code>. The specification of the model can be one of the three exponential families: gaussian, binomial and poisson. The systematic component <code class="reqn">\eta</code> is <code class="reqn">E(y)</code>, the log odds of <code class="reqn">y = 1</code>, and the logarithm of <code class="reqn">E(y)</code> respectively. A predictor can be a non-parametrically modelled variable with or without a shape or order restriction, or a parametrically modelled unconstrained covariate. In terms of a non-parametrically modelled predictor, the user is supposed to indicate the relationship between the systematic component <code class="reqn">\eta</code> and a predictor <code class="reqn">x</code> in the following way:
</p>
<p>Assume that <code class="reqn">\eta</code> is the systematic component and <code class="reqn">x</code> is a predictor: 
</p>

<ul>
<li>
<p>incr(x): <code class="reqn">\eta</code> is increasing in <code class="reqn">x</code>. See <code>incr</code> for more details.
</p>
</li>
<li>
<p>s.incr(x): <code class="reqn">\eta</code> is smoothly increasing in <code class="reqn">x</code>. See <code>s.incr</code> for more details.
</p>
</li>
<li>
<p>decr(x): <code class="reqn">\eta</code> is decreasing in <code class="reqn">x</code>.  See <code>decr</code> for more details.
</p>
</li>
<li>
<p>s.decr(x): <code class="reqn">\eta</code> is smoothly decreasing in <code class="reqn">x</code>.  See <code>s.decr</code> for more details.
</p>
</li>
<li>
<p>conc(x): <code class="reqn">\eta</code> is concave in <code class="reqn">x</code>.  See <code>conc</code> for more details.
</p>
</li>
<li>
<p>s.conc(x): <code class="reqn">\eta</code> is smoothly concave in <code class="reqn">x</code>.  See <code>s.conc</code> for more details.
</p>
</li>
<li>
<p>conv(x): <code class="reqn">\eta</code> is convex in <code class="reqn">x</code>.  See <code>conv</code> for more details.
</p>
</li>
<li>
<p>s.conv(x): <code class="reqn">\eta</code> is smoothly convex in <code class="reqn">x</code>.  See <code>s.conv</code> for more details.
</p>
</li>
<li>
<p>incr.conc(x): <code class="reqn">\eta</code> is increasing and concave in <code class="reqn">x</code>.  See <code>incr.conc</code> for more details.
</p>
</li>
<li>
<p>s.incr.conc(x): <code class="reqn">\eta</code> is smoothly increasing and concave in <code class="reqn">x</code>. See <code>s.incr.conc</code> for more details.
</p>
</li>
<li>
<p>decr.conc(x): <code class="reqn">\eta</code> is decreasing and concave in <code class="reqn">x</code>. See <code>decr.conc</code> for more details.
</p>
</li>
<li>
<p>s.decr.conc(x): <code class="reqn">\eta</code> is smoothly decreasing and concave in <code class="reqn">x</code>. See <code>s.decr.conc</code> for more details.
</p>
</li>
<li>
<p>incr.conv(x): <code class="reqn">\eta</code> is increasing and convex in <code class="reqn">x</code>. See <code>incr.conv</code> for more details.
</p>
</li>
<li>
<p>s.incr.conv(x): <code class="reqn">\eta</code> is smoothly increasing and convex in <code class="reqn">x</code>. See <code>s.incr.conv</code> for more details.
</p>
</li>
<li>
<p>decr.conv(x): <code class="reqn">\eta</code> is decreasing and convex in <code class="reqn">x</code>. See <code>decr.conv</code> for more details.
</p>
</li>
<li>
<p>s.decr.conv(x): <code class="reqn">\eta</code> is smoothly decreasing and convex in <code class="reqn">x</code>. See <code>s.decr.conv</code> for more details.
</p>
</li>
<li>
<p>s(x): <code class="reqn">\eta</code> is smooth in <code class="reqn">x</code>. See <code>s</code> for more details.
</p>
</li>
<li>
<p>tree(x): <code class="reqn">\eta</code> has a tree-ordering in <code class="reqn">x</code>. See <code>tree</code> for more details.
</p>
</li>
<li>
<p>umbrella(x): <code class="reqn">\eta</code> has an umbrella-ordering in <code class="reqn">x</code>. See <code>umbrella</code> for more details.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cic</code></td>
<td>
<p>Logical flag indicating if or not simulations are used to get the cic value. 
The default is cic = FALSE
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>The number of simulations used to get the cic parameter. The default is nsim = 100. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>A parameter indicating the error distribution and link function to be used in the model. It can be a character string naming a family function or the result of a call to a family function. This is borrowed from the glm routine in the stats package. There are four families used in csvy: Gaussian, binomial, poisson, and Gamma.  Note that if family = Ord is specified, a proportional odds regression model with shape constraints is fitted. This is under development. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpar</code></td>
<td>
<p>A multiplier to estimate the model variance, which is defined as <code class="reqn">\sigma^2 = SSR / (n - cpar * edf)</code>. SSR is the sum of squared residuals for the full model and edf is the effective degrees of freedom. The default is cpar = 1.2. The user-defined value must be between 1 and 2. See Meyer, M. C. and M. Woodroofe (2000) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>An optional data frame, list or environment containing the variables in the model. The default is data = NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>An optional non-negative vector of "replicate weights" which has the same length as the response vector. If weights are not given, all weights are taken to equal 1. The default is weights = NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc_x</code></td>
<td>
<p>Logical flag indicating if or not continuous predictors are normalized. The default is sc_x = FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc_y</code></td>
<td>
<p>Logical flag indicating if or not the response variable is normalized. The default is sc_y = FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen</code></td>
<td>
<p>User-defined penalty parameter. It must be non-negative. It will only be used in a warped-plane spline fit or a triangle spline fit. The default is pen = 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pnt</code></td>
<td>
<p>Logical flag indicating if or not penalized constrained regression splines are used. It will only be used in a warped-plane spline fit or a triangle spline fit. The default is pnt = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.est</code></td>
<td>
<p>To do a monotonic variance function estimation, the user can set var.est = s.incr(x) or var.est = s.decr(x). See <code>s.incr</code> and <code>s.decr</code> for more details. The default is var.est = NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcv</code></td>
<td>
<p>Logical flag indicating if or not gcv is used to choose a penalty term in warped-plane surface fit. The default is gcv = FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvf</code></td>
<td>
<p>Logical flag indicating if or not simulations are used to find the p-value of the test of linear vs double monotone in warped plane surface fit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We consider generalized partial linear models with independent observations from an exponential family of the form <code class="reqn">p(y_i;\theta,\tau) = exp[\{y_i\theta_i - b(\theta_i)\}\tau - c(y_i, \tau)], i = 1,\ldots,n</code>, where the specifications of the functions <code class="reqn">b</code> and <code class="reqn">c</code> determine the sub-family of models. The mean vector <code class="reqn">\mu = E(y)</code> has values <code class="reqn">\mu_i = b'(\theta_i)</code>, and is related to a design matrix of predictor variables through a monotonically increasing link function <code class="reqn">g(\mu_i) = \eta_i, i = 1,\ldots,n</code>, where <code class="reqn">\eta</code> is the systematic component and describes the relationship with the predictors. The relationship between <code class="reqn">\eta</code> and <code class="reqn">\theta</code> is determined by the link function <code class="reqn">b</code>.
</p>
<p>For the additive model, the systematic component is specified for each observation by <code class="reqn">\eta_i = f_1(x_{1i}) + \ldots + f_L(x_{Li}) + z_i'\beta</code>, where the functions <code class="reqn">f_l</code> describe the relationships of the non-parametrically modelled predictors <code class="reqn">x_l</code>, <code class="reqn">\beta</code> is a parameter vector, and <code class="reqn">z_i</code> contains the values of variables to be modelled parametrically. The non-parametric components are modelled with shape or order assumptions with optional smoothing, and the solution is obtained through an iteratively re-weighted cone projection, with no back-fitting of individual components.
</p>
<p>Suppose that <code class="reqn">\eta</code> is a <code class="reqn">n</code> by <code class="reqn">1</code> vector. The matrix form of the systematic component and the predictor is <code class="reqn">\eta = \phi_1 + \ldots + \phi_L + Z\beta</code>, where <code class="reqn">\phi_l</code> is the individual component for the <code class="reqn">l</code>th non-parametrically modelled predictor, <code class="reqn">l = 1, \ldots, L</code>, and <code class="reqn">Z</code> is an <code class="reqn">n</code> by <code class="reqn">p</code> design matrix for the parametrically modelled covariate. 
</p>
<p>To model the component <code class="reqn">\phi_l</code>, smooth regression splines or non-smooth ordinal basis functions can be used. The constraints for the component <code class="reqn">\phi_l</code> are in <code class="reqn">C_l</code>. In the first case, <code class="reqn">C_l</code> = <code class="reqn">\{\phi_l \in R^n: \phi_l = v_l+B_l\beta_l</code>, where <code class="reqn">\beta_l \ge 0</code> and <code class="reqn">v_l\in V_l \}</code>, where <code class="reqn">B_l</code> has regression splines as columns and <code class="reqn">V_l</code> is the linear space contained in <code class="reqn">C_l</code>, and in the second case, <code class="reqn">C_l</code> = <code class="reqn">\{\phi \in R^n: A_l\phi \ge 0</code> and <code class="reqn">B_l\phi = 0\}</code>, for inequality constraint matrix <code class="reqn">A_l</code> and equality constraint matrix <code class="reqn">B_l</code>. 
</p>
<p>The set <code class="reqn">C_l</code> is a convex cone and the set <code class="reqn">C = C_1 + \ldots + C_p + Z</code> is also a convex cone with a finite set of edges, where the edges are the generators of <code class="reqn">C</code>, and <code class="reqn">Z</code> is the column space of the design matrix <code class="reqn">Z</code> for the parametrically modelled covariate. 
</p>
<p>An iteratively re-weighted cone projection algorithm is used to fit the generalized regression model over the cone <code class="reqn">C</code>. 
</p>
<p>See references cited in this section and the official manual (<a href="https://cran.r-project.org/package=coneproj">https://cran.r-project.org/package=coneproj</a>) for the R package coneproj for more details.
</p>


<h3>Value</h3>


<table>
<tr style="vertical-align: top;">
<td><code>etahat</code></td>
<td>
<p>The fitted systematic component <code class="reqn">\eta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muhat</code></td>
<td>
<p>The fitted mean value, obtained by transforming the systematic component <code class="reqn">\eta</code> by the inverse of the link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcoefs</code></td>
<td>
<p>The estimated coefficients for the basis spanning the null space of the constraint set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xcoefs</code></td>
<td>
<p>The estimated coefficients for the edges corresponding to the smooth predictors with no shape constraint and shape-restricted predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zcoefs</code></td>
<td>
<p>The estimated coefficients for the parametrically modelled covariate, i.e., the estimation for the vector <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ucoefs</code></td>
<td>
<p>The estimated coefficients for the edges corresponding to the predictors with an umbrella-ordering constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tcoefs</code></td>
<td>
<p>The estimated coefficients for the edges corresponding to the predictors with a tree-ordering constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>The estimated coefficients for the basis spanning the null space of the constraint set and edges corresponding to the shape-restricted and order-restricted predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cic</code></td>
<td>
<p>The cone information criterion proposed in Meyer(2013a). It uses the "null expected degrees of freedom" as a measure of the complexity of the model. See Meyer(2013a) for further details of cic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d0</code></td>
<td>
<p>The dimension of the linear space contained in the cone generated by all constraint conditions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf0</code></td>
<td>
<p>The estimated "null expected degrees of freedom". It is a measure of the complexity of the model. See Meyer (2013a) and Meyer (2013b) for further details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>The constrained effective degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etacomps</code></td>
<td>
<p>The fitted systematic component value for non-parametrically modelled predictors. It is a matrix of which each row is the fitted systematic component value for a non-parametrically modelled predictor. If there are more than one such predictors, the order of the rows is the same as the order that the user defines such predictors in the formula argument of cgam.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmat_add</code></td>
<td>
<p>A matrix whose columns represent the shape-restricted predictors and smooth predictors with no shape constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zmat</code></td>
<td>
<p>A matrix whose columns represent the basis for the parametrically modelled covariate. The user can choose to include a constant vector in it or not. It must have full column rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ztb</code></td>
<td>
<p>A list keeping track of the order of the parametrically modelled covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr</code></td>
<td>
<p>A matrix whose columns represent the predictors with a tree-ordering constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>umb</code></td>
<td>
<p>A matrix whose columns represent  the predictors with an umbrella-ordering constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree.delta</code></td>
<td>
<p>A matrix whose rows are the edges corresponding to the predictors with a tree-ordering constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>umbrella.delta</code></td>
<td>
<p>A matrix whose rows are the edges corresponding to the predictors with an umbrella-ordering constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bigmat</code></td>
<td>
<p>A matrix whose rows are the basis spanning the null space of the constraint set and the edges corresponding to the shape-restricted and order-restricted predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shapes</code></td>
<td>
<p>A vector including the shape and partial-ordering constraints in a cgam fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shapesx</code></td>
<td>
<p>A vector including the shape constraints in a cgam fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.w</code></td>
<td>
<p>User-defined weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>The weights in the final iteration of the iteratively re-weighted cone projections.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt.iter</code></td>
<td>
<p>Logical flag indicating if or not iteratively re-weighted cone projections may be used. If the response is gaussian, then wt.iter = FALSE; if the response is binomial or poisson, then wt.iter = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The family parameter defined in a cgam formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE0</code></td>
<td>
<p>The sum of squared residuals for the linear part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE1</code></td>
<td>
<p>The sum of squared residuals for the full model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvals.beta</code></td>
<td>
<p>The approximate p-values for the estimation of the vector <code class="reqn">\beta</code>. A t-distribution is used as the approximate distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.beta</code></td>
<td>
<p>The standard errors for the estimation of the vector <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null_df</code></td>
<td>
<p>The degree of freedom for the null model of a cgam fit, i.e., the model only containing a constant vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The degree of freedom for the null space of a cgam fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_df_obs</code></td>
<td>
<p>The observed degree of freedom for the residuals of a cgam fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null_deviance</code></td>
<td>
<p>The deviance for the null model of a cgam fit, i.e., the model only containing a constant vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>The residual deviance of a cgam fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tms</code></td>
<td>
<p>The terms objects extracted by the generic function <em>terms</em> from a cgam fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capm</code></td>
<td>
<p>The number of edges corresponding to the shape-restricted predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capms</code></td>
<td>
<p>The number of edges corresponding to the smooth predictors with no shape constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capk</code></td>
<td>
<p>The number of non-constant columns of zmat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capt</code></td>
<td>
<p>The number of edges corresponding to the tree-ordering predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capu</code></td>
<td>
<p>The number of edges corresponding to the umbrella-ordering predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the set of edges in bigmat for each shape-restricted predictor and smooth predictor with no shape constraint in xmat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xid2</code></td>
<td>
<p>A vector keeping track of the end position of the set of edges in bigmat for each shape-restricted predictor and smooth predictor with no shape constraint in xmat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the set of edges in bigmat for each tree-ordering factor in tr.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tid2</code></td>
<td>
<p>A vector keeping track of the end position of the set of edges in bigmat for each tree-ordering factor in tr.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the set of edges in bigmat for each umbrella-ordering factor in umb.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uid2</code></td>
<td>
<p>A vector keeping track of the end position of the set of edges in bigmat for each umbrella-ordering factor in umb.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zid</code></td>
<td>
<p>A vector keeping track of the positions of the parametrically modelled covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vals</code></td>
<td>
<p>A vector storing the levels of each variable used as a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the levels of each variable used as a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zid2</code></td>
<td>
<p>A vector keeping track of the end position of the levels of each variable used as a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of simulations used to get the cic parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xnms</code></td>
<td>
<p>A vector storing the names of the shape-restricted predictors and the smooth predictors with no shape constraint in xmat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ynm</code></td>
<td>
<p>The name of the response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>znms</code></td>
<td>
<p>A vector storing the names of the parametrically modelled covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_param</code></td>
<td>
<p>A logical scalar showing if or not a variable is a parametrically modelled covariate, which could be a linear term or a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_fac</code></td>
<td>
<p>A logical scalar showing if or not a variable is a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>A list storing the knots used for each shape-restricted predictor and smooth predictor with no shape constraint. For a smooth,  constrained and a smooth, unconstrainted predictor, <em>knots</em> is a vector of more than <code class="reqn">1</code> elements, and for a shape-restricted predictor without smoothing, <em>knots</em> = <code class="reqn">0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numknots</code></td>
<td>
<p>A vector storing the number of knots for each shape-restricted predictor and smooth predictor with no shape constraint. For a smooth, constrained and a smooth, unconstrainted predictor, <em>numknots</em> &gt; <code class="reqn">1</code>, and for a shape-restricted predictor without smoothing, <em>numknots</em> = <code class="reqn">0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sps</code></td>
<td>
<p>A character vector storing the <em>space</em> parameter to create knots for each shape-restricted predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ms</code></td>
<td>
<p>The centering terms used to make edges for shape-restricted predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpar</code></td>
<td>
<p>The cpar argument in the cgam formula</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vh</code></td>
<td>
<p>The estimated monotonic variance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kts.var</code></td>
<td>
<p>The knots used in monotonic variance function estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao </p>


<h3>References</h3>

<p>Liao, X. and Meyer, M. C. (2019) cgam: An R Package for the Constrained Generalized Additive Model.
<em>Journal of Statistical Software <b>89(5)</b></em>, 1–24. 
</p>
<p>Meyer, M. C. (2018) A Framework for Estimation and Inference in Generalized Additive Models with Shape and Order Restrictions.
<em>Statistical Science <b>33(4)</b></em>, 595–614. 
</p>
<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. 
<em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126–1139.  
</p>
<p>Meyer, M. C. and M. Woodroofe (2000) On the degrees of freedom in shape-restricted regression. <em>Annals of Statistics <b>28</b></em>, 1083–1104.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013–1033.
</p>
<p>Mammen, E. and K. Yu (2007) Additive isotonic regression. <em>IMS Lecture  Notes-Monograph Series Asymptotics: Particles, Process, and Inverse Problems <b>55</b></em>, 179–195.
</p>
<p>Huang, J. (2002) A note on estimating a partly linear model under monotonicity constraints. <em>Journal of Statistical Planning and Inference <b>107</b></em>, 343–351.
</p>
<p>Cheng, G.(2009) Semiparametric additive isotonic regression. <em>Journal of Statistical Planning and Inference <b>139</b></em>, 1980–1991.
</p>
<p>Bacchetti, P. (1989) Additive isotonic models. <em>Journal of the American Statistical Association <b>84(405)</b></em>, 289–294.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1.
  data(cubic)
  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with no restriction with lm()
  fit.lm &lt;- lm(y ~ x + I(x^2) + I(x^3))

  # regress y on x under the restriction: "increasing and convex"
  fit.cgam &lt;- cgam(y ~ incr.conv(x))

  # make a plot to compare the two fits
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fit.cgam$muhat, col = 2, lty = 2)
  lines(x, fitted(fit.lm), col = 1, lty = 1)
  legend("topleft", bty = "n", c("constrained cgam fit", "unconstrained lm fit"), 
  lty = c(2, 1), col = c(2, 1))

# Example 2.
## Not run: 
  library(gam)
  data(kyphosis)
  
  # regress Kyphosis on Age, Number, and Start under the restrictions:
  # "concave", "increasing and concave", and "decreasing and concave" 
  fit &lt;- cgam(Kyphosis ~ conc(Age) + incr.conc(Number) + decr.conc(Start), 
  family = binomial(), data = kyphosis) 

## End(Not run)

# Example 3.
  library(MASS)
  data(Rubber)
  
  # regress loss on hard and tens under the restrictions:
  # "decreasing" and "decreasing"
  fit.cgam &lt;- cgam(loss ~ decr(hard) + decr(tens), data = Rubber)
  # "smooth and decreasing" and "smooth and decreasing"
  fit.cgam.s &lt;- cgam(loss ~ s.decr(hard) + s.decr(tens), data = Rubber)
  summary(fit.cgam.s)
  anova(fit.cgam.s)
  
  # make a 3D plot based on fit.cgam and fit.cgam.s
  plotpersp(fit.cgam, th = 120, main = "3D Plot of a Cgam Fit")
  plotpersp(fit.cgam.s, tens, hard, data = Rubber, th = 120, main = "3D Plot of a Smooth Cgam Fit")

# Example 4. monotonic variance estimation
  n &lt;- 400
  x &lt;- runif(n)
  sig &lt;- .1 + exp(15*x-8)/(1+exp(15*x-8))
  e &lt;- rnorm(n)
  mu &lt;- 10*x^2
  y &lt;- mu + sig*e

  fit &lt;- cgam(y ~ s.incr.conv(x), var.est = s.incr(x))
  est.var &lt;- fit$vh
  muhat &lt;- fit$muhat

  par(mfrow = c(1, 2))
  plot(x, y)
  points(sort(x), muhat[order(x)], type = "l", lwd = 2, col = 2)
  lines(sort(x), (mu)[order(x)], col = 4)

  plot(sort(x), est.var[order(x)], col=2, lwd=2, type="l", 
  lty=2, ylab="Variance", ylim=c(0, max(c(est.var, sig^2))))
  points(sort(x), (sig^2)[order(x)], col=1, lwd=2, type="l")

# Example 5. monotonic variance estimation with the lidar data set in SemiPar
  library(SemiPar)
  data(lidar)

  fit &lt;- cgam(logratio ~ s.decr(range), var.est=s.incr(range), data=lidar)
  muhat &lt;- fit$muhat
  est.var &lt;- fit$vh
  
  logratio &lt;- lidar$logratio
  range &lt;- lidar$range
  pfit &lt;- predict(fit, newData=data.frame(range=range), interval="confidence", level=0.95)
  upp &lt;- pfit$upper
  low &lt;- pfit$lower
  
  par(mfrow = c(1, 2))
  plot(range, logratio)
  points(sort(range), muhat[order(range)], type = "l", lwd = 2, col = 2)
  lines(sort(range), upp[order(range)], type = "l", lwd = 2, col = 4)
  lines(sort(range), low[order(range)], type = "l", lwd = 2, col = 4)
  title("Smoothly Decreasing Fit with a Point-Wise Confidence Interval", cex.main=0.5)
  
  plot(range, est.var, col=2, lwd=2, type="l",lty=2, ylab="variance")
  title("Smoothly Increasing Variance", cex.main=0.5)
</code></pre>


</div>