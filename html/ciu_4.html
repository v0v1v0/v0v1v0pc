<div class="container">

<table style="width: 100%;"><tr>
<td>ciu.blackbox.new</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create CIU.BlackBox object</h2>

<h3>Description</h3>

<p>This method mainly serves as an "interface specification" for objects of
class <code>CIU.BlackBox</code>, i.e. it defines what method(s) have to be implemented
by any object of class <code>CIU.BlackBox</code>. A <code>CIU.BlackBox</code> object
is actually a <code>list</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ciu.blackbox.new()
</code></pre>


<h3>Details</h3>

<p>An alternative and simpler (but less flexible) way to do the same is to
use the <code>predict.function</code> parameter of <code>ciu.new</code>, where
<code>predict.function &lt;- function(model, inputs) {predict(model,inputs,n.trees=10000)}</code>
would accomplish the same as for the Example below. An example using this
approach is also included in Examples.
</p>
<p>The advantage of using a <code>CIU.BlackBox</code> wrapper
(rather than the simplee <code>predict.function</code> approach) is that it is
possible to keep object variables or maintain whatever state
information might be needed between calls.
</p>
<p>The only things that are actually required from a
<code>CIU.BlackBox</code> object is:
</p>

<ol>
<li>
<p> That it is a <code>list</code> with an element called <code>eval</code>.
</p>
</li>
<li>
<p> That the value of <code>eval</code> element is a function of the form <code style="white-space: pre;">⁠eval = function(inputs)⁠</code>
</p>
</li>
<li>
<p> That it inherits the class <code>CIU.BlackBox</code>.
</p>
</li>
</ol>
<h3>Value</h3>

<p>Object of class <code>CIU.BlackBox</code>.
</p>


<h3>Author(s)</h3>

<p>Kary Främling
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create CIU.BlackBox wrapper for Gradient Boosting
library(MASS) # Just in case Boston is not already available
library(gbm)
gbm.ciu.bb &lt;- function(gbm, n.trees=1) {
  o.gbm &lt;- gbm
  o.n.trees &lt;- n.trees
  pub &lt;- list(eval = function(inputs) { predict(o.gbm,inputs,n.trees=o.n.trees) })
  class(pub) &lt;- c("CIU.BlackBox",class(pub))
  return(pub)
}

# Train and explain. We don't care about training/test sets here.
gbm.Boston &lt;- gbm(medv ~ . ,data = Boston, distribution = "gaussian",
n.trees=10000, shrinkage = 0.01, interaction.depth = 4)
gbm.ciu &lt;- gbm.ciu.bb(gbm.Boston, 10000)
ciu &lt;- ciu.new(gbm.ciu, medv~., Boston)
ciu$barplot.ciu(Boston[370,1:13], sort = "CI")

# Same but using `predict.function` parameter in `ciu.new`.
# Using `ggplot.col.ciu` here for a change.
predict.function &lt;- function(model, inputs) {predict(model,inputs,n.trees=10000)}
ciu &lt;- ciu.new(gbm.Boston, medv~., Boston, predict.function=predict.function)
ciu$ggplot.col.ciu(Boston[370,1:13], sort = "CI")

</code></pre>


</div>