<div class="container">

<table style="width: 100%;"><tr>
<td>CRPScirc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Continuous Ranked Probability Score for Circular Variables.</h2>

<h3>Description</h3>

<p><code>CRPScirc</code> function computes the The Continuous Ranked Probability Score for Circular Variables
</p>


<h3>Usage</h3>

<pre><code class="language-R">CRPScirc(obs, sim, bycol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obs, </code></td>
<td>
<p>a vector of the  values of the process at the test locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim, </code></td>
<td>
<p>a matrix with nrow the test locations and ncol the number of posterior samples
from the posterior distributions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bycol, </code></td>
<td>
<p>logical. It is TRUE if the columns of sim represent the observations
and the rows the posterior samples, the default value is FALSE</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of 2 elements
</p>

<dl>
<dt><code>CRPSvec</code></dt>
<dd>
<p> a vector of CRPS, one element for each test point</p>
</dd>
<dt><code>CRPS</code></dt>
<dd>
<p> the  overall mean</p>
</dd>
</dl>
<h3>References</h3>

<p>Grimit, Eric P., Tilmann Gneiting, Veronica J. Berrocal,
Nicholas Alexander Johnson.
"The Continuous Ranked Probability Score for Circular Variables
and its Application to Mesoscale Forecast Ensemble Verification",  Q.J.R. Meteorol. Soc. 132 (2005), 2925-2942.
</p>


<h3>See Also</h3>

<p><code>ProjKrigSp</code> and <code>WrapKrigSp</code> for posterior spatial interpolation, and
<code>ProjKrigSpTi</code> and <code>WrapKrigSpTi</code> for posterior spatio-temporal interpolation
</p>
<p>Other model performance indices: <code>APEcirc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#' library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
## graphical check
par(mfrow = c(3,1))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))
##### We move to the spatial interpolation

Krig &lt;- WrapKrigSp(
  WrapSp_out = mod,
  coords_obs =  coords[-val,],
  coords_nobs =  coords[val,],
  x_obs = theta[-val]
)

#### check the quality of the prediction using APE and CRPS
ApeCheck &lt;- APEcirc(theta[val],Krig$Prev_out)
CrpsCheck &lt;- CRPScirc(theta[val],Krig$Prev_out)
</code></pre>


</div>