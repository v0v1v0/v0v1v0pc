<div class="container">

<table style="width: 100%;"><tr>
<td>CorrectBatch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CorrectBatch</h2>

<h3>Description</h3>

<p>Batch effect correction on two single-cell batches
</p>


<h3>Usage</h3>

<pre><code class="language-R">CorrectBatch(
  refBatch,
  queBatch,
  cnRef = NULL,
  cnQue = NULL,
  queNumCelltypes = NULL,
  maxMem = 5,
  pairs = NULL,
  kNN = 30,
  sampling = FALSE,
  numSamples = NULL,
  idxQuery = NULL,
  idxRef = NULL,
  pcaDim = 50,
  perCellMNN = 0.08,
  fuzzy = TRUE,
  fuzzyPCA = 10,
  estMethod = "Median",
  clusterMethod = "louvain",
  pairsFilter = FALSE,
  doCosNorm = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>refBatch</code></td>
<td>
<p>Reference batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queBatch</code></td>
<td>
<p>Query batch (batch to correct).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cnRef</code></td>
<td>
<p>Cosine normalization of the reference batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cnQue</code></td>
<td>
<p>Cosine normalization of the query batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queNumCelltypes</code></td>
<td>
<p>Number of cell types in the query batch. By default Canek searches the number of cell
types using an heuristic algorithm. Change this parameter if you know the number of cell types in advanced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxMem</code></td>
<td>
<p>Maximum number of memberships from the query batch. This parameter is used on the
heuristic algorithm to find the number of cell types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairs</code></td>
<td>
<p>A numerical matrix containing MNNs pairs cell indexes. First column corresponds to query batch cell indexes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kNN</code></td>
<td>
<p>Number of k-nearest-neighbors used to define the MNNs pairs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling</code></td>
<td>
<p>Use MNNs pairs sampling when using a Kalman filter to estimate the correction vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numSamples</code></td>
<td>
<p>If sampling. Number of MNNs pairs samples to use on the estimation process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idxQuery</code></td>
<td>
<p>Numerical vector indicating the index of the cells from the query batch to use
on the correction vector estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idxRef</code></td>
<td>
<p>Numerical vector indicating the index of the cells from the reference batch to use
on the correction vector estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcaDim</code></td>
<td>
<p>Number of PCA dimensions to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perCellMNN</code></td>
<td>
<p>Threshold value to decide if a membership's correction value is calculated.
As a rough interpretation, this values can be thought as the proportion of cells from a membership
with an associated MNN pair. If the proportion is low, an specific correction vectors is
not calculated for this membership.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fuzzy</code></td>
<td>
<p>Use fuzzy logic to join the local correction vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fuzzyPCA</code></td>
<td>
<p>Number of PCs to use in the fuzzy process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estMethod</code></td>
<td>
<p>Method to use when estimating the correction vectors:
</p>

<ul>
<li>
<p>Median. Use the cells median distance.
</p>
</li>
<li>
<p>EKF. Use an extended Kalman filter.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterMethod</code></td>
<td>
<p>Method used to identify memberships.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairsFilter</code></td>
<td>
<p>Filter MNNs pairs before estimating the correction vectors. If TRUE,
the pairs are filtered from outliers using an interquartile range method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doCosNorm</code></td>
<td>
<p>Whether to do cosine normalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>CorrectBatch is a method to correct batch-effect from two single-cell batches.
Batch-effects observations are defined using mutual nearest neighbors (MNNs) pairs and cell
groups from the query batch are distinguished using clustering. We estimate a correction vector
for each cluster using its MNNs pairs and use these vectors to remove the batch effect from the query batch in two ways:
</p>

<ul>
<li>
<p>A linear correction is performed by equally correcting the cells from the same cluster.
</p>
</li>
<li>
<p>A non-linear correction is performed by differently correcting each cell using fuzzy logic.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A list containing the input batches, the corrected query batch, and the correction data
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- SimBatches$batches[[1]]
y &lt;- SimBatches$batches[[2]]
z &lt;- CorrectBatch(x, y)
Corrected &lt;- z$`Corrected Query Batch`

Uncorrected_PCA &lt;- prcomp(t(cbind(x,y)))
plot(Uncorrected_PCA$x[,1:2])
Corrected_PCA &lt;- prcomp(t(cbind(x,z$`Corrected Query Batch`)))
plot(Corrected_PCA$x[,1:2])

</code></pre>


</div>