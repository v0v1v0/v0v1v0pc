<div class="container">

<table style="width: 100%;"><tr>
<td>blocks_to_rowrecs_q</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Map sets rows to columns (query based, take name of table).</h2>

<h3>Description</h3>

<p>Transform data facts from rows into additional columns using SQL
and controlTable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">blocks_to_rowrecs_q(
  tallTable,
  keyColumns,
  controlTable,
  my_db,
  ...,
  columnsToCopy = NULL,
  tempNameGenerator = mk_tmp_name_source("mvtcq"),
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  checkNames = TRUE,
  checkKeys = FALSE,
  showQuery = FALSE,
  defaultValue = NULL,
  dropDups = TRUE,
  temporary = FALSE,
  resultName = NULL,
  incoming_qualifiers = NULL,
  outgoing_qualifiers = NULL,
  executeQuery = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tallTable</code></td>
<td>
<p>name of table containing data to be mapped (db/Spark data)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keyColumns</code></td>
<td>
<p>character list of column defining row groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controlTable</code></td>
<td>
<p>table specifying mapping (local data frame)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my_db</code></td>
<td>
<p>db handle</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columnsToCopy</code></td>
<td>
<p>character list of column names to copy</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tempNameGenerator</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>logical, if TRUE check control table name forms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controlTableKeys</code></td>
<td>
<p>character, which column names of the control table are considered to be keys.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkNames</code></td>
<td>
<p>logical, if TRUE check names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkKeys</code></td>
<td>
<p>logical, if TRUE check keying of tallTable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showQuery</code></td>
<td>
<p>if TRUE print query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defaultValue</code></td>
<td>
<p>if not NULL literal to use for non-match values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropDups</code></td>
<td>
<p>logical if TRUE suppress duplicate columns (duplicate determined by name, not content).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temporary</code></td>
<td>
<p>logical, if TRUE make result temporary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resultName</code></td>
<td>
<p>character, name for result table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incoming_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outgoing_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>executeQuery</code></td>
<td>
<p>logical, if TRUE execute the query and return result.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is using the theory of "fluid data"n
(<a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>), which includes the
principle that each data cell has coordinates independent of the
storage details and storage detail dependent coordinates (usually
row-id, column-id, and group-id) can be re-derived at will (the
other principle is that there may not be "one true preferred data
shape" and many re-shapings of data may be needed to match data to
different algorithms and methods).
</p>
<p>The controlTable defines the names of each data element in the two notations:
the notation of the tall table (which is row oriented)
and the notation of the wide table (which is column oriented).
controlTable[ , 1] (the group label) cross colnames(controlTable)
(the column labels) are names of data cells in the long form.
controlTable[ , 2:ncol(controlTable)] (column labels)
are names of data cells in the wide form.
To get behavior similar to tidyr::gather/spread one builds the control table
by running an appropriate query over the data.
</p>
<p>Some discussion and examples can be found here:
<a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a> and
here <a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>.
</p>


<h3>Value</h3>

<p>wide table built by mapping key-grouped tallTable rows to one row per group
</p>


<h3>See Also</h3>

<p><code>build_pivot_control_q</code>, <code>blocks_to_rowrecs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  # pivot example
  d &lt;- data.frame(meas = c('AUC', 'R2'), val = c(0.6, 0.2))
  rquery::rq_copy_to(my_db,
                    'd',
                    d,
                    temporary = TRUE)
  cT &lt;- build_pivot_control_q('d',
                              columnToTakeKeysFrom= 'meas',
                              columnToTakeValuesFrom= 'val',
                              my_db = my_db)
  tab &lt;- blocks_to_rowrecs_q('d',
                             keyColumns = NULL,
                             controlTable = cT,
                             my_db = my_db)
  qlook(my_db, tab)
  DBI::dbDisconnect(my_db)
}

</code></pre>


</div>