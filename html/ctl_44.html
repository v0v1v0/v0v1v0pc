<div class="container">

<table style="width: 100%;"><tr>
<td>CTLscan.cross</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CTLscan.cross - Scan for Correlated Trait Locus (CTL) (R/qtl cross object) </h2>

<h3>Description</h3>

<p>Scan for Correlated Trait Locus (CTL) in populations (using an R/qtl cross object)
</p>


<h3>Usage</h3>

<pre><code class="language-R">CTLscan.cross(cross, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cross</code></td>
<td>
<p> An object of class <code>cross</code>. See <code>read.cross</code> for details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Passed to <code>CTLscan</code> function: 
</p>

<ul>
<li>
<p> phenocol   - Which phenotype column should we analyse.
</p>
</li>
<li>
<p> method     - We provide 3 ways of mapping correlation differences across the genome:
</p>

<ul>
<li>
<p> Exact: Uses a Correlation to Z score transformation to calculate the
likelihood of a difference in correlation: 
Cor(AA) - Cor(BB)
</p>
</li>
<li>
<p> Power: More powerful analysis method using the squared difference in     
correlation:
(Cor(AA) - Cor(BB))^2
</p>
</li>
<li>
<p> Adjacency: Adjacency method which using the squared difference in squared   
correlation, but keeping the sign of correlation:
(sign*Cor(AA)^2 - sign*Cor(BB)^2)^2
</p>
</li>
</ul>
<p>Note: Exact is the default and fastest option it uses a normal distribution for 
estimating p-values and uses bonferoni correction. It has however the least power 
to detect CTLs, the two other methods (Power and Adjacency) perform permutations to
assign significance.
</p>
</li>
<li>
<p> n.perm     - Number of permutations to perform.
</p>
</li>
<li>
<p> strategy   - The permutation strategy to use, either Full (Compensate for marker and trait
correlation structure) or Pairwise (Compensate for marker correlation structure). 
This parameter is not used when method="Exact".
</p>
</li>
<li>
<p> conditions - A vector of experimental conditions applied during the experiment. These conditions 
will be used as covariates in the QTL modeling step.
</p>
</li>
<li>
<p> n.cores    - Number of CPU cores to use during the analysis.
</p>
</li>
<li>
<p> verbose    - Be verbose.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>TODO
</p>

<ul><li>
<p> NOTE: Main bottleneck of the algorithm is the RAM available to the system
</p>
</li></ul>
<h3>Value</h3>

<p>CTLscan object, a list with at each index a CTL matrix (Rows: Phenotypes, 
Columns: Genetic markers) for the phenotype.
</p>


<h3>Note</h3>

<p>TODO
</p>


<h3>Author(s)</h3>

 
<p>Danny Arends <a href="mailto:Danny.Arends@gmail.com">Danny.Arends@gmail.com</a><br>
Maintainer: Danny Arends <a href="mailto:Danny.Arends@gmail.com">Danny.Arends@gmail.com</a> 
</p>


<h3>References</h3>

 
<p>TODO
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>CTLscan</code> - Main function to scan for CTL
</p>
</li>
<li> <p><code>CTLsignificant</code> - Significant interactions from a <code>CTLscan</code>
</p>
</li>
<li> <p><code>CTLnetwork</code> - Create a CTL network from a <code>CTLscan</code>
</p>
</li>
<li> <p><code>image.CTLobject</code> - Heatmap overview of a <code>CTLscan</code>
</p>
</li>
<li> <p><code>plot.CTLscan</code> - Plot the CTL curve for a single trait
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">  library(ctl)
  data(multitrait)      # Arabidopsis Thaliana (R/qtl cross object)

  mtrait &lt;- calc.genoprob(multitrait)          # Calculate genotype probabilities
  qtls   &lt;- scanone(mtrait, pheno.col = 1)     # Scan for QTLS using R/qtl

  ctls   &lt;- CTLscan.cross(mtrait, phenocol = 1, qtl = FALSE)
  ctls[[1]]$qtl &lt;- qtls[,3]

  ctl.lineplot(ctls, qtls[,1:2], significance = 0.05) # Line plot all the phenotypes

  summary &lt;- CTLsignificant(ctls)              # Get a list of significant CTLs
  summary
</code></pre>


</div>