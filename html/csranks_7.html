<div class="container">

<table style="width: 100%;"><tr>
<td>irank</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute ranks</h2>

<h3>Description</h3>

<p>Compute integer of fractional ranks with flexible handling of ties.
</p>


<h3>Usage</h3>

<pre><code class="language-R">irank(x, omega = 0, increasing = FALSE, na.rm = FALSE)

frank(x, omega = 0, increasing = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of values to be ranked</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>numeric value in [0,1], defining how ties in <code>x</code> (if any) are handled; default is <code>0</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>increasing</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), then large elements in <code>x</code> receive a small rank. Otherwise, large elements in <code>x</code> receive a large rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code>. Default: <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>irank</code> implements all possible definitions of ranks of the values in <code>x</code>. Different definitions of the ranks are chosen through combinations of the two arguments
<code>omega</code> and <code>increasing</code>. Suppose <code>x</code> is of length <code class="reqn">p</code>. If <code>increasing=TRUE</code>, then the largest value in <code>x</code> receives the rank <code class="reqn">p</code> and the smallest
the rank <code class="reqn">1</code>. If <code>increasing=FALSE</code>, then the largest value in <code>x</code> receives the rank <code class="reqn">1</code> and the smallest
the rank <code class="reqn">p</code>.
</p>
<p>The value of <code>omega</code> indicates how ties are handled. If there are no ties in <code>x</code>, then the value of <code>omega</code> does not affect the ranks and the only choice to be made is whether
the ranks should be increasing or decreasing with the values in <code>x</code>. When there are ties in <code>x</code>, however, then there are infinitely
many possible ranks that can be assigned to a tied value.
</p>
<p>When <code>increasing=TRUE</code>, then <code>omega=0</code> leads to the smallest possible and <code>omega=1</code> to the largest possible rank of a tied value. Values of <code>omega</code> between
0 and 1 lead to values of the rank between the largest and smallest.
</p>
<p><code>frank</code> takes the ranking returned by <code>irank</code> and divides the result by <code>length(x)</code>. The result is a ranking with
ranks in the interval [0,1]. An important special case occurs for <code>increasing=TRUE</code> and <code>omega=1</code>: in this case, the rank
of the value <code>x[j]</code> is equal to the empirical cdf of <code>x</code> evaluated at <code>x[j]</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code> containing the integer (for <code>irank</code>) or fractional (for <code>frank</code>) ranks.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simple example without ties:
x &lt;- c(3,8,-4,10,2)
irank(x, increasing=TRUE)
irank(x, increasing=FALSE)

# since there are no ties, the value of omega has no impact:
irank(x, increasing=TRUE, omega=0)
irank(x, increasing=TRUE, omega=0.5)
irank(x, increasing=TRUE, omega=1)

# simple example with ties:
x &lt;- c(3,4,7,7,10,11,15,15,15,15)
irank(x, increasing=TRUE, omega=0) # smallest possible ranks
irank(x, increasing=TRUE, omega=0.5) # mid-ranks
irank(x, increasing=TRUE, omega=1) # largest possible ranks

# simple example of fractional ranks without ties:
x &lt;- c(3,8,-4,10,2)
frank(x, increasing=TRUE)
frank(x, increasing=FALSE)
</code></pre>


</div>