<div class="container">

<table style="width: 100%;"><tr>
<td>ffexp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Full factorial experiment</h2>

<h3>Description</h3>

<p>A class for easily creating and evaluating full factorial experiments.
</p>


<h3>Usage</h3>

<pre>
e1 &lt;- ffexp$new(eval_func=, )

e1$run_all()

e1$plot_run_times()

e1$save_self()

</pre>


<h3>Arguments</h3>

<p><code>eval_func</code> The function called to evaluate each design point.
</p>
<p><code>...</code> Factors and their levels to be evaluated at.
</p>
<p><code>save_output</code> Should the output be saved?
</p>
<p><code>parallel</code> If <code>TRUE</code>, function evaluations are done in parallel.
</p>
<p><code>parallel_cores</code> Number of cores to be used in parallel.
If <code>"detect"</code>, <code>parallel::detectCores()</code> is used to determine
number. <code>"detect-1"</code> may be used so that the computer isn't running
at full capacity, which can slow down other tasks.
</p>


<h3>Methods</h3>

<p><code>$new()</code> Initialize an experiment. The preprocessing is done,
but no function evaluations are run.
</p>
<p><code>$run_all()</code> Run all factor combinations.
</p>
<p><code>$run_one()</code> Run a single factor combination.
</p>
<p><code>$add_result_of_one()</code> Used to add result of evaluation to data set,
don't manually call.
</p>
<p><code>$plot_run_times()</code> Plot the run times. Especially useful when
they have been run in parallel.
</p>
<p><code>$save_self()</code> Save ffexp R6 object.
</p>
<p><code>$recover_parallel_temp_save()</code> If you ran the experiment using
parallel with <code>parallel_temp_save=TRUE</code> and it crashes partway
through, call this to recover the runs that were completed.
Runs that were stopped mid-execution are not recoverable.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>outrawdf</code></dt>
<dd>
<p>Raw data frame of output.</p>
</dd>
<dt><code>outcleandf</code></dt>
<dd>
<p>Clean output in data frame.</p>
</dd>
<dt><code>rungrid</code></dt>
<dd>
<p>matrix specifying which inputs will be run
for each experiment.</p>
</dd>
<dt><code>nvars</code></dt>
<dd>
<p>Number of variables</p>
</dd>
<dt><code>allvars</code></dt>
<dd>
<p>All variables</p>
</dd>
<dt><code>varlist</code></dt>
<dd>
<p>Character vector of objects to pass to a parallel
cluster.</p>
</dd>
<dt><code>arglist</code></dt>
<dd>
<p>List of values for each argument</p>
</dd>
<dt><code>number_runs</code></dt>
<dd>
<p>Total number of runs</p>
</dd>
<dt><code>completed_runs</code></dt>
<dd>
<p>Logical vector of whether each run has been
completed.</p>
</dd>
<dt><code>eval_func</code></dt>
<dd>
<p>The function that is called for each experiment trial.</p>
</dd>
<dt><code>outlist</code></dt>
<dd>
<p>A list of the output from each run.</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Logical of whether the output should be saved.</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Logical whether experiment runs should be run in
parallel. Allows for massive speedup.</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>How many cores to use when running in parallel.
Can be an integer, or 'detect' will detect how many cores are
available, or 'detect-1' will do one less than that.</p>
</dd>
<dt><code>parallel_cluster</code></dt>
<dd>
<p>The parallel cluster being used.</p>
</dd>
<dt><code>folder_path</code></dt>
<dd>
<p>The path to the folder where output will be saved.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>extract_output_to_df</code></dt>
<dd>
<p>A function to extract the raw output into
a data frame. E.g., if the output is a list, but you want a single
item to show up in the output data frame.</p>
</dd>
<dt><code>hashvalue</code></dt>
<dd>
<p>A value used to make sure inputs match when reloading.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ffexp-new"><code>ffexp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_all"><code>ffexp$run_all()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_for_time"><code>ffexp$run_for_time()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_superbatch"><code>ffexp$run_superbatch()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_one"><code>ffexp$run_one()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-add_result_of_one"><code>ffexp$add_result_of_one()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-plot_run_times"><code>ffexp$plot_run_times()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-plot_pairs"><code>ffexp$plot_pairs()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-plot"><code>ffexp$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-calculate_effects"><code>ffexp$calculate_effects()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-calculate_effects2"><code>ffexp$calculate_effects2()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-save_self"><code>ffexp$save_self()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-create_save_folder_if_nonexistent"><code>ffexp$create_save_folder_if_nonexistent()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-rename_save_folder"><code>ffexp$rename_save_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-delete_save_folder_if_empty"><code>ffexp$delete_save_folder_if_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-recover_parallel_temp_save"><code>ffexp$recover_parallel_temp_save()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-rungrid2"><code>ffexp$rungrid2()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-add_variable"><code>ffexp$add_variable()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-add_level"><code>ffexp$add_level()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-remove_results"><code>ffexp$remove_results()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-print"><code>ffexp$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-set_parallel_cores"><code>ffexp$set_parallel_cores()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-stop_cluster"><code>ffexp$stop_cluster()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-finalize"><code>ffexp$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-clone"><code>ffexp$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-ffexp-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create an 'ffexp' object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$new(
  ...,
  eval_func,
  save_output = FALSE,
  parallel = FALSE,
  parallel_cores = "detect",
  folder_path,
  varlist = NULL,
  verbose = 2,
  extract_output_to_df = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Input arguments for the experiment</p>
</dd>
<dt><code>eval_func</code></dt>
<dd>
<p>The function to be run. It must take
named arguments matching the names of ...</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Should output be saved to file?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should a parallel cluster be used?</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>folder_path</code></dt>
<dd>
<p>Where the data and files should be stored.
If not given, a folder in the existing directory will be created.</p>
</dd>
<dt><code>varlist</code></dt>
<dd>
<p>Character vector of names of objects that need to be
passed to the parallel environment.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>extract_output_to_df</code></dt>
<dd>
<p>A function to extract the raw output into
a data frame. E.g., if the output is a list, but you want a single
item to show up in the output data frame.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-run_all"></a>



<h4>Method <code>run_all()</code>
</h4>

<p>Run an experiment. The user can choose
to run all rows, or just specified ones, if it should
be run in parallel, and what files should be saved.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_all(
  to_run = NULL,
  random_n = NULL,
  redo = FALSE,
  run_order,
  save_output = self$save_output,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores,
  parallel_temp_save = save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  delete_parallel_temp_save_after = FALSE,
  varlist = self$varlist,
  verbose = self$verbose,
  outfile,
  warn_repeat = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>to_run</code></dt>
<dd>
<p>Which rows should be run? If NULL, then all that haven't
been run yet.</p>
</dd>
<dt><code>random_n</code></dt>
<dd>
<p>Randomly selects n trials among those not yet completed
and runs them.</p>
</dd>
<dt><code>redo</code></dt>
<dd>
<p>Should already completed rows be run again?</p>
</dd>
<dt><code>run_order</code></dt>
<dd>
<p>In what order should the rows by run?
Options: random, in_order, and reverse.</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Should the output be saved?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should it be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>parallel_temp_save</code></dt>
<dd>
<p>Should temp files be written when running
in parallel? Prevents losing results if it crashes partway through.</p>
</dd>
<dt><code>write_start_files</code></dt>
<dd>
<p>Should start files be written?</p>
</dd>
<dt><code>write_error_files</code></dt>
<dd>
<p>Should error files be written for rows that
fail?</p>
</dd>
<dt><code>delete_parallel_temp_save_after</code></dt>
<dd>
<p>If using parallel temp save
files, should they be deleted afterwards?</p>
</dd>
<dt><code>varlist</code></dt>
<dd>
<p>A character vector of names of variables to be passed
the the parallel cluster.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>outfile</code></dt>
<dd>
<p>Where should master output file be saved when running
in parallel?</p>
</dd>
<dt><code>warn_repeat</code></dt>
<dd>
<p>Should warnings be given when repeating already
completed rows?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-run_for_time"></a>



<h4>Method <code>run_for_time()</code>
</h4>

<p>Run the experiment for a given time, not for a specified
number of trials. Runs 'batch_size' trials between checking the time
elapsed, only needs to be more than 1 when running in parallel.
It will complete the current batch before stopping, it does not quit
in the middle of the batch when reaching the time limit, so it will
go over the time limit given.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_for_time(
  sec,
  batch_size,
  show_time_in_bar = FALSE,
  save_output = self$save_output,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores,
  parallel_temp_save = save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  delete_parallel_temp_save_after = FALSE,
  varlist = self$varlist,
  verbose = self$verbose,
  warn_repeat = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sec</code></dt>
<dd>
<p>Number of seconds to run for</p>
</dd>
<dt><code>batch_size</code></dt>
<dd>
<p>Number of trials to run between checking the time
elapsed.</p>
</dd>
<dt><code>show_time_in_bar</code></dt>
<dd>
<p>The progress bar can show either the number of
runs completed or the time elapsed.</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Should the output be saved?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should it be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>parallel_temp_save</code></dt>
<dd>
<p>Should temp files be written when running
in parallel? Prevents losing results if it crashes partway through.</p>
</dd>
<dt><code>write_start_files</code></dt>
<dd>
<p>Should start files be written?</p>
</dd>
<dt><code>write_error_files</code></dt>
<dd>
<p>Should error files be written for rows that
fail?</p>
</dd>
<dt><code>delete_parallel_temp_save_after</code></dt>
<dd>
<p>If using parallel temp save
files, should they be deleted afterwards?</p>
</dd>
<dt><code>varlist</code></dt>
<dd>
<p>A character vector of names of variables to be passed
the the parallel cluster.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>warn_repeat</code></dt>
<dd>
<p>Should warnings be given when repeating already
completed rows?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-run_superbatch"></a>



<h4>Method <code>run_superbatch()</code>
</h4>

<p>Run batches. Allows for better progress visualization
and saving when running in parallel
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_superbatch(
  nsb,
  redo = FALSE,
  run_order,
  save_output = self$save_output,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores,
  parallel_temp_save = save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  delete_parallel_temp_save_after = FALSE,
  varlist = self$varlist,
  verbose = self$verbose,
  warn_repeat = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nsb</code></dt>
<dd>
<p>Number of super batches</p>
</dd>
<dt><code>redo</code></dt>
<dd>
<p>Should already completed rows be run again?</p>
</dd>
<dt><code>run_order</code></dt>
<dd>
<p>In what order should the rows by run?
Options: random, in_order, and reverse.</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Should the output be saved?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should it be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>parallel_temp_save</code></dt>
<dd>
<p>Should temp files be written when running
in parallel? Prevents losing results if it crashes partway through.</p>
</dd>
<dt><code>write_start_files</code></dt>
<dd>
<p>Should start files be written?</p>
</dd>
<dt><code>write_error_files</code></dt>
<dd>
<p>Should error files be written for rows that
fail?</p>
</dd>
<dt><code>delete_parallel_temp_save_after</code></dt>
<dd>
<p>If using parallel temp save
files, should they be deleted afterwards?</p>
</dd>
<dt><code>varlist</code></dt>
<dd>
<p>A character vector of names of variables to be passed
the the parallel cluster.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>warn_repeat</code></dt>
<dd>
<p>Should warnings be given when repeating already
completed rows?</p>
</dd>
<dt><code>outfile</code></dt>
<dd>
<p>Where should master output file be saved when running
in parallel?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-run_one"></a>



<h4>Method <code>run_one()</code>
</h4>

<p>Run a single row of the experiment.
You can specify which one to run.
Generally this should not be used by users, use 'run_all'
instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_one(
  irow = NULL,
  save_output = self$save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  warn_repeat = TRUE,
  is_parallel = FALSE,
  return_list_result_of_one = FALSE,
  verbose = self$verbose,
  force_this_as_output
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>irow</code></dt>
<dd>
<p>Which row should be run?</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Should the output be saved?</p>
</dd>
<dt><code>write_start_files</code></dt>
<dd>
<p>Should a file be written when starting
the experiment?</p>
</dd>
<dt><code>write_error_files</code></dt>
<dd>
<p>Should a file be written if there is
an error?</p>
</dd>
<dt><code>warn_repeat</code></dt>
<dd>
<p>Should a warning be given if repeating a row?</p>
</dd>
<dt><code>is_parallel</code></dt>
<dd>
<p>Is this being run in parallel?</p>
</dd>
<dt><code>return_list_result_of_one</code></dt>
<dd>
<p>Should the list of the result of
this one be return?</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>force_this_as_output</code></dt>
<dd>
<p>Value to use instead of evaluating
function.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-add_result_of_one"></a>



<h4>Method <code>add_result_of_one()</code>
</h4>

<p>Add the result of a single experiment to the object.
This shouldn't be used by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$add_result_of_one(
  output,
  systime,
  irow,
  row_grid,
  row_df,
  start_time,
  end_time,
  save_output,
  hashvalue
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output</code></dt>
<dd>
<p>The output of the experiment.</p>
</dd>
<dt><code>systime</code></dt>
<dd>
<p>The time it took to run</p>
</dd>
<dt><code>irow</code></dt>
<dd>
<p>The row of inputs used.</p>
</dd>
<dt><code>row_grid</code></dt>
<dd>
<p>The corresponding row in the run grid.</p>
</dd>
<dt><code>row_df</code></dt>
<dd>
<p>The corresponding row data frame.</p>
</dd>
<dt><code>start_time</code></dt>
<dd>
<p>The start time of the experiment.</p>
</dd>
<dt><code>end_time</code></dt>
<dd>
<p>The end time of the experiment.</p>
</dd>
<dt><code>save_output</code></dt>
<dd>
<p>Should the output be saved?</p>
</dd>
<dt><code>hashvalue</code></dt>
<dd>
<p>Not used.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-plot_run_times"></a>



<h4>Method <code>plot_run_times()</code>
</h4>

<p>Plot the run times of each trial.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$plot_run_times()</pre></div>


<hr>
<a id="method-ffexp-plot_pairs"></a>



<h4>Method <code>plot_pairs()</code>
</h4>

<p>Plot pairs of inputs and outputs.
Helps see correlations and distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$plot_pairs()</pre></div>


<hr>
<a id="method-ffexp-plot"></a>



<h4>Method <code>plot()</code>
</h4>

<p>Calling 'plot' on an 'ffexp' object calls 'plot_pairs()'
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$plot()</pre></div>


<hr>
<a id="method-ffexp-calculate_effects"></a>



<h4>Method <code>calculate_effects()</code>
</h4>

<p>Calculate the effects of each variable as if this
was an experiment using a linear model.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$calculate_effects()</pre></div>


<hr>
<a id="method-ffexp-calculate_effects2"></a>



<h4>Method <code>calculate_effects2()</code>
</h4>

<p>Calculate the effects of each variable as if this
was an experiment using a linear model.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$calculate_effects2()</pre></div>


<hr>
<a id="method-ffexp-save_self"></a>



<h4>Method <code>save_self()</code>
</h4>

<p>Save this R6 object
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$save_self(verbose = self$verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-create_save_folder_if_nonexistent"></a>



<h4>Method <code>create_save_folder_if_nonexistent()</code>
</h4>

<p>Create the save folder if it doesn't already exist.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$create_save_folder_if_nonexistent()</pre></div>


<hr>
<a id="method-ffexp-rename_save_folder"></a>



<h4>Method <code>rename_save_folder()</code>
</h4>

<p>Rename the save folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$rename_save_folder(new_folder_path, new_folder_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_folder_path</code></dt>
<dd>
<p>New path for the save folder</p>
</dd>
<dt><code>new_folder_name</code></dt>
<dd>
<p>If you want the new save folder to be in the
current directory, you can use this instead of 'new_folder_path' and
just give the folder name.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-delete_save_folder_if_empty"></a>



<h4>Method <code>delete_save_folder_if_empty()</code>
</h4>

<p>Delete the save folder if it is empty.
Used to prevent leaving behind empty folders.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$delete_save_folder_if_empty(verbose = self$verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt>
<dd>
<p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-recover_parallel_temp_save"></a>



<h4>Method <code>recover_parallel_temp_save()</code>
</h4>

<p>Running this loads the information saved to files
if 'save_parallel_temp_save=TRUE' was used when running.
Useful when running long jobs in parallel so that you don't
lose all results if it crashes before finishing.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$recover_parallel_temp_save(delete_after = FALSE, only_reload_new = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>delete_after</code></dt>
<dd>
<p>Should the temp files be deleted after they
are recovered? If TRUE, make sure you save the ffexp object after
running this function so
you don't lose the data.</p>
</dd>
<dt><code>only_reload_new</code></dt>
<dd>
<p>Will only reload output from runs that don't show as
completed yet. Can make it much faster if there are many saved files, but
most have already been loaded to this object.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-rungrid2"></a>



<h4>Method <code>rungrid2()</code>
</h4>

<p>Display the input rows of the experiment.
rungrid just gives integers, this gives the actual values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$rungrid2(rows = 1:nrow(self$rungrid))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>Which rows to display the inputs for? On big
experiments, specifying the rows can be much faster.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-add_variable"></a>



<h4>Method <code>add_variable()</code>
</h4>

<p>Add a variable to the experiment. You must specify the
value of the variable for all existing rows, and then also the values
of the variable which haven't been run yet.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$add_variable(name, existing_value, new_values, suppressMessage = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>Name of the variable being added.</p>
</dd>
<dt><code>existing_value</code></dt>
<dd>
<p>Which existing argument is a level being added to?</p>
</dd>
<dt><code>new_values</code></dt>
<dd>
<p>The values of the new variable which have not been
run. This should not include 'arg_name', the name of the new variable
at the existing values.</p>
</dd>
<dt><code>suppressMessage</code></dt>
<dd>
<p>Should the message be suppressed? The message
tells the user a new variable was added and it is being returned in a new
object. Default FALSE.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-add_level"></a>



<h4>Method <code>add_level()</code>
</h4>

<p>Add a level to one of the arguments. This returns a new
object. The existing object is not changed.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$add_level(arg_name, new_values, suppressMessage = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg_name</code></dt>
<dd>
<p>Which existing argument is a level being added to?</p>
</dd>
<dt><code>new_values</code></dt>
<dd>
<p>The value of the new levels to be added to 'arg_name'.</p>
</dd>
<dt><code>suppressMessage</code></dt>
<dd>
<p>Should the message be suppressed? The message
tells the user a new level was added and it is being returned in a new
object. Default FALSE.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-remove_results"></a>



<h4>Method <code>remove_results()</code>
</h4>

<p>Remove results of completed trials. They will be rerun
next time $run_all() is called.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$remove_results(to_remove)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>to_remove</code></dt>
<dd>
<p>Indexes of trials to remove</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Printing the object shows some
summary information.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$print()</pre></div>


<hr>
<a id="method-ffexp-set_parallel_cores"></a>



<h4>Method <code>set_parallel_cores()</code>
</h4>

<p>Set the number of parallel cores to be used when
running in parallel. Needed in case user sets "detect"
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$set_parallel_cores(parallel_cores)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parallel_cores</code></dt>
<dd>
<p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ffexp-stop_cluster"></a>



<h4>Method <code>stop_cluster()</code>
</h4>

<p>Stop the parallel cluster.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$stop_cluster()</pre></div>


<hr>
<a id="method-ffexp-finalize"></a>



<h4>Method <code>finalize()</code>
</h4>

<p>Cleanup after deleting object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$finalize()</pre></div>


<hr>
<a id="method-ffexp-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R"># Two factors, both with two levels.
#   The evaluation function simply prints out the combination
cc &lt;- ffexp$new(a=1:2,b=c("A","B"),
                eval_func=function(...) {c(...)})
# View the factor settings it will run (each row).
cc$rungrid
# Evaluate all four settings
cc$run_all()


cc &lt;- ffexp$new(a=1:3,b=2, cd=data.frame(c=3:4,d=5:6),
                eval_func=function(...) {list(...)})
</code></pre>


</div>