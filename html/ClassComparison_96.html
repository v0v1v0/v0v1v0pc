<div class="container">

<table style="width: 100%;"><tr>
<td>TwoGroupStats-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "TwoGroupStats"</h2>

<h3>Description</h3>

<p>Compute row-by-row means and variances for a data matrix
whose columns belong to two different groups of interest.
</p>


<h3>Usage</h3>

<pre><code class="language-R">TwoGroupStats(data, classes, name=comparison, name1=A, name2=B)
## S4 method for signature 'TwoGroupStats'
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'TwoGroupStats'
summary(object, ...)
## S4 method for signature 'TwoGroupStats'
print(x, ...)
## S4 method for signature 'TwoGroupStats'
show(object)
## S4 method for signature 'TwoGroupStats,missing'
plot(x, main=x@name, useLog=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code>ExpressionSet</code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code>phenoData</code> subobject.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p> A character string; the name of this object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name1</code></td>
<td>
<p> A character string; the name of the first group </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name2</code></td>
<td>
<p> A character string; the name of the second group </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>TwoGroupStats</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>See the base version of <code>as.data.frame.default</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>See the base version of <code>as.data.frame.default</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>TwoGroupStats</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>Plot title</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useLog</code></td>
<td>
<p>a logical flag; should the values be log-transformed
before plotting?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>The usual extra arguments to generic functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This class was one of the earliest developments in our suite of tools
to analyze microarrays. Its main purpose is to segregate out the
preliminary computation of summary statistics on a row-by-row basis,
along with a set of plots that could be generated automatically and
used for quality control.
</p>


<h3>Creating Objects</h3>

<p>Although objects of the class can be created by a direct call to
new, the preferred method is to use the
<code>TwoGroupStats</code> generator. The inputs to this
function are the same as those used for row-by-row statistical tests
throughout the ClassComparison package; a detailed description can be
found in the <code>MultiTtest</code> class.
</p>
<p>One should note that this class serves as the front end to the
<code>SmoothTtest</code> class, providing it with an interface that
accepts <code>ExpressionSet</code>
objects compatible with the other statistical tests in the
ClassComparison package.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>mean1</code>:</dt>
<dd>
<p>numeric vector of means in the first group</p>
</dd>
<dt>
<code>mean2</code>:</dt>
<dd>
<p>numeric vector of means in the second group</p>
</dd>
<dt>
<code>overallMean</code>:</dt>
<dd>
<p>numeric vector of overall row means</p>
</dd>
<dt>
<code>var1</code>:</dt>
<dd>
<p>numeric vector of variances in the first group</p>
</dd>
<dt>
<code>var2</code>:</dt>
<dd>
<p>numeric vector of variances in the second group</p>
</dd>
<dt>
<code>overallVar</code>:</dt>
<dd>
<p>numeric vector of variances assuming
the two groups have the same mean</p>
</dd>
<dt>
<code>pooledVar</code>:</dt>
<dd>
<p>numeric vector of row-by-row pooled variances,
assuming the two groups have the same variance but different means</p>
</dd>
<dt>
<code>n1</code>:</dt>
<dd>
<p>numeric scalar specifying number of items in the
first group</p>
</dd>
<dt>
<code>n2</code>:</dt>
<dd>
<p>numeric scalar specifying number of items in the
second group</p>
</dd>
<dt>
<code>name1</code>:</dt>
<dd>
<p>character string specifying name of the first group</p>
</dd>
<dt>
<code>name2</code>:</dt>
<dd>
<p>character string specifying name of the second group</p>
</dd>
<dt>
<code>name</code>:</dt>
<dd>
<p>character string specifying name of the object</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>as.data.frame(x, row.names=NULL, optional=FALSE)</dt>
<dd>
<p>Collect the
numeric vectors from the object into a single dat fame, suitable
for printing or exporting.</p>
</dd>
<dt>summary(object, ...)</dt>
<dd>
<p>Write out a summary of the object.</p>
</dd>
<dt>print(x, ...)</dt>
<dd>
<p>Print the object. (Actually, it only prints a
summary, since the whole object is almost always more than you
really want to see. If you insist on printing everything, use
<code>as.data.frame</code>.)</p>
</dd>
<dt>show(object)</dt>
<dd>
<p>Print the object (same as print method).)</p>
</dd>
<dt>plot(x, main=x@name, useLog=FALSE, ...)</dt>
<dd>
<p>This function
actually produces six different plots of the data, so it is
usually wrapped by a graphical layout command like
<code>par(mfrow=c(2,3))</code>. The first two plots show the relation
between the mean and standard deviation for the two groups
separately; the third plot does the same for the overall mean and
variance.  The fourth plot is a Bland-Altman plot of the difference
between the means against the overall mean. (In the microarray
world, this is usually called an M-vs-A plot.)  A loess fit is
overlaid on the scatter plot, and points outside confidence bounds
based on the fit are printed in a different color to flag them as
highly variable. The fifth plot shows a loess fit (with confidence
bounds) of the difference as a function of the row index (which
often is related to the geometric position of spots on a
microarray). Thus, this plot gives a possible indication of regions
of an array where unusual things happen. The final plot compares
the overall variances to the pooled variances.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Altman DG, Bland JM.<br><em>Measurement in Medicine: the Analysis of Method Comparison Studies.</em><br>
The Statistician, 1983; 32: 307-317. 
</p>


<h3>See Also</h3>

<p><code>MultiTtest</code>,
<code>SmoothTtest</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">showClass("TwoGroupStats")
bogus &lt;- matrix(rnorm(30*1000, 8, 3), ncol=30, nrow=1000)
splitter &lt;- rep(FALSE, 30)
splitter[16:30] &lt;- TRUE

x &lt;- TwoGroupStats(bogus, splitter)
summary(x)

opar&lt;-par(mfrow=c(2,3), pch='.')
plot(x)
par(opar)
</code></pre>


</div>