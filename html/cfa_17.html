<div class="container">

<table style="width: 100%;"><tr>
<td>PXisM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Test according to Lindner</h2>

<h3>Description</h3>

<p>Performs a test of significance according to Lindner
</p>


<h3>Usage</h3>

<pre><code class="language-R">PXisM(m,n,Nt,k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Observed frequency of the observation tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Marginal sums of the parameters realized in the configuration to be tested (vector) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nt</code></td>
<td>
<p>Sample size of configurations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of parameters</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p> returns p for the test according to Linder
</p>


<h3>Note</h3>

<p> The test according to Lindner requires the packages parallel. All other parts of cfa do not.
</p>


<h3>Author(s)</h3>

<p>J. Harloff &lt;oachimharloff@joachimharloff.de&gt; </p>


<h3>References</h3>

<p>Lindner, K.: Eine exakte Auswertungsmethode zur Konfigurationsfrequenzanalyse [An exact procedure for
the configural frequency analysis]. Psycholog Beitraege 26, 393?415 (1984)
</p>
<p>Harloff, Joachim, An efficient algorithm for Lindners test
(configural frequency analysis), Qual Quant DOI 10.1007/s11135-011-9499-9
</p>


<h3>See Also</h3>

 <p><code>cfa</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Does not work with windows since there is no parallel for it
if (require(parallel)) {
lk&lt;-4 # number of parameters
ln&lt;-c(59,57,59,58) # marginal sums of the parameters realized in the configuration to be tested
lNt&lt;-116 # sample size of configurations
lm0&lt;-16 # observed frequency of the configuration tested


# New algorithm
starttime=proc.time()
pHXsmallerequalM0&lt;-sum(unlist(mclapply(0:lm0,PXisM,ln,lNt,lk)))
pHXequalM0&lt;-PXisM(lm0,ln,lNt,lk)
pHlargerequalM0&lt;-sum(unlist(mclapply(lm0: min(ln),PXisM,ln,lNt,lk)))
stoptime&lt;-proc.time()
list(pHXsmallerequalM0=pHXsmallerequalM0,pHXequalM0=pHXequalM0,pHlargerequalM0=pHlargerequalM0,
timed.required=stoptime-starttime)

# End of the new algorithm
}

</code></pre>


</div>