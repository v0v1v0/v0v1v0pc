<div class="container">

<table style="width: 100%;"><tr>
<td>permute_costmatrices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Permute costmatrices</h2>

<h3>Description</h3>

<p>Given vectors of states and costs, permutes all possible costmatrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">permute_costmatrices(states = c("0", "1"), costs = c(1:3), symmetry = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>A vector of character states, e.g., "0", "1", "2".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>costs</code></td>
<td>
<p>A vector of numeric costs, e.g., 1, 2, Inf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetry</code></td>
<td>
<p>Must be one of <code>"symmetric"</code>, <code>"asymmetric"</code> or <code>"both"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Costmatrices define the cost of each state-to-state transition, but they are restricted in what these costs can be (see check_costMatrix). Nevertheless, strictly speaking there are infinite possible costmatrices - even where costs are restricted to integer values (as TNT does; Goloboff et al. 2008; Goloboff and Catalano 2016), i.e., "stepmatrices" (Swofford and Maddison 1992). Thus this function operates on a finite system by requiring the user to specify a restricted set of states and individual cost values, with the function permuting every possible combination of finite costs. Note that not <em>every</em> permutation will be returned as not all of these will be valid costmatrices (see check_costMatrix and fix_costmatrix). Others will not be returned because their cost <em>ratio</em> can be considered redundant. For example, for a binary character (states "0", and "1") the following two costmatrices would be mutually redundant as the ratio of their costs is identical:
</p>
<pre>  A B
A 0 1
B 2 0

  A B
A 0 2
B 4 0</pre>
<p>(If the user does want to consider these kinds of alternatives then a better solution is to simply weight the first matrix by two, or any other value, in any downstream analys(es).)
</p>
<p>For the function to work costs must be unique positive values. This includes infinity (<code>Inf</code> in R). Infinite costs can be used to denote a particular transition is impossible and allows defining (e.g.) irreversible characters, or those that force a particular root value.
</p>


<h3>Value</h3>

<p>A list of unique costmatrices containing every possible combination of costs.
</p>


<h3>Author(s)</h3>

<p>Graeme T. Lloyd <a href="mailto:graemetlloyd@gmail.com">graemetlloyd@gmail.com</a>
</p>


<h3>References</h3>

<p>Goloboff, P. A. and Catalano, S. A., 2016. TNT version 1.5, including a full implementation of phylogenetic morphometrics/ <em>Cladistics</em>, <b>32</b>. 221-238
</p>
<p>Goloboff, P., Farris, J. and Nixon, K., 2008. TNT, a free program for phylogenetic analysis. <em>Cladistics</em>, <b>24</b>, 774-786.
</p>
<p>Swofford, D. L. and Maddison, W. P., 1992. Parsimony, character-state reconstructions, and evolutionary inferences. <em>In</em> R. L. Mayden (ed.) Systematics, Historical Ecology, and North American Freshwater Fishes. Stanford University Press, Stanford, p187-223.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Permute all the ways to assign the costs 1 and 2 for a three state
# character:
permute_costmatrices(
  states = c("0", "1", "2"),
  costs = c(1, 2),
  symmetry = "both"
)

</code></pre>


</div>