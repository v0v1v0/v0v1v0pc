<div class="container">

<table style="width: 100%;"><tr>
<td>cadence.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a CDEN model
</h2>

<h3>Description</h3>

<p>Fit a CDEN model via nonlinear optimization of the maximum likelihood cost
function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cadence.fit(x, y, iter.max = 500, n.hidden = 2, hidden.fcn = tanh,
            distribution = NULL, sd.norm = Inf, init.range = c(-0.5, 0.5),
            method = c("optim", "psoptim", "Rprop"), n.trials = 1,
            trace = 0, maxit.Nelder = 2000, trace.Nelder = 0,
            swarm.size = NULL, vectorize = TRUE,
            delta.0 = 0.1, delta.min = 1e-06, delta.max = 50, epsilon = 1e-08,
            range.mult = 2, step.tol = 1e-08, f.target = -Inf,
            f.cost = cadence.cost, max.exceptions = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictor variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>column matrix of predictand values with number of rows equal to the number of samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>

<p>maximum number of iterations of the optimization function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.hidden</code></td>
<td>

<p>number of hidden nodes in the CDEN model; can be a vector indicating a range of values to fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden.fcn</code></td>
<td>

<p>hidden layer transfer function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>

<p>a list that describes the probability density function associated with the predictand.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.norm</code></td>
<td>

<p><code>sd</code> parameter for normal distribution prior for the magnitude of input-hidden layer weights; equivalent to weight penalty regularization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.range</code></td>
<td>

<p>range for random weights on [<code>min(init.range)</code>, <code>max(init.range)</code>]
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>specifies the optimization method used to minimize <code>cadence.cost</code>; must be chosen from <code>c("optim", "psoptim", "Rprop")</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trials</code></td>
<td>

<p>number of repeated trials used to avoid shallow local minima during optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>the level of printing which is done during optimization. A value of <code>0</code> suppresses
any progress reporting.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.Nelder</code></td>
<td>

<p>maximum number of iterations of the Nelder-Mead optimization function prior to main calling <code>method</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.Nelder</code></td>
<td>

<p>the level of printing which is done during Nelder-Mead optimization. A value of <code>0</code> suppresses
any progress reporting.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swarm.size</code></td>
<td>

<p><code>swarm.size</code> if <code>psoptim</code> is used for optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectorize</code></td>
<td>

<p><code>vectorize</code> if <code>psoptim</code> is used for optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.0</code></td>
<td>

<p>size of the initial update-value if <code>rprop</code> is used for optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.min</code></td>
<td>

<p>minimum value for the adaptive update-value if <code>rprop</code> is used for optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.max</code></td>
<td>

<p>maximum value for the adaptive update-value if <code>rprop</code> is used for optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>step-size used in the finite difference calculation of the gradient if <code>rprop</code> is used for optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range.mult</code></td>
<td>

<p>if <code>psoptim</code> is used for optimization, sets the search space boundaries to <code>range.mult</code> times the range of weights found by the Nelder-Mead algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.tol</code></td>
<td>

<p>convergence criterion if <code>rprop</code> is used for optimization. Optimization will stop if the change in <code>f</code> over the previous three iterations falls below this value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.target</code></td>
<td>

<p>target value of <code>f</code> if <code>rprop</code> is used for optimization. Optimization will stop if <code>f</code> falls below this value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.cost</code></td>
<td>

<p>cost function to be optimized.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.exceptions</code></td>
<td>

<p>maximum number of repeated exceptions allowed during optimization.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Fit a CDEN model by optimizing the maximum likelihood cost function
<code>f.cost</code>, which is set by default to <code>cadence.cost</code>.
Optimization relies on the standard <code>optim</code> function, the
built-in <code>rprop</code> function, or, optionally,
the <code>psoptim</code> function from the <code>pso</code> package.
</p>
<p>The hidden layer transfer function <code>hidden.fcn</code> should be set to
<code>tanh</code> for a nonlinear model and to <code>identity</code> for a
linear model. In the nonlinear case, the number of hidden nodes <code>n.hidden</code>
controls the overall complexity of the model. The predictand distribution
is set by the <code>distribution</code> argument. Parameters of the specified
distribution can be held constant via the <code>parameters.fixed</code> element
<code>distribution</code>. Weight penalty regularization for the magnitude of the
input-hidden layer weights can be applied by setting <code>sd.norm</code> to a value
less than <code>Inf</code>.
</p>
<p>The <code>distribution</code> argument in <code>cadence.fit</code> is the most important
part of the <code>CaDENCE</code> modelling framework and has been designed to be
as flexible as possible. To this end, <code>distribution</code> is a list with three
mandatory elements: <code>density.fcn</code>, which specifies the R density function
for the predictand distribution; <code>parameters</code>, which specifies the names
of the parameters used as arguments in <code>density.fcn</code>; and
<code>output.fcns</code>, which specifies the functions used to constrain the density
function parameters to their allowable ranges (i.e., inverse link
functions). If not specified, <code>distribution</code> defaults to a normal
distribution. Note: the order of <code>parameters</code> and <code>output.fcns</code> must
match the order of arguments in the specified <code>density.fcn</code>.
</p>
<p>A fourth element of <code>distribution</code>, <code>parameters.fixed</code>, is optional.
Setting <code>parameters.fixed</code><code>="sd"</code> for the normal distribution would, for
example, force the <code>sd</code> parameter to take a constant value.
</p>
<p>Samples of <code>distribution</code> lists for a variety of probability distributions
are given below for reference:
</p>
<pre>
# normal distribution
norm.distribution &lt;- list(density.fcn = dnorm,
                          parameters = c("mean", "sd"),
                          parameters.fixed = NULL,
                          output.fcns = c(identity, exp))

# lognormal distribution
lnorm.distribution &lt;- list(density.fcn = dlnorm,
                           parameters = c("meanlog", "sdlog"),
                           parameters.fixed = NULL,
                           output.fcns = c(identity, exp))

# exponential distribution
exp.distribution &lt;- list(density.fcn = dexp,
                         parameters = c("rate"),
                         parameters.fixed = NULL,
                         output.fcns = c(exp))

# Poisson distribution
poisson.distribution &lt;- list(density.fcn = dpois,
                             parameters = c("lambda"),
                             parameters.fixed = NULL,
                             output.fcns = c(exp))

# Bernoulli-gamma distribution
bgamma.distribution &lt;- list(density.fcn = dbgamma,
                            parameters = c("prob", "scale", "shape"),
                            parameters.fixed = NULL,
                            output.fcns = c(logistic, exp, exp))

# Bernoulli-Weibull distribution
bweibull.distribution &lt;- list(density.fcn = dbweibull,
                              parameters = c("prob", "scale", "shape"),
                              parameters.fixed = NULL,
                              output.fcns = c(logistic, exp, exp))

# Bernoulli-lognormal distribution
blnorm.distribution &lt;- list(density.fcn = dblnorm,
                            parameters = c("prob", "meanlog", "sdlog"),
                            parameters.fixed = NULL,
                            output.fcns = c(logistic, identity, exp))

# Bernoulli-Pareto 2 distribution
bpareto2.distribution &lt;- list(density.fcn = dbpareto2,
                          parameters = c("prob", "scale", "shape"),
                          parameters.fixed = NULL,
                          output.fcns = c(logistic, exp, exp))

# beta distribution
beta.distribution &lt;- list(density.fcn=dbeta,
                          parameters=c("shape1", "shape2"),
                          parameters.fixed=NULL,
                          output.fcns=c(exp, exp))

# truncated normal distribution with lower = 0
library(msm)
dtnormal &lt;- function(x, mean, sd) dtnorm(x, mean, sd, lower = 0)
dtnorm.distribution &lt;- list(density.fcn = dtnormal,
                            parameters = c("mean", "sd"),
                            parameters.fixed = NULL,
                            output.fcns = c(identity, exp))

# mixture of two normal distributions (mixture density network)
library(nor1mix)
dnormix &lt;- function(x, mu1, mu2, sig1, sig2, w1){
    if(length(x) &gt; 1){
        dens &lt;- mapply(dnormix, x, mu1 = mu1, mu2 = mu2,
                       sig1 = sig1, sig2 = sig2, w1 = w1)
    } else{
        mix &lt;- norMix(mu = c(mu1, mu2), sigma = c(sig1, sig2),
                      w = c(w1, 1-w1))
        dens &lt;- dnorMix(x, mix)
    }
        dens
}
normix.distribution &lt;- list(density.fcn = dnormix,
                            parameters = c("mu1", "mu2", "sig1",
                                           "sig2", "w1"),
                            parameters.fixed = NULL,
                            output.fcns = c(identity, identity,
                                            exp, exp, logistic))
</pre>
<p>Values of the Akaike information criterion with small sample size correction
(AICc), and Bayesian information criterion (BIC) are calculated to assist in
model selection. It is possible for such criteria to fail in the face of
overfitting, for example with a nonlinear model and <code>n.hidden</code> set too
high, as the distribution may converge on one or more samples. This can usually
be diagnosed by inspecting the scale parameter of the distribution for near
zero values. In this case, one can apply a weight penalty (via <code>sd.norm</code>),
although this rules out the straightforward use of AICc/BIC for model
selection as the effective number of model parameters will no longer equal the
number of weights in the CDEN model.
</p>
<p>Note: values of <code>x</code> need not be standardized or rescaled by the user.
Predictors are automatically scaled to zero mean and unit standard deviation
and are rescaled by <code>cadence.predict</code>.
</p>


<h3>Value</h3>

<p>a list of with number of elements equal to the length of <code>n.hidden</code>; each list consists of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>W1</code></td>
<td>
<p>input-hidden layer weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W2</code></td>
<td>
<p>hidden-output layer weights. Attributes indicating the
mean and standard deviation of columns of <code>x</code>; the value
of <code>hidden.fcn</code>; the valud of <code>hidden.fcn</code>; the negative
log-likelihood <code>NLL</code>; the number of model parameters <code>k</code>;
the value of the weight penalty <code>penalty</code> (if <code>sd.norm</code> is
less than infinity); the value of the <code>BIC</code>, <code>AIC</code>, and
<code>AICc</code> cost-complexity criteria; and the predictand
<code>distribution</code> list are also returned.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Cannon, A.J., 2012. Neural networks for probabilistic environmental
prediction: Conditional Density Estimation Network Creation &amp; Evaluation
(CaDENCE) in R. Computers &amp; Geosciences 41: 126-135.
doi:10.1016/j.cageo.2011.08.023
</p>
<p>Neuneier, R., F. Hergert, W. Finnoff, and D. Ormoneit, 1994., Estimation of
conditional densities: a comparison of neural network approaches. In:
M. Marinaro and P. Morasso (eds.), Proceedings of ICANN 94, Berlin, Springer,
p. 689-692.
</p>


<h3>See Also</h3>

<p><code>cadence.predict</code>, <code>optim</code>, <code>rprop</code>,
<code>xval.buffer</code>, <code>logistic</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">    data(FraserSediment)
    set.seed(1)
    lnorm.distribution &lt;- list(density.fcn = dlnorm,
                               parameters = c("meanlog", "sdlog"),
                               parameters.fixed = NULL,
                               output.fcns = c(identity, exp))
    fit &lt;- cadence.fit(x = FraserSediment$x.1970.1976[c(TRUE, rep(FALSE, 19)),],
                       y = FraserSediment$y.1970.1976[c(TRUE, rep(FALSE, 19)),,
                       drop=FALSE], n.hidden = 3, n.trials = 1,
                       maxit.Nelder = 100, trace.Nelder = 1, hidden.fcn = tanh,
                       distribution = lnorm.distribution, trace = 1)
    pred &lt;- cadence.predict(x = FraserSediment$x.1977.1979, fit = fit)
    matplot(pred, type = "l")
</code></pre>


</div>