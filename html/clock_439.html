<div class="container">

<table style="width: 100%;"><tr>
<td>time-point-rounding</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Time point rounding</h2>

<h3>Description</h3>


<ul>
<li> <p><code>time_point_floor()</code> rounds a sys-time or naive-time down to a multiple of
the specified <code>precision</code>.
</p>
</li>
<li> <p><code>time_point_ceiling()</code> rounds a sys-time or naive-time up to a multiple of
the specified <code>precision</code>.
</p>
</li>
<li> <p><code>time_point_round()</code> rounds up or down depending on what is closer,
rounding up on ties.
</p>
</li>
</ul>
<p>Rounding time points is mainly useful for rounding sub-daily time points
up to daily time points.
</p>
<p>It can also be useful for flooring by a set number of days (like 20) with
respect to some origin. By default, the origin is 1970-01-01 00:00:00.
</p>
<p>If you want to group by components, such as "day of the month", rather than
by "n days", see <code>calendar_group()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">time_point_floor(x, precision, ..., n = 1L, origin = NULL)

time_point_ceiling(x, precision, ..., n = 1L, origin = NULL)

time_point_round(x, precision, ..., n = 1L, origin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code style="white-space: pre;">⁠[clock_sys_time / clock_naive_time]⁠</code>
</p>
<p>A sys-time or naive-time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p><code style="white-space: pre;">⁠[character(1)]⁠</code>
</p>
<p>A time point precision. One of:
</p>

<ul>
<li> <p><code>"day"</code>
</p>
</li>
<li> <p><code>"hour"</code>
</p>
</li>
<li> <p><code>"minute"</code>
</p>
</li>
<li> <p><code>"second"</code>
</p>
</li>
<li> <p><code>"millisecond"</code>
</p>
</li>
<li> <p><code>"microsecond"</code>
</p>
</li>
<li> <p><code>"nanosecond"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p><code style="white-space: pre;">⁠[positive integer(1)]⁠</code>
</p>
<p>A positive integer specifying the multiple of <code>precision</code> to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p><code style="white-space: pre;">⁠[clock_sys_time(1) / clock_naive_time(1) / NULL]⁠</code>
</p>
<p>An origin to begin counting from. Mostly useful when <code>n &gt; 1</code> and you
want to control how the rounding groups are created.
</p>
<p>If <code>x</code> is a sys-time, <code>origin</code> must be a sys-time.
</p>
<p>If <code>x</code> is a naive-time, <code>origin</code> must be a naive-time.
</p>
<p>The precision of <code>origin</code> must be equally precise as or less
precise than <code>precision</code>.
</p>
<p>If <code>NULL</code>, a default origin of midnight on 1970-01-01 is used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>x</code> rounded to the new <code>precision</code>.
</p>


<h3>Boundary Handling</h3>

<p>To understand how flooring and ceiling work, you need to know how they
create their intervals for rounding.
</p>

<ul>
<li> <p><code>time_point_floor()</code> constructs intervals of <code>[lower, upper)</code> that
bound each element of <code>x</code>, then always chooses the <em>left-hand side</em>.
</p>
</li>
<li> <p><code>time_point_ceiling()</code> constructs intervals of <code>(lower, upper]</code> that
bound each element of <code>x</code>, then always chooses the <em>right-hand side</em>.
</p>
</li>
</ul>
<p>As an easy example, consider 2020-01-02 00:00:05.
</p>
<p>To floor this to the nearest day, the following interval is constructed,
and the left-hand side is returned at day precision:
</p>
<p><code>[2020-01-02 00:00:00, 2020-01-03 00:00:00)</code>
</p>
<p>To ceiling this to the nearest day, the following interval
is constructed, and the right-hand side is returned at day precision:
</p>
<p><code>(2020-01-02 00:00:00, 2020-01-03 00:00:00]</code>
</p>
<p>Here is another example, this time with a time point on a boundary,
2020-01-02 00:00:00.
</p>
<p>To floor this to the nearest day, the following interval is constructed,
and the left-hand side is returned at day precision:
</p>
<p><code>[2020-01-02 00:00:00, 2020-01-03 00:00:00)</code>
</p>
<p>To ceiling this to the nearest day, the following interval
is constructed, and the right-hand side is returned at day precision:
</p>
<p><code>(2020-01-01 00:00:00, 2020-01-02 00:00:00]</code>
</p>
<p>Notice that, regardless of whether you are doing a floor or ceiling, if
the input falls on a boundary then it will be returned as is.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(magrittr)

x &lt;- as_naive_time(year_month_day(2019, 01, 01))
x &lt;- add_days(x, 0:40)
head(x)

# Floor by sets of 20 days
# The implicit origin to start the 20 day counter is 1970-01-01
time_point_floor(x, "day", n = 20)

# You can easily customize the origin by supplying a new one
# as the `origin` argument
origin &lt;- year_month_day(2019, 01, 01) %&gt;%
  as_naive_time()

time_point_floor(x, "day", n = 20, origin = origin)

# For times on the boundary, floor and ceiling both return the input
# at the new precision. Notice how the first element is on the boundary,
# and the second is 1 second after the boundary.
y &lt;- as_naive_time(year_month_day(2020, 01, 02, 00, 00, c(00, 01)))
time_point_floor(y, "day")
time_point_ceiling(y, "day")
</code></pre>


</div>