<div class="container">

<table style="width: 100%;"><tr>
<td>make.crf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make CRF</h2>

<h3>Description</h3>

<p>Generate CRF from the adjacent matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">make.crf(adj.matrix = NULL, n.states = 2, n.nodes = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adj.matrix</code></td>
<td>
<p>The adjacent matrix of CRF network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.states</code></td>
<td>
<p>The state numbers of nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.nodes</code></td>
<td>
<p>The number of nodes, which is only used to generate linear chain CRF when <code>adj.matrix</code> is NULL.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function will generate an empty CRF from a given adjacent
matrix. If the length of <code>nstates</code> is less than <code>n.nodes</code>, it will
be used repeatly. All node and edge potentials are initilized as 1.
</p>
<p>Since the CRF data are often very huge, CRF is implemented as an environment.
The assignment of environments will only copy the addresses instead of real data,
therefore the variables using normal assignment will refer to the exactly same CRF.
For complete duplication of the data, please use <code>duplicate.crf</code>.
</p>


<h3>Value</h3>

<p>The function will return a new CRF, which is an environment with
components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>n.nodes</code></td>
<td>
<p>The number of nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.edges</code></td>
<td>
<p>The number of edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.states</code></td>
<td>
<p>The number of states for each node. It is a vector of length <code>n.nodes</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.state</code></td>
<td>
<p>The maximum number of states. It is equal to <code>max(n.states)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edges</code></td>
<td>
<p>The node pair of each edge. It is a matrix with 2 columns and <code>n.edges</code> rows. Each row
denotes one edge. The node with smaller id is put in the first column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.adj</code></td>
<td>
<p>The number of adjacent nodes for each node. It is a vector of length <code>n.nodes</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.nodes</code></td>
<td>
<p>The list of adjacent nodes for each
node. It is a list of length <code>n.nodes</code> and the i-th element is a vector
of length <code>n.adj[i]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.edges</code></td>
<td>
<p>The list of adjacent edges for each node. It is similiar to <code>adj.nodes</code>
while contains the edge ids instead of node ids.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node.pot</code></td>
<td>
<p>The node potentials. It is a matrix with dimmension <code>(n.nodes, max.state)</code>.
Each row <code>node.pot[i,]</code> denotes the node potentials of the i-th node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.pot</code></td>
<td>
<p>The edge potentials. It is a list of <code>n.edges</code> matrixes. Each matrix
<code>edge.pot[[i]]</code>, with dimension <code>(n.states[edges[i,1]],
    n.states[edges[i,2]])</code>, denotes the edge potentials of the i-th edge.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>duplicate.crf</code>, <code>clamp.crf</code>, <code>sub.crf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(CRF)

nNodes &lt;- 4
nStates &lt;- 2

adj &lt;- matrix(0, nrow=nNodes, ncol=nNodes)
for (i in 1:(nNodes-1))
{
	adj[i,i+1] &lt;- 1
	adj[i+1,i] &lt;- 1
}

crf &lt;- make.crf(adj, nStates)

crf$node.pot[1,] &lt;- c(1, 3)
crf$node.pot[2,] &lt;- c(9, 1)
crf$node.pot[3,] &lt;- c(1, 3)
crf$node.pot[4,] &lt;- c(9, 1)

for (i in 1:crf$n.edges)
{
   crf$edge.pot[[i]][1,] &lt;- c(2, 1)
   crf$edge.pot[[i]][2,] &lt;- c(1, 2)
}

</code></pre>


</div>