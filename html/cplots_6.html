<div class="container">

<table style="width: 100%;"><tr>
<td>cmdensity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multi-class Circular Density Curve</h2>

<h3>Description</h3>

<p>Function <code>cmdensity</code> can be used to plot 2-dimensional 
density curves for circular data with multiple classes. The density curves 
are stacked to avoid any overlap.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cmdensity(
  funlist,
  funprop = 1,
  radius = 1/sqrt(base::pi),
  area.prop = TRUE,
  total.area = 1,
  n = 500,
  nlabels = 4,
  cols = NULL,
  borders = NULL,
  xlim = NULL,
  ylim = NULL,
  main = NULL,
  type = c("null", "compass", "clock"),
  add = FALSE,
  x.legend = "bottomright",
  y.legend = NULL,
  fill = TRUE,
  lty = 1,
  lwd = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>funlist</code></td>
<td>
<p>a list of functions which can be used to calculate the
density values for each class, evaluated at given points defined by
the first argument of the functions. The set of points is a sequence
from <code class="reqn">0</code> to <code class="reqn">2\pi</code>, with length <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funprop</code></td>
<td>
<p>proportions for functions. It is 1 by default. A user can
choose different proportions for the functions so as to represent
different numbers of observations. If they do not add up to the number
of functions (k), it will be normalised so that <code>sum(classprop) =
k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>the radius of the reference circle.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area.prop</code></td>
<td>
<p>logical; if <code>TRUE</code>, an area-proportional
transformation is applied; if <code>FALSE</code>, a height-proportional
transformationis applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total.area</code></td>
<td>
<p>a positive number specifying the total area under all the
density curves. If <code>total.area = NULL</code>, no scaling is applied, the
plot is in the original scale. If <code>area.prop = TRUE</code>, the total area 
is automatically unity without scaling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of points used to plot each density curve.  The
larger the number is, the more accurate the curve is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlabels</code></td>
<td>
<p>integer, for the number of levels to be plotted; if
<code>0</code>, no label is plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>the colors to fill the area under each density curve, with
the same order as the class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>borders</code></td>
<td>
<p>the colors of the borders.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>numeric vectors of length 2, giving the x coordinates
ranges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the y coordinates
ranges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>the main title (on top)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the type of circular data, one of the values <code>"null"</code>,
<code>"compass"</code> or <code>"clock"</code>.  If <code>"null"</code>, no special
lables plotted for directions. If <code>"compass"</code>, the four cardinal
directions are printed inside the reference circle. If <code>"clock"</code>,
labels for 24 hours are printed inside the reference circle.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>logical; if <code>TRUE</code>, density curves are superimposed to
the current plot, for example, the circular histograms, rose diagrams
and stacked dot plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.legend</code></td>
<td>
<p>x coordinate to plot the legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.legend</code></td>
<td>
<p>y coordinate to plot the legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>logical. If <code>TRUEt</code>, fills the regions with colors
under/between the density curves. If <code>FALSE</code>, only the density
curves are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>line width</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>line width</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Danli Xu &lt;dxu452@aucklanduni.ac.nz&gt;, Yong Wang &lt;yongwang@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Xu, D. and Wang, Y. (2020). Area-proportional Visualization for
Circular Data. <em>Journal of Computational and Graphical
Statistics</em>, <b>29</b>, 351-357.
</p>


<h3>See Also</h3>

<p><code>cdensity</code>, <code>cmhist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load and pre-process the dataset
library(circular)
data("pigeons", package = "circular")
x = pigeons[,2] / 180 * pi                  # bearing
y = pigeons[,1]                             # treatment
vs = split(x, factor(y, unique(y)))    # list of classified value
prop = sapply(vs, length) / length(x)  # proportion of each class

# Define the kde function for each class using von Mises kernels
dvm = function(x, mu=0, kappa=1)  # von Mises density
  exp(kappa * cos(x - mu)) * (2 * pi * besselI(kappa, 0))^(-1)
kdevm = function(x, x0, bw=0.3) 
  rowMeans(outer(x, x0, dvm, 0.5 / (1 - exp(-bw^2 / 2))))
fs = list(function(x) kdevm(x, x0=vs[[1]]),
          function(x) kdevm(x, x0=vs[[2]]),
          function(x) kdevm(x, x0=vs[[3]]))

# stacked density curves for 3 classes
cmdensity(fs)                         # 1:1:1
cmdensity(fs, prop)                   # using proportions for functions

</code></pre>


</div>