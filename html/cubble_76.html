<div class="container">

<table style="width: 100%;"><tr>
<td>arrange.temporal_cubble_df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<code>dplyr</code> methods</h2>

<h3>Description</h3>

<p>Verbs supported for both nested and long cubble include:
<code>dplyr::mutate()</code>, <code>dplyr::filter()</code>,  <code>dplyr::arrange()</code>, <code>dplyr::select()</code>,
<code>dplyr::group_by()</code>, <code>dplyr::ungroup()</code>, <code>dplyr::summarise()</code>,.
<code>dplyr::rename()</code>, <code>dplyr::bind_cols()</code>, <code>dplyr::rowwise()</code>,
<code>dplyr::slice_*()</code>, <code>dplyr::*_join()</code>, <code>dplyr::relocate()</code>,
<code>dplyr::pull()</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'temporal_cubble_df'
arrange(.data, ...)

## S3 method for class 'spatial_cubble_df'
select(.data, ...)

## S3 method for class 'temporal_cubble_df'
select(.data, ...)

## S3 method for class 'spatial_cubble_df'
group_by(.data, ..., .add, .drop)

## S3 method for class 'temporal_cubble_df'
group_by(.data, ..., .add, .drop)

## S3 method for class 'spatial_cubble_df'
ungroup(x, ...)

## S3 method for class 'temporal_cubble_df'
ungroup(x, ...)

## S3 method for class 'spatial_cubble_df'
summarise(.data, ..., .by = NULL, .groups = NULL)

## S3 method for class 'temporal_cubble_df'
summarise(.data, ..., .by = key_vars(.data), .groups = NULL)

## S3 method for class 'spatial_cubble_df'
rename(.data, ...)

## S3 method for class 'temporal_cubble_df'
rename(.data, ...)

bind_rows.temporal_cubble_df(..., .id = NULL)

bind_cols.spatial_cubble_df(..., .name_repair)

bind_cols.temporal_cubble_df(..., .name_repair)

## S3 method for class 'spatial_cubble_df'
rowwise(data, ...)

## S3 method for class 'temporal_cubble_df'
rowwise(data, ...)

## S3 method for class 'cubble_df'
dplyr_col_modify(data, cols)

## S3 method for class 'spatial_cubble_df'
dplyr_row_slice(data, i, ...)

## S3 method for class 'temporal_cubble_df'
dplyr_row_slice(data, i, ...)

## S3 method for class 'spatial_cubble_df'
dplyr_reconstruct(data, template)

## S3 method for class 'temporal_cubble_df'
dplyr_reconstruct(data, template)

## S3 method for class 'spatial_cubble_df'
mutate(.data, ...)

## S3 method for class 'temporal_cubble_df'
mutate(.data, ...)

## S3 method for class 'spatial_cubble_df'
filter(.data, ...)

## S3 method for class 'spatial_cubble_df'
arrange(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code>group_by_drop_default()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>tbl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>&lt;<code>tidy-select</code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code>group_by()</code>. For
details and examples, see ?dplyr_by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a> Grouping structure of the
result.
</p>

<ul>
<li>
<p> "drop_last": dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li>
<p> "drop": All levels of grouping are dropped.
</p>
</li>
<li>
<p> "keep": Same grouping structure as <code>.data</code>.
</p>
</li>
<li>
<p> "rowwise": Each row is its own group.
</p>
</li>
</ul>
<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li>
<p> If all the results have 1 row, you get "drop_last".
</p>
</li>
<li>
<p> If the number of rows varies, you get "keep" (note that returning a
variable number of rows was deprecated in favor of <code>reframe()</code>, which
also unconditionally drops all levels of grouping).
</p>
</li>
</ul>
<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option "dplyr.summarise.inform" is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.id</code></td>
<td>
<p>The name of an optional identifier column. Provide a string to
create an output column that identifies each input. The column will use
names if available, otherwise it will use positions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, or
<code>"check_unique"</code>. See <code>vctrs::vec_as_names()</code> for the meaning of these
options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, .data</code></td>
<td>
<p>a cubble object of class <code>spatial_cubble_df</code> or
<code>temporal_cubble_df</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>A named list used to modify columns. A <code>NULL</code> value should remove
an existing column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>A numeric or logical vector that indexes the rows of <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>template</code></td>
<td>
<p>Template data frame to use for restoring attributes.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You may find not all the verbs have a <code>verb.spatial_cubble_df</code> or
<code>verb.temporal_cubble_df</code> implemented. These verbs call
the dplyr extending trios: <code>dplyr_row_slice</code>, <code>dplyr_col_modify</code>,
and <code>dplyr_reconstruct</code> under the hood.
See https://dplyr.tidyverse.org/reference/dplyr_extending.html
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)
cb_nested &lt;- climate_mel
cb_long &lt;- face_temporal(climate_mel)

# filter - currently filter.spatial_cubble_df, dply_row_slice
cb_nested |&gt; filter(elev &gt; 40)
cb_long |&gt; filter(prcp &gt; 0)

# mutate - curerntly mutate.spatial_cubble_df, dply_col_modify
cb_nested |&gt; mutate(elev2 = elev + 10)
cb_long |&gt; mutate(prcp2 = prcp + 10)

# arrange - currently arrange.spatial_cubble_df, arrange.temporal_cubble_df
cb_nested |&gt; arrange(wmo_id)
cb_long |&gt; arrange(prcp)

# summarise - summarise.spatial_cubble_df,  summarise.temporal_cubble_df
cb_long |&gt;
  group_by(first_5 = ifelse(lubridate::day(date) &lt;=5, 1, 2 )) |&gt;
  summarise(tmax = mean(tmax))
cb_long |&gt;
  mutate(first_5 = ifelse(lubridate::day(date) &lt;=5, 1, 2)) |&gt;
  summarise(t = mean(tmax), .by = first_5)

# select -  select.spatial_cubble_df,  select.temporal_cubble_df
cb_nested |&gt; select(name)
cb_nested |&gt; select(-id, -name)
cb_long |&gt; select(prcp)
cb_long |&gt; select(-prcp, -date)

# rename - rename.spatial_cubble_df, rename.temporal_cubble_df
cb_nested |&gt; rename(elev2 = elev)
cb_long |&gt; rename(prcp2 = prcp)
# rename on key attributes
cb_nested |&gt; rename(id2 = id)
cb_long |&gt; rename(date2 = date)

# join - mutate_join - dplyr_reconstruct()
# join - filter_join - dplyr_row_slice()
df1 &lt;- cb_nested |&gt; as_tibble() |&gt; select(id, name) |&gt; head(2)
nested &lt;- cb_nested |&gt; select(-name)
nested |&gt; left_join(df1, by = "id")
nested |&gt; right_join(df1, by = "id")
nested |&gt; inner_join(df1, by = "id")
nested |&gt; full_join(df1, by = "id")
nested |&gt; anti_join(df1, by = "id")

# bind_rows - dplyr_reconstruct, bind_rows.temporal_cubble_df
df1 &lt;- cb_nested |&gt; head(1)
df2 &lt;- cb_nested |&gt; tail(2)
bind_rows(df1, df2)
df1 &lt;- cb_long |&gt; head(10)
df2 &lt;- cb_long |&gt; tail(20)
bind_rows(df1, df2)

# relocate - dplyr_col_select, dplyr_col_select
cb_nested |&gt; relocate(ts, .before = name)
cb_nested |&gt; face_temporal() |&gt; relocate(tmin)

# slice - all the slice_* uses dplyr::slice(), which uses dplyr_row_slice()
cb_nested |&gt; slice_head(n = 2)
cb_nested |&gt; slice_tail(n = 2)
cb_nested |&gt; slice_max(elev)
cb_nested |&gt; slice_min(elev)
cb_nested |&gt; slice_sample(n = 2)

# rowwise - rowwise.spatial_cubble_df, rowwise.temporal_cuble_df
cb_nested |&gt; rowwise()
cb_long |&gt; rowwise()

# group_by &amp; ungroup -
(res &lt;- cb_nested |&gt; mutate(group1 = c(1, 1, 2)) |&gt; group_by(group1))
res |&gt; ungroup()
(res2 &lt;- res |&gt; face_temporal())
res2 |&gt; ungroup()
res2 |&gt; mutate(first_5 = ifelse(lubridate::day(date) &lt;= 5, 1, 6)) |&gt;
  group_by(first_5)
</code></pre>


</div>