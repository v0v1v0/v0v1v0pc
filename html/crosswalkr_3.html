<div class="container">

<table style="width: 100%;"><tr>
<td>encodefrom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Encode data frame column using external crosswalk file.</h2>

<h3>Description</h3>

<p>Encode data frame column using external crosswalk file.
</p>


<h3>Usage</h3>

<pre><code class="language-R">encodefrom(
  .data,
  var,
  cw_file,
  raw,
  clean,
  label,
  delimiter = NULL,
  sheet = NULL,
  case_ignore = TRUE,
  ignore_tibble = FALSE
)

encodefrom_(
  .data,
  var,
  cw_file,
  raw,
  clean,
  label,
  delimiter = NULL,
  sheet = NULL,
  case_ignore = TRUE,
  ignore_tibble = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>Data frame or tbl_df</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>Column name of vector to be encoded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cw_file</code></td>
<td>
<p>Either data frame object or string with path to
external crosswalk file, including path, which has columns
representing <code>raw</code> (current) vector values, <code>clean</code>
(new) vector values, and <code>label</code>s for values. Values in
<code>raw</code> and <code>clean</code> columns must be unique (1:1 match)
or an error will be thrown. Acceptable file types include:
delimited (.csv, .tsv, or other), R (.rda, .rdata, .rds), or
Stata (.dta).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>Name of column in <code>cw_file</code> that contains values in
current vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean</code></td>
<td>
<p>Name of column in <code>cw_file</code> that contains new
values for vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>Name of column in <code>cw_file</code> with labels for new
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delimiter</code></td>
<td>
<p>String delimiter used to parse
<code>cw_file</code>. Only necessary if using a delimited file that
isn't a comma-separated or tab-separated file (guessed by
function based on file ending).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sheet</code></td>
<td>
<p>Specify sheet if <code>cw_file</code> is an Excel file and
required sheet isn't the first one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case_ignore</code></td>
<td>
<p>Ignore case when matching current (<code>raw</code>)
vector name with new (<code>clean</code>) column name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_tibble</code></td>
<td>
<p>Ignore <code>.data</code> status as tbl_df and
return vector as a factor rather than labelled vector.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Vector that is either a factor or labelled, depending on
data input and options
</p>


<h3>Functions</h3>


<ul><li> <p><code>encodefrom_</code>: Standard evaluation version of
<code>encodefrom</code> (<code>var</code>, <code>raw</code>, <code>clean</code>,
and <code>label</code> must be strings when using this version)
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">df &lt;- data.frame(state = c('Kentucky','Tennessee','Virginia'),
                 stfips = c(21,47,51),
                 cenregnm = c('South','South','South'))

df_tbl &lt;- tibble::as_tibble(df)

cw &lt;- get(data(stcrosswalk))

df$state2 &lt;- encodefrom(df, state, cw, stname, stfips, stabbr)
df_tbl$state2 &lt;- encodefrom(df_tbl, state, cw, stname, stfips, stabbr)
df_tbl$state3 &lt;- encodefrom(df_tbl, state, cw, stname, stfips, stabbr,
                            ignore_tibble = TRUE)

haven::as_factor(df_tbl)
haven::zap_labels(df_tbl)
</code></pre>


</div>