<div class="container">

<table style="width: 100%;"><tr>
<td>cv.isb.splsdrcox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross validation cv.isb.splsdrcox</h2>

<h3>Description</h3>

<p>This function performs cross-validated sparse partial least squares iterative single
block for splsdrcox. The function returns the optimal number of components and the optimal sparsity
penalty value based on cross-validation. The performance could be based on multiple metrics as
Area Under the Curve (AUC), Brier Score or C-Index. Furthermore, the user could establish more
than one metric simultaneously.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.isb.splsdrcox(
  X,
  Y,
  max.ncomp = 8,
  penalty.list = seq(0.1, 0.9, 0.2),
  n_run = 3,
  k_folds = 10,
  x.center = TRUE,
  x.scale = FALSE,
  remove_near_zero_variance = TRUE,
  remove_zero_variance = TRUE,
  toKeep.zv = NULL,
  remove_variance_at_fold_level = FALSE,
  remove_non_significant_models = FALSE,
  remove_non_significant = FALSE,
  alpha = 0.05,
  w_AIC = 0,
  w_c.index = 0,
  w_AUC = 1,
  w_BRIER = 0,
  times = NULL,
  max_time_points = 15,
  MIN_AUC_INCREASE = 0.01,
  MIN_AUC = 0.8,
  MIN_COMP_TO_CHECK = 3,
  pred.attr = "mean",
  pred.method = "cenROC",
  fast_mode = FALSE,
  MIN_EPV = 5,
  returnData = TRUE,
  return_models = FALSE,
  PARALLEL = FALSE,
  verbose = FALSE,
  seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix or data.frame. Explanatory variables. Qualitative variables must be
transform into binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric matrix or data.frame. Response variables. Object must have two columns named as
"time" and "event". For event column, accepted values are: 0/1 or FALSE/TRUE for censored and
event observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.ncomp</code></td>
<td>
<p>Numeric. Maximum number of PLS components to compute for the cross validation
(default: 8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.list</code></td>
<td>
<p>Numeric vector. Vector of penalty values. Penalty for sPLS-DRCOX. If
penalty = 0 no penalty is applied, when penalty = 1 maximum penalty (no variables are selected)
based on 'plsRcox' penalty. Equal or greater than 1 cannot be selected (default: seq(0.1,0.9,0.2)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_run</code></td>
<td>
<p>Numeric. Number of runs for cross validation (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_folds</code></td>
<td>
<p>Numeric. Number of folds for cross validation (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.center</code></td>
<td>
<p>Logical. If x.center = TRUE, X matrix is centered to zero means (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.scale</code></td>
<td>
<p>Logical. If x.scale = TRUE, X matrix is scaled to unit variances (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_near_zero_variance</code></td>
<td>
<p>Logical. If remove_near_zero_variance = TRUE, near zero variance
variables will be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_zero_variance</code></td>
<td>
<p>Logical. If remove_zero_variance = TRUE, zero variance variables will
be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toKeep.zv</code></td>
<td>
<p>Character vector. Name of variables in X to not be deleted by (near) zero variance
filtering (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_variance_at_fold_level</code></td>
<td>
<p>Logical. If remove_variance_at_fold_level = TRUE, (near) zero
variance will be removed at fold level (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant_models</code></td>
<td>
<p>Logical. If remove_non_significant_models = TRUE,
non-significant models are removed before computing the evaluation. A non-significant model is a
model with at least one component/variable with a P-Value higher than the alpha cutoff.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant</code></td>
<td>
<p>Logical. If remove_non_significant = TRUE, non-significant
variables/components in final cox model will be removed until all variables are significant by
forward selection (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Numerical values are regarded as significant if they fall below the
threshold (default: 0.05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_AIC</code></td>
<td>
<p>Numeric. Weight for AIC evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_c.index</code></td>
<td>
<p>Numeric. Weight for C-Index evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_AUC</code></td>
<td>
<p>Numeric. Weight for AUC evaluator. All weights must sum 1 (default: 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_BRIER</code></td>
<td>
<p>Numeric. Weight for BRIER SCORE evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of
'max_time_points' points will be selected equally distributed (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time_points</code></td>
<td>
<p>Numeric. Maximum number of time points to use for evaluating the model
(default: 15).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC_INCREASE</code></td>
<td>
<p>Numeric. Minimum improvement between different cross validation models to
continue evaluating higher values in the multiple tested parameters. If it is not reached for next
'MIN_COMP_TO_CHECK' models and the minimum 'MIN_AUC' value is reached, the evaluation stops
(default: 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC</code></td>
<td>
<p>Numeric. Minimum AUC desire to reach cross-validation models. If the minimum is
reached, the evaluation could stop if the improvement does not reach an AUC higher than adding
the 'MIN_AUC_INCREASE' value (default: 0.8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_COMP_TO_CHECK</code></td>
<td>
<p>Numeric. Number of penalties/components to evaluate to check if the AUC
improves. If for the next 'MIN_COMP_TO_CHECK' the AUC is not better and the 'MIN_AUC' is meet,
the evaluation could stop (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.attr</code></td>
<td>
<p>Character. Way to evaluate the metric selected. Must be one of the following:
"mean" or "median" (default: "mean").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.method</code></td>
<td>
<p>Character. AUC evaluation algorithm method for evaluate the model performance.
Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C",
"smoothROCtime_I" (default: "cenROC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast_mode</code></td>
<td>
<p>Logical. If fast_mode = TRUE, for each run, only one fold is evaluated
simultaneously. If fast_mode = FALSE, for each run, all linear predictors are computed for test
observations. Once all have their linear predictors, the evaluation is perform across all the
observations together (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_EPV</code></td>
<td>
<p>Numeric. Minimum number of Events Per Variable (EPV) you want reach for the final
cox model. Used to restrict the number of variables/components can be computed in final cox models.
If the minimum is not meet, the model cannot be computed (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnData</code></td>
<td>
<p>Logical. Return original and normalized X and Y matrices (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_models</code></td>
<td>
<p>Logical. Return all models computed in cross validation (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PARALLEL</code></td>
<td>
<p>Logical. Run the cross validation with multicore option. As many cores as your
total cores - 1 will be used. It could lead to higher RAM consumption (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Number. Seed value for performing runs/folds divisions (default: 123).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>cv.isb.splsdrcox</code> function performs cross-validation for the integrative single-block sparse
partial least squares deviance residual Cox analysis. Unlike the single-block (SB) approach, the
integrative single-block (ISB) method allows for the consideration of multiple blocks of data,
potentially from different sources or types, to be integrated into a single model. A key distinction
of the ISB approach is its ability to compute and optimize hyperparameters individually for each
block, rather than applying a uniform set of hyperparameters across all blocks. This ensures that
each block's unique characteristics are taken into account, leading to a more tailored and
potentially more accurate model.
</p>
<p>Cross-validation is essential for assessing the generalizability of the model and avoiding
overfitting. By partitioning the original dataset into training and test sets multiple times, the
function evaluates the model's performance across different subsets of the data. This iterative
process ensures that the model's performance is robust and not overly reliant on a specific
partition of the data.
</p>
<p>The function evaluates a range of hyperparameters, including the number of latent components
(<code>max.ncomp</code>) and the penalty for variable selection (<code>penalty.list</code>). For each combination of
hyperparameters, the dataset is divided into training and test sets based on the specified number
of folds (<code>k_folds</code>). The model is then trained on the training set and its performance is assessed
on the test set. This process is repeated for the specified number of runs (<code>n_run</code>), providing a
comprehensive evaluation of the model's performance.
</p>
<p>Various evaluation metrics, such as AIC, C-Index, Brier Score, and AUC, are computed for each
combination of hyperparameters. These metrics provide insights into the model's accuracy,
discriminative ability, and calibration. The function then identifies the optimal hyperparameters
that yield the best performance based on these metrics.
</p>
<p>In summary, the <code>cv.isb.splsdrcox</code> function offers a robust and integrative approach for
hyperparameter tuning and model evaluation for the sparse partial least squares deviance residual
Cox analysis. By allowing individualized hyperparameter optimization for each block, the ISB
approach ensures a more nuanced and potentially more accurate model compared to the traditional
SB method.
</p>


<h3>Value</h3>

<p>Instance of class "Coxmos" and model "sb.splscox". The class contains the following
elements:
<code>X</code>: List of normalized X data information.
</p>

<ul>
<li> <p><code>(data)</code>: normalized X matrix
</p>
</li>
<li> <p><code>(weightings)</code>: PLS weights
</p>
</li>
<li> <p><code>(weightings_norm)</code>: PLS normalize weights
</p>
</li>
<li> <p><code>(W.star)</code>: PLS W* vector
</p>
</li>
<li> <p><code>(scores)</code>: PLS scores/variates
</p>
</li>
<li> <p><code>(x.mean)</code>: mean values for X matrix
</p>
</li>
<li> <p><code>(x.sd)</code>: standard deviation for X matrix
</p>
</li>
</ul>
<p><code>Y</code>: List of normalized Y data information.
</p>

<ul>
<li> <p><code>(deviance_residuals)</code>: deviance residual vector used as Y matrix in the sPLS.
</p>
</li>
<li> <p><code>(dr.mean)</code>: mean values for deviance residuals Y matrix
</p>
</li>
<li> <p><code>(dr.sd)</code>: standard deviation for deviance residuals Y matrix'
</p>
</li>
<li> <p><code>(data)</code>: normalized X matrix
</p>
</li>
<li> <p><code>(y.mean)</code>: mean values for Y matrix
</p>
</li>
<li> <p><code>(y.sd)</code>: standard deviation for Y matrix'
</p>
</li>
</ul>
<p><code>survival_model</code>: List of survival model information.
</p>

<ul>
<li> <p><code>fit</code>: coxph object.
</p>
</li>
<li> <p><code>AIC</code>: AIC of cox model.
</p>
</li>
<li> <p><code>BIC</code>: BIC of cox model.
</p>
</li>
<li> <p><code>lp</code>: linear predictors for train data.
</p>
</li>
<li> <p><code>coef</code>: Coefficients for cox model.
</p>
</li>
<li> <p><code>YChapeau</code>: Y Chapeau residuals.
</p>
</li>
<li> <p><code>Yresidus</code>: Y residuals.
</p>
</li>
</ul>
<p><code>list_spls_models</code>: List of sPLS-DRCOX models computed for each block.
</p>
<p><code>n.comp</code>: Number of components selected.
</p>
<p><code>penalty</code> Penalty applied.
</p>
<p><code>call</code>: call function
</p>
<p><code>X_input</code>: X input matrix
</p>
<p><code>Y_input</code>: Y input matrix
</p>
<p><code>nzv</code>: Variables removed by remove_near_zero_variance or remove_zero_variance.
</p>
<p><code>nz_coeffvar</code>: Variables removed by coefficient variation near zero.
</p>
<p><code>class</code>: Model class.
</p>
<p><code>time</code>: time consumed for running the cox analysis.
</p>


<h3>Author(s)</h3>

<p>Pedro Salguero Garcia. Maintainer: pedsalga@upv.edu.es
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("X_multiomic")
data("Y_multiomic")
set.seed(123)
index_train &lt;- caret::createDataPartition(Y_multiomic$event, p = .5, list = FALSE, times = 1)
X_train &lt;- X_multiomic
X_train$mirna &lt;- X_train$mirna[index_train,1:50]
X_train$proteomic &lt;- X_train$proteomic[index_train,1:50]
Y_train &lt;- Y_multiomic[index_train,]
isb.splsdrcox_model &lt;- cv.isb.splsdrcox(X_train, Y_train, max.ncomp = 2, penalty.list = c(0.5),
n_run = 1, k_folds = 2, x.center = TRUE, x.scale = TRUE)
</code></pre>


</div>