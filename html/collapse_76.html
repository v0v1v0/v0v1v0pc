<div class="container">

<table style="width: 100%;"><tr>
<td>get_elem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find and Extract / Subset List Elements</h2>

<h3>Description</h3>

<p>A suite of functions to subset or extract from (potentially complex) lists and list-like structures. Subsetting may occur according to certain data types, using identifier functions, element names or regular expressions to search the list for certain objects.
</p>

<ul>
<li> <p><code>atomic_elem</code> and <code>list_elem</code> are non-recursive functions to extract and replace the atomic and sub-list elements at the top-level of the list tree.
</p>
</li>
<li> <p><code>reg_elem</code> is the recursive equivalent of <code>atomic_elem</code> and returns the 'regular' part of the list - with atomic elements in the final nodes. <code>irreg_elem</code> returns all the non-regular elements (i.e. call and terms objects, formulas, etc...). See Examples.
</p>
</li>
<li> <p><code>get_elem</code> returns the part of the list responding to either an identifier function, regular expression, exact element names or indices applied to all final objects. <code>has_elem</code> checks for the existence of an element and returns <code>TRUE</code> if a match is found. See Examples.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">## Non-recursive (top-level) subsetting and replacing
atomic_elem(l, return = "sublist", keep.class = FALSE)
atomic_elem(l) &lt;- value
list_elem(l, return = "sublist", keep.class = FALSE)
list_elem(l) &lt;- value

## Recursive separation of regular (atomic) and irregular (non-atomic) parts
reg_elem(l, recursive = TRUE, keep.tree = FALSE, keep.class = FALSE)
irreg_elem(l, recursive = TRUE, keep.tree = FALSE, keep.class = FALSE)

## Extract elements / subset list tree
get_elem(l, elem, recursive = TRUE, DF.as.list = FALSE, keep.tree = FALSE,
         keep.class = FALSE, regex = FALSE, invert = FALSE, ...)

## Check for the existence of elements
has_elem(l, elem, recursive = TRUE, DF.as.list = FALSE, regex = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>a list of the same length as the extracted subset of <code>l</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elem</code></td>
<td>
<p>a function returning <code>TRUE</code> or <code>FALSE</code> when applied to elements of <code>l</code>, or a character vector of element names or regular expressions (if <code>regex = TRUE</code>). <code>get_elem</code> also supports a vector or indices which will be used to subset all final objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p>an integer or string specifying what the selector function should return. The options are:
</p>

<table>
<tr>
<td style="text-align: left;">
<em> Int. </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> String </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
<td style="text-align: left;">
                 1 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "sublist"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> subset of list (default) </td>
</tr>
<tr>
<td style="text-align: left;">
                 2 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "names" </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> column names </td>
</tr>
<tr>
<td style="text-align: left;">
                 3 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "indices"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> column indices </td>
</tr>
<tr>
<td style="text-align: left;">
                 4 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "named_indices"  </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> named column indices </td>
</tr>
<tr>
<td style="text-align: left;">
                 5 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "logical"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> logical selection vector </td>
</tr>
<tr>
<td style="text-align: left;">
                 6 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "named_logical"     </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> named logical vector </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p><em>Note</em>: replacement functions only replace data, names are replaced together with the data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>logical. Should the list search be recursive (i.e. go though all the elements), or just at the top-level?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DF.as.list</code></td>
<td>
<p>logical. <code>TRUE</code> treats data frames like (sub-)lists; <code>FALSE</code> like atomic elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.tree</code></td>
<td>
<p>logical. <code>TRUE</code> always returns the entire list tree leading up to all matched results, while <code>FALSE</code> drops the top-level part of the tree if possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.class</code></td>
<td>
<p>logical. For list-based objects: should the class be retained? This only works if these objects have a <code>[</code> method that retains the class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>logical. Should regular expression search be used on the list names, or only exact matches?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>logical. Invert search i.e. exclude matched elements from the list?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to <code>grep</code> (if <code>regex = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a lack of better terminology, <em>collapse</em> defines 'regular' R objects as objects that are either atomic or a list. <code>reg_elem</code> with <code>recursive = TRUE</code> extracts the subset of the list tree leading up to atomic elements in the final nodes. This part of the list tree is unlistable - calling <code>is_unlistable(reg_elem(l))</code> will be <code>TRUE</code> for all lists <code>l</code>. Conversely, all elements left behind by <code>reg_elem</code> will be picked up be <code>irreg_elem</code>. Thus <code>is_unlistable(irreg_elem(l))</code> is always <code>FALSE</code> for lists with irregular elements (otherwise <code>irreg_elem</code> returns an empty list). <br></p>
<p>If <code>keep.tree = TRUE</code>, <code>reg_elem</code>, <code>irreg_elem</code> and <code>get_elem</code> always return the entire list tree, but cut off all of the branches not leading to the desired result. If <code>keep.tree = FALSE</code>, top-level parts of the tree are omitted as far as possible. For example in a nested list with three levels and one data-matrix in one of the final branches, <code>get_elem(l, is.matrix, keep.tree = TRUE)</code> will return a list (<code>lres</code>) of depth 3, from which the matrix can be accessed as <code>lres[[1]][[1]][[1]]</code>. This however does not make much sense. <code>get_elem(l, is.matrix, keep.tree = FALSE)</code> will therefore figgure out that it can drop the entire tree and return just the matrix. <code>keep.tree = FALSE</code> makes additional optimizations if matching elements are at far-apart corners in a nested structure, by only preserving the hierarchy if elements are above each other on the same branch. Thus for a list <code>l &lt;- list(list(2,list("a",1)),list(1,list("b",2)))</code> calling <code>get_elem(l, is.character)</code> will just return <code>list("a","b")</code>.
</p>


<h3>See Also</h3>

<p>List Processing, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">m &lt;- qM(mtcars)
get_elem(list(list(list(m))), is.matrix)
get_elem(list(list(list(m))), is.matrix, keep.tree = TRUE)

l &lt;- list(list(2,list("a",1)),list(1,list("b",2)))
has_elem(l, is.logical)
has_elem(l, is.numeric)
get_elem(l, is.character)
get_elem(l, is.character, keep.tree = TRUE)

l &lt;- lm(mpg ~ cyl + vs, data = mtcars)
str(reg_elem(l))
str(irreg_elem(l))
get_elem(l, is.matrix)
get_elem(l, "residuals")
get_elem(l, "fit", regex = TRUE)
has_elem(l, "tol")
get_elem(l, "tol")

</code></pre>


</div>