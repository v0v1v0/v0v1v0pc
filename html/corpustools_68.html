<div class="container">

<table style="width: 100%;"><tr>
<td>search_dictionary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dictionary lookup</h2>

<h3>Description</h3>

<p>Similar to search_features, but for fast matching of large dictionaries.
</p>


<h3>Usage</h3>

<pre><code class="language-R">search_dictionary(
  tc,
  dict,
  token_col = "token",
  string_col = "string",
  code_col = "code",
  sep = " ",
  mode = c("unique_hits", "features"),
  case_sensitive = F,
  use_wildcards = T,
  ascii = F,
  verbose = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tc</code></td>
<td>
<p>A tCorpus</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dict</code></td>
<td>
<p>A dictionary. Can be either a data.frame or a quanteda dictionary. If a data.frame is given, it has to
have a column named "string"  (or use string_col argument) that contains the dictionary terms, and a column "code" (or use code_col argument) that contains the
label/code represented by this string. Each row has a single string, that can be
a single word or a sequence of words seperated by a whitespace (e.g., "not bad"), and can have the common ? and * wildcards.
If a quanteda dictionary is given, it is automatically converted to this type of data.frame with the
<code>melt_quanteda_dict</code> function. This can be done manually for more control over labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token_col</code></td>
<td>
<p>The feature in tc that contains the token text.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>string_col</code></td>
<td>
<p>If dict is a data.frame, the name of the column in dict with the dictionary lookup string. Default is "string"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code_col</code></td>
<td>
<p>The name of the column in dict with the dictionary code/label. Default is "code".
If dict is a quanteda dictionary with multiple levels, "code_l2", "code_l3", etc. can be used to select levels..</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>A regular expression for separating multi-word lookup strings (default is " ", which is what quanteda dictionaries use).
For example, if the dictionary contains "Barack Obama", sep should be " " so that it matches the consequtive tokens "Barack" and "Obama".
In some dictionaries, however, it might say "Barack+Obama", so in that case sep = '\\+' should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>There are two modes: "unique_hits" and "features". The "unique_hits" mode prioritizes finding unique matches, which is recommended for counting how often a dictionary term occurs.
If a term matches multiple dictionary terms (which should only happen for nested multi-word terms, such as "bad" and "not bad"), the longest term is always used. 
The features mode does not delete duplicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case_sensitive</code></td>
<td>
<p>logical, should lookup be case sensitive?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_wildcards</code></td>
<td>
<p>Use the wildcards * (any number including none of any character) and ? (one or none of any character). If FALSE, exact string matching is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ascii</code></td>
<td>
<p>If true, convert text to ascii before matching</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If true, report progress</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector with the id value (taken from dict$id) for each row in tc$tokens
</p>


<h3>Examples</h3>

<pre><code class="language-R">dict = data.frame(string = c('this is', 'for a', 'not big enough'), code=c('a','c','b'))
tc = create_tcorpus(c('this is a test','This town is not big enough for a test'))
search_dictionary(tc, dict)$hits
</code></pre>


</div>