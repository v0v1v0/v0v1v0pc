<div class="container">

<table style="width: 100%;"><tr>
<td>sim_ame</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute average marginal effects</h2>

<h3>Description</h3>

<p><code>sim_ame()</code> is a wrapper for <code>sim_apply()</code> that computes average
marginal effects, the average effect of changing a single variable from one
value to another (i.e., from one category to another for categorical
variables or a tiny change for continuous variables).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_ame(
  sim,
  var,
  subset = NULL,
  by = NULL,
  contrast = NULL,
  outcome = NULL,
  type = NULL,
  eps = 1e-05,
  verbose = TRUE,
  cl = NULL
)

## S3 method for class 'clarify_ame'
print(x, digits = NULL, max.ests = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>a <code>clarify_sim</code> object; the output of a call to <code>sim()</code> or
<code>misim()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>either the names of the variables for which marginal effects are
to be computed or a named list containing the values the variables should
take. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>optional; a vector used to subset the data used to compute the
marginal effects. This will be evaluated within the original dataset used
to fit the model using <code>subset()</code>, so nonstandard evaluation is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>a one-sided formula or character vector containing the names of
variables for which to stratify the estimates. Each quantity will be
computed within each level of the complete cross of the variables specified
in <code>by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>
<p>a string containing the name of a contrast between the
average marginal means when the variable named in <code>var</code> is categorical and
takes on two values. Allowed options include <code>"diff"</code> for the difference in
means (also <code>"rd"</code>), <code>"rr"</code> for the risk ratio (also <code>"irr"</code>), <code style="white-space: pre;">⁠"log(rr):⁠</code>
for the log risk ratio (also <code>"log(irr)"</code>), <code>"sr"</code> for the survival ratio,
<code style="white-space: pre;">⁠"log(sr):⁠</code> for the log survival ratio, <code>"srr"</code> for the switch relative
risk (also <code>"grrr"</code>), <code>"or"</code> for the odds ratio, <code>"log(or)"</code> for the log
odds ratio, and <code>"nnt"</code> for the number needed to treat. These options are
not case sensitive, but the parentheses must be included if present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>
<p>a string containing the name of the outcome or outcome level
for multivariate (multiple outcomes) or multi-category outcomes. Ignored
for univariate (single outcome) and binary outcomes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a string containing the type of predicted values (e.g., the link
or the response). Passed to <code>marginaleffects::get_predict()</code> and eventually
to <code>predict()</code> in most cases. The default and allowable option depend on
the type of model supplied, but almost always corresponds to the response
scale (e.g., predicted probabilities for binomial models).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>when the variable named in <code>var</code> is continuous, the value by which
to change the variable values to approximate the derivative. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>; whether to display a text progress bar indicating
progress and estimated time remaining for the procedure. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a cluster object created by <code>parallel::makeCluster()</code>, or an
integer to indicate the number of child-processes (integer values are
ignored on Windows) for parallel evaluations. See <code>pbapply::pblapply()</code> for
details. If <code>NULL</code>, no parallelization will take place.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>clarify_ame</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the minimum number of significant digits to be used; passed to <code>print.data.frame()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.ests</code></td>
<td>
<p>the maximum number of estimates to display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments passed to <code>FUN</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sim_ame()</code> computes average adjusted predictions or average marginal effects depending on which variables are named in <code>var</code> and how they are specified. Canonically, <code>var</code> should be specified as a named list with the value(s) each variable should be set to. For example, specifying <code>var = list(x1 = 0:1)</code> computes average adjusted predictions setting <code>x1</code> to 0 and 1. Specifying a variable's values as <code>NULL</code>, e.g., <code>list(x1 = NULL)</code>, is equivalent to requesting average adjusted predictions at each unique value of the variable when that variable is binary or a factor or character and requests the average marginal effect of that variable otherwise. Specifying an unnamed entry in the list with a string containing the value of that variable, e.g., <code>list("x1")</code> is equivalent to specifying <code>list(x1 = NULL)</code>. Similarly, supplying a vector with the names of the variables is equivalent to specifying a list, e.g., <code>var = "x1"</code> is equivalent to <code>var = list(x1 = NULL)</code>.
</p>
<p>Multiple variables can be supplied to <code>var</code> at the same time to set the corresponding variables to those values. If all values are specified directly or the variables are categorical, e.g., <code>list(x1 = 0:1, x2 = c(5, 10))</code>, this computes average adjusted predictions at each combination of the supplied variables. If any one variable's values is specified as <code>NULL</code> and the variable is continuous, the average marginal effect of that variable will be computed with the other variables set to their corresponding combinations. For example, if <code>x2</code> is a continuous variable, specifying <code>var = list(x1 = 0:1, x2 = NULL)</code> requests the average marginal effect of <code>x2</code> computed first setting <code>x1</code> to 0 and then setting <code>x1</code> to 1. The average marginal effect can only be computed for one variable at a time.
</p>
<p>Below are some examples of specifications and what they request, assuming <code>x1</code> is a binary variable taking on values of 0 and 1 and <code>x2</code> is a continuous variable:
</p>

<ul>
<li> <p><code>list(x1 = 0:1)</code>, <code>list(x1 = NULL)</code>, <code>list("x1")</code>, <code>"x1"</code> – the average adjusted predictions setting <code>x1</code> to 0 and to 1
</p>
</li>
<li> <p><code>list(x2 = NULL)</code>, <code>list("x2")</code>, <code>"x2"</code> – the average marginal effect of <code>x2</code>
</p>
</li>
<li> <p><code>list(x2 = c(5, 10))</code> – the average adjusted predictions setting <code>x2</code> to 5 and to 10
</p>
</li>
<li> <p><code>list(x1 = 0:1, x2 = c(5, 10))</code>, <code>list("x1", x2 = c(5, 10))</code> – the average adjusted predictions setting <code>x1</code> and <code>x2</code> in a full cross of 0, 1 and 5, 10, respectively (e.g., (0, 5), (0, 10), (1, 5), and (1, 10))
</p>
</li>
<li> <p><code>list(x1 = 0:1, "x2")</code>, <code>list("x1", "x2")</code>, <code>c("x1", "x2")</code> – the average marginal effects of <code>x2</code> setting <code>x1</code> to 0 and to 1
</p>
</li>
</ul>
<p>The average adjusted prediction is the average predicted outcome
value after setting all units' value of a variable to a specified level. (This quantity
has several names, including the average potential outcome, average marginal mean, and standardized mean). When exactly two average adjusted predictions are requested, a contrast
between them can be requested by supplying an argument
to <code>contrast</code> (see Effect Measures section below). Contrasts can be manually computed using <code>transform()</code>
afterward as well; this is required when multiple average adjusted predictions are requested (i.e., because a single variable was supplied to <code>var</code> with more than two levels or a combination of multiple variables was supplied).
</p>
<p>A marginal effect is the instantaneous rate of change
corresponding to changing a unit's observed value of a variable by a tiny amount
and considering to what degree the predicted outcome changes. The ratio of
the change in the predicted outcome to the change in the value of the variable is
the marginal effect; these are averaged across the sample to arrive at an
average marginal effect. The "tiny amount" used is <code>eps</code> times the standard
deviation of the focal variable.
</p>
<p>The difference between using <code>by</code> or <code>subset</code> vs. <code>var</code> is that <code>by</code> and <code>subset</code> subset the data when computing the requested quantity, whereas <code>var</code> sets the corresponding variable to given a value for all units. For example, using <code>by = ~v</code> computes the quantity of interest separately for each subset of the data defined by <code>v</code>, whereas setting <code>var = list(., "v")</code> computes the quantity of interest for all units setting their value of <code>v</code> to its unique values. The resulting quantities have different interpretations. Both <code>by</code> and <code>var</code> can be used simultaneously.
</p>


<h4>Effect measures</h4>

<p>The effect measures specified in <code>contrast</code> are defined below. Typically only
<code>"diff"</code> is appropriate for continuous outcomes and <code>"diff"</code> or <code>"irr"</code> are
appropriate for count outcomes; the rest are appropriate for binary outcomes.
For a focal variable with two levels, <code>0</code> and <code>1</code>, and an outcome <code>Y</code>, the
average marginal means will be denoted in the below formulas as <code>E[Y(0)]</code> and
<code>E[Y(1)]</code>, respectively.</p>

<table>
<tr>
<td style="text-align: left;">
   <code>contrast</code> </td>
<td style="text-align: left;"> <strong>Description</strong> </td>
<td style="text-align: left;"> <strong>Formula</strong> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"diff"</code>/<code>"rd"</code> </td>
<td style="text-align: left;"> Mean/risk difference </td>
<td style="text-align: left;"> <code>E[Y(1)] - E[Y(0)]</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"rr"</code>/<code>"irr"</code> </td>
<td style="text-align: left;"> Risk ratio/incidence rate ratio </td>
<td style="text-align: left;"> <code>E[Y(1)] / E[Y(0)]</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"sr"</code> </td>
<td style="text-align: left;"> Survival ratio </td>
<td style="text-align: left;"> <code>(1 - E[Y(1)]) / (1 - E[Y(0)])</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"srr"</code>/<code>"grrr"</code> </td>
<td style="text-align: left;"> Switch risk ratio </td>
<td style="text-align: left;"> <code>1 - sr</code> if <code>E[Y(1)] &gt; E[Y(0)]</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">  </td>
<td style="text-align: left;"> <code>rr - 1</code> if <code>E[Y(1)] &lt; E[Y(0)]</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">  </td>
<td style="text-align: left;"> <code>0</code> otherwise </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"or"</code> </td>
<td style="text-align: left;"> Odds ratio </td>
<td style="text-align: left;"> <code>O[Y(1)] / O[Y(0)]</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">  </td>
<td style="text-align: left;"> where <code>O[Y(.)]</code> = <code>E[Y(.)] / (1 - E[Y(.)])</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"nnt"</code> </td>
<td style="text-align: left;"> Number needed to treat </td>
<td style="text-align: left;"> <code>1 / rd</code> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The <code>log(.)</code> versions are defined by taking the <code>log()</code> (natural log) of the
corresponding effect measure.
</p>



<h3>Value</h3>

<p>A <code>clarify_ame</code> object, which inherits from <code>clarify_est</code> and is
similar to the output of <code>sim_apply()</code>, with the additional attributes
<code>"var"</code> containing the variable values specified in <code>var</code> and <code>"by"</code> containing the
names of the variables specified in <code>by</code> (if any). The average adjusted
predictions will be named <code>E[Y({v})]</code>, where <code>{v}</code> is replaced with the
values the variables named in <code>var</code> take on. The average marginal effect for a
continuous <code>var</code> will be named <code>E[dY/d({x})]</code> where <code>{x}</code> is replaced with
<code>var</code>. When <code>by</code> is specified, the average adjusted predictions will be named
<code>E[Y({v})|{b}]</code> and the average marginal effect <code>E[dY/d({x})|{b}]</code> where
<code>{b}</code> is a comma-separated list of of values of the <code>by</code> variables at which
the quantity is computed. See examples.
</p>


<h3>See Also</h3>

<p><code>sim_apply()</code>, which provides a general interface to computing any
quantities for simulation-based inference; <code>plot.clarify_est()</code> for plotting the
output of a call to <code>sim_ame()</code>; <code>summary.clarify_est()</code> for computing
p-values and confidence intervals for the estimated quantities.
</p>
<p><code>marginaleffects::avg_predictions()</code>, <code>marginaleffects::avg_comparisons()</code> and <code>marginaleffects::avg_slopes()</code> for delta method-based implementations of computing average marginal effects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("lalonde", package = "MatchIt")

# Fit the model
fit &lt;- glm(I(re78 &gt; 0) ~ treat + age + race +
             married + re74,
           data = lalonde, family = binomial)

# Simulate coefficients
set.seed(123)
s &lt;- sim(fit, n = 100)

# Average marginal effect of `age`
est &lt;- sim_ame(s, var = "age", verbose = FALSE)
summary(est)

# Contrast between average adjusted predictions
# for `treat`
est &lt;- sim_ame(s, var = "treat", contrast = "rr",
               verbose = FALSE)
summary(est)

# Average adjusted predictions for `race`; need to follow up
# with contrasts for specific levels
est &lt;- sim_ame(s, var = "race", verbose = FALSE)

est &lt;- transform(est,
                 `RR(h,b)` = `E[Y(hispan)]` / `E[Y(black)]`)

summary(est)

# Average adjusted predictions for `treat` within levels of
# `married`, first using `subset` and then using `by`
est0 &lt;- sim_ame(s, var = "treat", subset = married == 0,
                contrast = "rd", verbose = FALSE)
names(est0) &lt;- paste0(names(est0), "|married=0")
est1 &lt;- sim_ame(s, var = "treat", subset = married == 1,
                contrast = "rd", verbose = FALSE)
names(est1) &lt;- paste0(names(est1), "|married=1")

summary(cbind(est0, est1))

est &lt;- sim_ame(s, var = "treat", by = ~married,
               contrast = "rd", verbose = FALSE)

est
summary(est)

# Average marginal effect of `age` within levels of
# married*race
est &lt;- sim_ame(s, var = "age", by = ~married + race,
               verbose = FALSE)
est
summary(est, null = 0)

# Comparing AMEs between married and unmarried for
# each level of `race`
est_diff &lt;- est[4:6] - est[1:3]
names(est_diff) &lt;- paste0("AME_diff|", levels(lalonde$race))
summary(est_diff)

# Average adjusted predictions at a combination of `treat`
# and `married`
est &lt;- sim_ame(s, var = c("treat", "married"),
               verbose = FALSE)
est

# Average marginal effect of `age` setting `married` to 1
est &lt;- sim_ame(s, var = list("age", married = 1),
               verbose = FALSE)
</code></pre>


</div>