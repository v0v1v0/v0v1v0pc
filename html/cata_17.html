<div class="container">

<table style="width: 100%;"><tr>
<td>selectionPlot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot variation in retained sensory differentiation</h2>

<h3>Description</h3>

<p>Plot variation in retained sensory differentiation of cluster memberships
obtained from b-cluster analysis. This plot can be used to help the decision
of how many clusters to retain.
</p>


<h3>Usage</h3>

<pre><code class="language-R">selectionPlot(x, pctB = NULL, x.input = "deltaB", indx = NULL, 
ylab = "change in B (K to G)", xlab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input vector which is either deltaB (default; change 
in sensory differentiation retained) or B (sensory differentiation 
retained) if <code>x.input</code> is <code>"B"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pctB</code></td>
<td>
<p>vector of percentage of the total sensory differentiation retained</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.input</code></td>
<td>
<p>indicates what <code>x</code> is; either <code>"deltaB"</code> (default) 
or <code>B</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indx</code></td>
<td>
<p>numeric value indicating which point(s) to emphasize</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>label shown on y axis and at selection point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>label for points along x axis</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; NÃ¦s, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(123)
G2 &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 2, runs = 3)
G3 &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 3, runs = 3)
G4 &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 4, runs = 3)

best.indx &lt;- c(which.max(unlist(lapply(G2, function(x) x$retainedB))),
               which.max(unlist(lapply(G3, function(x) x$retainedB))),
               which.max(unlist(lapply(G4, function(x) x$retainedB))))
               
G1.bc &lt;- barray(bread$cata[1:8, , 1:5])
G1.B &lt;- getb(G1.bc[,,1,], G1.bc[,,2,])
BpctB &lt;- data.frame(retainedB = c(G1.B, 
                                  G2[[best.indx[1]]]$retainedB, 
                                  G3[[best.indx[2]]]$retainedB,
                                  G4[[best.indx[3]]]$retainedB))
BpctB$pctB &lt;- 100*BpctB$retainedB / G2[[1]]$totalB
BpctB$deltaB &lt;- 
           c(100*(1-BpctB$retainedB[-nrow(BpctB)] / BpctB$retainedB[-1]), NA)
BpctB &lt;- BpctB[-nrow(BpctB),]

opar &lt;- par(no.readonly=TRUE)
par(mar = rep(5,4))
selectionPlot(BpctB$deltaB, BpctB$pctB, indx = 2)
par(opar)
</code></pre>


</div>