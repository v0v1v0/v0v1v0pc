<div class="container">

<table style="width: 100%;"><tr>
<td>hms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hierarchical multimodal spinglass algorithm</h2>

<h3>Description</h3>

<p>Description of the hierarchical multimodal spinglass algorithm function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hms(input_net, spins, alpha, coolfact, tol, max_layers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input_net</code></td>
<td>
<p>a <code>spinglass_net</code> object (see
<code>matrix_to_df</code> for more details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spins</code></td>
<td>
<p>an integer indicating the maximum number of spins, or
communities, that can be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a double parameter balancing the use of the guidance matrix in
modularity calculation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coolfact</code></td>
<td>
<p>a double parameter that indicates how quickly (or slowly) to
cool the heatbath algorithm, typically set to be 0.95-0.99</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a double parameter that indicates the tolerance level of accepting
the proposed changes within a temperature; at the end of each sweep, the number
of proposed changes to the partition is assessed to see if it exceeds a threshold
determined as a function of tol and spins, typically set to be 0.01-0.05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_layers</code></td>
<td>
<p>an integer parameter that specifies the maximum number of
layers of communities within the network</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is the main function of the algorithm. After running checks on the input
parameters, the algorithm begins on the first layer of the network, finding
the optimal configuration of nodes to communities using the heatbath
algorithm. Once the community assignments have been finalized, the set of
nodes within each of these communities is broken up and become their own
subnetworks, on which the algorithm is applied again to get further
subnetwork community assignments. This continues until the maximum number of
layers is reached.
</p>


<h3>Value</h3>

<p>a list of two components: comm_layers_tree, a dataframe whose first
column is the node id and all subsequent columns are the partitioning of the
nodes to communities across the number of pre-specified layers; and
best_hamiltonian, a vector of the optimized Hamiltonian values for each
run of the algorithm
</p>


<h3>See Also</h3>

<p><code>matrix_to_df</code>, <code>community_plot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
hms_object &lt;-
  hms(input_net = SBM_net, 
      spins = 4,
      alpha = 0,
      coolfact = 0.90,
      tol = 0.05,
      max_layers = 1)

str(hms_object)
str(hms_object$comm_layers_tree)
str(hms_object$net)

identical(SBM_net, hms_object$net)
hms_object$net$vertexes

community_plot(hms_object)
  
</code></pre>


</div>