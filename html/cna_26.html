<div class="container">

<table style="width: 100%;"><tr>
<td>cyclic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Detect cyclic substructures in complex solution formulas (csf)
</h2>

<h3>Description</h3>

<p>Given a character vector <code>x</code> specifying complex solution formula(s) (csf), <code>cyclic(x)</code> checks whether <code>x</code> contains cyclic substructures. The function can be used, for instance, to filter cyclic causal models out of <code>cna</code> solution objects (e.g. in order to reduce ambiguities).
</p>


<h3>Usage</h3>

<pre><code class="language-R">cyclic(x, cycle.type = c("factor", "value"), use.names = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character vector specifying one or several csf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycle.type</code></td>
<td>
<p>Character string specifying what type of cycles to be detected: <code>"factor"</code> (the default) or <code>"value"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.names</code></td>
<td>
<p>Logical; if <code>TRUE</code>, names are added to the result (see examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the checked causal paths are printed to the console.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Detecting causal cycles is one of the most challenging tasks in causal data analysisâ€”in all methodological traditions. In a nutshell, the reason is that factors in a cyclic structure are so highly interdependent that, even under optimal discovery conditions, the diversity of (observational) data tends to be too limited to draw informative conclusions about the data generating structure. In consequence, various methods (most notably, Bayes nets methods, cf. Spirtes et al. 2000) assume that analyzed data generating structures are acyclic.
</p>
<p><code>cna</code> outputs cyclic complex solution formulas (csf) if they fit the data. Typically, however, the causal modeling of configurational data that can be modeled in terms of cycles is massively ambiguous. Therefore, if there are independent reasons to assume that the data are not generated by a cyclic structure, the function <code>cyclic</code> can be used to reduce the ambiguities in a <code>cna</code> output by filtering out all csf with cyclic substructures.
</p>
<p>A causal structure has a cyclic substructure if, and only if, it contains a directed causal path from at least one cause back to itself. The INUS-theory of causation spells this criterion out as follows: a csf <code>x</code> has a cyclic substructure if, and only if, <code>x</code> contains a sequence &lt;Z1, Z2,..., Zn&gt; every element of which is an INUS condition of its successor and Z1=Zn. Accordingly, the function <code>cyclic</code> searches for sequences &lt;Z1, Z2,..., Zn&gt; of factors or factor values in a csf <code>x</code> such that (i) every Zi is contained in the antecedent (i.e. the left-hand side of "<code>&lt;-&gt;</code>") of and atomic solution formula (asf) of Zi+1 in <code>x</code>, and (ii) Zn is identical to Z1. The function returns <code>TRUE</code> if, and only if, at least one such sequence (i.e. directed causal path) is contained in <code>x</code>. 
</p>
<p>The <code>cycle.type</code> argument controls whether the sequence &lt;Z1, Z2,..., Zn&gt; is composed of factors (<code>cycle.type = "factor"</code>) or factor values (<code>cycle.type = "value"</code>). To illustrate, if <code>cycle.type = "factor"</code>, the following csf is considered cyclic: (A + B &lt;-&gt; C)*(c + D &lt;-&gt; A). The factor A (with value 1) appears in the antecedent of an asf of C (with value 1), and the factor C (with value 0) appears in the antecedent of an asf of A (with value 1). But if <code>cycle.type = "value"</code>, that same csf does not pass as cyclic. Although the factor value 1 of A appears in the antecedent of an asf of the factor value 1 of C, that same value of C does not appear in the antecedent of an asf of A; rather, the value 0 of C appears in the antecedent of A.
</p>
<p>If <code>verbose = TRUE</code>, the sequences (paths) tested for cyclicity are output to the console. Note that the search for cycles is stopped as soon as one cyclic sequence (path) has been detected. Accordingly, not all sequences (paths) contained in <code>x</code> may be output to the console.
</p>


<h3>Value</h3>

<p>A logical vector: <code>TRUE</code> for a csf with at least one cyclic substructure, <code>FALSE</code> for a csf without any cyclic substructures.</p>


<h3>References</h3>

<p>Spirtes, Peter, Clark Glymour, and Richard Scheines. 2000. <em>Causation, Prediction, and Search</em> (second ed.). Cambridge MA: MIT Press.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># cna() infers two csf from the d.educate data, neither of which has a cyclic
# substructure.
cnaedu &lt;- cna(d.educate)
cyclic(csf(cnaedu)$condition)

# At con = .82 and cov = .82, cna() infers 47 csf for the d.pacts data, some
# of which are cyclic, others are acyclic. If there are independent
# reasons to assume acyclicity, here is how to extract all acyclic csf.
cnapacts &lt;- cna(d.pacts, con = .82, cov = .82)
cyclic(csf(cnapacts)$condition)
subset(csf(cnapacts, n.init = Inf, details = "cyclic"), !cyclic)

# With verbose = TRUE, the tested sequences (causal paths) are printed.
cyclic("(L=1 + G=1 &lt;-&gt; E=2)*(U=5 + D=3 &lt;-&gt; L=1)*(E=2*G=4 &lt;-&gt; D=3)", verbose = TRUE) 
cyclic("(e*G + F*D + E*c*g*f &lt;-&gt; A)*(d + f*e + c*a &lt;-&gt; B)*(A*e + G*a*f &lt;-&gt; C)",
       verbose = TRUE)

# Argument cycle.type = "factor" or "value".
cyclic("(A*b + C -&gt; D)*(d + E &lt;-&gt; A)")
cyclic("(A*b + C -&gt; D)*(d + E &lt;-&gt; A)", cycle.type = "value")

cyclic("(L=1 + G=1 &lt;-&gt; E=2)*(U=5 + D=3 &lt;-&gt; L=2)*(E=2 + G=3 &lt;-&gt; D=3)") 
cyclic("(L=1 + G=1 &lt;-&gt; E=2)*(U=5 + D=3 &lt;-&gt; L=2)*(E=2 + G=3 &lt;-&gt; D=3)", cycle.type = "v") 

cyclic("a &lt;-&gt; A")
cyclic("a &lt;-&gt; A", cycle.type = "v")

sol1 &lt;- "(A*X1 + Y1 &lt;-&gt; B)*(b*X2 + Y2 &lt;-&gt; C)*(C*X3 + Y3 &lt;-&gt; A)"
cyclic(sol1)
cyclic(sol1, cycle.type = "value") 

sol2 &lt;- "(A*X1 + Y1 &lt;-&gt; B)*(B*X2 + Y2 &lt;-&gt; C)*(C*X3 + Y3 &lt;-&gt; A)"
cyclic(sol2)
cyclic(sol2, cycle.type = "value")

# Argument use.names.
cyclic("a*b + C -&gt; A", use.names = FALSE)

# More examples.
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)")
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)*(B &lt;-&gt; G)")
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)*(B &lt;-&gt; G)*(L &lt;-&gt; G)")
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)*(B &lt;-&gt; G)*(L &lt;-&gt; C)")
cyclic("(D -&gt; A)*(A -&gt; B)*(A -&gt; C)*(B -&gt; C)")
cyclic("(B=3*C=2 + C=1*E=3 &lt;-&gt; A=2)*(B=2*C=1 &lt;-&gt; D=2)*(A=2*B=2 + A=3*C=3 &lt;-&gt; E=3)")
cyclic("(B=3*C=2 + D=2*E=3 &lt;-&gt; A=2)*(A=2*E=3 + B=2*C=1 &lt;-&gt; D=2)*(A=3*C=3 + A=2*D=2 &lt;-&gt; E=3)")

cyclic("(B + d*f &lt;-&gt; A)*(E + F*g &lt;-&gt; B)*(G*e + D*A &lt;-&gt; C)")
cyclic("(B*E + d*f &lt;-&gt; A)*(A + E*g + f &lt;-&gt; B)*(G*e + D*A &lt;-&gt; C)")
cyclic("(B + d*f &lt;-&gt; A)*(C + F*g &lt;-&gt; B)*(G*e + D*A &lt;-&gt; C)")
cyclic("(e*G + F*D + E*c*g*f &lt;-&gt; A)*(d + f*e + c*a &lt;-&gt; B)*(A*e + G*a*f &lt;-&gt; C)")
cyclic("(e*G + F*D + E*c*g*f &lt;-&gt; A)*(d + f*e + c*a &lt;-&gt; B)*(A*e + G*a*f &lt;-&gt; C)", 
       verbose = TRUE)
</code></pre>


</div>