<div class="container">

<table style="width: 100%;"><tr>
<td>cnlt.spec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A function to compute CNLT spectral quantities for univariate and bivariate series
</h2>

<h3>Description</h3>

<p>The function takes a nondecimated complex lifting decomposition of a univariate or bivariate series, and uses
smoothing before computing spectral quantities such as the complex periodograms, coherence and phase
</p>


<h3>Usage</h3>

<pre><code class="language-R">cnlt.spec(x, ...)
## S3 method for class 'SG'
cnlt.spec(x, M = 50, fact = 1, ...)
## S3 method for class 'DG'
cnlt.spec(x, M = 50, fact = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>cnlt</code>, i.e. the output from either <code>cnlt.univ</code> or <code>cnlt.biv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The smoothing parameter (binwidth) or vector of smoothing parameters (one for each scale) for the time-domain kernel smoothing method, see <code>smooth.over.time</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fact</code></td>
<td>
<p>If <code>length(M)==1</code>, a factor indicating how the smoothing parameter (binwidth) in the time-domain kernel smoothing method should increase from 
one scale to the next, see <code>smooth.over.time</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other parameters to be passed to the scale smoothing function, see the documentation for <code>smooth.over.scale</code> for univariate <code>cnlt</code> objects, or <code>pre.per</code> for bivariate <code>cnlt</code> objects.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For univariate series, the nondecimated complex lifting object can be used to form a spectral object by smoothing the squared details over scale (with <code>smooth.over.scale</code>), and then smoothing over time (using <code>smooth.over.time</code>).  Smoothing over scale is done via <code>smooth.spline</code>; smoothing over time is done with a kernel smoother (e.g. a "box" kernel for a moving average).
See Hamilton et al. (2018) for more details.	
</p>


<h3>Value</h3>

<p>An object of class <code>cnlt.spec</code> (subclasses: <code>DG</code>, <code>SG</code>, <code>univ</code>, <code>biv</code>).  <br></p>
<p>For subclass <code>univ</code>, a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>S1</code></td>
<td>
<p>A spectral object (matrix) of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the spectrum of the univariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mscale</code></td>
<td>
<p>A vector of scales corresponding to the rows of the spectrum <code>S1</code> (after smoothing the periodogram), see <code>smooth.over.scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtime</code></td>
<td>
<p>The vector <code>cnltobj$x</code>, the vector of times corresponding to the columns of the spectrum <code>S1</code>.</p>
</td>
</tr>
</table>
<p>For subclass <code>biv</code>, a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>coh</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the coherence between the two components of the bivariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the phase between the two components of the bivariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the co-periodogram of the bivariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the quadrature periodogram of the bivariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S1</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the spectrum of the first component of the bivariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S2</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the spectrum of the second component of the  bivariate series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mscale</code></td>
<td>
<p>A vector of scales corresponding to the rows of the spectrum <code>S1</code> (after smoothing the periodogram), see <code>smooth.over.scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtime</code></td>
<td>
<p>A vector of times corresponding to the columns of the spectrum <code>S1</code>.  If the class of <code>cnlt.obj</code> is <code>SG</code>, this is <code>cnlt.obj$x1</code>, else this is a vector formed by binning detail coefficients within equal intervals of time, see <code>pre.per</code> for more details.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes, Jean Hamilton
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code>cnlt.biv</code>,
<code>cnlt.univ</code>,
<code>cnltspec.plot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# read some data in (a bivariate series)

## Not run: 

data(Baidu)
data(Google)

BaiGoo&lt;-cnlt.biv(Baidu$Seconds[1:100], Google$Seconds[1:100], Baidu$Return[1:100], 
Google$Return[1:100], P = 500)

specobj&lt;-cnlt.spec(BaiGoo,M=10,fact=1.05, Tstar=20)

## End(Not run)

</code></pre>


</div>