<div class="container">

<table style="width: 100%;"><tr>
<td>cnaOpt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find atomic solution formulas with optimal consistency and coverage
</h2>

<h3>Description</h3>

<p><code>cnaOpt</code> attempts to find atomic solution formulas (asfs) for a given <code>outcome</code> (inferred from crisp-set, <code>"cs"</code>, or multi-value, <code>"mv"</code>, data) that are optimal with respect to the model fit parameters consistency and coverage (cf. Baumgartner and Ambuehl 2021). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cnaOpt(x, outcome, ..., reduce = c("ereduce", "rreduce", "none"), 
       niter = 1, crit = quote(con * cov), cond = quote(TRUE), 
			 approx = FALSE, maxCombs = 1e7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A <code>data.frame</code> or <code>configTable</code> of type <code>"cs"</code> or <code>"mv"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>

<p>A character string specifying one outcome, i.e. one factor value in <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments passed to <code>configTable</code>, for instance <code>rm.dup.factors</code>, <code>rm.dup.factors</code>, or <code>case.cutoff</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce</code></td>
<td>

<p>A character string: if <code>"ereduce"</code> or <code>"rreduce"</code>, the canonical DNF realizing the con-cov optimum is freed of redundancies using <code>ereduce</code> or <code>rreduce</code> (possibly repeatedly, see <code>niter</code>), respectively; if <code>"none"</code>, the unreduced canonical DNF is returned. <code>reduce = TRUE</code> is interpreted as <code>"rreduce"</code>, <code>reduce = FALSE</code> and <code>reduce = NULL</code> as <code>"none"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>

<p>An integer value indicating the number of repetitive applications of <code>rreduce</code>. 
<code>niter</code> will be ignored (with a warning) if <code>reduce</code> is not equal to <code>"rreduce"</code>. 
Note that repeated applications may yield identical solutions and that duplicate solutions are eliminiated, so that the number of resulting solutions can be smaller than <code>niter</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>

<p>Quoted expression specifying a numeric criterion to be maximized when selecting the best solutions among the ones that meet criterion <code>cond</code>, for example, <code>quote(min(con,cov))</code> or <code>quote(0.8*con + 0.2*cov)</code>, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>

<p>Quoted expression specifying a logical criterion to be imposed on the solutions inferred from <code>x</code> before selecting the best solutions on the basis of <code>crit</code>, for example, <code>quote(con &gt; 0.85)</code> or <code>quote(con &gt; cov)</code>, etc.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx</code></td>
<td>

<p>As in <code>conCovOpt</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxCombs</code></td>
<td>

<p>Maximal number of combinations that will be tested for optimality. If the number of necessary iterations exceeds <code>maxCombs</code>, <code>cnaOpt</code> will stop executing and return an error message stating the necessary number of iterations. Early termination can then be avoided by increasing <code>maxCombs</code> accordingly. This argument is passed to <code>conCovOpt</code> and <code>ereduce</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>cnaOpt</code> implements a procedure introduced in Baumgartner and Ambuehl (2021). It infers causal models (atomic solution formulas, asf) for the <code>outcome</code> from data <code>x</code> that comply with the logical condition <code>cond</code> and maximize the numeric criterion <code>crit</code>. Data <code>x</code> may be crisp-set (<code>"cs"</code>) or multi-value (<code>"mv"</code>), but not fuzzy-set (<code>"fs"</code>). The function proceeds as follows:
</p>

<ol>
<li>
<p> it calculates consistency and coverage optima (con-cov optima) for <code>x</code>;
</p>
</li>
<li>
<p> it selects the optima that meet <code>cond</code>;
</p>
</li>
<li>
<p> among those optima, it selects those that maximize <code>crit</code>;
</p>
</li>
<li>
<p> it builds the canonical disjunctive normal forms (DNF) of the selected optima
</p>
</li>
<li>
<p> it generates all minimal forms of those canonical DNFs
</p>
</li>
</ol>
<p>Roughly speaking, running <code>cnaOpt</code> amounts to sequentially executing <code>configTable</code>, <code>conCovOpt</code>, <code>selectMax</code>, <code>DNFbuild</code> and <code>condTbl</code>.
</p>
<p>In the default setting, <code>cnaOpt</code> attempts to build all optimal solutions using <code>ereduce</code>. But that may be too computationally demanding because the space of optimal solutions can be very large. If the argument <code>reduce</code> is set to <code>"rreduce"</code>, <code>cnaOpt</code> builds one arbitrarily selected optimal solution, which typically terminates quickly. By giving the argument <code>niter</code> a non-default value, say, 20, the process of selecting one optimal solution under <code>reduce = "rreduce"</code> is repeated 20 times. As the same solutions will be generated on some iterations and duplicates are not returned, the output may contain less models than the value given to <code>niter</code>. If <code>reduce</code> is not set to <code>"rreduce"</code>, <code>niter</code> is ignored with a warning.
</p>


<h3>Value</h3>

<p><code>cnaOpt</code> returns a <code>data.frame</code> with additional classes "cnaOpt" and "condTbl". See the "Value" section in <code>?condTbl</code> for details.
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2021. “Optimizing Consistency and Coverage in Configurational Causal Modeling.” <em>Sociological Methods &amp; Research</em>.<br> doi:10.1177/0049124121995554. 
</p>


<h3>See Also</h3>

<p><code>cna</code>, <code>conCovOpt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1: Real-life crisp-set data, d.educate.
(res_opt1 &lt;- cnaOpt(d.educate, "E"))

# Using the pipe operator (%&gt;%), the steps processed by cnaOpt in the 
# call above can be reproduced as follows:
library(dplyr)
conCovOpt(d.educate, "E") %&gt;% selectMax %&gt;% DNFbuild(reduce = "ereduce") %&gt;% 
  paste("&lt;-&gt; E") %&gt;% condTbl(d.educate)

# Example 2: Simulated crisp-set data.
dat1 &lt;- data.frame(
  A = c(1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0), 
  B = c(0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0), 
  C = c(0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0), 
  D = c(1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1), 
  E = c(1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1), 
  F = c(0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1)
)

(res_opt2 &lt;- cnaOpt(dat1, "E"))

# Change the maximality criterion.
cnaOpt(dat1, "E", crit = quote(min(con, cov)))
# Change the selection condition.
cnaOpt(dat1, "E", cond = quote(con &gt;= 0.9))
# Build all con-cov optima with coverage above 0.9 that maximize min(con, cov).
cnaOpt(dat1, "E", crit = quote(min(con, cov)), cond = quote(cov &gt; 0.9))
# Different values of the reduce argument.
cnaOpt(dat1, "E", reduce = "none") # canonical DNF
cnaOpt(dat1, "E", reduce = "rreduce") # one randomly drawn optimal solution
# Iterate random solution generation 10 times.
cnaOpt(dat1, "E", reduce = "rreduce", niter = 10) 

# Example 3: All logically possible configurations.
(res_opt3 &lt;- cnaOpt(full.ct(4), "D"))  # All combinations are equally bad.

# Example 4: Real-life multi-value data, d.pban.
cnaOpt(d.pban, outcome = "PB=1")
cnaOpt(d.pban, outcome = "PB=1", crit = quote(0.8*con + 0.2*cov))
cnaOpt(d.pban, outcome = "PB=1", cond = quote(con &gt; 0.9))
cnaOpt(d.pban, outcome = "PB=0")
cnaOpt(d.pban, outcome = "PB=0", cond = quote(con &gt; 0.9))
cnaOpt(d.pban, outcome = "F=2")
cnaOpt(d.pban, outcome = "F=2", crit = quote(0.8*con + 0.2*cov))

# Example 5: High computational demand.
dat2 &lt;- configTable(d.performance[,1:8], frequency = d.performance$frequency)
try(cnaOpt(dat2, outcome = "SP"))   # error because too computationally demanding
# The following call does not terminate because of reduce = "ereduce".
try(cnaOpt(dat2, outcome = "SP", approx = TRUE))
# We could increase maxCombs, as in the line below
## Not run: cnaOpt(dat2, outcome = "SP", approx = TRUE, maxCombs = 1.08e+09) 
# but this takes very long to terminate.
# Alternative approach: Produce one (randomly selected) optimal solution using reduce = "rreduce".
cnaOpt(dat2, outcome = "SP",  approx = TRUE, reduce = "rreduce")
# Iterate the previous call 10 times.
cnaOpt(dat2, outcome = "SP", approx = TRUE, reduce = "rreduce", niter = 10)
# Another alternative: Use ereduce for minimization but introduce a case.cutoff.
cnaOpt(dat2, outcome = "SP", case.cutoff = 10)
</code></pre>


</div>