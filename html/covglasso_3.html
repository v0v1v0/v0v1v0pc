<div class="container">

<table style="width: 100%;"><tr>
<td>covglasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse covariance matrix estimation</h2>

<h3>Description</h3>

<p>Direct estimation of a sparse covariance matrix using the covariance graphical lasso.
</p>


<h3>Usage</h3>

<pre><code class="language-R">covglasso(data = NULL,
          S = NULL, n = NULL,
          lambda = NULL,
          rho = NULL,
          duplicated = TRUE,
          L = 10,
          crit = c("bic", "ebic"),
          gamma = 0.5,
          penalize.diag = FALSE,
          start = NULL,
          ctrl = control(),
          path = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A numerical dataframe or matrix, where rows correspond to observations and columns to variables. If <code>data = NULL</code>, the sample covariance <code>S</code> must be provided in input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>The sample covariance matrix of the data. If <code>S = NULL</code>, the maximum likelihood estimate of the covariance matrix is used in the estimation of the sparse covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of observations. If <code>data = NULL</code> and <code>S</code> is provided in input, <code>n</code> must be provided in input as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A vector or array of non-negative lasso regularization parameters. Penalization is applied elementwise to all entries of the covariance matrix. If an array, each entry must be a matrix with same dimensions of the sample covariance matrix. Values should be increasing from the smallest to the largest. If <code>lambda = NULL</code>, an alternative penalization based on thresholding of the empirical correlation matrix is used; see "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>A vector of correlation values used to define the penalization in terms of the thresholded sample correlation matrix. See "Details". Note that this penalization is used by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duplicated</code></td>
<td>
<p>Remove duplicated penalty matrices when the default penalty term based on the thresholded correlation matrix is used. Suggest to leave this argument to <code>TRUE</code> all the time as several redundant matrices giving the same penalty term are discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>The number of <code>rho</code> values. Only used when <code>lambda</code> and <code>rho</code> are NULL. Default is <code>L = 10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>The model selection criterion employed to select the optimal covariance graph model. Can be <code>"bic"</code> or <code>"ebic"</code>; see "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>A penalty parameter used when <code>crit = "ebic"</code> and EBIC is used to select the optimal graph covariance model. The value of <code>gamma</code> must be in the range <code>[0,1]</code>. Default is <code>gamma = 0.5</code>, which encourages sparser models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalize.diag</code></td>
<td>
<p>A logical argument indicating if the diagonal of the covariance matrix should be penalized. Default to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A starting matrix for the estimation algorithm. If <code>NULL</code>, the starting value is the diagonal sample covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctrl</code></td>
<td>
<p>A list of control parameters for the coordinate descent algorithm employed for estimation. See also <code>control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>A logical argument controlling whether all the estimated covariance matrices along the path defined by <code>lambda</code> or <code>rho</code> should be included in the output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function estimates a sparse covariance matrix using a fast coordinate descent algorithm to solve the covariance graphical lasso. The estimated sparse covariance matrix is obtained by optimizing the following penalized log-likelihood:
</p>
<p style="text-align: center;"><code class="reqn">-\frac{n}{2}\{ \mathrm{logdet}(\Sigma) + \mathrm{trace}(S\Sigma^{-1})  \} - ||\Lambda * \Sigma||_1</code>
</p>

<p>subject to <code class="reqn">\Sigma</code> being positive definite. In the penalty term, the <code class="reqn">L_1</code> norm and the matrix multiplication between <code class="reqn">\Lambda</code> and <code class="reqn">\Sigma</code> is elementwise.
</p>
<p>By default (when <code>lambda = NULL</code>), the penalization matrix <code class="reqn">\Lambda</code> is defined in terms of a sequential thresholding of the sample correlation matrix. Given <code class="reqn">\rho_l</code> a threshold value and <code class="reqn">R</code> the sample correlation matrix, the penalty term matrix <code class="reqn">\Lambda</code> is defined by the values <code class="reqn">(1/s_{ij})I(r_{ij} &lt; \rho_l)</code>, that is:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda = \frac{1}{S}I(R &lt; \rho_l)</code>
</p>

<p>where the inequality is taken elementwise. Such choice of penalty matrix provides a framework related to the adaptive lasso of Fan et al. (2009) and the method of Chaudhuri et al. (2007).
If the vector <code>rho</code> is not given in input, the sequence of threshold values is defined as the <code>L</code> quantiles of the absolute values of the sample correlations in <code class="reqn">R</code>. If <code>lambda</code> is provided in input, the penalization corresponds to the standard covariance graphical lasso of Bien, Tibshirani (2011).
</p>
<p>The sparse covariance matrix corresponds to a Gaussian covariance graphical model of marginal independence, where in the sparse covariance matrix a zero entry corresponds to two variables being marginally independent. Different penalizations <code>lambda</code> imply different models, and selection of the optimal graphical model is performed using <code>"bic"</code> (default) or <code>"ebic"</code>. In the latter case, the argument <code>gamma</code> controls the additional penalty term in the model selection criterion; see Foygel, Drton, (2010).
</p>


<h3>Value</h3>

<p>A list containing the following elements.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>The estimated covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>The estimated concentration (inverse covariance) matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>The adjacency matrix given in input corresponding to the marginal or conditional independence graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>Value of the maximized log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npar</code></td>
<td>
<p>Number of estimated non-zero parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Value of the penalty term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bic</code></td>
<td>
<p>Optimal BIC or EBIC value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC</code></td>
<td>
<p>All BIC or EBIC values along the path defined by <code>lambda</code> or <code>rho</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>A list containing all the estimated sparse covariance models. Provided in output only when <code>path = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>The values of <code>rho</code> thresholds used to define the penalization based on the thresholded sample correlation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The values of <code>lambda</code> penalty parameters for the penalization.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bien, J., Tibshirani, R.J. (2011). Sparse estimation of a covariance matrix. <em>Biometrika</em>, 98(4), 807–820.
</p>
<p>Chaudhuri, S., Drton M., Richardson, T. S. (2007). Estimation of a covariance matrix with zeros. <em>Biometrika</em>, 94(1), 199-216.
</p>
<p>Fan, J., Feng, Y., Wu, Y. (2009). Network exploration via the adaptive lasso and scad penalties. <em>The Annals of Applied Statistics</em>, 3(2), 521.
</p>
<p>Foygel, R., Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. In <em>Advances in neural information processing systems</em>, pages 604–612.
</p>
<p>Wang, H. (2014). Coordinate descent algorithm for covariance graphical lasso. <em>Statistics and Computing</em>, 24:521.
</p>


<h3>See Also</h3>

<p><code>control</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># a simple example with a 3-block diagonal matrix
library(MASS)
p &lt;- 3
n &lt;- 300
sig &lt;- matrix(0.8, p,p)
diag(sig) &lt;- 1
set.seed(190188)
tmp &lt;- replicate( 3, mvrnorm(n, rep(0,p), sig) )
x &lt;- matrix(c(tmp), n, p*3)

fit1 &lt;- covglasso(x)
plot(fit1$rho, fit1$BIC)
image(fit1$sigma != 0)

# refine search
fit2 &lt;- covglasso(x, rho = seq(0.1, 0.4, length = 50))
image(fit2$sigma != 0)

fit1$bic
fit2$bic


# Cars93 data in MASS package
data("Cars93", package = "MASS")
dat &lt;- na.omit( Cars93[,c(4:8,12:15,17,19:25)] )

fit1 &lt;- covglasso(dat, L = 50)

# more sparse
fit2 &lt;- covglasso(dat, L = 50,
                    crit = "ebic", gamma = 1)

oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
plot(fit1$rho, fit1$BIC, main = "BIC")
plot(fit2$rho, fit2$BIC, main = "EBIC")
image(fit1$sigma != 0, col = c("white", "black"), main = "BIC")
image(fit2$sigma != 0, col = c("white", "black"), main = "EBIC")
par(oldpar)  # reset par
</code></pre>


</div>