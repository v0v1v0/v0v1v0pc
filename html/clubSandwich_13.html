<div class="container">

<table style="width: 100%;"><tr>
<td>pattern_covariance_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute a patterned block-diagonal covariance matrix</h2>

<h3>Description</h3>

<p>'r lifecycle::badge("superseded")'
</p>
<p>This function is superseded by the <code>vcalc</code> provided by
the <code>metafor</code> package. Compared to <code>pattern_covariance_matrix</code>,
<code>vcalc</code> provides many further features, includes a
<code>data</code> argument, and uses syntax that is consistent with other
functions in <code>metafor</code>.
</p>
<p><code>pattern_covariance_matrix</code> calculates a
block-diagonal covariance matrix, given the marginal variances, the block
structure, and an assumed correlation structure defined by a patterned
correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pattern_covariance_matrix(
  vi,
  cluster,
  pattern_level,
  r_pattern,
  r,
  smooth_vi = FALSE,
  subgroup = NULL,
  return_list = identical(as.factor(cluster), sort(as.factor(cluster))),
  check_PD = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vi</code></td>
<td>
<p>Vector of variances</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Vector indicating which effects belong to the same cluster.
Effects with the same value of 'cluster' will be treated as correlated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern_level</code></td>
<td>
<p>Vector of categories for each effect size, used to
determine which entry of the pattern matrix will be used to impute a
correlation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_pattern</code></td>
<td>
<p>Patterned correlation matrix with row and column names
corresponding to the levels of <code>pattern</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Vector or numeric value of assumed constant correlation(s) between
effect size estimates from each study.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth_vi</code></td>
<td>
<p>Logical indicating whether to smooth the marginal variances
by taking the average <code>vi</code> within each cluster. Defaults to
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgroup</code></td>
<td>
<p>Vector of category labels describing sub-groups of effects.
If non-null, effects that share the same category label and the same
cluster will be treated as correlated, but effects with different category
labels will be treated as uncorrelated, even if they come from the same
cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_list</code></td>
<td>
<p>Optional logical indicating whether to return a list of
matrices (with one entry per block) or the full variance-covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_PD</code></td>
<td>
<p>Optional logical indicating whether to check whether each
covariance matrix is positive definite. If <code>TRUE</code> (the default), the
function will display a warning if any covariance matrix is not positive
definite.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A block-diagonal variance-covariance matrix (possibly represented as
a list of matrices) with a specified correlation structure, defined by a
patterned correlation matrix. Let <code class="reqn">v_{ij}</code> denote the specified
variance for effect <code class="reqn">i</code> in cluster <code class="reqn">j</code> and
<code class="reqn">C_{hij}</code> be the covariance between effects <code class="reqn">h</code> and
<code class="reqn">i</code> in cluster <code class="reqn">j</code>. Let <code class="reqn">p_{ij}</code> be the level
of the pattern variable for effect <code class="reqn">i</code> in cluster <code class="reqn">j</code>,
taking a value in <code class="reqn">1,...,C</code>. A patterned correlation matrix
is defined as a set of correlations between pairs of effects taking each
possible combination of patterns. Formally, let <code class="reqn">r_{cd}</code> be the
correlation between effects in categories <code class="reqn">c</code> and <code class="reqn">d</code>,
respectively, where <code class="reqn">r_{cd} = r_{dc}</code>. Then the
covariance between effects <code class="reqn">h</code> and <code class="reqn">i</code> in cluster
<code class="reqn">j</code> is taken to be </p>
<p style="text-align: center;"><code class="reqn">C_{hij} = \sqrt{v_{hj} v_{ij}} \times
  r_{p_{hj} p_{ij}}.</code>
</p>
 
<p>Correlations between effect sizes within the same category are defined by the diagonal
values of the pattern matrix, which may take values less than one. 
</p>
<p>Combinations of pattern levels that do not occur in the patterned correlation matrix will be set equal to <code>r</code>.
</p>
<p>If <code>smooth_vi = TRUE</code>, then all of the variances within cluster
<code class="reqn">j</code> will be set equal to the average variance of cluster
<code class="reqn">j</code>, i.e., </p>
<p style="text-align: center;"><code class="reqn">v'_{ij} = \frac{1}{n_j} \sum_{i=1}^{n_j}
  v_{ij}</code>
</p>
<p> for
<code class="reqn">i=1,...,n_j</code> and <code class="reqn">j=1,...,k</code>.
</p>


<h3>Value</h3>

<p>If <code>cluster</code> is appropriately sorted, then a list of matrices,
with one entry per cluster, will be returned by default. If <code>cluster</code>
is out of order, then the full variance-covariance matrix will be returned
by default. The output structure can be controlled with the optional
<code>return_list</code> argument.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
pkgs_available &lt;- 
  requireNamespace("metafor", quietly = TRUE) &amp; 
  requireNamespace("robumeta", quietly = TRUE)
  
if (pkgs_available) {
library(metafor)

data(oswald2013, package = "robumeta")
dat &lt;- escalc(data = oswald2013, measure = "ZCOR", ri = R, ni = N)
subset_ids &lt;- unique(dat$Study)[1:20]
dat &lt;- subset(dat, Study %in% subset_ids)

# make a patterned correlation matrix 

p_levels &lt;- levels(dat$Crit.Cat)
r_pattern &lt;- 0.7^as.matrix(dist(1:length(p_levels)))
diag(r_pattern) &lt;- seq(0.75, 0.95, length.out = 6)
rownames(r_pattern) &lt;- colnames(r_pattern) &lt;- p_levels

# impute the covariance matrix using patterned correlations
V_list &lt;- pattern_covariance_matrix(vi = dat$vi, 
                                    cluster = dat$Study, 
                                    pattern_level = dat$Crit.Cat,
                                    r_pattern = r_pattern,
                                    smooth_vi = TRUE)
                                    
# fit a model using imputed covariance matrix

MVFE &lt;- rma.mv(yi ~ 0 + Crit.Cat, V = V_list, 
               random = ~ Crit.Cat | Study,
               data = dat)
               
conf_int(MVFE, vcov = "CR2")

}

</code></pre>


</div>