<div class="container">

<table style="width: 100%;"><tr>
<td>estimators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pre-implemented estimators</h2>

<h3>Description</h3>

<p>Pre-implemented change-point estimators that can be passed to the argument <code>estimator</code> in the cross-validation functions, see the functions listed in <cite>See Also</cite>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">leastSquares(Y, param, ...)
pelt(Y, param, ...)
binseg(Y, param, ...)
wbs(Y, param, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a numeric vector giving the observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>a <code>list</code> giving the possible tuning parameters. See <cite>Details</cite> to see which tuning parameters are allowed for which function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, see <cite>Details</cite> to see which arguments are allowed for which function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>leastSquares</code> implements least squares estimation by using the segment neighbourhoods algorithm with functional pruning from <cite>Rigaill (20015)</cite>, see also <cite>Auger and Lawrence (1989)</cite> for the original segment neighbourhoods algorithm. It calls <code>Fpsn</code>. Each list entry in <code>param</code> has to be a single integer giving the number of change-points.
</p>
<p><code>optimalPartitioning</code> is outdated. It will give the same results as <code>leastSquares</code>, but is slower. It is part of the package for backwards compatibility only.
</p>
<p><code>pelt</code> implements <abbr><span class="acronym">PELT</span></abbr> <cite>(Killick et al., 2012)</cite>, i.e. penalised maximum likelihood estimation computed by a pruned dynamic program. For each list entry in <code>param</code> it calls <code>cpt.mean</code> with <code>method = "PELT"</code> and <code>penalty = param[[i]]</code> or when <code>param[[i]]</code> is a numeric with <code>penalty = "Manual"</code> and <code>pen.value = param[[i]]</code>. Hence, each entry in <code>param</code> must be a single numeric or an argument that can be passed to <code>penalty</code>. Additionally <code>minseglen</code> can be specified in <code>...</code>, by default <code>minseglen = 1</code>.
</p>
<p><code>binseg</code> implements binary segmentation <cite>(Vostrikova, 1981)</cite>. The call is the same as for <code>pelt</code>, but with <code>method = "BinSeg"</code>. Additionally, the maximal number of change-points <code>Q</code> can be specified in <code>...</code>, by default <code>Q = 5</code>. Alternatively, each list entry of <code>param</code> can be a list itself containing the named entries <code>penalty</code> and <code>Q</code>. Note that this estimator differs from binary segmentation in <cite>Zou et al. (2020)</cite>, it requires a penalty instead of a given number of change-points. Warnings that <code>Q</code> is chosen too small are suppressed when <code>Q</code> is given in <code>param</code>, but not when it is a global parameter specified in <code>...</code> or <code>Q = 5</code> by default.
</p>
<p><code>wbs</code> implements wild binary segmentation <cite>(Fryzlewicz, 2014)</cite>. It calls <code>changepoints</code> with <code>th.const = param</code>, hence <code>param</code> has to be a list of positive scalars. Additionally, <code>...</code> will be passed.
</p>


<h3>Value</h3>

<p>For <code>leastSquares</code> and <code>wbs</code> a list of length <code>length(param)</code> with each entry containing the estimated change-point locations for the given entry in <code>param</code>. For the other functions a list containing the named entries <code>cps</code> and <code>value</code>, with <code>cps</code> a list of the estimated change-points as before and <code>value</code> a list of the locally estimated values for each entry in <code>param</code>, i.e. each list entry is a list itself of length one entry longer than the corresponding entry in <code>cps</code>.
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>
<p>Rigaill, G. (2015) A pruned dynamic programming algorithm to recover the best segmentations with 1 to Kmax change-points. <em>Journal de la Societe Francaise de Statistique</em> <b>156</b>(4), 180–205.
</p>
<p>Auger, I. E., Lawrence, C. E. (1989) Algorithms for the Optimal Identification of Segment Neighborhoods. <em>Bulletin of Mathematical Biology</em>, <b>51</b>(1), 39–54.
</p>
<p>Killick, R., Fearnhead, P., Eckley, I. A. (2012) Optimal detection of changepoints with a linear computational cost. <em>Journal of the American Statistical Association</em>, <b>107</b>(500), 1590–1598.
</p>
<p>Vostrikova, L. Y. (1981). Detecting 'disorder' in multidimensional random processes. <em>Soviet Mathematics Doklady</em>,
<b>24</b>, 55–59.
</p>
<p>Fryzlewicz, P. (2014) Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, <b>42</b>(6), 2243–2281.
</p>
<p>Zou, C., Wang, G., and Li, R. (2020). Consistent selection of the number of change-points via sample-splitting. <em>The Annals of Statistics</em>, <b>48</b>(1), 413–439.
</p>


<h3>See Also</h3>

<p><code>crossvalidationCP</code>, <code>VfoldCV</code>, <code>COPPS</code>, <code>CV1</code>, <code>CVmod</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># all functions can be called directly, e.g.
leastSquares(Y = rnorm(100), param = 2)

# but their main purpose is to serve as a local estimator in the cross-validation functions, e.g.
crossvalidationCP(rnorm(100), estimator = leastSquares)

# param must contain values that are suitable for the given estimator
crossvalidationCP(rnorm(100), estimator = pelt, param = list("SIC", "MBIC"))
</code></pre>


</div>