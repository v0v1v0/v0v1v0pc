<div class="container">

<table style="width: 100%;"><tr>
<td>CBPS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Covariate Balancing Propensity Score (CBPS) Estimation</h2>

<h3>Description</h3>

<p><code>CBPS</code> estimates propensity scores such that both covariate balance and
prediction of treatment assignment are maximized.  The method, therefore,
avoids an iterative process between model fitting and balance checking and
implements both simultaneously. For cross-sectional data, the method can
take continuous treatments and treatments with a control (baseline)
condition and either 1, 2, or 3 distinct treatment conditions.
</p>
<p>Fits covariate balancing propensity scores.
</p>
<p>### @aliases CBPS CBPS.fit print.CBPS
</p>


<h3>Usage</h3>

<pre><code class="language-R">CBPS(
  formula,
  data,
  na.action,
  ATT = 1,
  iterations = 1000,
  standardize = TRUE,
  method = "over",
  twostep = TRUE,
  sample.weights = NULL,
  baseline.formula = NULL,
  diff.formula = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object of class <code>formula</code> (or one that can be coerced
to that class): a symbolic description of the model to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible
by as.data.frame to a data frame) containing the variables in the model. If
not found in data, the variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>CBPS</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain NAs. The default is set by the na.action setting of options, and is
na.fail if that is unset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ATT</code></td>
<td>
<p>Default is 1, which finds the average treatment effect on the
treated interpreting the second level of the treatment factor as the
treatment.  Set to 2 to find the ATT interpreting the first level of the
treatment factor as the treatment.  Set to 0 to find the average treatment
effect. For non-binary treatments, only the ATE is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>An optional parameter for the maximum number of iterations
for the optimization.  Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Default is <code>TRUE</code>, which normalizes weights to sum
to 1 within each treatment group.  For continuous treatments, normalizes
weights to sum up to 1 for the entire sample.  Set to <code>FALSE</code> to return
Horvitz-Thompson weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Choose "over" to fit an over-identified model that combines
the propensity score and covariate balancing conditions; choose "exact" to
fit a model that only contains the covariate balancing conditions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twostep</code></td>
<td>
<p>Default is <code>TRUE</code> for a two-step estimator, which will
run substantially faster than continuous-updating.  Set to <code>FALSE</code> to
use the continuous-updating estimator described by Imai and Ratkovic (2014).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.weights</code></td>
<td>
<p>Survey sampling weights for the observations, if
applicable.  When left NULL, defaults to a sampling weight of 1 for each
observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline.formula</code></td>
<td>
<p>Used only to fit iCBPS (see Fan et al). Currently
only works with binary treatments.  A formula specifying the balancing
covariates in the baseline outcome model, i.e., E(Y(0)|X).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff.formula</code></td>
<td>
<p>Used only to fit iCBPS (see Fan et al).  Currently only
works with binary treatments.  A formula specifying the balancing covariates
in the difference between the treatment and baseline outcome model, i.e.,
E(Y(1)-Y(0)|X).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters to be passed through to <code>optim()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>The fitted propensity score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictor</code></td>
<td>
<p>X * beta</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Minus twice the log-likelihood of the CBPS fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The optimal weights.  Let <code class="reqn">\pi_i = f(T_i | X_i)</code>.  For binary ATE, these are given by <code class="reqn">\frac{T_i}{\pi_i} +
\frac{(1 - T_i)}{(1 - \pi_i)}</code>.  For
binary ATT, these are given by <code class="reqn">\frac{n}{n_t} * \frac{T_i - \pi_i}{1 -
\pi_i}</code>.  For multi_valued treatments,
these are given by <code class="reqn">\sum_{j=0}^{J-1} T_{i,j} /
\pi_{i,j}</code>.  For continuous treatments,
these are given by <code class="reqn">\frac{f(T_i)}{f(T_i | X_i)}</code>.  These expressions for weights are all before standardization (i.e. with
standardize=<code>FALSE</code>).  Standardization will make weights sum to 1
within each treatment group.  For continuous treatment, standardization will
make all weights sum to 1.  If sampling weights are used, the weight for
each observation is multiplied by the survey sampling weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The
treatment vector used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The covariate matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The model
frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>Convergence value.  Returned from the call to
<code>optim()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The formula
supplied</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>A named vector
of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmasq</code></td>
<td>
<p>The sigma-squared value, for continuous
treatments only</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>The J-statistic at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mle.J</code></td>
<td>
<p>The
J-statistic for the parameters from maximum likelihood estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>The covariance matrix for the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ttilde</code></td>
<td>
<p>For
internal use only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xtilde</code></td>
<td>
<p>For internal use only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.tilde</code></td>
<td>
<p>For internal use only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simgasq.tilde</code></td>
<td>
<p>For internal
use only.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Christian Fong, Marc Ratkovic, Kosuke Imai, and Xiaolin Yang; The
CBPS function is based on the code for version 2.15.0 of the glm function
implemented in the stats package, originally written by Simon Davies.  This
documentation is likewise modeled on the documentation for glm and borrows
its language where the arguments and values are the same.
</p>


<h3>References</h3>

<p>Imai, Kosuke and Marc Ratkovic.  2014. “Covariate Balancing
Propensity Score.” Journal of the Royal Statistical Society, Series B
(Statistical Methodology).
<a href="http://imai.princeton.edu/research/CBPS.html">http://imai.princeton.edu/research/CBPS.html</a> <br> Fong, Christian, Chad
Hazlett, and Kosuke Imai.  2018.  “Covariate Balancing Propensity Score
for a Continuous Treatment.” The Annals of Applied Statistics.
<a href="http://imai.princeton.edu/research/files/CBGPS.pdf">http://imai.princeton.edu/research/files/CBGPS.pdf</a> <br>
Fan, Jianqing and Imai, Kosuke and Liu, Han and Ning, Yang and Yang,
Xiaolin. “Improving Covariate Balancing Propensity Score: A Doubly Robust
and Efficient Approach.” Unpublished Manuscript.
<a href="http://imai.princeton.edu/research/CBPStheory.html">http://imai.princeton.edu/research/CBPStheory.html</a>
</p>


<h3>See Also</h3>

<p>summary.CBPS
</p>


<h3>Examples</h3>

<pre><code class="language-R">
###
### Example: propensity score matching
###

##Load the LaLonde data
data(LaLonde)
## Estimate CBPS
fit &lt;- CBPS(treat ~ age + educ + re75 + re74 + 
			I(re75==0) + I(re74==0), 
			data = LaLonde, ATT = TRUE)
summary(fit)
## Not run: 
## matching via MatchIt: one to one nearest neighbor with replacement
library(MatchIt)
m.out &lt;- matchit(treat ~ fitted(fit), method = "nearest", 
				 data = LaLonde, replace = TRUE)

### Example: propensity score weighting 
###
## Simulation from Kang and Shafer (2007).
set.seed(123456)
n &lt;- 500
X &lt;- mvrnorm(n, mu = rep(0, 4), Sigma = diag(4))
prop &lt;- 1 / (1 + exp(X[,1] - 0.5 * X[,2] + 
			 0.25*X[,3] + 0.1 * X[,4]))
treat &lt;- rbinom(n, 1, prop)
y &lt;- 210 + 27.4*X[,1] + 13.7*X[,2] + 13.7*X[,3] + 13.7*X[,4] + rnorm(n)

##Estimate CBPS with a misspecified model
X.mis &lt;- cbind(exp(X[,1]/2), X[,2]*(1+exp(X[,1]))^(-1)+10, 
			  (X[,1]*X[,3]/25+.6)^3, (X[,2]+X[,4]+20)^2)
fit1 &lt;- CBPS(treat ~ X.mis, ATT = 0)
summary(fit1)
	
## Horwitz-Thompson estimate
mean(treat*y/fit1$fitted.values)
## Inverse propensity score weighting
sum(treat*y/fit1$fitted.values)/sum(treat/fit1$fitted.values)

rm(list=c("y","X","prop","treat","n","X.mis","fit1"))

### Example: Continuous Treatment as in Fong, Hazlett, 
### and Imai (2018).  See 
### https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/AIF4PI
### for a real data example.
set.seed(123456)
n &lt;- 1000
X &lt;- mvrnorm(n, mu = rep(0,2), Sigma = diag(2))
beta &lt;- rnorm(ncol(X)+1, sd = 1)
treat &lt;- cbind(1,X)%*%beta + rnorm(n, sd = 5)

treat.effect &lt;- 1
effect.beta &lt;- rnorm(ncol(X))
y &lt;- rbinom(n, 1, (1 + exp(-treat.effect*treat - 
				   X%*%effect.beta))^-1)

fit2 &lt;- CBPS(treat ~ X)
summary(fit2)
summary(glm(y ~ treat + X, weights = fit2$weights, 
			family = "quasibinomial"))

rm(list=c("n", "X", "beta", "treat", "treat.effect",
		  "effect.beta", "y", "fit2"))

### Simulation example: Improved CBPS (or iCBPS) from Fan et al
set.seed(123456)
n &lt;- 500
X &lt;- mvrnorm(n, mu = rep(0, 4), Sigma = diag(4))
prop &lt;- 1 / (1 + exp(X[,1] - 0.5 * X[,2] + 0.25*X[,3] + 0.1 * X[,4]))
treat &lt;- rbinom(n, 1, prop)
y1 &lt;- 210 + 27.4*X[,1] + 13.7*X[,2] + 13.7*X[,3] + 13.7*X[,4] + rnorm(n)
y0 &lt;- 210 + 13.7*X[,2] + 13.7*X[,3] + 13.7*X[,4] + rnorm(n)
##Estimate iCBPS with a misspecificied model
X.mis &lt;- cbind(exp(X[,1]/2), X[,2]*(1+exp(X[,1]))^(-1)+10, 
			   (X[,1]*X[,3]/25+.6)^3, (X[,2]+X[,4]+20)^2)
fit1 &lt;- CBPS(treat ~ X.mis, baseline.formula=~X.mis[,2:4], 
			 diff.formula=~X.mis[,1], ATT = FALSE)
summary(fit1)

## End(Not run)

</code></pre>


</div>