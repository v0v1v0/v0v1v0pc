<div class="container">

<table style="width: 100%;"><tr>
<td>CKTmatrix.kernel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate the conditional Kendall's tau matrix
at different conditioning points</h2>

<h3>Description</h3>

<p>Assume that we are interested in a random vector <code class="reqn">(X, Z)</code>,
where <code class="reqn">X</code> is of dimension <code class="reqn">d &gt; 2</code> and <code class="reqn">Z</code> is of dimension <code class="reqn">1</code>.
We want to estimate the dependence across the elements of the conditioned vector <code class="reqn">X</code>
given <code class="reqn">Z=z</code>.
This function takes in parameter observations of <code class="reqn">(X,Z)</code>
and returns kernel-based estimators of </p>
<p style="text-align: center;"><code class="reqn">\tau_{i,j | Z=zk}</code>
</p>

<p>which is the conditional Kendall's tau between <code class="reqn">X_i</code> and <code class="reqn">X_j</code>
given to <code class="reqn">Z=zk</code>, for every conditioning point <code class="reqn">zk</code> in <code>gridZ</code>.
If the conditional Kendall's tau matrix has a block structure,
then improved estimation is possible by averaging over the kernel-based estimators of
pairwise conditional Kendall's taus.
Groups of variables composing the same blocks can be defined
using the parameter <code>blockStructure</code>, and the averaging can be set on using
the parameter <code>averaging=all</code>, or <code>averaging=diag</code>
for faster estimation by averaging only over diagonal elements of each block.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CKTmatrix.kernel(
  dataMatrix,
  observedZ,
  gridZ,
  averaging = "no",
  blockStructure = NULL,
  h,
  kernel.name = "Epa",
  typeEstCKT = "wdm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dataMatrix</code></td>
<td>
<p>a matrix of size <code>(n,d)</code> containing <code>n</code> observations of a
<code>d</code>-dimensional random vector <code class="reqn">X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observedZ</code></td>
<td>
<p>vector of observed points of a conditioning variable <code class="reqn">Z</code>.
It must have the same length as the number of rows of <code>dataMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridZ</code></td>
<td>
<p>points at which the conditional Kendall's tau is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>averaging</code></td>
<td>
<p>type of averaging used for fast estimation.
Possible choices are </p>

<ul>
<li> <p><code>no</code>: no averaging;
</p>
</li>
<li> <p><code>all</code>: averaging all Kendall's taus in each block;
</p>
</li>
<li> <p><code>diag</code>: averaging along diagonal blocks elements.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blockStructure</code></td>
<td>
<p>list of vectors.
Each vector corresponds to one group of variables
and contains the indexes of the variables that belongs to this group.
<code>blockStructure</code> must be a partition of <code>1:d</code>,
where <code>d</code> is the number of columns in <code>dataMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>bandwidth. It can be a real, in this case the same <code>h</code>
will be used for every element of <code>gridZ</code>.
If <code>h</code> is a vector then its elements are recycled to match the length of
<code>gridZ</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.name</code></td>
<td>
<p>name of the kernel used for smoothing.
Possible choices are: <code>"Gaussian"</code> (Gaussian kernel)
and <code>"Epa"</code> (Epanechnikov kernel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>array with dimensions depending on <code>averaging</code>:
</p>

<ul>
<li>
<p> If <code>averaging = "no"</code>:
it returns an array of dimensions <code>(n, n, length(gridZ))</code>,
containing the estimated conditional Kendall's tau matrix given <code class="reqn">Z = z</code>.
Here, <code>n</code> is the number of rows in <code>dataMatrix</code>.
</p>
</li>
<li>
<p> If <code>averaging = "all"</code> or <code>"diag"</code>:
it returns an array of dimensions
<code>(length(blockStructure), length(blockStructure), length(gridZ))</code>,
containing the block estimates of the conditional Kendall's tau given <code class="reqn">Z = z</code>
with ones on the diagonal.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Rutger van der Spek, Alexis Derumigny
</p>


<h3>References</h3>

<p>van der Spek, R., &amp; Derumigny, A. (2022).
Fast estimation of Kendall's Tau and conditional Kendall's Tau matrices
under structural assumptions.
<a href="https://arxiv.org/abs/2204.03285">arxiv:2204.03285</a>.
</p>


<h3>See Also</h3>

<p><code>CKT.kernel</code> for kernel-based estimation of conditional Kendall's tau
between two variables (i.e. the equivalent of this function
when <code class="reqn">X</code> is bivariate and <code>d=2</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Data simulation
n = 100
Z = runif(n)
d = 5
CKT_11 = 0.8
CKT_22 = 0.9
CKT_12 = 0.1 + 0.5 * cos(pi * Z)
data_X = matrix(nrow = n, ncol = d)
for (i in 1:n){
  CKT_matrix = matrix(data =
    c(  1      , CKT_11   , CKT_11   , CKT_12[i], CKT_12[i] ,
      CKT_11   ,   1      , CKT_11   , CKT_12[i], CKT_12[i] ,
      CKT_11   , CKT_11   ,    1     , CKT_12[i], CKT_12[i] ,
      CKT_12[i], CKT_12[i], CKT_12[i],   1      , CKT_22    ,
      CKT_12[i], CKT_12[i], CKT_12[i], CKT_22   ,   1
      ) ,
     nrow = 5, ncol = 5)
  sigma = sin(pi * CKT_matrix/2)
  data_X[i, ] = mvtnorm::rmvnorm(n = 1, sigma = sigma)
}
plot(as.data.frame.matrix(data_X))

# Estimation of CKT matrix
h = 1.06 * sd(Z) * n^{-1/5}
gridZ = c(0.2, 0.8)
estMatrixAll &lt;- CKTmatrix.kernel(
  dataMatrix = data_X, observedZ = Z, gridZ = gridZ, h = h)
# Averaging estimator
estMatrixAve &lt;- CKTmatrix.kernel(
  dataMatrix = data_X, observedZ = Z, gridZ = gridZ,
  averaging = "diag", blockStructure = list(1:3,4:5), h = h)

# The estimated CKT matrix conditionally to Z=0.2 is:
estMatrixAll[ , , 1]
# Using the averaging estimator,
# the estimated CKT between the first group (variables 1 to 3)
# and the second group (variables 4 and 5) is
estMatrixAve[1, 2, 1]

# True value (of CKT between variables in block 1 and 2 given Z = 0.2):
0.1 + 0.5 * cos(pi * 0.2)


</code></pre>


</div>