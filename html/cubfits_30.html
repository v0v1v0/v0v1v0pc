<div class="container">

<table style="width: 100%;"><tr>
<td>CUB Model Approximation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Codon Usage Bias Approximation for ORFs without Expression</h2>

<h3>Description</h3>

<p>This function provides codon usage bias approximation with observed ORFs
but without any expressions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  cubappr(reu13.df.obs, phi.pred.Init, y, n,
          nIter = 1000,
          b.Init = NULL, init.b.Scale = .CF.CONF$init.b.Scale,
              b.DrawScale = .CF.CONF$b.DrawScale,
              b.RInit = NULL,
          p.Init = NULL, p.nclass = .CF.CONF$p.nclass,
              p.DrawScale = .CF.CONF$p.DrawScale,
          phi.pred.DrawScale = .CF.CONF$phi.pred.DrawScale,
          model = .CF.CT$model[1], model.Phi = .CF.CT$model.Phi[1],
          adaptive = .CF.CT$adaptive[1],
          verbose = .CF.DP$verbose,
          iterThin = .CF.DP$iterThin, report = .CF.DP$report)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>reu13.df.obs</code></td>
<td>
<p>a <code>reu13.df</code> object, ORFs information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.pred.Init</code></td>
<td>
<p>a <code>phi.Obs</code> object, temporarily initial of expression
without measurement errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a <code>y</code> object, codon counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>a <code>n</code> object, total codon counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p>number of iterations after burn-in iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.Init</code></td>
<td>
<p>initial values for parameters <code>b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.b.Scale</code></td>
<td>
<p>for initial <code>b</code> if <code>b.Init = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code>b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.RInit</code></td>
<td>
<p>initial values (in a list) for <code>R</code> matrices of
parameters <code>b</code> yielding from QR decomposition
of <code>vglm()</code> for the variance-covariance matrix of
<code>b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.Init</code></td>
<td>
<p>initial values for hyper-parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.nclass</code></td>
<td>
<p>number of components for <code>model.Phi = "logmixture"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code>sigma.Phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.pred.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new Phi of predicted set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>model to be fitted, currently "roc" only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.Phi</code></td>
<td>
<p>prior model for Phi, currently "lognormal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>adaptive method of MCMC for proposing new <code>b</code> and
Phi.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print iteration messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterThin</code></td>
<td>
<p>thinning iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>report</code></td>
<td>
<p>number of iterations to report more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Total number of MCMC iterations is <code>nIter + 1</code>, but the
outputs may be thinned to <code>nIter / iterThin + 1</code>
iterations.
</p>
<p>Temporary result dumping may be controlled by <code>.CF.DP</code>.
</p>


<h3>Value</h3>

<p>A list contains three big lists of MCMC traces including:
<code>b.Mat</code> for mutation and selection coefficients of <code>b</code>,
<code>p.Mat</code> for hyper-parameters, and
<code>phi.Mat</code> for expected expression values Phi.
All lists are of length <code>nIter / iterThin + 1</code> and
each element contains the output of each iteration.
</p>
<p>All lists also can be binded as trace matrices, such as via
<code>do.call("rbind", b.Mat)</code> yielding a matrix of dimension number of
iterations by number of parameters. Then, those traces can be analyzed
further via other MCMC packages such as <span class="pkg">coda</span>.
</p>


<h3>Note</h3>

<p>Note that <code>phi.pred.Init</code> need to be normalized to mean 1.
</p>
<p><code>p.DrawScale</code> may cause scaling prior if adaptive MCMC is used, and
it can result in non-exits of equilibrium distribution.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p>DataIO, DataConverting,
<code>cubfits()</code> and <code>cubpred()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

demo(roc.appr, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>


</div>