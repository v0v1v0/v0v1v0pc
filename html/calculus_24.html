<div class="container">

<table style="width: 100%;"><tr>
<td>derivative</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numerical and Symbolic Derivatives</h2>

<h3>Description</h3>

<p>Computes symbolic derivatives based on the <code>D</code> function, or numerical derivatives based on finite differences.
</p>


<h3>Usage</h3>

<pre><code class="language-R">derivative(
  f,
  var,
  params = list(),
  order = 1,
  accuracy = 4,
  stepsize = NULL,
  drop = TRUE,
  deparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>integer vector, giving the differentiation order for each variable. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>if <code>TRUE</code>, return the array of derivatives without adding a dummy dimension when <code>order</code> is of length 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deparse</code></td>
<td>
<p>if <code>TRUE</code>, return <code>character</code> instead of <code>expression</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function behaves differently depending on the arguents <code>order</code>, 
the order of differentiation, and <code>var</code>, the variable names with respect to 
which the derivatives are computed.
</p>
<p>When multiple variables are provided and <code>order</code> is a single integer <code class="reqn">n</code>, 
then the <code class="reqn">n</code>-th order derivative is computed for each element of <code>f</code> 
with respect to each variable:
</p>
<p style="text-align: center;"><code class="reqn">D = \partial^{(n)} \otimes F</code>
</p>

<p>that is:
</p>
<p style="text-align: center;"><code class="reqn">D_{i,\dots,j,k} = \partial^{(n)}_{k} F_{i,\dots,j}</code>
</p>

<p>where <code class="reqn">F</code> is the array of functions and <code class="reqn">\partial_k^{(n)}</code> denotes the 
<code class="reqn">n</code>-th order partial derivative with respect to the <code class="reqn">k</code>-th variable.
</p>
<p>When <code>order</code> matches the length of <code>var</code>, it is assumed that the 
differentiation order is provided for each variable. In this case, each element 
is derived <code class="reqn">n_k</code> times with respect to the <code class="reqn">k</code>-th variable, for each 
of the <code class="reqn">m</code> variables.
</p>
<p style="text-align: center;"><code class="reqn">D_{i,\dots,j} = \partial^{(n_1)}_1\cdots\partial^{(n_m)}_m F_{i,\dots,j}</code>
</p>

<p>The same applies when <code>order</code> is a named vector giving the differentiation 
order for each variable. For example, <code>order = c(x=1, y=2)</code> differentiates 
once with respect to <code class="reqn">x</code> and twice with respect to <code class="reqn">y</code>. A call with 
<code>order = c(x=1, y=0)</code> is equivalent to <code>order = c(x=1)</code>. 
</p>
<p>To compute numerical derivatives or to evaluate symbolic derivatives at a point, 
the function accepts a named vector for the argument <code>var</code>; e.g. 
<code>var = c(x=1, y=2)</code> evaluates the derivatives in <code class="reqn">x=1</code> and <code class="reqn">y=2</code>. 
For <code>functions</code> where the first argument is used as a parameter vector, 
<code>var</code> should be a <code>numeric</code> vector indicating the point at which the 
derivatives are to be calculated.
</p>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). "calculus: High-Dimensional Numerical and Symbolic Calculus in R." Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other derivatives: 
<code>taylor()</code>
</p>
<p>Other differential operators: 
<code>curl()</code>,
<code>divergence()</code>,
<code>gradient()</code>,
<code>hessian()</code>,
<code>jacobian()</code>,
<code>laplacian()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### symbolic derivatives
derivative(f = "sin(x)", var = "x")

### numerical derivatives
f &lt;- function(x) sin(x)
derivative(f = f, var = c(x=0))

### higher order derivatives
f &lt;- function(x) sin(x)
derivative(f = f, var = c(x=0), order = 3)

### multivariate functions 
##  - derive once with respect to x
##  - derive twice with respect to y
##  - evaluate in x=0 and y=0
f &lt;- function(x, y) y^2*sin(x)
derivative(f = f, var = c(x=0, y=0), order = c(1,2))

### vector-valued functions
##  - derive each element twice with respect to each variable
##  - evaluate in x=0 and y=0
f &lt;- function(x, y) c(x^2, y^2)
derivative(f, var = c(x=0, y=0), order = 2)

### vectorized interface
f &lt;- function(x) c(sum(x), prod(x))
derivative(f, var = c(0,0,0), order = 1)

</code></pre>


</div>