<div class="container">

<table style="width: 100%;"><tr>
<td>RFcop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Raftery Copula</h2>

<h3>Description</h3>

<p>The <em>Raftery copula</em> (Nelsen, 2006, p. 172) is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\Theta}(u,v) = \mathbf{RF}(u,v) = \mathbf{M}(u,v) + \frac{1-\Theta}{1+\Theta}\bigl(uv\bigr)^{1/(1-\Theta)}\bigl[1-(\mathrm{max}\{u,v\})^{-(1+\Theta)/(1-\Theta)}\bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">\Theta \in (0,1)</code>. The copula, as <code class="reqn">\Theta \rightarrow 0^{+}</code> limits, to the <em>independence coupla</em> (<code class="reqn">\mathbf{P}(u,v)</code>; <code>P</code>), and as <code class="reqn">\Theta \rightarrow 1^{-}</code>, limits to the <em>comonotonicity copula</em> (<code class="reqn">\mathbf{M}(u,v)</code>;  <code>M</code>). The parameter <code class="reqn">\Theta</code> is readily computed from <em>Spearman Rho</em> (<code>rhoCOP</code>) by <code class="reqn">\rho_\mathbf{C} = \Theta(4-3\Theta)/(2-\Theta)^2</code> or from <em>Kendall Tau</em> (<code>tauCOP</code>) by <code class="reqn">\tau_\mathbf{C} = 2\Theta/(3-\Theta)</code>. However, this copula like others within the <span class="pkg">copBasic</span> package can be reflected (rotated) at will with the <code>COP</code> abstraction layer to acquire negative or inverse dependency (<em>countermonotonicity</em>) (see the <b>Examples</b>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">RFcop(u, v, para=NULL, rho=NULL, tau=NULL, fit=c("rho", "tau"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>A vector (single element) of parametersâ€”the <code class="reqn">\Theta</code> parameter of the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Optional Spearman Rho from which the parameter will be estimated and presence of <code>rho</code> trumps <code>tau</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Optional Kendall Tau from which the parameter will be estimated;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>If <code>para</code>, <code>rho</code>, and <code>tau</code> are all <code>NULL</code>, then the <code>u</code> and <code>v</code> represent the sample. The measure of association by the <code>fit</code> declaration will be computed and the parameter estimated subsequently. The <code>fit</code> has no other utility than to trigger which measure of association is computed internally by the <code>cor</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned. Otherwise if either <code>rho</code> or <code>tau</code> is given, then the <code class="reqn">\Theta</code> is computed and a <code>list</code> having
</p>
<table>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>The parameter <code class="reqn">\Theta</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Spearman Rho if the <code>rho</code> is given; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Kendall Tau if the <code>tau</code> is given but also if both <code>rho</code> and <code>tau</code> are <code>NULL</code> as mentioned next.</p>
</td>
</tr>
</table>
<p>and if <code>para=NULL</code> and <code>rho</code> and <code>tau=NULL</code>, then the values within <code>u</code> and <code>v</code> are used to compute Kendall Tau and then compute the parameter, and these are returned in the aforementioned list.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>M</code>, <code>P</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Lower tail dependency of Theta = 0.5 --&gt; 2*(0.5)/(1+0.5) = 2/3 (Nelsen, 2006, p. 214)
taildepCOP(cop=RFcop, para=0.5)$lambdaL # 0.66667

## Not run: 
# Simulate for a Spearman Rho of 0.7, then extract estimated Theta that internally
# is based on Kendall Tau of U and V, then convert estimate to equivalent Rho.
set.seed(1)
UV &lt;- simCOP(1000, cop=RFcop, RFcop(rho=0.7)$para)
Theta &lt;- RFcop(UV$U, UV$V, fit="tau")$para # 0.607544
Rho   &lt;- Theta*(4-3*Theta)/(2-Theta)^2     # 0.682255 (nearly 0.7) #
## End(Not run)

## Not run: 
set.seed(1)
UV &lt;- simCOP(1000, cop=COP, para=list(cop=RFcop, para=RFcop(rho=0.5)$para, reflect=3))
cor(UV$U, UV$V, method="spearman") # -0.492677 as expected with reversal of V #
## End(Not run)
</code></pre>


</div>