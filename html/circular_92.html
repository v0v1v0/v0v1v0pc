<div class="container">

<table style="width: 100%;"><tr>
<td>lm.circular</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Circular-Circular and Circular-Linear Regression</h2>

<h3>Description</h3>

<p>Fits a regression model for a circular dependent and circular
independent variable or for a circular dependent and linear independent
variables.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">lm.circular(..., type=c("c-c", "c-l"))
lm.circular.cc(y, x, order = 1, level = 0.05, control.circular = list())
lm.circular.cl(y, x, init = NULL, verbose = FALSE, tol = 1e-10, 
  control.circular = list())
## S3 method for class 'lm.circular.cl'
print(x, digits = max(3, getOption("digits") - 3), 
  signif.stars= getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>lm.circular.cc</code> or to
<code>lm.circular.cl</code> depending on the value of <code>type</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>if <code>type=="c-c"</code> then <code>lm.circular.cc</code> is called
otherwise <code>lm.circular.cl</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>vector of data for the dependent circular variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of data for the independent circular variable if
<code>type="c-c"</code> or <code>lm.circular.cc</code> is used otherwise a matrix
or a vector containing the independent linear variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>order of trigonometric polynomial to be fit. Order must be
an integer value.  By default, order=1. Used if <code>type="c-c"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>level of the test for the significance of higher order
trigonometric terms. Used if <code>type="c-c"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>fitted</code>, <code>residuals</code> components in the case of <code>type=="c-c"</code> and <code>mu</code> and <code>se.mu</code>) otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>a vector with initial values of length equal to the columns
of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical: if <code>TRUE</code> messages are printed while the
function is running.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the absolute accuracy to be used to achieve convergence of the
algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally encoded
visually as “significance stars” in order to help scanning of long
coefficient tables. It defaults to the <code>show.signif.stars</code> slot of <code>options</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>type=="c-c"</code> or <code>lm.circular.cc</code> is called directly a
trigonometric polynomial of x is fit against the cosine and sine of y.
The order of trigonometric polynomial is specified by order.  Fitted
values of y are obtained by taking the inverse tangent of the predicted
values of sin(y) divided by the predicted values of cos(y).  Details of
the regression model can be found in Sarma and Jammalamadaka (1993).
</p>
<p>If <code>type=="c-l"</code> or <code>lm.circular.cl</code> is called directly, 
this function implements the homoscedastic version of the maximum 
likelihood regression model proposed by Fisher and Lee (1992). The 
model assumes that a circular response variable theta has a von Mises 
distribution with concentration parameter kappa, and mean direction 
related to a vector of linear predictor variables according to the 
relationship: mu + 2*atan(beta'*x), where mu and beta are unknown 
parameters, beta being a vector of regression coefficients. The 
function uses Green's (1984) iteratively reweighted least squares 
algorithm to perform the maximum likelihood estimation of kappa, mu, 
and beta. Standard errors of the estimates of kappa, mu, and beta are 
estimated via large-sample asymptotic variances using the information 
matrix. An estimated circular standard error of the estimate of mu is 
then obtained according to Fisher and Lewis (1983, Example 1). 
</p>


<h3>Value</h3>

<p>If <code>type=="c-c"</code> or <code>lm.circular.cc</code> is called directly an
object of class <code>lm.circular.cc</code> is returned with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the <code>match.call</code> result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>square root of the average of the squares of the estimated
conditional concentration parameters of y given x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>fitted values of the model of class <code>circular</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>matrix whose columns correspond to x and y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>circular residuals of the model of class <code>circular</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>matrix whose entries are the estimated coefficients of the
model. The first column corresponds to the coefficients of the model predicting
the cosine of y, while the second column contains the estimates for the model
predicting the sine of y.  The rows of the matrix correspond to the coefficients
according to increasing trigonometric order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.values</code></td>
<td>
<p>p-values testing whether the (order + 1) trigonometric terms are
significantly different from zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.k</code></td>
<td>
<p>is mean of the cosines of the circular residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>assuming the circular residuals come from a von Mises
distribution, kappa is the MLE of the concentration parameter.</p>
</td>
</tr>
</table>
<p>If <code>type=="c-l"</code> or <code>lm.circular.cl</code> is called directly an
object of class <code>lm.circular.cc</code> is returned with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the <code>match.call</code> result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the independent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the dependent variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>the circular mean of the dependent variable of class <code>circular</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.mu</code></td>
<td>
<p>an estimated standard error of the circular mean with the same units of measure used for <code>mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>the concentration parameter for the dependent variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.kappa</code></td>
<td>
<p>an estimated standard error of the concentration parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the estimated coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.coef</code></td>
<td>
<p>covariance matrix of the estimated coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.coef</code></td>
<td>
<p>standard errors of the estimated coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.lik</code></td>
<td>
<p>log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.values</code></td>
<td>
<p>values of the t statistics for the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.values</code></td>
<td>
<p>p-values of the t statistics. Approximated values using
Normal distribution.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Fisher, N. and Lee, A. (1992). Regression models for an angular response. 
Biometrics, 48, 665-677. 
</p>
<p>Fisher, N. and Lewis, T. (1983). Estimating the common mean direction of 
several circular or spherical distributions with different dispersions. 
Biometrika, 70, 333-341. 
</p>
<p>Green, P. (1984). Iteratively reweighted least squares for maximum 
likelihood estimation, and some robust and resistant alternatives. 
Journal of the Royal Statistical Society, B, 46, 149-192. 
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics,
Section 8.3, World Scientific Press, Singapore.
</p>
<p>Sarma, Y. and Jammalamadaka, S. (1993).  Circular Regression.  Statistical
Science and Data Analysis, 109-128.  Proceeding of the Thrid Pacific Area
Statistical Conference.  VSP: Utrecht, Netherlands.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate a data set of dependent circular variables.
x &lt;- circular(runif(50, 0, 2*pi))
y &lt;- atan2(0.15*cos(x) + 0.25*sin(x), 0.35*sin(x)) + 
  rvonmises(n=50, mu=circular(0), kappa=5)

# Fit a circular-circular regression model.
circ.lm &lt;- lm.circular(y, x, order=1)
# Obtain a crude plot of the data and fitted regression line.
plot.default(x, y)
circ.lm$fitted[circ.lm$fitted&gt;pi] &lt;- circ.lm$fitted[circ.lm$fitted&gt;pi] - 2*pi 
points.default(x[order(x)], circ.lm$fitted[order(x)], type='l')

# Fit a circular-linear regression model and show predictions.
set.seed(1234)
x &lt;- cbind(rnorm(10), rep(1, 10))
x &lt;- cbind(rnorm(10), rep(1,10))
y &lt;- circular(2*atan(c(x%*%c(5,1))))+rvonmises(10, mu=circular(0), kappa=100)
lm.circular(y=y, x=x, init=c(5,1), type='c-l', verbose=TRUE)
plot(y)
lmC &lt;- lm.circular(y=y, x=x, init=c(5,1), type='c-l', verbose=TRUE)
p &lt;- circular(lmC$mu+2*atan(x%*%lmC$coefficients))
points(p, col=2, pch= "+")
</code></pre>


</div>