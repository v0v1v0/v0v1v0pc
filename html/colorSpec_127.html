<div class="container">

<table style="width: 100%;"><tr>
<td>ptransform</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>make a linear transformation to a colorSpec responder</h2>

<h3>Description</h3>

<p>apply a linear transformation to a <b>colorSpec</b> responder with M spectra,
so that multiples of M given <em>primary</em> vectors
are transformed to the standard basis of <code class="reqn">R^M</code>.
And a given <em>white</em> vector is transformed to the M-vector of all 1s.<br>
The returned object is always
<code>multiply(x,A)</code> where  <code>A</code> is an internally calculated MxM matrix.
The name <code>ptransform</code> is short for <em>projective transformation</em>.<br>
In case of ERROR, a message is logged and NULL returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'colorSpec'
ptransform( x, primary, white, digits=Inf )

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <b>colorSpec</b> responder with M spectra.  
<code>type(x)</code> must be <code>'responsivity.light'</code> or <code>'responsivity.material'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>primary</code></td>
<td>
<p>an MxM matrix whose rows define the M primary vectors
in the response space of <code>x</code>.
It is OK for each row to have a single value that is NA.
In this case the NA value is changed so that the sum of the row is 1.
This is done because typically the rows represent chromaticities
in the response space of <code>x</code>.
After this change, the rows of <code>primary</code> must form a basis of <code class="reqn">R^M</code>.<br><code>rownames(primary)</code> must be defined; when M=3 they are typically
<code>c('R','G','B')</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>white</code></td>
<td>
<p>an M-vector in the response space of <code>x</code>,
that is typically the ideal white point of a color display.
When <code>white</code> is expressed in the basis defined by <code>primary</code>,
the coordinates must all be non-zero.<br><code>white</code> can also be a <b>colorSpec</b> object with a single spectrum
suitable as stimulus for <code>x</code>;
in this case the vector <code>white</code> is set to
<code> product( white, x, wavelength='auto' )</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>if a positive integer,
then <code>white</code> is rounded to this number of decimal digits,
but in a non-standard way, see <b>Details</b>.  
This is typically done so the internally calculated MxM matrix <code>A</code> agrees
with that from a color standard, see <b>Examples</b>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The formal mathematical requirements for <code>primary</code> and <code>white</code> are:
</p>
 
<ul>
<li>
<p> The rows of <code>primary</code> must form a basis of <code class="reqn">R^M</code>.
Equivalently, if <code class="reqn">P</code> denotes the matrix <code>primary</code>,
then <code class="reqn">P</code> is invertible.
</p>
</li>
<li>
<p> The coordinates of <code>white</code> in this basis are all non-zero.
Equivalently, if <code class="reqn">x</code> is the solution of <code class="reqn"> x P = white</code>,
then every component of x is non-zero.
</p>
</li>
</ul>
<p>Assuming both of these are true, then there is a unique matrix <code class="reqn">A</code> so that
</p>
 
<ul>
<li> <p><code class="reqn">A</code> transforms a multiple of the <code class="reqn">i</code>'th row of <code class="reqn">P</code> to the <code class="reqn">i</code>'th
standard basis vector of <code class="reqn">R^M</code>.
</p>
</li>
<li> <p><code class="reqn">A</code> transforms <code>white</code> to the M-vector of all 1s.
</p>
</li>
</ul>
<p>This statement is essentially the fundamental theorem of (analytic) projective geometry;
see <em>Bumcrot</em> page 87, and <em>Semple</em> page 398.
The rows of <code class="reqn">P</code> plus <code class="reqn">white</code> define a <em>projective frame</em>;
the former are the <em>fundamental points</em> and the latter is the <em>unit point</em>.
</p>
<p>If <code>digits</code> is a positive integer,
the chromaticity of <code>white</code> is computed by dividing <code>white</code> by <code>sum(white)</code>.
The latter must be non-zero, or else it is an ERROR.
This chromaticity is rounded to <code>digits</code> decimal digits, while preserving the sum of 1.
This <em>rounded chromaticity</em> is non-zero, and defines a line through 0.
The vector <code>white</code> is projected onto this line to get the new and rounded <code>white</code>,
with the rounded chromaticity.
See <b>Examples</b>.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object equal to <code>multiply(x,A)</code> 
where <code>A</code> is an internally calculated MxM matrix.  
The <code>quantity</code> and <code>wavelength</code> are preserved.
The <code>specnames</code> of the returned object are set to <code>tolower( rownames(primary) )</code>.<br>
The user may want to change the <code>quantity</code> of the returned object;
see <b>Examples</b>.
</p>


<h3>References</h3>

<p>Bumcrot, Robert J.
<b>Modern Projective Geometry</b>.
Holt, Rinehart, and Winston. 1969.
</p>
<p>IEC 61966-2-1:1999.
Multimedia systems and equipment - Colour measurement and management.
Part 2-1: Colour management - Default RGB colour space - sRGB.
<a href="https://webstore.iec.ch/publication/6169">https://webstore.iec.ch/publication/6169</a>
</p>
<p>Semple, J. G. and G. T. Kneebone.
<b>Algebraic Projective Geometry</b>.
Oxford. 1952.
</p>


<h3>See Also</h3>

<p><code>quantity</code>,
<code>wavelength</code>,
<code>colorSpec</code>,
<code>multiply</code>,
<code>product</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">############ Example for sRGB   ###########

# assign the standard sRGB primaries
P = matrix( c(0.64,0.33,NA,  0.3,0.6,NA, 0.15,0.06,NA ), 3, 3, byrow=TRUE )
rownames(P) = c('R','G','B')
P
#   [,1] [,2] [,3]
# R 0.64 0.33   NA
# G 0.30 0.60   NA
# B 0.15 0.06   NA

white = product( D65.1nm, xyz1931.1nm, wave='auto' )
white
#           X        Y        Z
# D65 100.437 105.6708 115.0574

white/sum(white)
#             X         Y         Z
# D65 0.3127269 0.3290232 0.3582499    

# But the sRGB standard D65 is xy=(0.3127,0.3290)
# so when the next line is executed,
# the calculated 3x3 matrix will *NOT* agree with the sRGB standard
y = ptransform( xyz1931.1nm, P, white, digits=Inf )

product( D65.1nm, y, wave='auto' )
#     R G B
# D65 1 1 1      # this is exactly what we want, but the internal 3x3 matrix is a little off

# now repeat, but this time round the white chromaticity to
# xy=(0.3127,0.3290) in order to get the matrix right
y = ptransform( xyz1931.1nm, P, white, digits=4 )

rgb = product( D65.1nm, y, wave='auto' )
rgb
#            R        G        B
# D65 1.000238 1.000053 0.999835   # off in the 4'th digit  (WARN: this is linear RGB)

255 * rgb
#            R        G        B
# D65 255.0607 255.0134 254.9579   # good enough for 8-bit RGB

65535 * rgb
#            R        G        B
# D65 65550.59 65538.44 65524.18   # NOT good enough for 16-bit RGB  

# So for 16-bit RGB, one can get the white RGB right, or the 3x3 matrix right, but not both !


############ Example for ProPhoto RGB   ###########

# assign the standard ProPhoto RGB primaries
P = matrix( c(0.7347,0.2653,NA,  0.1596,0.8404,NA, 0.0366,0.0001,NA ), 3, 3, byrow=TRUE )
rownames(P) = c('R','G','B')
P
#     [,1]   [,2] [,3]
# R 0.7347 0.2653   NA
# G 0.1596 0.8404   NA
# B 0.0366 0.0001   NA

white = product( D50.5nm, xyz1931.5nm, wave='auto' )
white
#            X       Y        Z
# D50 101.2815 105.042 86.67237

white / sum(white)
#             X         Y         Z
# D50 0.3456755 0.3585101 0.2958144  

# but the ProPhoto RGB standard is xy=(0.3457,0.3585);  proceed anyway
y = ptransform( xyz1931.5nm, P, white, digits=Inf )

product( D50.5nm, y, wave='auto' )
#     R G B
# D50 1 1 1     #  this is exactly what we want, but the internal 3x3 matrix is a little off

# the following line is an equivalent way to compute y.
# pass D50.5nm directly as the 'white' argument
y = ptransform( xyz1931.5nm, P, D50.5nm )
</code></pre>


</div>