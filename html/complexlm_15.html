<div class="container">

<table style="width: 100%;"><tr>
<td>mahalanobis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mahalanobis Distance, with better complex behavior</h2>

<h3>Description</h3>

<p>The Mahalanobis distance function included in the <code>stats</code> package returns a complex number when given complex values of <code>x</code>.
But a distance (and thus its square) is always positive real. This function calculates the Mahalanobis distance using
the conjugate transpose if given complex data, otherwise it calls stats::mahalanobis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mahalanobis(x, center, cov, pcov = NULL, inverted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A length <code class="reqn">p</code> vector or matrix with row length <code class="reqn">p</code>. Or, a length <code class="reqn">2p</code> vector or matrix with row length <code class="reqn">2p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>A vector of length equal to that of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>The covariance matrix <code class="reqn">(p x p)</code> of the distribution. Or, the "double covariance matrix" of the distribution, which contains the information from <code>cov</code> and <code>pcov</code> in a single <code class="reqn">(2p x 2p)</code> matrix.
Can be generated by matrixweave, vcov.zlm, or vcov.rzlm.
vcov.rzlm].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcov</code></td>
<td>
<p>The pseudo covariance matrix <code class="reqn">(p x p)</code> of the distribution. Optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverted</code></td>
<td>
<p>Boolean, if TRUE, <code>cov</code> and <code>pcov</code> are not taken to be the <em>inverse</em> covariance and pseudo covariance matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments to be passed to solve, which is used for computing the inverse of <code>cov</code>. If <code>inverted = TRUE</code>, unused.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depending on the relative sizes of <code>x</code>, <code>cov</code>, and <code>pcov</code>, the function will perform slightly different calculations. If <code>pcov</code> is not included,
the Mahalanobis distance is calculated using only <code>cov</code>. In this case if the dimension of <code>cov</code> is twice that of <code>x</code>, <code>x</code> is interleaved with its complex conjugate
so that it becomes the same length as <code>cov</code>. Note that in this case the resulting Mahalanobis distance will only incorporate information about the interactions between
the real and imaginary components if the "double covariance matrix is given as <code>cov</code> . If <code>pcov</code> is included in the input, <code>pcov</code> and <code>cov</code> are interleaved to form the "double covariance", and this is used to
calculate the Mahalanobis distance, interleaving <code>x</code> if necessary. This gives the user a great deal of flexibility when it comes to input.
</p>


<h3>Value</h3>

<p>numeric. The squared Mahalanobis distance (divergence) between <code>x</code> and <code>center</code>.
</p>


<h3>References</h3>

<p>D. Dai and Y. Liang, High-Dimensional Mahalanobis Distances of Complex Random Vectors, Mathematics 9, 1877 (2021).
</p>


<h3>See Also</h3>

<p>matrixweave
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(4242)
n &lt;- 8
x &lt;- matrix(complex(real = rnorm(n), imaginary = rnorm(n)), ncol = 2)
mu &lt;- complex(real = 1.4, imaginary = 0.4)
sigma &lt;- 3.4
mahalanobis(x, mu, sigma * diag(2))
</code></pre>


</div>