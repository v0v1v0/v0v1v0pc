<div class="container">

<table style="width: 100%;"><tr>
<td>cnlt.reg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Performs 'nondecimated' complex-valued wavelet lifting for signal denoising
</h2>

<h3>Description</h3>

<p>The transform-threshold-invert procedure for signal denoising is dependent on the trajectory (lifting order) used in the forward lifting transform.  This procedure uses trajectory bootstrapping and averaging of estimates to gain denoising performance
</p>


<h3>Usage</h3>

<pre><code class="language-R">cnlt.reg(x, f, P, returnall = FALSE, nkeep = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of any length (not necessarily equally spaced) that gives the grid on which the signal is
observed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Vector of the same length as <code>x</code> that gives the signal values corresponding to the
<code>x</code>-locations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>

<p>Number of trajectories to be used by the nondecimated lifting algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nkeep</code></td>
<td>

<p>Number of scaling points we want at the end of the transform. The usual choice is <code>nkeep</code>=2.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other arguments to be passed to <code>denoisepermC</code>, see the function documentation for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Essentially, this function applies the complex wavelet lifting
denoising procedure <code>denoisepermC</code> <span class="env">P</span> times, each with a different random lifting trajectory. 
This results in <span class="env">P</span> estimates of the (unknown) true
signal. The average of these estimators is the proposed estimator.
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>,
a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>vec</code></td>
<td>
<p>A matrix of dimension <code>P x (n - nkeep)</code>, each row corresponding to a different lifting trajectory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aveghat</code></td>
<td>
<p>Estimated signal after removing the noise.</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>Using a large number of trajectories for long datasets could take a long time!</p>


<h3>Author(s)</h3>

<p>Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applicati$
<em>Technometrics</em>, bold60 (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br><br>
For the real-valued equivalent procedure, see also<br>
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1â€“16.
</p>


<h3>See Also</h3>

<p><code>denoisepermCh</code>,
<code>fwtnppermC</code>,
<code>mthreshC</code>,
<code>nlt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> 
    library(adlift)

    # construct an (irregular) observation grid
     x&lt;-runif(256) 
     
     #construct the true, normally unknown, signal
     g&lt;-make.signal2("blocks",x=x) 
     
     #generate noise with mean 0 and signal-to-noise ratio 5
     noise&lt;-rnorm(256,mean=0,sd=sqrt(var(g))/5)
     
     #generate a noisy version of g 
     f&lt;-g+noise 
     
     #decide on a number of random trajectories to be used (e.g. J=5 below), and apply
     # the nondecimated lifting transform to the noisy signal (x,f): 
## Not run: 
     est&lt;-cnlt.reg(x,f,P=50,LocalPred=AdaptPred,neighbours=1,returnall=FALSE) 

## End(Not run)
</code></pre>


</div>