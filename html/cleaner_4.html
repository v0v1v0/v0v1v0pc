<div class="container">

<table style="width: 100%;"><tr>
<td>clean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clean column data to a class</h2>

<h3>Description</h3>

<p>Use any of these functions to quickly clean columns in your data set. Use <code>clean()</code> to pick the functions that return the least relative number of <code>NA</code>s. They <strong>always</strong> return the class from the function name (e.g. <code>clean_Date()</code> always returns class <code>Date</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">clean(x)

## S3 method for class 'data.frame'
clean(x)

clean_logical(
  x,
  true = regex_true(),
  false = regex_false(),
  na = NULL,
  fixed = FALSE,
  ignore.case = TRUE
)

clean_factor(
  x,
  levels = unique(x),
  ordered = FALSE,
  droplevels = FALSE,
  fixed = FALSE,
  ignore.case = TRUE
)

clean_numeric(x, remove = "[^0-9.,-]", fixed = FALSE)

clean_double(x, remove = "[^0-9.,-]", fixed = FALSE)

clean_integer(x, remove = "[^0-9.,-]", fixed = FALSE)

clean_character(
  x,
  remove = "[^a-z \t\r\n]",
  fixed = FALSE,
  ignore.case = TRUE,
  trim = TRUE
)

clean_currency(x, currency_symbol = NULL, remove = "[^0-9.,-]", fixed = FALSE)

clean_percentage(x, remove = "[^0-9.,-]", fixed = FALSE)

clean_Date(x, format = NULL, guess_each = FALSE, max_date = Sys.Date(), ...)

clean_POSIXct(
  x,
  tz = "",
  remove = "[^.0-9 :/-]",
  fixed = FALSE,
  max_date = Sys.Date(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data to clean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>true</code></td>
<td>
<p>regex to interpret values as <code>TRUE</code> (which defaults to <code>regex_true</code>), see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>false</code></td>
<td>
<p>regex to interpret values as <code>FALSE</code> (which defaults to <code>regex_false</code>), see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na</code></td>
<td>
<p>regex to force interpret values as <code>NA</code>, i.e. not as <code>TRUE</code> or <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>logical to indicate whether regular expressions should be turned off</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>logical to indicate whether matching should be case-insensitive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>new factor levels, may be named with regular expressions to match existing values, see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>logical to indicate whether the factor levels should be ordered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>droplevels</code></td>
<td>
<p>logical to indicate whether non-existing factor levels should be dropped</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove</code></td>
<td>
<p>regex to define the character(s) that should be removed, see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>logical to indicate whether the result should be trimmed with <code>trimws(..., which = "both")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>currency_symbol</code></td>
<td>
<p>the currency symbol to use, which will be guessed based on the input and otherwise defaults to the current system locale setting (see <code>Sys.localeconv</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>character string giving a date-time format as used by strptime. 
</p>
<p>For <code>clean_Date(..., guess_each = TRUE)</code>, this can be a vector of values to be used for guessing, see Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guess_each</code></td>
<td>
<p>logical to indicate whether all items of <code>x</code> should be guessed one by one, see Examples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_date</code></td>
<td>
<p>date (coercible with [as.Date()]) to indicate to maximum allowed of <code>x</code>, which defaults to today. This is to prevent that <code>clean_Date("23-03-47")</code> will return 23 March 2047 and instead returns 23 March 1947 with a warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for <code>clean_Date</code> and <code>clean_POSIXct</code>: other parameters passed on these functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tz</code></td>
<td>
<p>time zone specification to be used for the conversion,
<em>if one is required</em>.  System-specific (see time zones),
but <code>""</code> is the current time zone, and <code>"GMT"</code> is UTC
(Universal Time, Coordinated).  Invalid values are most commonly
treated as UTC, on some platforms with a warning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Using <code>clean()</code> on a vector will guess a cleaning function based on the potential number of <code>NAs</code> it returns. Using <code>clean()</code> on a data.frame to apply this guessed cleaning over all columns.
</p>
<p>Info about the different functions:
</p>

<ul>
<li>
<p><code>clean_logical()</code>:<br>Use parameters <code>true</code> and <code>false</code> to match values using case-insensitive regular expressions (regex). Unmatched values are considered <code>NA</code>. At default, values are matched with <code>regex_true</code> and <code>regex_false</code>. This allows support for values "Yes" and "No" in the following languages: Arabic, Bengali, Chinese (Mandarin), Dutch, English, French, German, Hindi, Indonesian, Japanese, Malay, Portuguese, Russian, Spanish, Telugu, Turkish and Urdu. Use parameter <code>na</code> to override values as <code>NA</code> that would else be matched with <code>true</code> or <code>false</code>. See Examples.
</p>
</li>
<li>
<p><code>clean_factor()</code>:<br>Use parameter <code>levels</code> to set new factor levels. They can be case-insensitive regular expressions to match existing values of <code>x</code>. For matching, new values for <code>levels</code> are internally temporary sorted descending on text length. See Examples.
</p>
</li>
<li>
<p><code>clean_numeric()</code>, <code>clean_double()</code>, <code>clean_integer()</code> and <code>clean_character()</code>:<br>Use parameter <code>remove</code> to match values that must be removed from the input, using regular expressions (regex). In case of <code>clean_numeric()</code>, comma's will be read as dots and only the last dot will be kept. Function <code>clean_character()</code> will keep middle spaces at default. See Examples.
</p>
</li>
<li>
<p><code>clean_percentage()</code>:<br>This new class works like <code>clean_numeric()</code>, but transforms it with <code>as.percentage</code>, which will retain the original values, but will print them as percentages. See Examples. 
</p>
</li>
<li>
<p><code>clean_currency()</code>:<br>This new class works like <code>clean_numeric()</code>, but transforms it with <code>as.currency</code>. The currency symbol is guessed based on the most traded currencies by value (see Source): the United States dollar, Euro, Japanese yen, Pound sterling, Swiss franc, Renminbi, Swedish krona, Mexican peso, South Korean won, Turkish lira, Russian ruble, Indian rupee and the South African rand. See Examples.
</p>
</li>
<li>
<p><code>clean_Date()</code>:<br>Use parameter <code>format</code> to define a date format, or leave it empty to have the format guessed. Use <code>"Excel"</code> to read values as Microsoft Excel dates. The <code>format</code> parameter will be evaluated with <code>format_datetime</code>, which means that a format like <code>"d-mmm-yy"</code> with be translated internally to <code>"%e-%b-%y"</code> for convenience. See Examples.
</p>
</li>
<li>
<p><code>clean_POSIXct()</code>:<br>Use parameter <code>remove</code> to match values that must be removed from the input, using regular expressions (regex). The resulting string will be coerced to a date/time element with class <code>POSIXct</code>, using <code>as.POSIXct()</code>. See Examples.
</p>
</li>
</ul>
<p>The use of invalid regular expressions in any of the above functions will not return an error (like in base R), but will instead interpret the expression as a fixed value and will throw a warning.
</p>


<h3>Value</h3>

<p>The <code>clean_*</code> functions <strong>always</strong> return the class from the function name:
</p>

<ul>
<li>
<p><code>clean_logical()</code>: class <code>logical</code>
</p>
</li>
<li>
<p><code>clean_factor()</code>: class <code>factor</code>
</p>
</li>
<li>
<p><code>clean_numeric()</code> and <code>clean_double()</code>: class <code>numeric</code>
</p>
</li>
<li>
<p><code>clean_integer()</code>: class <code>integer</code>
</p>
</li>
<li>
<p><code>clean_character()</code>: class <code>character</code>
</p>
</li>
<li>
<p><code>clean_percentage()</code>: class <code>percentage</code>
</p>
</li>
<li>
<p><code>clean_currency()</code>: class <code>currency</code>
</p>
</li>
<li>
<p><code>clean_Date()</code>: class <code>Date</code>
</p>
</li>
<li>
<p><code>clean_POSIXct()</code>: classes <code>POSIXct/POSIXt</code>
</p>
</li>
</ul>
<h3>Source</h3>

<p><a href="https://www.bis.org/publ/rpfx16fx.pdf">Triennial Central Bank Survey Foreign exchange turnover in April 2016</a> (PDF). Bank for International Settlements. 11 December 2016. p. 10.
</p>


<h3>Examples</h3>

<pre><code class="language-R">clean_logical(c("Yes", "No"))   # English
clean_logical(c("Oui", "Non"))  # French
clean_logical(c("ya", "tidak")) # Indonesian
clean_logical(x = c("Positive", "Negative", "Unknown", "Some value"),
              true = "pos", false = "neg")

gender_age &lt;- c("male 0-50", "male 50+", "female 0-50", "female 50+")
clean_factor(gender_age, c("M", "F"))
clean_factor(gender_age, c("Male", "Female"))
clean_factor(gender_age, c("0-50", "50+"), ordered = TRUE)

clean_Date("13jul18", "ddmmmyy")
clean_Date("12 August 2010")
clean_Date("12 06 2012")
clean_Date("October 1st 2012")
clean_Date("43658")
clean_Date("14526", "Excel")
clean_Date(c("1 Oct 13", "October 1st 2012")) # could not be fitted in 1 format
clean_Date(c("1 Oct 13", "October 1st 2012"), guess_each = TRUE)
clean_Date(c("12-14-13", "1 Oct 2012"), 
           guess_each = TRUE,
           format = c("d mmm yyyy", "mm-yy-dd")) # only these formats will be tried

clean_POSIXct("Created log on 2020/02/11 11:23 by user Joe")
clean_POSIXct("Created log on 2020.02.11 11:23 by user Joe", tz = "UTC")

clean_numeric("qwerty123456")
clean_numeric("Positive (0.143)")
clean_numeric("0,143")
clean_numeric("minus 12 degrees")

clean_percentage("PCT: 0.143")
clean_percentage(c("Total of -12.3%", "Total of +4.5%"))

clean_character("qwerty123456")
clean_character("Positive (0.143)")

clean_currency(c("Received 25", "Received 31.40"))
clean_currency(c("Jack sent £ 25", "Bill sent £ 31.40"))

df &lt;- data.frame(A = c("2 Apr 2016", "5 Feb 2020"), 
                 B = c("yes", "no"),
                 C = c("Total of -12.3%", "Total of +4.5%"),
                 D = c("Marker: 0.4513 mmol/l", "Marker: 0.2732 mmol/l"))
df
clean(df)
</code></pre>


</div>