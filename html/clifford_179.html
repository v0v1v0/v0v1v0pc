<div class="container">

<table style="width: 100%;"><tr>
<td>signature</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The signature of the Clifford algebra</h2>

<h3>Description</h3>

<p>Getting and setting the signature of the Clifford algebra</p>


<h3>Usage</h3>

<pre><code class="language-R">signature(p,q=0)
is_ok_sig(s)
showsig(s)
## S3 method for class 'sigobj'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s,p,q</code></td>
<td>
<p>Integers, specifying number of positive elements on the
diagonal of the quadratic form, with <code>s=c(p,q)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>sigobj</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td>
</tr>
</table>
<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>The signature functionality is modelled on <code>lorentz::sol()</code> which
gets and sets the speed of light.
</p>
<p>Clifford algebras require a bilinear form on \(\mathbb{R}^n\)
\(\left\langle\cdot,\cdot\right\rangle\), usually written
</p>
\[\left\langle{\mathbf x},{\mathbf x}\right\rangle=x_1^2+x_2^2+\cdots
  +x_p^2-x_{p+1}^2-\cdots -x_{p+q}^2
\]
<p>where \(p+q=n\).  With this quadratic form the vector space
is denoted \(\mathbb{R}^{p,q}\) and we say that
\((p,q)\) is the <dfn>signature</dfn> of the bilinear form
\(\left\langle\cdot,\cdot\right\rangle\).  This gives rise to
the Clifford algebra \(C_{p,q}\).
</p>
<p>If the signature is \((p,q)\), then we have
</p>
\[
  e_i e_i =   +1\, (\mbox{if } 1\leq i\leq p), 
              -1\, (\mbox{if } p+1\leq i\leq p+q),
               0\, (\mbox{if } i&gt;p+q).
  \]
<p>Note that \((p,0)\) corresponds to a positive-semidefinite
quadratic form in which \(e_ie_i=+1\) for all \(i\leq
p\) and \(e_ie_i=0\) for all \(i &gt; p\).
Similarly, \((0,q)\) corresponds to a negative-semidefinite
quadratic form in which \(e_ie_i=-1\) for all \(i\leq
q\) and \(e_ie_i=0\) for all \(i &gt; q\).
</p>
<p>Package idiom for a strictly positive-definite quadratic form would be
to specify infinite \(p\) [in which case \(q\) is irrelevant]
and for a strictly negative-definite quadratic form we would need
\(p=0,q=\infty\).
</p>
<p>If we specify \(e_ie_i=0\) for all \(i\), then the
operation reduces to the wedge product of a Grassman algebra.  Package
idiom for this is to set \(p=q=0\), but this is not recommended:
use the <span class="pkg">stokes</span> package for Grassman algebras, which is much more
efficient and uses nicer idiom.
</p>
<p>Function <code>signature(p,q)</code> returns the signature silently; but
setting option <code>show_signature</code> to <code>TRUE</code> makes
<code>signature()</code> have the side-effect of calling <code>showsig()</code>,
which changes the default prompt to display the signature, much like
<code>showSOL</code> in the <code>lorentz</code> package.  There is special
dispensation for “infinite” \(p\) or \(q\).
</p>
<p>Calling <code>signature()</code> [that is, with no arguments] returns an
object of class <code>sigobj</code> with elements corresponding to <code class="reqn">p</code> and
<code class="reqn">q</code>.  The <code>sigobj</code> class ensures that a near-infinite integer
such as <code>.Machine$integer.max</code> will be printed as
“<code>Inf</code>” rather than, for example,
“<code>2147483647</code>”.
</p>
<p>Function <code>is_ok_sig()</code> is a helper function that checks for a
proper signature.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">

signature()

e(1)^2
e(2)^2

signature(1)
e(1)^2
e(2)^2   # note sign

signature(3,4)
sapply(1:10,function(i){drop(e(i)^2)})


signature(Inf)   # restore default




# Nice mapping from Cl(0,2) to the quaternions (loading clifford and
# onion simultaneously is discouraged):

# library("onion")
# signature(0,2)
# Q1 &lt;- rquat(1)
# Q2 &lt;- rquat(1)
# f &lt;- function(H){Re(H)+i(H)*e(1)+j(H)*e(2)+k(H)*e(1:2)}
# f(Q1)*f(Q2) - f(Q1*Q2) # zero to numerical precision
# signature(Inf)

</code></pre>


</div>