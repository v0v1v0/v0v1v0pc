<div class="container">

<table style="width: 100%;"><tr>
<td>crossvalidationCP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation in change-point regression</h2>

<h3>Description</h3>

<p>Generic function for cross-validation to select tuning parameters in change-point regression. It selects among a list of parameters the one with the smallest cross-validation criterion for a given method. The cross-validation criterion, the estimator, and the the folds can be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">crossvalidationCP(Y, param = 5L, folds = 5L, estimator = leastSquares,
                  criterion = criterionL1loss,
                  output = c("param", "fit", "detailed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>the observations, can be any data type that supports the function <code>length</code> and the operator <code>[]</code> and can be passed to <code>estimator</code> and <code>criterion</code>, e.g. a numeric vector or a list. Support for <code>matrices</code>, i.e. for multivariate data, is planned but not implemented so far</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>a <code>list</code> giving the possible tuning parameters. Alternatively, a single integer which will be interpreted as the maximal number of change-points and converted to <code>as.list(0:param)</code>. All values have to be acceptable values for the specified <code>estimator</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>either a <code>list</code>, a single integer or the string <code>"COPPS"</code> specifying the folds. If a <code>list</code>, each entry should be an integer vector with values between <code>1</code> and <code>length(Y)</code> giving the indices of the observations in the fold. A single integer specifies the number of folds and ordered folds are automatically created, i.e. fold <code>i</code> will be <code>seq(i, length(Y), folds)</code>. <code>"COPPS"</code> means that a generalised <abbr><span class="acronym">COPPS</span></abbr> procedure <cite>Zou et al. (2020)</cite> will be used, i.e. 2-fold cross-validation with Order-Preserved Sample-Splitting, meaning that the folds will be the odd and even indexed observations. Note that observations will be given in reverse order to the cross-validation criterion when the odd-indexed observations are in the test set. This allows criteria such as the modified criterion, where for the odd-indexed the first and for the even-indexed the last observation is removed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>a function providing a local estimate. For pre-implemented estimators see estimators. The function must have the arguments <code>Y</code>, <code>param</code> and <code>...</code>, where <code>Y</code> will be a subset of the observations, and <code>param</code> and <code>...</code> will be the corresponding arguments of the called function. Note that <code>...</code> will be passed to <code>estimator</code> and <code>criterion</code>. The return value must be either a list of length <code>length(param)</code> with each entry containing the estimated change-point locations for the given entry in <code>param</code> or a list containing the named entries <code>cps</code> and <code>value</code>. In this case <code>cps</code> has to be a list of the estimated change-points as before and <code>value</code> has to be a list of the locally estimated values for each entry in <code>param</code>, i.e. each list entry has to be a list itself of length one entry longer than the corresponding entry in <code>cps</code>. The function <code>convertSingleParam</code> offers the conversion of an estimator allowing a single parameter into an estimator allowing multiple parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>a function providing the cross-validation criterion. For pre-implemented criteria see criteria. The function must have the arguments <code>testset</code>, <code>estset</code> and <code>value</code>. <code>testset</code> and <code>estset</code> are the observations of one segment that are in the test and estimation set, respectively. <code>value</code> is the local parameter on the segment if provided by <code>estimator</code>, otherwise <code>NULL</code>. Additionally, <code>...</code> is possible and potentially necessary to absorb arguments, since the argument <code>...</code> of <code>crossvalidationCP</code> will be passed to <code>estimator</code> and <code>criterion</code>. It must return a single numeric. All return values will be summed accordingly and <code>which.min</code> will be called on the vector to determine the parameter with the smallest criterion, hence some <code>NaN</code> values etc. are allowed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>a string specifying the output, either <code>"param"</code>, <code>"fit"</code> or <code>"detailed"</code>. For details what they mean see <cite>Value</cite></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters that are passed to <code>estimator</code> and <code>criterion</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>if <code>output == "param"</code>, the selected tuning parameter, i.e. an entry from <code>param</code>. If <code>output == "fit"</code>, a list with the entries <code>param</code>, giving the selected tuning parameter, and <code>fit</code>. The named entry <code>fit</code> is a list giving the returned fit obtained by applying <code>estimator</code> to the whole data <code>Y</code> with the selected tuning parameter. The retured value is transformed to a list with an entry <code>cps</code> giving the estimated change-points and, if provided by <code>estimator</code>, an entry <code>value</code> giving the estimated local values. If <code>output == "detailed"</code>, the same as for <code>output == "fit"</code>, but additionally an entry <code>CP</code> giving all calculated cross-validation criteria. Those values are summed over all folds
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>
<p>Zou, C., Wang, G., and Li, R. (2020) Consistent selection of the number of change-points via sample-splitting. <em>The Annals of Statistics</em>, <b>48</b>(1), 413â€“439.
</p>


<h3>See Also</h3>

<p>estimators, criteria, <code>convertSingleParam</code>, <code>VfoldCV</code>, <code>COPPS</code>, <code>CV1</code>, <code>CVmod</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># call with default parameters:
# 5-fold cross-validation with absolute error loss, least squares estimation,
# and possible parameters being 0 to 5 change-points
# a simpler access to it is offered by VfoldCV()
crossvalidationCP(Y = rnorm(100))

# more interesting data and more detailed output
set.seed(1L)
Y &lt;- c(rnorm(50), rnorm(50, 5), rnorm(50), rnorm(50, 5))
crossvalidationCP(Y = Y, output = "detailed")
# finds the correct change-points at 50, 100, 150
# (plus the start and end points 0 and 200)

# list of parameters, only allowing 1 or 2 change-points
crossvalidationCP(Y = Y, param = as.list(1:2))

# reducing the number of folds to 3
ret &lt;- crossvalidationCP(Y = Y, folds = 3L, output = "detailed")
# the same but with explicitly specified folds
identical(crossvalidationCP(Y = Y, folds = list(seq(1, 200, 3), seq(2, 200, 3), seq(3, 200, 3)),
                            output = "detailed"), ret)
                            
# 2-fold cross-validation with Order-Preserved Sample-Splitting
ret &lt;- crossvalidationCP(Y = Y, folds = "COPPS", output = "detailed")

# a simpler access to it is offered by CV1()
identical(CV1(Y = Y, output = "detailed"), ret)

# different criterion: quadratic error loss
ret &lt;- crossvalidationCP(Y = Y, folds = "COPPS", output = "detailed", criterion = criterionL2loss)

# same as COPPS procedure; as offered by COPPS()
identical(COPPS(Y = Y, output = "detailed"), ret)

# COPPS potentially fails to provide a good selection when large changes occur at odd locations
# Example 1 in (Pein and Shah, 2021), see Section 2.2 in this paper for more details
set.seed(1)
exampleY &lt;- rnorm(102, c(rep(10, 46), rep(0, 5), rep(30, 51)))
# misses one change-point
crossvalidationCP(Y = exampleY, folds = "COPPS", criterion = criterionL2loss) 

# correct number of change-points when modified criterion (or absolute error loss) is used
(ret &lt;- crossvalidationCP(Y = exampleY, folds = "COPPS", criterion = criterionMod)) 

# a simpler access to it is offered by CVmod() 
identical(CVmod(Y = exampleY), ret)

# manually given criterion; identical to criterionL1loss()
testCriterion &lt;- function(testset, estset, value = NULL, ...) {
  if (!is.null(value)) {
    return(sum(abs(testset - value)))
  }
  
  sum(abs(testset - mean(estset)))
}
identical(crossvalidationCP(Y = Y, criterion = testCriterion, output = "detailed"),
          crossvalidationCP(Y = Y, output = "detailed"))
          
# PELT as a local estimator instead of least squares estimation
# param must contain parameters that are acceptable for the given estimator
crossvalidationCP(Y = Y, estimator = pelt, output = "detailed",
                  param = list("SIC", "MBIC", 3 * log(length(Y))))

# argument minseglen of pelt specified in ...
crossvalidationCP(Y = Y, estimator = pelt, output = "detailed",
                  param = list("SIC", "MBIC", 3 * log(length(Y))), minseglen = 60)
</code></pre>


</div>