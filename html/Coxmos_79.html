<div class="container">

<table style="width: 100%;"><tr>
<td>splsdacox_dynamic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sPLSDA-COX Dynamic</h2>

<h3>Description</h3>

<p>The splsdacox_dynamic function conducts a sparse partial least squares discriminant analysis Cox
(sPLSDA-COX) using dynamic variable selection methodology. This method is particularly useful for
high-dimensional survival data where the goal is to identify a subset of variables that are most
predictive of survival outcomes. The function integrates the power of sPLSDA with the Cox
proportional hazards model to provide a robust tool for survival analysis in the context of large
datasets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">splsdacox_dynamic(
  X,
  Y,
  n.comp = 4,
  vector = NULL,
  MIN_NVAR = 10,
  MAX_NVAR = 1000,
  n.cut_points = 5,
  MIN_AUC_INCREASE = 0.01,
  x.center = TRUE,
  x.scale = FALSE,
  remove_near_zero_variance = TRUE,
  remove_zero_variance = TRUE,
  toKeep.zv = NULL,
  remove_non_significant = FALSE,
  alpha = 0.05,
  EVAL_METHOD = "AUC",
  pred.method = "cenROC",
  max.iter = 200,
  times = NULL,
  max_time_points = 15,
  MIN_EPV = 5,
  returnData = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix or data.frame. Explanatory variables. Qualitative variables must be
transform into binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric matrix or data.frame. Response variables. Object must have two columns named as
"time" and "event". For event column, accepted values are: 0/1 or FALSE/TRUE for censored and
event observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.comp</code></td>
<td>
<p>Numeric. Number of latent components to compute for the (s)PLS model (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vector</code></td>
<td>
<p>Numeric vector. Used for computing best number of variables. As many values as
components have to be provided. If vector = NULL, an automatic detection is perform (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_NVAR</code></td>
<td>
<p>Numeric. Minimum range size for computing cut points to select the best number of
variables to use (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MAX_NVAR</code></td>
<td>
<p>Numeric. Maximum range size for computing cut points to select the best number of
variables to use (default: 1000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cut_points</code></td>
<td>
<p>Numeric. Number of cut points for searching the optimal number of variables.
If only two cut points are selected, minimum and maximum size are used. For MB approaches as many
as n.cut_points^n.blocks models will be computed as minimum (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC_INCREASE</code></td>
<td>
<p>Numeric. Minimum improvement between different cross validation models to
continue evaluating higher values in the multiple tested parameters. If it is not reached for next
'MIN_COMP_TO_CHECK' models and the minimum 'MIN_AUC' value is reached, the evaluation stops
(default: 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.center</code></td>
<td>
<p>Logical. If x.center = TRUE, X matrix is centered to zero means (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.scale</code></td>
<td>
<p>Logical. If x.scale = TRUE, X matrix is scaled to unit variances (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_near_zero_variance</code></td>
<td>
<p>Logical. If remove_near_zero_variance = TRUE, near zero variance
variables will be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_zero_variance</code></td>
<td>
<p>Logical. If remove_zero_variance = TRUE, zero variance variables will
be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toKeep.zv</code></td>
<td>
<p>Character vector. Name of variables in X to not be deleted by (near) zero variance
filtering (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant</code></td>
<td>
<p>Logical. If remove_non_significant = TRUE, non-significant
variables/components in final cox model will be removed until all variables are significant by
forward selection (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Numerical values are regarded as significant if they fall below the
threshold (default: 0.05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EVAL_METHOD</code></td>
<td>
<p>Character. If EVAL_METHOD = "AUC", AUC metric will be use to compute the best
number of variables. In other case, c-index metric will be used (default: "AUC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.method</code></td>
<td>
<p>Character. AUC evaluation algorithm method for evaluate the model performance.
Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C",
"smoothROCtime_I" (default: "cenROC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Numeric. Maximum number of iterations for PLS convergence (default: 200).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of
'max_time_points' points will be selected equally distributed (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time_points</code></td>
<td>
<p>Numeric. Maximum number of time points to use for evaluating the model
(default: 15).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_EPV</code></td>
<td>
<p>Numeric. Minimum number of Events Per Variable (EPV) you want reach for the final
cox model. Used to restrict the number of variables/components can be computed in final cox models.
If the minimum is not meet, the model cannot be computed (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnData</code></td>
<td>
<p>Logical. Return original and normalized X and Y matrices (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function begins by checking the input parameters for consistency and ensuring that the response
variable Y has the required columns "time" and "event". It then preprocesses the data by centering
and scaling (if specified), and removing variables with zero or near-zero variance. The function
also checks for multicollinearity in the data and addresses it if detected.
</p>
<p>The core of the function involves determining the optimal number of variables to retain in the model.
If the vector parameter is not provided, the function employs a strategy to identify the best number
of variables for each latent component. This is achieved by evaluating different combinations of
variables and selecting the one that maximizes the model's performance, as determined by the
specified evaluation metric (EVAL_METHOD).
</p>
<p>Once the optimal number of variables is determined, the function proceeds to compute the sPLSDA-COX
model. It employs the mixOmics::splsda function to compute the sPLSDA model, which is then
integrated with the Cox proportional hazards model. The resulting model provides insights into the
relationship between the predictor variables and survival outcomes.
</p>
<p>The function also offers the flexibility to refine the model further by removing non-significant
variables based on a specified alpha threshold.
</p>


<h3>Value</h3>

<p>Instance of class "Coxmos" and model "sPLS-DACOX-Dynamic". The class contains the
following elements:
<code>X</code>: List of normalized X data information.
</p>

<ul>
<li> <p><code>(data)</code>: normalized X matrix
</p>
</li>
<li> <p><code>(weightings)</code>: sPLS weights
</p>
</li>
<li> <p><code>(W.star)</code>: sPLS W* vector
</p>
</li>
<li> <p><code>(loadings)</code>: sPLS loadings
</p>
</li>
<li> <p><code>(scores)</code>: sPLS scores/variates
</p>
</li>
<li> <p><code>(x.mean)</code>: mean values for X matrix
</p>
</li>
<li> <p><code>(x.sd)</code>: standard deviation for X matrix
</p>
</li>
</ul>
<p><code>Y</code>: List of normalized Y data information.
</p>

<ul>
<li> <p><code>(data)</code>: normalized X matrix
</p>
</li>
<li> <p><code>(y.mean)</code>: mean values for Y matrix
</p>
</li>
<li> <p><code>(y.sd)</code>: standard deviation for Y matrix'
</p>
</li>
</ul>
<p><code>survival_model</code>: List of survival model information.
</p>

<ul>
<li> <p><code>fit</code>: coxph object.
</p>
</li>
<li> <p><code>AIC</code>: AIC of cox model.
</p>
</li>
<li> <p><code>BIC</code>: BIC of cox model.
</p>
</li>
<li> <p><code>lp</code>: linear predictors for train data.
</p>
</li>
<li> <p><code>coef</code>: Coefficients for cox model.
</p>
</li>
<li> <p><code>YChapeau</code>: Y Chapeau residuals.
</p>
</li>
<li> <p><code>Yresidus</code>: Y residuals.
</p>
</li>
</ul>
<p><code>n.comp</code>: Number of components selected.
</p>
<p><code>n.varX</code>: Number of Variables selected in each PLS component.
</p>
<p><code>var_by_component</code>: Variables selected in each PLS component.
</p>
<p><code>plot_accuracyPerVariable</code>: If NULL vector is selected, return a plot for understanding the
number of variable selection.
</p>
<p><code>call</code>: call function
</p>
<p><code>X_input</code>: X input matrix
</p>
<p><code>Y_input</code>: Y input matrix
</p>
<p><code>alpha</code>: alpha value selected
</p>
<p><code>nsv</code>: Variables removed by cox alpha cutoff.
</p>
<p><code>nzv</code>: Variables removed by remove_near_zero_variance or remove_zero_variance.
</p>
<p><code>nz_coeffvar</code>: Variables removed by coefficient variation near zero.
</p>
<p><code>class</code>: Model class.
</p>
<p><code>time</code>: time consumed for running the cox analysis.
</p>


<h3>Author(s)</h3>

<p>Pedro Salguero Garcia. Maintainer: pedsalga@upv.edu.es
</p>


<h3>References</h3>

<p>Rohart F, Gautier B, Singh A, Cao KAL (2017).
“mixOmics: An R package for ‘omics feature selection and multiple data integration.”
<em>PLoS Computational Biology</em>, <b>13</b>(11).
ISSN 15537358, <a href="https://pubmed.ncbi.nlm.nih.gov/29099853/">https://pubmed.ncbi.nlm.nih.gov/29099853/</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("X_proteomic")
data("Y_proteomic")
X &lt;- X_proteomic[,1:20]
Y &lt;- Y_proteomic
splsdacox_dynamic(X, Y, n.comp = 2, vector = NULL, x.center = TRUE, x.scale = TRUE)
</code></pre>


</div>