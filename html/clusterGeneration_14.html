<div class="container">

<table style="width: 100%;"><tr>
<td>simClustDesign</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>DESIGN FOR RANDOM CLUSTER GENERATION WITH SPECIFIED DEGREE OF SEPARATION</h2>

<h3>Description</h3>

<p>Generating data sets via a factorial design, which has factors: 
degree of separation, number of clusters, number of non-noisy variables, 
number of noisy variables. The separation between any cluster and its 
nearest neighboring clusters can be set to a specified value. 
The covariance matrices of clusters can have arbitrary diameters, shapes 
and orientations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simClustDesign(numClust = c(3,6,9), 
               sepVal = c(0.01, 0.21, 0.342), 
               sepLabels = c("L", "M", "H"), 
               numNonNoisy = c(4,8,20), 
               numNoisy = NULL, 
               numOutlier = 0, 
               numReplicate = 3, 
               fileName = "test", 
               clustszind = 2, 
               clustSizeEq = 50, 
               rangeN = c(50,200), 
               clustSizes = NULL,
               covMethod = c("eigen", "onion", "c-vine", "unifcorrmat"), 
	       eigenvalue = NULL,
               rangeVar = c(1, 10), 
               lambdaLow = 1, 
               ratioLambda = 10, 
               alphad = 1, 
               eta = 1, 
               rotateind = TRUE, 
               iniProjDirMethod = c("SL", "naive"), 
               projDirMethod = c("newton", "fixedpoint"), 
               alpha = 0.05, 
               ITMAX = 20, 
               eps = 1.0e-10, 
               quiet = TRUE, 
               outputDatFlag = TRUE, 
               outputLogFlag = TRUE, 
               outputEmpirical = TRUE, 
               outputInfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>numClust</code></td>
<td>

<p>Vector of the number of clusters for data sets in the design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepVal</code></td>
<td>

<p>Vector of desired values of the separation index between clusters
and their nearest neighboring clusters. Each element of <code>sepVal</code> can 
take values within the interval <code>[-1, 1)</code>. 
The closer to 1 an element of <code>sepVal</code> is, the more separated the 
pair of clusters are.
The values <code class="reqn">0.01, 0.21, 0.34</code> are the values of the separation index for
two univariate clusters generated from <code class="reqn">N(0, 1)</code> and <code class="reqn">N(0, A)</code>,
where <code class="reqn">A=4, 6, 8</code>, respectively. <code>sepVal</code><code class="reqn">=0.01 (A=4)</code> indicates 
a close cluster structure. <code>sepVal</code><code class="reqn">=0.21 (A=6)</code> indicates a 
separated cluster structure. <code>sepVal</code><code class="reqn">=0.34 (A=8)</code> indicates 
a well-separated cluster.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepLabels</code></td>
<td>

<p>Labels for "close", "separated", and "well-separated" cluster structures.
By default, "L" (low) means "close", "M" (medium) means "separated",
"H" (high) means "well-separated".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numNonNoisy</code></td>
<td>

<p>Vector of the number of non-noisy variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numNoisy</code></td>
<td>

<p>Vectors of the number of noisy variables. The default value of <code>numNoisy</code> 
is <code>NULL</code> so that the program can automatically assign the value of 
<code>numNoisy</code> as a vector with elements <code class="reqn">1, round(p1/2), p1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numOutlier</code></td>
<td>

<p>The number or ratio of outliers. If <code>numOutlier</code> is a 
positive integer, then <code>numOutlier</code> means the number of outliers. 
If <code>numOutlier</code> is a real number between <code class="reqn">(0, 1)</code>, then 
<code>numOutlier</code> means the ratio of outliers, i.e. the number of outliers 
is equal to 
<code>round</code>(<code>numOutlier</code><code class="reqn">*n_1</code>), where <code class="reqn">n_1</code> is the total number 
of non-outliers.  If <code>numOutlier</code> is a real number greater than <code class="reqn">1</code>, 
then <code>numOutlier</code> is rounded to an integer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numReplicate</code></td>
<td>

<p>Number of data sets to be generated for the same cluster structure specified 
by the other arguments of the function <code>genRandomClust</code>.
The default value <code class="reqn">3</code> follows the design in Milligan (1985).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fileName</code></td>
<td>

<p>The first part of the names of data files that record the generated data sets 
and associated information, such as cluster membership of data points, labels 
of noisy variables, separation index matrix, projection directions, etc. 
(see details). The default value of <code>fileName</code> is ‘<span class="file">test</span>’.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustszind</code></td>
<td>

<p>Cluster size indicator.
<code>clustszind</code><code class="reqn">=1</code> indicates that all cluster have equal size. 
The size is specified by the argument <code>clustSizeEq</code>.
<code>clustszind</code><code class="reqn">=2</code> indicates that the cluster sizes are randomly 
generated from the range specified by the argument <code>rangeN</code>.
<code>clustszind</code><code class="reqn">=3</code> indicates that the cluster sizes are specified
via the vector <code>clustSizes</code>.
The default value is <code class="reqn">2</code> so that the generated clusters are more
realistic.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustSizeEq</code></td>
<td>

<p>Cluster size.
If the argument <code>clustszind</code><code class="reqn">=1</code>, then all clusters will have the 
equal number <code>clustSizeEq</code> of data points. The value of <code>clustSizeEq</code> should be large enough to get non-singular cluster covariance matrices. 
We recommend the <code>clustSizeEq</code> is at least <code class="reqn">10*p</code>, where <code class="reqn">p</code> 
is the total number of variables (including both non-noisy and noisy variables).
The default value <code class="reqn">100</code> is a reasonable cluster size.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rangeN</code></td>
<td>

<p>The range of cluster sizes.
If <code>clustszind</code><code class="reqn">=2</code>, then cluster sizes will be randomly generated 
from the range specified by <code>rangeN</code>. The lower bound of the number of 
clusters should be large enough to get non-singular cluster covariance 
matrices. We recommend the minimum cluster size is at least <code class="reqn">10*p</code>, where 
<code class="reqn">p</code> is the total number of variables (including both non-noisy and noisy 
variables).  The default range is <code class="reqn">[50, 200]</code> which
can produce reasonable variability of cluster sizes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustSizes</code></td>
<td>

<p>The sizes of clusters.
If <code>clustszind</code><code class="reqn">=3</code>, then cluster sizes will be specified by the 
vector <code>clustSizes</code>.  We recommend the minimum cluster size is at least 
<code class="reqn">10*p</code>, where <code class="reqn">p</code> is the total number of variables (including both 
non-noisy and noisy variables).
The user needs to specify the value of <code>clustSizes</code>. Therefore, we
set the default value of <code>clustSizes</code> as <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covMethod</code></td>
<td>

<p>Method to generate covariance matrices for clusters (see details).
The default method is 'eigen' so that the user can directly 
specify the range of the <dfn>diameters</dfn> of clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigenvalue</code></td>
<td>

<p>numeric. user-specified eigenvalues when <code>covMethod = "eigen"</code>. If <code>eigenvalue = NULL</code> and <code>covMethod = "eigen"</code>, then eigenvalues will be automatically generated.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rangeVar</code></td>
<td>

<p>Range for variances of a covariance matrix (see details).
The default range is <code class="reqn">[1, 10]</code> which can generate reasonable
variability of variances.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaLow</code></td>
<td>

<p>Lower bound of the eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, we need to generate eigenvalues for 
cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>lambdaLow</code> should be positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratioLambda</code></td>
<td>

<p>The ratio of the upper bound of the eigenvalues to the lower bound of the 
eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, we need to generate eigenvalues for 
cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>ratioLambda</code> should be larger than <code class="reqn">1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphad</code></td>
<td>
<p>parameter for unifcorrmat method to generate random correlation matrix
<code>alphad=1</code> for uniform. <code>alphad</code> should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>parameter for “c-vine” and “onion” methods to generate random correlation matrix
<code>eta=1</code> for uniform. <code>eta</code> should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotateind</code></td>
<td>

<p>Rotation indicator.
<code>rotateind=TRUE</code> indicates randomly rotating data in non-noisy 
dimensions so that we may not detect the full cluster structure from 
pair-wise scatter plots of the variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iniProjDirMethod</code></td>
<td>

<p>Indicating the method to get initial projection direction when calculating
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br><code>iniProjDirMethod</code>=“SL”, the default, indicates the initial 
projection direction is the sample version of the SL's projection direction 
(Su and Liu, 1993, JASA)
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code><br><code>iniProjDirMethod</code>=“naive” indicates the initial projection 
direction is <code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projDirMethod</code></td>
<td>

<p>Indicating the method to get the optimal projection direction when calculating 
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br><code>projDirMethod</code>=“newton” indicates we use the modified
Newton-Raphson method to search the optimal projection direction 
(c.f. Qiu and Joe, 2006a). This requires the assumptions that both covariance 
matrices of the pair of clusters are positive-definite. If this assumption 
is violated, the “fixedpoint” method could be used. The 
“fixedpoint” method iteratively searches the optimal projection 
direction based on the first derivative of the separation index to the 
projection direction (c.f. Qiu and Joe, 2006b).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
We set <code>alpha</code><code class="reqn">=0.05</code> like we set
the significance level in hypothesis testing as <code class="reqn">0.05</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ITMAX</code></td>
<td>

<p>Maximum iteration allowed when to iteratively calculating the
optimal projection direction.
The actual number of iterations is usually much less than the default value 20.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>Convergence threshold. A small positive number to check if a quantitiy <code class="reqn">q</code> 
is equal to zero.  If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> as equal 
to zero.  <code>eps</code> is used to check if an algorithm converges.
The default value is <code class="reqn">1.0e-10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputDatFlag</code></td>
<td>

<p>Indicates if data set should be output to file.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputLogFlag</code></td>
<td>

<p>Indicates if log info should be output to file.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputEmpirical</code></td>
<td>

<p>Indicates if empirical separation indices and projection directions should be 
calculated. This option is useful when generating clusters with sizes which 
are not large enough so that the sample covariance matrices may be singular.
Hence, by default, <code>outputEmpirical=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputInfo</code></td>
<td>

<p>Indicates if theoretical and empirical separation information data frames 
should be output to a file with format <code>[fileName]_info.log</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>simClustDesign</code> is an implementation of the design for 
generating random clusters proposed in Qiu and Joe (2006a). In the design, 
the degree of separation between any cluster and its nearest neighboring 
cluster could be set to a specified value while the cluster covariance 
matrices can be arbitrary positive definite matrices, and so that clusters 
generated might not be visualized by pair-wise scatterplots of variables. 
The separation between a pair of clusters is measured by the separation index 
proposed in Qiu and Joe (2006b).
</p>
<p>The current version of the function <code>simClustDesign</code> implements two 
methods to generate covariance matrices for clusters. The first method, 
denoted by <code>eigen</code>, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots&gt;\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then uses columns of a randomly generated 
orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\dots,\lambda_p)*\boldsymbol{Q}^T</code>.
The second method, denoted as <code>unifcorrmat</code>, first generates a random
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots, \sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>
<p>For each data set generated, the function <code>simClustDesign</code> outputs
four files: data file, log file, membership file, and noisy set file. 
All four files have the same format: <br><code>[fileName]J[j]G[g]v[p1]nv[p2]out[numOutlier]_[numReplicate].[extension]</code> 
<br>
where ‘<span class="file">extension</span>’ can be ‘<span class="file">dat</span>’, ‘<span class="file">log</span>’, ‘<span class="file">mem</span>’, or 
‘<span class="file">noisy</span>’. ‘J’ indicates separation index, with ‘j’ 
indicating the level of the factor ‘separation index’; 
‘G’ indicates number of clusters, with ‘g’ indicating the 
level of the factor ‘number of clusters’; ‘v’ indicates 
the number of non-noisy variables, with ‘p1’ indicating the level 
of the factor ‘number of non-noisy variables’; ‘nv’ indicates 
the number of noisy variables, with ‘p2’ indicating the level of 
the factor ‘number of noisy variables’; ‘out’ indicates  
number of outliers, with ‘numOutlier’ indicating the value of the 
argument <code>numOutlier</code> of the function <code>simClustDesign</code>; 
‘numReplicate’ indicates the value of the argument <code>numReplicate</code> 
of the function <code>simClustDesign</code>.
</p>
<p>The data file with file extension ‘<span class="file">dat</span>’ contains <code class="reqn">n+1</code> rows and 
<code class="reqn">p</code> columns, where <code class="reqn">n</code> is the number of data points and <code class="reqn">p</code> is 
the number of variables. The first row is the variable names. The log file 
with file extension ‘<span class="file">log</span>’ contains information such as cluster sizes, 
mean vectors, covariance matrices, projection directions, separation index 
matrices, etc. The membership file with file extension ‘<span class="file">mem</span>’ contains 
<code class="reqn">n</code> rows and one column of cluster memberships for data points. The noisy 
set file with file extension ‘<span class="file">noisy</span>’ contains a row of labels of noisy 
variables.
</p>
<p>When generating clusters, population covariance matrices are all 
positive-definite. However sample covariance matrices might be 
semi-positive-definite due to small cluster sizes. In this case, the 
function <code>genRandomClust</code> will automatically use the 
“fixedpoint” method to search the optimal projection direction.
</p>


<h3>Value</h3>

<p>The function outputs four data files for each data set (see details).
</p>
<p>This function also returns separation information data frames 
<code>infoFrameTheory</code> and <code>infoFrameData</code> based on population 
and empirical mean vectors and covariance matrices of clusters for all 
the data sets generated. Both <code>infoFrameTheory</code> and <code>infoFrameData</code> 
contain the following seven columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Column 1:</code></td>
<td>

<p>Labels of clusters (<code class="reqn">1, 2, \ldots, numClust</code>), where <code class="reqn">numClust</code> 
is the number of clusters for the data set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 2:</code></td>
<td>

<p>Labels of the corresponding nearest neighbors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 3:</code></td>
<td>

<p>Separation indices of the clusters to their nearest neighboring clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 4:</code></td>
<td>

<p>Labels of the corresponding farthest neighboring clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 5:</code></td>
<td>

<p>Separation indices of the clusters to their farthest neighbors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 6:</code></td>
<td>

<p>Median separation indices of the clusters to their neighbors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 7:</code></td>
<td>

<p>Data file names with format 
<code>[fileName]J[j]G[g]v[p1]nv[p2]out[numOutlier]_[numReplicate]</code> (see details).
</p>
</td>
</tr>
</table>
<p>The function also returns three lists: <code>datList</code>, <code>memList</code>, and <code>noisyList</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>datList:</code></td>
<td>

<p>a list of lists of data matrices for generated data sets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memList:</code></td>
<td>

<p>a list of lists of cluster memberships for data points for generated data sets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noisyList:</code></td>
<td>

<p>a list of lists of sets of noisy variables for generated data sets.
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The speed of this function might be slow.</p>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br>
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177–2189.
</p>
<p>Milligan G. W. (1985) 
An Algorithm for Generating Artificial Test Clusters.
<em>Psychometrika</em> <b>50</b>, 123–127.
</p>
<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585–603.
</p>
<p>Su, J. Q. and Liu, J. S. (1993)
Linear Combinations of Multiple Diagnostic Markers.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 1350–1355
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
tmp &lt;- simClustDesign(
		      numClust = 3, 
                      sepVal = c(0.01, 0.21), 
                      sepLabels = c("L", "M"), 
                      numNonNoisy = 4, 
                      numOutlier = 0, 
                      numReplicate = 2, 
                      clustszind = 2)
## End(Not run)
</code></pre>


</div>