<div class="container">

<table style="width: 100%;"><tr>
<td>HttpClient</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>HTTP client</h2>

<h3>Description</h3>

<p>Create and execute HTTP requests
</p>


<h3>Value</h3>

<p>an HttpResponse object
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>handles</h3>

<p>curl handles are re-used on the level of the connection object, that is,
each <code>HttpClient</code> object is separate from one another so as to better
separate connections.
</p>
<p>If you don't pass in a curl handle to the <code>handle</code> parameter,
it gets created when a HTTP verb is called. Thus, if you try to get <code>handle</code>
after creating a <code>HttpClient</code> object only passing <code>url</code> parameter, <code>handle</code>
will be <code>NULL</code>. If you pass a curl handle to the <code>handle</code> parameter, then
you can get the handle from the <code>HttpClient</code> object. The response from a
http verb request does have the handle in the <code>handle</code> slot.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>url</code></dt>
<dd>
<p>(character) a url</p>
</dd>
<dt><code>opts</code></dt>
<dd>
<p>(list) named list of curl options</p>
</dd>
<dt><code>proxies</code></dt>
<dd>
<p>a <code>proxy()</code> object</p>
</dd>
<dt><code>auth</code></dt>
<dd>
<p>an <code>auth()</code> object</p>
</dd>
<dt><code>headers</code></dt>
<dd>
<p>(list) named list of headers, see http-headers</p>
</dd>
<dt><code>handle</code></dt>
<dd>
<p>a <code>handle()</code></p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>only supports <code>httr::progress()</code>, see progress</p>
</dd>
<dt><code>hooks</code></dt>
<dd>
<p>a named list, see hooks</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HttpClient-print"><code>HttpClient$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-new"><code>HttpClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-get"><code>HttpClient$get()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-post"><code>HttpClient$post()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-put"><code>HttpClient$put()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-patch"><code>HttpClient$patch()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-delete"><code>HttpClient$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-head"><code>HttpClient$head()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-verb"><code>HttpClient$verb()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-retry"><code>HttpClient$retry()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-handle_pop"><code>HttpClient$handle_pop()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-url_fetch"><code>HttpClient$url_fetch()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpClient-clone"><code>HttpClient$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-HttpClient-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>print method for <code>HttpClient</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>self</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>ignored</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new HttpClient object
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$new(
  url,
  opts,
  proxies,
  auth,
  headers,
  handle,
  progress,
  hooks,
  verbose
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt>
<dd>
<p>(character) A url. One of <code>url</code> or <code>handle</code> required.</p>
</dd>
<dt><code>opts</code></dt>
<dd>
<p>any curl options</p>
</dd>
<dt><code>proxies</code></dt>
<dd>
<p>a <code>proxy()</code> object</p>
</dd>
<dt><code>auth</code></dt>
<dd>
<p>an <code>auth()</code> object</p>
</dd>
<dt><code>headers</code></dt>
<dd>
<p>named list of headers, see http-headers</p>
</dd>
<dt><code>handle</code></dt>
<dd>
<p>a <code>handle()</code></p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>only supports <code>httr::progress()</code>, see progress</p>
</dd>
<dt><code>hooks</code></dt>
<dd>
<p>a named list, see hooks</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>a special handler for verbose curl output,
accepts a function only. default is <code>NULL</code>. if used, <code>verbose</code>
and <code>debugfunction</code> curl options are ignored if passed to <code>opts</code>
on <code style="white-space: pre;">⁠$new()⁠</code> and ignored if <code>...</code> passed to a http method call</p>
</dd>
<dt><code>urls</code></dt>
<dd>
<p>(character) one or more URLs</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>HttpClient</code> object
</p>


<hr>
<a id="method-HttpClient-get"></a>



<h4>Method <code>get()</code>
</h4>

<p>Make a GET request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$get(path = NULL, query = list(), disk = NULL, stream = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>disk</code></dt>
<dd>
<p>a path to write to. if NULL (default), memory used.
See <code>curl::curl_fetch_disk()</code> for help.</p>
</dd>
<dt><code>stream</code></dt>
<dd>
<p>an R function to determine how to stream data. if
NULL (default), memory used. See <code>curl::curl_fetch_stream()</code>
for help</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-post"></a>



<h4>Method <code>post()</code>
</h4>

<p>Make a POST request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$post(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>disk</code></dt>
<dd>
<p>a path to write to. if NULL (default), memory used.
See <code>curl::curl_fetch_disk()</code> for help.</p>
</dd>
<dt><code>stream</code></dt>
<dd>
<p>an R function to determine how to stream data. if
NULL (default), memory used. See <code>curl::curl_fetch_stream()</code>
for help</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-put"></a>



<h4>Method <code>put()</code>
</h4>

<p>Make a PUT request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$put(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>disk</code></dt>
<dd>
<p>a path to write to. if NULL (default), memory used.
See <code>curl::curl_fetch_disk()</code> for help.</p>
</dd>
<dt><code>stream</code></dt>
<dd>
<p>an R function to determine how to stream data. if
NULL (default), memory used. See <code>curl::curl_fetch_stream()</code>
for help</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-patch"></a>



<h4>Method <code>patch()</code>
</h4>

<p>Make a PATCH request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$patch(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>disk</code></dt>
<dd>
<p>a path to write to. if NULL (default), memory used.
See <code>curl::curl_fetch_disk()</code> for help.</p>
</dd>
<dt><code>stream</code></dt>
<dd>
<p>an R function to determine how to stream data. if
NULL (default), memory used. See <code>curl::curl_fetch_stream()</code>
for help</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-delete"></a>



<h4>Method <code>delete()</code>
</h4>

<p>Make a DELETE request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$delete(
  path = NULL,
  query = list(),
  body = NULL,
  disk = NULL,
  stream = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>disk</code></dt>
<dd>
<p>a path to write to. if NULL (default), memory used.
See <code>curl::curl_fetch_disk()</code> for help.</p>
</dd>
<dt><code>stream</code></dt>
<dd>
<p>an R function to determine how to stream data. if
NULL (default), memory used. See <code>curl::curl_fetch_stream()</code>
for help</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-head"></a>



<h4>Method <code>head()</code>
</h4>

<p>Make a HEAD request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$head(path = NULL, query = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-HttpClient-verb"></a>



<h4>Method <code>verb()</code>
</h4>

<p>Use an arbitrary HTTP verb supported on this class
Supported verbs: "get", "post", "put", "patch", "delete", "head". Also
supports retry
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$verb(verb, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt>
<dd>
<p>an HTTP verb supported on this class: "get",
"post", "put", "patch", "delete", "head". Also supports retry.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
x$verb('get')
x$verb('GET')
x$verb('GET', query = list(foo = "bar"))
x$verb('retry', 'GET', path = "status/400")
}
</pre>
</div>


<hr>
<a id="method-HttpClient-retry"></a>



<h4>Method <code>retry()</code>
</h4>

<p>Retry a request
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$retry(
  verb,
  ...,
  pause_base = 1,
  pause_cap = 60,
  pause_min = 1,
  times = 3,
  terminate_on = NULL,
  retry_only_on = NULL,
  onwait = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verb</code></dt>
<dd>
<p>an HTTP verb supported on this class: "get",
"post", "put", "patch", "delete", "head". Also supports retry.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
<dt><code>pause_base, pause_cap, pause_min</code></dt>
<dd>
<p>basis, maximum, and minimum for
calculating wait time for retry. Wait time is calculated according to the
exponential backoff with full jitter algorithm. Specifically, wait time is
chosen randomly between <code>pause_min</code> and the lesser of <code>pause_base * 2</code> and
<code>pause_cap</code>, with <code>pause_base</code> doubling on each subsequent retry attempt.
Use <code>pause_cap = Inf</code> to not terminate retrying due to cap of wait time
reached.</p>
</dd>
<dt><code>times</code></dt>
<dd>
<p>the maximum number of times to retry. Set to <code>Inf</code> to
not stop retrying due to exhausting the number of attempts.</p>
</dd>
<dt><code>terminate_on, retry_only_on</code></dt>
<dd>
<p>a vector of HTTP status codes. For
<code>terminate_on</code>, the status codes for which to terminate retrying, and for
<code>retry_only_on</code>, the status codes for which to retry the request.</p>
</dd>
<dt><code>onwait</code></dt>
<dd>
<p>a callback function if the request will be retried and
a wait time is being applied. The function will be passed two parameters,
the response object from the failed request, and the wait time in seconds.
Note that the time spent in the function effectively adds to the wait time,
so it should be kept simple.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Retries the request given by <code>verb</code> until successful
(HTTP response status &lt; 400), or a condition for giving up is met.
Automatically recognizes <code>Retry-After</code> and <code>X-RateLimit-Reset</code> headers
in the response for rate-limited remote APIs.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")

# retry, by default at most 3 times
(res_get &lt;- x$retry("GET", path = "status/400"))

# retry, but not for 404 NOT FOUND
(res_get &lt;- x$retry("GET", path = "status/404", terminate_on = c(404)))

# retry, but only for exceeding rate limit (note that e.g. Github uses 403)
(res_get &lt;- x$retry("GET", path = "status/429", retry_only_on = c(403, 429)))
}
</pre>
</div>


<hr>
<a id="method-HttpClient-handle_pop"></a>



<h4>Method <code>handle_pop()</code>
</h4>

<p>reset your curl handle
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$handle_pop()</pre></div>


<hr>
<a id="method-HttpClient-url_fetch"></a>



<h4>Method <code>url_fetch()</code>
</h4>

<p>get the URL that would be sent (i.e., before executing
the request) the only things that change the URL are path and query
parameters; body and any curl options don't change the URL
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$url_fetch(path = NULL, query = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>URL (character)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$url_fetch()
x$url_fetch('get')
x$url_fetch('post')
x$url_fetch('get', query = list(foo = "bar"))
</pre>
</div>


<hr>
<a id="method-HttpClient-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpClient$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Note</h3>

<p>A little quirk about <code>crul</code> is that because user agent string can
be passed as either a header or a curl option (both lead to a <code>User-Agent</code>
header being passed in the HTTP request), we return the user agent
string in the <code>request_headers</code> list of the response even if you
pass in a <code>useragent</code> string as a curl option. Note that whether you pass
in as a header like <code>User-Agent</code> or as a curl option like <code>useragent</code>,
it is returned as <code>request_headers$User-Agent</code> so at least accessing
it in the request headers is consistent.
</p>


<h3>See Also</h3>

<p>http-headers, writing-options, cookies, hooks
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# set your own handle
(h &lt;- handle("https://hb.opencpu.org"))
(x &lt;- HttpClient$new(handle = h))
x$handle
x$url
(out &lt;- x$get("get"))
x$handle
x$url
class(out)
out$handle
out$request_headers
out$response_headers
out$response_headers_all

# if you just pass a url, we create a handle for you
#  this is how most people will use HttpClient
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
x$url
x$handle # is empty, it gets created when a HTTP verb is called
(r1 &lt;- x$get('get'))
x$url
x$handle
r1$url
r1$handle
r1$content
r1$response_headers
r1$parse()

(res_get2 &lt;- x$get('get', query = list(hello = "world")))
res_get2$parse()
library("jsonlite")
jsonlite::fromJSON(res_get2$parse())

# post request
(res_post &lt;- x$post('post', body = list(hello = "world")))

## empty body request
x$post('post')

# put request
(res_put &lt;- x$put('put'))

# delete request
(res_delete &lt;- x$delete('delete'))

# patch request
(res_patch &lt;- x$patch('patch'))

# head request
(res_head &lt;- x$head())

# query params are URL encoded for you, so DO NOT do it yourself
## if you url encode yourself, it gets double encoded, and that's bad
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
res &lt;- x$get("get", query = list(a = 'hello world'))

# access intermediate headers in response_headers_all
x &lt;- HttpClient$new("https://doi.org/10.1007/978-3-642-40455-9_52-1")
bb &lt;- x$get()
bb$response_headers_all

## End(Not run)

## ------------------------------------------------
## Method `HttpClient$verb`
## ------------------------------------------------

## Not run: 
(x &lt;- HttpClient$new(url = "https://hb.opencpu.org"))
x$verb('get')
x$verb('GET')
x$verb('GET', query = list(foo = "bar"))
x$verb('retry', 'GET', path = "status/400")

## End(Not run)

## ------------------------------------------------
## Method `HttpClient$retry`
## ------------------------------------------------

## Not run: 
x &lt;- HttpClient$new(url = "https://hb.opencpu.org")

# retry, by default at most 3 times
(res_get &lt;- x$retry("GET", path = "status/400"))

# retry, but not for 404 NOT FOUND
(res_get &lt;- x$retry("GET", path = "status/404", terminate_on = c(404)))

# retry, but only for exceeding rate limit (note that e.g. Github uses 403)
(res_get &lt;- x$retry("GET", path = "status/429", retry_only_on = c(403, 429)))

## End(Not run)

## ------------------------------------------------
## Method `HttpClient$url_fetch`
## ------------------------------------------------

x &lt;- HttpClient$new(url = "https://hb.opencpu.org")
x$url_fetch()
x$url_fetch('get')
x$url_fetch('post')
x$url_fetch('get', query = list(foo = "bar"))
</code></pre>


</div>