<div class="container">

<table style="width: 100%;"><tr>
<td>EMPIRcop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Bivariate Empirical Copula</h2>

<h3>Description</h3>

<p>The <em>bivariate empirical copula</em> (Nelsen, 2006, p. 219) for a bivariate sample of length <code class="reqn">n</code> is defined for random variables <code class="reqn">X</code> and <code class="reqn">Y</code> as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_n\biggl(\frac{i}{n}, \frac{j}{n}\biggr) = \frac{\mathrm{number\ of\ pairs\ (}x,y\mathrm{)\ with\ }x \le x_{(i)}\mathrm{\ and\ }y \le y_{(j)}}{n}\mbox{,}</code>
</p>

<p>where <code class="reqn">x_{(i)}</code> and <code class="reqn">y_{(i)}</code>, <code class="reqn">1 \le i,j \le n</code> or expressed as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_n\biggl(\frac{i}{n}, \frac{j}{n}\biggr) =
     \frac{1}{n}\sum_{i=1}^n \mathbf{1}\biggl(\frac{R_i}{n} \le u_i, \frac{S_i}{n} \le v_i \biggr)\mbox{,}</code>
</p>

<p>where <code class="reqn">R_i</code> and <code class="reqn">S_i</code> are ranks of the data for <code class="reqn">U</code> and <code class="reqn">V</code>, and <code class="reqn">\mathbf{1}(.)</code> is an <em>indicator function</em> that score 1 if condition is true otherwise scoring zero. Using more generic notation, the empirical copula can be defined by
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{n}(u,v) =
     \frac{1}{n}\sum_{i=1}^n \mathbf{1}\bigl(u^\mathrm{obs}_{i} \le u_i, v^\mathrm{obs}_{i} \le v_i \bigr)\mbox{,}</code>
</p>

<p>where <code class="reqn">u^\mathrm{obs}</code> and <code class="reqn">v^\mathrm{obs}</code> are thus some type of nonparametric nonexceedance probabilities based on counts of the underlying data expressed in probabilities.
</p>
<p><em>Hazen Empirical Copula</em>—The “Hazen form” of the empirical copula is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}^\mathcal{H}_{n}(u,v) =
     \frac{1}{n}\sum_{i=1}^n \mathbf{1}\biggl(\frac{R_i - 0.5}{n} \le u_i, \frac{S_i - 0.5}{n} \le v_i \biggr)\mbox{,}</code>
</p>

<p>which can be triggered by <code>ctype="hazen"</code>. This form is named for this package because of direct similarity of the <em>Hazen plotting position</em> to the above definition. Joe (2014, pp. 247–248) uses the Hazen form. Joe continues by saying “[the] adjustment of the uniform score [<code class="reqn">(R - 0.5)/n]</code>] could be done in an alternative form, but there is [asymptotic] equivalence[, and that] <code class="reqn">\mathbf{C}^\mathcal{H}_{n}</code> puts mass of <code class="reqn">n^{-1}</code> at the tuples <code class="reqn">([r_{i1} - 0.5]/n, \ldots, [r_{id} - 0.5]/n)</code> for <code class="reqn">i = 1, \ldots, n</code>.” A footnote by Joe (2014) says that “the conversion [<code class="reqn">R/(n+1)</code>] is commonly used for the empirical copula.” This later form is the “Weibull form” described next. Joe's preference for the Hazen form is so that the sum of squared normal scores is closer to unity for large <code class="reqn">n</code> than such a sum would be attained using the Weibull form.
</p>
<p><em>Weibull Empirical Copula</em>—The “Weibull form” of the empirical copula is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}^\mathcal{W}_{n}(u,v) =
     \frac{1}{n}\sum_{i=1}^n \mathbf{1}\biggl(\frac{R_i}{n+1} \le u_i, \frac{S_i}{n+1} \le v_i \biggr)\mbox{,}</code>
</p>

<p>which can be triggered by <code>ctype="weibull"</code>. This form is named for this package because of direct similarity of the <em>Weibull plotting position</em> to the definition, and this form is the default (see argument description).
</p>
<p><em>Bernstein Empirical Copula</em>—The empirical copula can be extended nonparametrically as the <em>Bernstein empirical copula</em> (Hernández-Maldonado, Díaz-Viera, and Erdely, 2012) and is formulated as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}^\mathcal{B}_n(u,v; \eta) = \sum_{i=1}^n\sum_{j=1}^n \mathbf{C}_{n}\biggl(\frac{i}{n},\frac{j}{n}\biggr) \times \eta(i,j; u,v)\mbox{,}</code>
</p>

<p>where the individual <em>Bernstein weights</em> <code class="reqn">\eta(i,j)</code> for the <code class="reqn">k</code>th paired value of the <code class="reqn">u</code> and <code class="reqn">v</code> vectors are
</p>
<p style="text-align: center;"><code class="reqn">\eta(i,j; u,v) = {n \choose i} u^i (1-u)^{n-i} \times {n \choose j} u^j (1-u)^{n-j}\mbox{.}</code>
</p>

<p>The Bernstein extension, albeit conceptually pure in its shuffling by binomial coefficients and left- and right-tail weightings, is quite CPU intensive as inspection of the equations above indicates a nest of four <code>for()</code> loops in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>. (The native <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> code of <span class="pkg">copBasic</span> uses the <code>sapply()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> liberally for substantial but not a blazing fast speed increase.) The Bernstein extension results in a smoother surface of the empirical copula and can be triggered by <code>ctype="bernstein"</code>.
</p>
<p><em>Checkerboard Empirical Copula</em>—A simple smoothing to the empirical copula is the <em>checkerboard empirical copula</em> (Segers et al., 2017) that has been adapted from the <span class="pkg">copula</span> package. It is numerically intensive like the Bernstein and possibly of limited usefulness for large sample sizes. The checkerboard extension can be triggered by <code>ctype="checkerboard"</code> and is formulated as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}^\sharp_{n}(U) = \frac{1}{n+o} \sum_{i=1}^n\prod_{i=1}^d \mathrm{min}[\mathrm{max}[n U_j - R^{(n)}_{i,j} + 1,0],1]\mathrm{,}</code>
</p>

<p>where <code class="reqn">U</code> is a <code class="reqn">d=2</code> column matrix of <code class="reqn">u</code> and <code class="reqn">v</code>, <code class="reqn">R</code> is a rank function, and <code class="reqn">o</code> is an offset term on <code class="reqn">[0,1]</code>.
</p>
<p>The <em>empirical copula frequency</em> can be defined (Nelson, 2006, p. 219) as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{c}_n(u, v) = \mathbf{C}_n\biggl(\frac{i}{n}, \frac{j}{n}\biggr) -
                           \mathbf{C}_n\biggl(\frac{i-1}{n}, \frac{j}{n}\biggr) -
                           \mathbf{C}_n\biggl(\frac{i}{n}, \frac{j-1}{n}\biggr) +
                           \mathbf{C}_n\biggl(\frac{i-i}{n}, \frac{j-1}{n}\biggr)\mbox{.}</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">EMPIRcop(u, v, para=NULL,
               ctype=c("weibull", "hazen", "1/n", "bernstein", "checkerboard"),
                          bernprogress=FALSE, checkerboard.offset=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>A vector (single element) of parameters—the U-statistics of the data (see <b>Examples</b>). Alternatively, <code>para</code> can be a <code>list</code> holding a <code>para</code> as would be done if it were a vector, but arguments <code>bernstein</code> and <code>bernprogress</code> can be optionally included—this feature is provided so that the Bernstein refinement can be controlled within the context of other functions calling <code>EMPIRcop</code> such as by <code>level.curvesCOP</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctype</code></td>
<td>
<p>An alternative means for trigging the definition of  <code class="reqn">\mathbf{C}_n</code>, <code class="reqn">\mathbf{C}^\mathcal{H}_n</code> (default), <code class="reqn">\mathbf{C}^\mathcal{W}_n</code>, <code class="reqn">\mathbf{C}^\mathcal{B}_n</code>, or <code class="reqn">\mathbf{C}^\sharp_n</code>. This argument of the same name is also used by <code>blomCOP</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bernprogress</code></td>
<td>
<p>The Bernstein copula extension is CPU intensive(!), so a splash counter is pushed to the console via the <code>message()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> so as to not discourage the user;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkerboard.offset</code></td>
<td>
<p>A scaling of the ratio <code>sum(....)/(n+offset)</code> for the checkerboard empirical copula; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Note</h3>

<p>Not all theoretical measures of copula dependence (both measures of association and measures of asymmetry), which use numerical integration by the <code>integrate()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, can be used for all empirical copulas because of “divergent” integral errors; however, examples using <em>Hoeffding Phi</em> (<code class="reqn">\Phi_\mathbf{C}</code>; <code>hoefCOP</code>) and shown under <b>Examples</b>. Other measures of copula dependence include <code>blomCOP</code>, <code>footCOP</code>, <code>giniCOP</code>, <code>rhoCOP</code>, <code>tauCOP</code>, <code>wolfCOP</code>, <code>joeskewCOP</code>, and <code>uvlmoms</code>. Each of these measures fortunately has a built-in sample estimator.
</p>
<p>It is important to distinquish between a sample estimator and the estimation of the measure using the empirical copula itself via the <code>EMPIRcop</code> function. The sample estimators (triggered by the <code>as.sample</code> arguments for the measures) are reasonably fast and numerically preferred over using the empirical copula. Further, the generally slow numerical integrations for the theoretical definitions of these copula measures might have difficulties. Limited testing, however, suggests prevalence of numerical integration not erroring using the Bernstein extension of the empirical copula, which must be a by-product of the enhanced and sufficient smoothness for the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> default numerical integration to succeed. Many of the measures have <code>brute</code> option for a brute-force numerical integration on a regular grid across the empirical copula—these are slow but should not trigger errors. As a general rule, users should still use the sample estimators instead.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Hernández-Maldonado, V., Díaz-Viera, M., and Erdely, A., 2012, A joint stochastic simulation method using the Bernstein copula as a flexible tool for modeling nonlinear dependence structures between petrophysical properties: Journal of Petroleum Science and Engineering, v. 90–91, pp. 112–123.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>
<p>Salvadori, G., De Michele, C., Kottegoda, N.T., and Rosso, R., 2007, Extremes in Nature—An approach using copulas: Springer, 289 p.
</p>
<p>Segers, J., Sibuya, M., and Tsukahara, H., 2017, The empirical beta copula: Journal of Multivariate Analysis, v. 155, pp. 35–51.
</p>


<h3>See Also</h3>

<p><code>diagCOP</code>, <code>level.curvesCOP</code>, <code>simCOP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(62)
EMPIRcop(0.321,0.78, para=simCOP(n=90, cop=N4212cop,
                                 para=2.32, graphics=FALSE)) # [1] 0.3222222
N4212cop(0.321,0.78, para=2.32)                              # [1] 0.3201281
## End(Not run)

## Not run: 
set.seed(62) # See note below about another seed to try.
psp &lt;- simCOP(n=34, cop=PSP, ploton=FALSE, points=FALSE) * 150
# Pretend psp is real data, the * 150 is to clearly get into an arbitrary unit system.

# The sort=FALSE is critical in the following two calls. Although the Weibull
# plotting positions are chosen, internally EMPIRcop uses ranks, but the model
# here is to imagine one having a sample in native units of the random variables
# and then casting them into probabilities for other purposes.
fakeU &lt;- lmomco::pp(psp[,1], sort=FALSE) # Weibull plotting position i/(n+1)
fakeV &lt;- lmomco::pp(psp[,2], sort=FALSE) # Weibull plotting position i/(n+1)
uv &lt;- data.frame(U=fakeU, V=fakeV); # our U-statistics

# The next four values should be very close if n above were say 1000, but the
# ctype="bernstein"" should not be used if n &gt;&gt; 34 because of inherently long runtime.
PSP(0.4,0.6)              # 0.3157895 (compare to listed values below)

# Two seeds are shown so that the user can see that depending on the distribution
# of the values given by para that different coincidences of which method is
# equivalent to another exist.
# For set.seed(62) --- "hazen" == "weibull" by coincidence
#    "hazen"     --&gt; 0.3529412
#    "weibull"   --&gt; 0.3529412
#    "1/n"       --&gt; 0.3235294
#    "bernstein" --&gt; 0.3228916
# For set.seed(85) --- "1/n" == "hazen" by coincidence
#    "hazen"     --&gt; 0.3529412
#    "weibull"   --&gt; 0.3823529
#    "1/n"       --&gt; 0.3529412
#    "bernstein" --&gt; 0.3440387

# For set.seed(62) --- not all measures of association can be used for all
# empirical copulas because of 'divergent' integral errors, but this is an example
# for Hoeffding Phi. These computations are CPU intensive, esp. Bernstein.
hoefCOP(as.sample=TRUE, para=uv) #  (sample estimator is fast)  # 0.4987755
hoefCOP(cop=EMPIRcop,   para=uv, ctype="hazen")                 # 0.5035348
hoefCOP(cop=EMPIRcop,   para=uv, ctype="weibull")               # 0.4977145
hoefCOP(cop=EMPIRcop,   para=uv, ctype="1/n")                   # 0.4003646
hoefCOP(cop=EMPIRcop,   para=uv, ctype="bernstein")             # 0.4563724
hoefCOP(cop=EMPIRcop,   para=uv, ctype="checkerboard")          # 0.4952427
## End(Not run)

# All other example suites shown below are dependent on the pseudo-data in the
# variable uv. It is suggested to not run with a sample size much larger than the
# above n=34 if the Bernstein comparison is intended (wanted) simply because of
# lengthy(!) run times, but the n=34 does provide a solid demonstration how the
# level curves for berstein weights are quite smooth.

## Not run: 
# Now let us construct as many as three sets of level curves to the sample
# resided in the uv sample from above using the PSP copula.
level.curvesCOP(cop=PSP); # TRUE, parametric, fast, BLACK CURVES

# Empirical copulas can consume lots of CPU.
# RED CURVES, if n is too small, uniroot() errors might be triggered and likely
# will be using the sample size of 34 shown above.
level.curvesCOP(cop=EMPIRcop, para=uv, delu=0.03, col=2, ploton=FALSE)

# GREEN CURVES (large CPU committment)
# Bernstein progress is uninformative because level.curvesCOP() has taken over control.
bpara &lt;- list(para=uv, ctype="bernstein", bernprogress=FALSE)
level.curvesCOP(cop=EMPIRcop, para=bpara, delu=0.03, col=3, ploton=FALSE)
# The delu is increased for faster execution but more important,
# notice the greater smoothness of the Bernstein refinement.
## End(Not run)

## Not run: 
# Experimental from R Graphics by Murrell (2005, p.112)
"trans3d" &lt;-                         # blackslashes seem needed for the package
function(x,y,z, pmat) {              # for user manual building but bad syntax
  tmat &lt;- cbind(x,y,z,1) %*% pmat    # because remember the percent sign is a
  return(tmat[,1:2] / tmat[,4])      # a comment character in LaTeX.
}

the.grid &lt;- EMPIRgrid(para=uv, ctype="checkerboard")
the.diag &lt;- diagCOP(cop=EMPIRcop, para=uv, ploton=FALSE, lines=FALSE)

the.persp &lt;- persp(the.grid$empcop, theta=-25, phi=20,
                   xlab="U VARIABLE", ylab="V VARIABLE", zlab="COPULA C(u,v)")
the.trace &lt;- trans3d(the.diag$t, the.diag$t, the.diag$diagcop, the.persp)
lines(the.trace, lwd=2, col=2) # The diagonal of the copula

# The following could have been used as an alternative to call persp()
the.persp &lt;- persp(x=the.grid$u, y=the.grid$v, z=the.grid$empcop, theta=-25, phi=20,
                   xlab="U VARIABLE", ylab="V VARIABLE", zlab="COPULA C(u,v)")
lines(the.trace, lwd=2, col=2) # The diagonal of the copula #
## End(Not run)
</code></pre>


</div>