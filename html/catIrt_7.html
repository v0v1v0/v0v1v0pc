<div class="container">

<table style="width: 100%;"><tr>
<td>FI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate Expected and Observed Fisher Information for IRT Models</h2>

<h3>Description</h3>

<p><code>FI</code> calculates expected and/or observed Fisher information for various
IRT models given a vector of ability values, a vector/matrix of item
parameters, and an IRT model.  It also calculates test
information and expected/observed standard error of measurement.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FI( params, theta, type = c("expected", "observed"), resp = NULL )
## S3 method for class 'brm'
FI( params, theta, type = c("expected", "observed"), resp = NULL )
## S3 method for class 'grm'
FI( params, theta, type = c("expected", "observed"), resp = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p><b>numeric:</b> a vector or matrix of item parameters.  If specified
as a matrix, the rows must index the items, and the columns
must designate the item parameters.  Furthermore, if calculating
<em>expected</em> information, the number of rows must match the number
of columns of <code>resp</code>.  The class of <code>params</code> must match
the model: either <span class="option">"brm"</span> or <span class="option">"grm"</span>.  For the binary response
model, <code>params</code> must either be a 3-dimensional vector or a 3-column
matrix.  See <b>Details</b> for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p><b>numeric:</b> a vector of ability values, one for each simulee.  If calculating
<em>expected</em> information, the length of <code>theta</code> must match
the number of rows of <code>resp</code>, unless <code>theta</code> is a scalar,
in which case <code>resp</code> could also be a vector of length
<code>nrow(params)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><b>character:</b> a character string indicating the type of information, either
<span class="option">"expected"</span> or <span class="option">"observed"</span>.  For the 1-parameter and
2-parameter binary response model (of class <span class="option">"brm"</span> with the
third column of <code>params</code> set to 0), both <span class="option">"expected"</span>
and <span class="option">"observed"</span> information are identical. See <b>Details</b>
for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resp</code></td>
<td>
<p><b>numeric:</b> either a <code class="reqn">N \times J</code> matrix (where <code class="reqn">N</code> indicates the
number of simulees and <code class="reqn">J</code> indicates the number of items), a
<code class="reqn">N</code> length vector (if there is only one item) or a <code class="reqn">J</code> length
vector (if there is only one simulee).  For the binary response model
(<span class="option">"brm"</span>), <code>resp</code> must solely contain 0s and 1s.  For the
graded response model (<span class="option">"grm"</span>), <code>resp</code> must solely contain
integers <code class="reqn">1, \ldots, K</code>, where <code class="reqn">K</code> is the number of categories, as
indicated by the dimension of <code>params</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>FI</code> returns item information, test information, and standard error
of measurement for the binary response model (<span class="option">"brm"</span>) or the graded response
model (<span class="option">"grm"</span>).  If the log likelihood is twice differentiable, expected Fisher
information is the negative, expected, second derivative of the log likelihood with respect
to the parameter. For the binary response model, expected item information simplifies to the
following:
</p>
<p style="text-align: center;"><code class="reqn"> I(\theta_i | a_j, b_j, c_j) = \frac{\left(\frac{\partial p_{ij}}{\partial \theta_i}\right)^2}{p_{ij}(1 - p_{ij})} </code>
</p>

<p>where <code class="reqn">\partial p_{ij}/\partial \theta_i</code> is the partial derivative
of <code class="reqn">p_{ij}</code> with respect to <code class="reqn">\theta</code>, and <code class="reqn">p_{ij}</code> is the probability of response, as
indicated in the help page for <code>simIrt</code>.
</p>
<p>For the graded response model, expected item information simplifies to the following:
</p>
<p style="text-align: center;"><code class="reqn"> I(\theta_i | a_j, b_{j1}, \ldots, b_{j(k - 1)}) = \sum_k\frac{\left(\frac{\partial P_{ijk}}{\partial \theta_i}\right)^2}{P_{ijk}}</code>
</p>

<p>where <code class="reqn">\partial P_{ijk}/\partial \theta_i</code> is the partial derivative
of <code class="reqn">P_{ijk}</code> with respect to <code class="reqn">\theta</code>, and <code class="reqn">P_{ijk}</code> is the probability of responding
in category k as indicated in the help page for <code>simIrt</code>. See van der Linden and Pashley
(2010).
</p>
<p>Observed information is the negative second derivative of the log-likelihood.  For the binary
response model (<span class="option">"brm"</span>) with 2-parameters (such that the third column of the
parameter matrix is set to 0), observed and expected information are identical because the second
derivative of their log-likelihoods do not contain observed data.  See Baker and Kim (2004),
pp. 66 – 69.
</p>
<p>For all models, test information is defined as the following:
</p>
<p style="text-align: center;"><code class="reqn"> T(\theta_i) = \sum_jI_j(\theta_i) </code>
</p>

<p>where <code class="reqn">I(\theta_i)_j</code> is shorthand for Fisher information of simulee <code class="reqn">i</code> on item <code class="reqn">j</code>.
Finally, the standard error of measurement (SEM) is the inverse, square-root of test information.
<code>FI</code> is frequently used to <em>select</em> items in a CAT and to estimate the precision
of <code class="reqn">\hat{\theta}_i</code> after test termination.
</p>


<h3>Value</h3>

<p><code>FI</code>, <code>FI.brm</code>, and <code>FI.grm</code> return a list of the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>either: (1) a <code class="reqn">N \times J</code> matrix of item information for each simulee to
each item; (2) a <code class="reqn">J</code>-length vector of item information for one simulee to
each item; or (3) an <code class="reqn">N</code>-length vector of item information for all simulees
to one item, depending on the dimensions of <code>params</code> and <code>theta</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>an <code class="reqn">N</code>-length vector of test information, one for each simulee. Test
information is the sum of item information across items.  See <b>Details</b> for
more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sem</code></td>
<td>
<p>an <code class="reqn">N</code>-length vector of expected or observed standard error of measurement
for each simulee, which is the inverse-square-root of test information.
See <b>Details</b> for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>either <span class="option">"observed"</span> or <span class="option">"expected"</span>, indicating the <em>type</em>
of information calculated.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Steven W. Nydick <a href="mailto:swnydick@gmail.com">swnydick@gmail.com</a>
</p>


<h3>References</h3>

<p>Baker, F. B., &amp; Kim, S.-H.  (2004).  <em>Item Response Theory: Parameter Estimation Techniques, Second Edition</em>.  New York, NY: Marcel Dekker, Inc.
</p>
<p>Dodd, B. G., De Ayala, R. J., &amp; Koch, W. R.  (1995).  Computerized adaptive testing with polytomous items.  <em>Applied Psychological Measurement</em>, <em>19</em>, 5 – 22.
</p>
<p>Embretson, S. E., &amp; Reise, S. P.  (2000).  <em>Item Response Theory for Psychologists</em>.  Mahway, NJ: Lawrence Erlbaum Associates.
</p>
<p>Kullback, S., &amp; Leibler, R. A.  (1951).  On information and sufficiency.  <em>The Annals of Mathematical Statistics</em>, <em>22</em>, 79 – 86.
</p>
<p>van der Linden, W. J. &amp; Pashley, P. J.  (2010).  Item selection and ability estimation in adaptive testing.  In W. J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>.  New York, NY: Springer.
</p>


<h3>See Also</h3>

<p><code>catIrt</code>, <code>KL</code>, <code>simIrt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#########################
# Binary Response Model #
#########################

## 1 ##
set.seed(888)
# generating random theta:
theta &lt;- rnorm(20)
# generating an item bank under a 2-parameter binary response model:
b.params &lt;- cbind(a = runif(100, .5, 1.5), b = rnorm(100, 0, 2), c = 0)
# simulating responses using random theta:
b.mod &lt;- simIrt(params = b.params, theta = theta, mod = "brm")

# you can indicate class of params or extract it from simIrt object:
class(b.params) &lt;- "brm"

# calculating expected and observed information:
e.info &lt;- FI(params = b.params, theta = theta, type = "expected")
o.info &lt;- FI(params = b.params, theta = theta, type = "observed", resp = b.mod$resp)

# 2-parameter model, so e.info will be equal to o.info:
all(signif(e.info$item) == signif(o.info$item))


## 2 ##
# generating an item bank under a 3-parameter binary response model:
b.params2 &lt;- cbind(a = runif(100, .5, 1.5), b = rnorm(100, 0, 2), c = .2)
# simulating responses using pre-specified thetas:
b.mod2 &lt;- simIrt(params = b.params2, mod = "brm")

# calculating expected and observed information:
# (if you don't indicate class, you can extract from simIrt object)
e.info2 &lt;- FI(params = b.params2, theta = b.mod2$theta, type = "expected")
o.info2 &lt;- FI(params = b.params2, theta = b.mod2$theta, type = "observed",
                                  resp = b.mod2$resp)

# 3-parameter model, so e.info will not be equal to o.info:
all(signif(e.info2$item) == signif(o.info2$item))


## 3 ##
# if theta is a scalar, item will be a vector and test will be a scalar:
e.info3 &lt;- FI(params = b.params2, theta = 0, type = "expected")
dim(e.info3$item)       # no dimension because it's a vector
length(e.info3$item)    # of length equal to the number of items

# if params is a vector, item will be a matrix with one row:
e.info4 &lt;- FI(params = c(1, 2, 0), theta = c(1, 2), type = "expected")
dim(e.info4$item)

# if you don't class params, FI will assume a binary response model.


#########################
# Graded Response Model #
#########################
set.seed(999)
# generating random theta
theta &lt;- rnorm(10)
# generating an item bank under a graded response model:
g.params &lt;- cbind(a = runif(30, .5, 1.5), b1 = rnorm(30), b2 = rnorm(30),
                                          b3 = rnorm(30), b4 = rnorm(30))
# you can sort the parameters yourself:
g.params &lt;- cbind(g.params[ , 1],
                  t(apply(g.params[ ,2:dim(g.params)[2]], MARGIN = 1,
                                                          FUN = sort)))
# simulating responses using random theta:
g.mod &lt;- simIrt(params = g.params, theta = theta, mod = "grm")

# calculating expected and observed information:
class(g.params) &lt;- "grm"   # always indicate model or extract from simulation.
e.info5 &lt;- FI(params = g.params, theta = theta, type = "expected")
o.info5 &lt;- FI(params = g.params, theta = theta, type = "observed", resp = g.mod$resp)

# grm, so e.info will not be equal to o.info:
all(signif(e.info5$item) == signif(o.info5$item))

# if thet is a vector and params is a vector, item will be a J x N matrix:
dim(e.info5$item)

# if you don't want to sort the parameters, you can extract from simIrt object:
e.info6 &lt;- FI(params = g.mod$params[ , -1], theta = g.mod$theta, type = "expected")

# but you first need to remove column 1 (the item number column).
</code></pre>


</div>