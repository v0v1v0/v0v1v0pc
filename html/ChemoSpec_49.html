<div class="container">

<table style="width: 100%;"><tr>
<td>splitSpectraGroups</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create New Groups from an Existing Spectra Object</h2>

<h3>Description</h3>

<p>This function takes an existing <code>Spectra</code> object and uses your
instructions to split the existing <code>spectra$groups</code> into new groups.
The new groups are added to the existing <code>Spectra</code> object (a
list) as new elements.  This allows one to use different combinations of
factors than were originally encoded in the <code>Spectra</code> object.
The option also exists to replace the color scheme with one which
corresponds to the new factors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">splitSpectraGroups(spectra, inst = NULL, rep.cols = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spectra</code></td>
<td>
<p>An object of S3 class <code>Spectra()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst</code></td>
<td>
<p>A list giving the name of the new element to be created from a
set of target strings given in a character vector.  See the example for the
syntax.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep.cols</code></td>
<td>
<p>Optional.  A vector giving new colors which correspond to
the levels of <code>inst</code>.  Only possible if <code>inst</code> has only one
element, as the possible combinations of levels and colors may get
complicated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed downstream. Currently not
used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The items in the character vector are grepped among the existing
<code>spectra$groups</code> entries; when found, they are placed in a new element
of <code>Spectra</code>.  In the example, all <code>spectra$groups</code> entries
containing "G" are coded as "G" in a new element called <code>spectra$env</code>,
and any entries containing "T" are handled likewise.  This amounts to a sort
of recoding of factors (the example demonstrates this).  Every entry in
<code>spectra$groups</code> should be matched by one of the entries in the
character vector.  If not, you will get <code>NA</code> entries.  Also, if the targets
in the character vector are not unique, your results will reflect the order
of the levels.  Since this is a grep process, you can pass any valid grep
string as the target.
</p>
<p>If <code>rep.cols</code> is provided, these colors are mapped one for one onto the
levels of the the first element of <code>inst</code>.  This provides a different
means of changing the sample color encoding than <code>conColScheme</code>.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>Spectra</code>, modified to have
additional elements as specified by <code>inst</code>.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson (DePauw University).
</p>


<h3>See Also</h3>

<p><code>conColScheme</code>
Additional documentation at <a href="https://bryanhanson.github.io/ChemoSpec/">https://bryanhanson.github.io/ChemoSpec/</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(metMUD2)
levels(metMUD2$groups) # original factor encoding

# Split those original levels into 2 new ones (re-code them)
new.grps &lt;- list(geneBb = c("B", "b"), geneCc = c("C", "c"))
res &lt;- splitSpectraGroups(metMUD2, new.grps)
str(res) # note two new elements, "geneBb" and "geneCc"
sumSpectra(res) # reports on extra elements

# Note that if you want to use a newly created group in
# plotScores and other functions to drive the color scheme
# and labeling, you'll have to update the groups element:
res$groups &lt;- as.factor(paste(res$geneBb, res$geneCc, sep = ""))

</code></pre>


</div>