<div class="container">

<table style="width: 100%;"><tr>
<td>cl_pclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prototype-Based Partitions of Clusterings</h2>

<h3>Description</h3>

<p>Compute prototype-based partitions of a cluster ensemble by minimizing
<code class="reqn">\sum w_b u_{bj}^m d(x_b, p_j)^e</code>, the sum of the case-weighted and
membership-weighted <code class="reqn">e</code>-th powers of the dissimilarities between
the elements <code class="reqn">x_b</code> of the ensemble and the prototypes <code class="reqn">p_j</code>,
for suitable dissimilarities <code class="reqn">d</code> and exponents <code class="reqn">e</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cl_pclust(x, k, method = NULL, m = 1, weights = 1,
          control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an ensemble of partitions or hierarchies, or something
coercible to that (see <code>cl_ensemble</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>an integer giving the number of classes to be used in the
partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the consensus method to be employed, see
<code>cl_consensus</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a number not less than 1 controlling the softness of the
partition (as the “fuzzification parameter” of the fuzzy
<code class="reqn">c</code>-means algorithm).  The default value of 1 corresponds to
hard partitions obtained from a generalized <code class="reqn">k</code>-means problem;
values greater than one give partitions of increasing softness
obtained from a generalized fuzzy <code class="reqn">c</code>-means problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a numeric vector of non-negative case weights.
Recycled to the number of elements in the ensemble given by <code>x</code>
if necessary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Partitioning is performed using <code>pclust</code> via a family
constructed from <code>method</code>.  The dissimilarities <code class="reqn">d</code> and
exponent <code class="reqn">e</code> are implied by the consensus method employed, and
inferred via a registration mechanism currently only made available to
built-in consensus methods.  The default methods compute Least Squares
Euclidean consensus clusterings, i.e., use Euclidean dissimilarity
<code class="reqn">d</code> and <code class="reqn">e = 2</code>.
</p>
<p>For <code class="reqn">m = 1</code>, the partitioning procedure was introduced by Gaul and
Schader (1988) for “Clusterwise Aggregation of Relations” (with
the same domains), containing equivalence relations, i.e., hard
partitions, as a special case.
</p>
<p>Available control parameters are as for <code>pclust</code>.
</p>
<p>The fixed point approach employed is a heuristic which cannot be
guaranteed to find the global minimum (as this is already true for the
computation of consensus clusterings).  Standard practice would
recommend to use the best solution found in “sufficiently many”
replications of the base algorithm.
</p>


<h3>Value</h3>

<p>An object of class <code>"cl_partition"</code> representing the obtained 
“secondary” partition by an object of class <code>"cl_pclust"</code>,
which is a list containing at least the following components.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>prototypes</code></td>
<td>
<p>a cluster ensemble with the <code class="reqn">k</code> prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>an object of class <code>"cl_membership"</code>
with the membership values <code class="reqn">u_{bj}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>the class ids of the nearest hard partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silhouette</code></td>
<td>
<p>Silhouette information for the partition, see
<code>silhouette</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validity</code></td>
<td>
<p>precomputed validity measures for the partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>the softness control argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>the dissimilarity function <code class="reqn">d = d(x, p)</code> employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>the exponent <code class="reqn">e</code> employed.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>J. C. Bezdek (1981).
<em>Pattern recognition with fuzzy objective function algorithms</em>.
New York: Plenum.
</p>
<p>W. Gaul and M. Schader (1988).
Clusterwise aggregation of relations.
<em>Applied Stochastic Models and Data Analysis</em>, <b>4</b>:273–282.
<a href="https://doi.org/10.1002/asm.3150040406">doi:10.1002/asm.3150040406</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Use a precomputed ensemble of 50 k-means partitions of the
## Cassini data.
data("CKME")
CKME &lt;- CKME[1 : 30]		# for saving precious time ...
diss &lt;- cl_dissimilarity(CKME)
hc &lt;- hclust(diss)
plot(hc)
## This suggests using a partition with three classes, which can be
## obtained using cutree(hc, 3).  Could use cl_consensus() to compute
## prototypes as the least squares consensus clusterings of the classes,
## or alternatively:
set.seed(123)
x1 &lt;- cl_pclust(CKME, 3, m = 1)
x2 &lt;- cl_pclust(CKME, 3, m = 2)
## Agreement of solutions.
cl_dissimilarity(x1, x2)
table(cl_class_ids(x1), cl_class_ids(x2))
</code></pre>


</div>