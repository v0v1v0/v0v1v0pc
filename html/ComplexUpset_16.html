<div class="container">

<table style="width: 100%;"><tr>
<td>upset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compose an UpSet plot</h2>

<h3>Description</h3>

<p>Compose an UpSet plot
</p>


<h3>Usage</h3>

<pre><code class="language-R">upset(
  data,
  intersect,
  base_annotations = "auto",
  name = "group",
  annotations = list(),
  themes = upset_themes,
  stripes = upset_stripes(),
  labeller = identity,
  height_ratio = 0.5,
  width_ratio = 0.3,
  wrap = FALSE,
  set_sizes = upset_set_size(),
  mode = "distinct",
  queries = list(),
  guides = NULL,
  encode_sets = TRUE,
  matrix = intersection_matrix(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a dataframe including binary columns representing membership in classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intersect</code></td>
<td>
<p>which columns should be used to compose the intersection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base_annotations</code></td>
<td>
<p>a named list with default annotations (i.e. the intersection size barplot)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>the label shown below the intersection matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>annotations</code></td>
<td>
<p>a named list of annotations, each being a list with: <code style="white-space: pre;">⁠list(aes=mapping, geom=geom or list of geoms)⁠</code>;
</p>

<ul>
<li>
<p> (optional) <code style="white-space: pre;">⁠highlight_geom=list of geoms⁠</code> geoms which can be highlighted with queries,
</p>
</li>
<li>
<p> (optional) <code style="white-space: pre;">⁠top_geom=list of geoms⁠</code> which should show up on top of highlighted queries.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>themes</code></td>
<td>
<p>a named list of themes for components and annotations, see <code>upset_default_themes()</code>/<code>upset_modify_themes()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stripes</code></td>
<td>
<p>specification of the stripes appearance created with <code>upset_stripes()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labeller</code></td>
<td>
<p>function modifying the names of the sets (rows in the matrix)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height_ratio</code></td>
<td>
<p>ratio of the intersection matrix to intersection size height</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width_ratio</code></td>
<td>
<p>ratio of the overall set size width to intersection matrix width</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap</code></td>
<td>
<p>whether the plot should be wrapped into a group (makes adding a tile/combining with other plots easier)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set_sizes</code></td>
<td>
<p>the overall set sizes plot, e.g. from <code>upset_set_size()</code> (<code>FALSE</code> to hide)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>region selection mode for computing the number of elements in intersection fragment. See <code>get_size_mode()</code> for accepted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queries</code></td>
<td>
<p>a list of queries generated with <code>upset_query()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guides</code></td>
<td>
<p>action for legends aggregation and placement ('keep', 'collect', 'over' the set sizes)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encode_sets</code></td>
<td>
<p>whether set names (column in input data) should be encoded as numbers (set to TRUE to overcome R limitations of max 10 kB for variable names for datasets with huge numbers of sets); default TRUE for upset() and FALSE for upset_data().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>the intersection matrix plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>upset_data</code>
</p>

<dl>
<dt><code>min_size</code></dt>
<dd>
<p>minimal number of observations in an intersection for it to be included</p>
</dd>
<dt><code>max_size</code></dt>
<dd>
<p>maximal number of observations in an intersection for it to be included</p>
</dd>
<dt><code>min_degree</code></dt>
<dd>
<p>minimal degree of an intersection for it to be included</p>
</dd>
<dt><code>max_degree</code></dt>
<dd>
<p>maximal degree of an intersection for it to be included</p>
</dd>
<dt><code>n_intersections</code></dt>
<dd>
<p>the exact number of the intersections to be displayed; n largest intersections that meet the size and degree criteria will be shown</p>
</dd>
<dt><code>keep_empty_groups</code></dt>
<dd>
<p>whether empty sets should be kept (including sets which are only empty after filtering by size)</p>
</dd>
<dt><code>warn_when_dropping_groups</code></dt>
<dd>
<p>whether a warning should be issued when empty sets are being removed</p>
</dd>
<dt><code>warn_when_converting</code></dt>
<dd>
<p>whether a warning should  be issued when input is not boolean</p>
</dd>
<dt><code>sort_sets</code></dt>
<dd>
<p>whether to sort the rows in the intersection matrix (descending sort by default); one of: <code>'ascending'</code>, <code>'descending'</code>, <code>FALSE</code></p>
</dd>
<dt><code>sort_intersections</code></dt>
<dd>
<p>whether to sort the columns in the intersection matrix (descending sort by default); one of: <code>'ascending'</code>, <code>'descending'</code>, <code>FALSE</code></p>
</dd>
<dt><code>sort_intersections_by</code></dt>
<dd>
<p>the mode of sorting, the size of the intersection (cardinality) by default; one of: <code>'cardinality'</code>, <code>'degree'</code>, <code>'ratio'</code>, or any combination of these (e.g. <code>c('degree', 'cardinality')</code>)</p>
</dd>
<dt><code>sort_ratio_numerator</code></dt>
<dd>
<p>the mode for numerator when sorting by ratio</p>
</dd>
<dt><code>sort_ratio_denominator</code></dt>
<dd>
<p>the mode for denominator when sorting by ratio</p>
</dd>
<dt><code>group_by</code></dt>
<dd>
<p>the mode of grouping intersections; one of: <code>'degree'</code>, <code>'sets'</code></p>
</dd>
<dt><code>size_columns_suffix</code></dt>
<dd>
<p>suffix for the columns to store the sizes (adjust if conflicts with your data)</p>
</dd>
<dt><code>intersections</code></dt>
<dd>
<p>whether only the intersections present in data (<code>observed</code>, default), or all intersections (<code>all</code>) should be computed; using all intersections for a high number of sets is not computationally feasible - use <code>min_degree</code> and <code>max_degree</code> to narrow down the selection; this is only useful for modes different from the default exclusive intersection. You can also provide a list with a custom selection of intersections (order is respected when you set <code>sort_intersections=FALSE</code>)</p>
</dd>
<dt><code>max_combinations_datapoints_n</code></dt>
<dd>
<p>a fail-safe limit preventing accidental use of <code>intersections='all'</code> with a high number of sets and observations</p>
</dd>
</dl>
</td>
</tr>
</table>
</div>