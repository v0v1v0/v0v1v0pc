<div class="container">

<table style="width: 100%;"><tr>
<td>rlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Robust Fitting of Linear Models, Compatible with Complex Variables</h2>

<h3>Description</h3>

<p>Uses robust M-estimation to fit a linear model to numeric or complex data. Based on MASS::rlm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rlm(x, ...)

## S3 method for class 'formula'
rlm(
  formula,
  data,
  weights,
  ...,
  subset,
  na.action,
  method = c("M", "MM", "model.frame"),
  wt.method = c("inv.var", "case"),
  model = TRUE,
  x.ret = TRUE,
  y.ret = FALSE,
  contrasts = NULL
)

## S3 method for class 'complex'
rlm(
  x,
  y,
  weights,
  ...,
  w = rep(1, nrow(x)),
  init = "ls",
  psi = psi.huber,
  scale.est = c("MAD", "Huber", "proposal 2"),
  k2 = 1.345,
  method = c("M", "MM"),
  wt.method = c("inv.var", "case"),
  maxit = 20,
  acc = 1e-04,
  test.vec = "resid",
  lqs.control = NULL,
  interc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric or complex. A matrix, dataframe, or vector containing the explanatory / independent / predictor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to rlm.default or to the psi function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object of the form y ~ x1 + x2. Note that algebraic expressions in formula cannot currently be used with complex data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variables upon which a robust fit is to be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>numeric. A vector of weights to apply to the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an index vector specifying the cases (rows of data or x and y) to be used for fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function that specifies what to do if NAs are found in the fitting data. The default is to omit them via na.omit. Can also be changed by options (na.action =).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string. What method of robust estimation should be used. Options are "M", "MM", or "model.frame". The default is M-estimation. MM-estimation has a high breakdown point but is not compatible with complex variables or case weights. model.frame just constructs the model frame, and only works with the formula method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt.method</code></td>
<td>
<p>string, either "inv.var" or "case". Specifies whether the weights are case weights that give the relative importance of each observation (higher weight means more important) / case, or the inverse variances of the cases (higher weight means that observation is less variable / uncertain).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>logical. Should the model frame be included in the returned object?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.ret</code></td>
<td>
<p>logical. Should the model (design) matrix be included in the returned object?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.ret</code></td>
<td>
<p>logical. Should the response be included in the returned object?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>optional contrast specifications: see stats::lm. Not compatible with complex data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric or complex. A vector containing the dependent / response variables, the same length as x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>(optional) initial down-weighting for each case</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>(optional) initial values for the coefficients OR a method to find initial values OR the result of a fit with a coef component. Known methods are "ls" (the default) for an initial least-squares fit using weights w*weights, and "lts" for an unweighted least-trimmed squares fit with 200 samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>the psi function is specified by this argument. It must give (possibly by name) a function g(x, ..., deriv) that for deriv=0 returns psi(x)/x and for deriv=1 returns psi'(x). Tuning constants will be passed in via ...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.est</code></td>
<td>
<p>method of scale estimation: re-scaled MAD of the residuals (default) or Huber's proposal 2 (which can be selected by either "Huber" or "proposal 2"). Only MAD is implemented for complex variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2</code></td>
<td>
<p>tuning constant used for Huber proposal 2 scale estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of IWLS iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc</code></td>
<td>
<p>the accuracy for the stopping criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.vec</code></td>
<td>
<p>the stopping criterion is based on changes in this vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lqs.control</code></td>
<td>
<p>An optional list of control values for lqs, ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interc</code></td>
<td>
<p>TRUE or FALSE, default is FALSE. Used with rlm.default when fitting complex valued data. If true, a y-intercept is calculated during fitting. Otherwise, the intercept is set to zero.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>M-estimation works by finding the model coefficients that minimize the sum of a function of the residuals.
This function, called the objective function rho(), is a kind of statistical distance (AKA divergence), and a semimetric.
As a semimetric it is a function of the measured value <code>y</code> and the modeled value <code>Y</code> (residual <code class="reqn">r = y - Y</code>) which maps from
the space of the data to the positive real numbers. Semimetrics can be defined for domains of any dimensionality, including the
two dimensional complex numbers, and thus so can M-estimation.
What's more, all the standard algebraic operations used in the itteratively (re)weighted least-squares M-estimator robust regression
algorithm are defined over the set of complex numbers. While ordering is not defined for them, it is the output of rho(), a real number, that must be
in M-estimation.
</p>


<h3>Value</h3>

<p>An object of class <code>c("rzlm", "zlm", "rlm", "lm")</code>, or for numeric data <code>c("rlm", "lm")</code>.
</p>
<p>Objects of class "rzlm" are lists with the same components as "zlm" objects, as well as,
</p>
<table>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p><code>NA</code> For "rzlm" objects the residual degrees of freedom are always set to <code>NA</code> in order to avoid estimation of residual scale by "zlm" or "lm" methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>The robust scale estimate used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>The weights used in the IWLS process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>The psi (itterative weighting) function with parameters substituted in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>The value of the convergence criteria at each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>Did the IWLS process converge?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wresid</code></td>
<td>
<p>A 'working residual', the residuals of the last re-weighted least-squares. Weighted by <code>weights</code> if "inv.var" weights were used. </p>
</td>
</tr>
</table>
<p>See MASS::rlm for a description of "rlm" objects.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>formula</code>: S3 method for class 'formula'
</p>
</li>
<li> <p><code>complex</code>: Complex Default S3 method
</p>
</li>
</ul>
<h3>References</h3>

<p>P. J. Huber (1981)
<em>Robust Statistics</em>.
Wiley.
</p>
<p>F. R. Hampel, E. M. Ronchetti, P. J. Rousseeuw and W. A. Stahel (1986)
<em>Robust Statistics: The Approach based on Influence Functions</em>.
Wiley.
</p>
<p>A. Marazzi (1993)
<em>Algorithms, Routines and S Functions for Robust Statistics</em>.
Wadsworth &amp; Brooks/Cole.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em>  Fourth edition.  Springer.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slope*xx + interc + e)
rlm(y ~ x, data = tframe, weights = rep(1,n))
set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
intercept &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
x &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
y &lt;- slope * x + intercept + e
rlm(x = x, y = y, weights = rep(1,n), interc = TRUE)
</code></pre>


</div>