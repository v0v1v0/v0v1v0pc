<div class="container">

<table style="width: 100%;"><tr>
<td>cov.shrink</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Shrinkage Estimates of Covariance and Correlation</h2>

<h3>Description</h3>

<p>The functions <code>var.shrink</code>, <code>cor.shrink</code>, and <code>cov.shrink</code> compute 
shrinkage estimates of variance, correlation, and covariance, respectively.
</p>


<h3>Usage</h3>

<pre><code class="language-R">var.shrink(x, lambda.var, w, verbose=TRUE)
cor.shrink(x, lambda, w, verbose=TRUE)
cov.shrink(x, lambda, lambda.var, w, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the correlation shrinkage intensity (range 0-1).
If <code>lambda</code> is not specified (the default) it is estimated
using an analytic formula from Sch\"afer and Strimmer (2005) 
- see details below.  
For <code>lambda=0</code> the empirical correlations are recovered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.var</code></td>
<td>
<p>the variance shrinkage intensity (range 0-1). 
If <code>lambda.var</code> is not specified (the default) it is estimated
using an analytic formula from Opgen-Rhein and Strimmer (2007)
- see details below.  
For <code>lambda.var=0</code> the empirical variances are recovered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>optional: weights for each data point - if not specified uniform weights are assumed
(<code>w = rep(1/n, n)</code> with <code>n = nrow(x)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>output some status messages while computing (default: TRUE)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>var.shrink</code> computes the empirical variance of each considered random variable, 
and shrinks them towards their median.  The shrinkage intensity is estimated using 
<code>estimate.lambda.var</code> (Opgen-Rhein and Strimmer 2007).
</p>
<p>Similarly   <code>cor.shrink</code> computes a shrinkage estimate of the correlation matrix by
shrinking the empirical correlations towards  the identity matrix.  
In this case the shrinkage intensity is computed using  <code>estimate.lambda</code>
(Sch\"afer and Strimmer 2005).
</p>
<p>In comparison with the standard empirical estimates 
(<code>var</code>, <code>cov</code>, and <code>cor</code>) the shrinkage estimates exhibit
a number of favorable properties.  For instance, 
</p>

<ol>
<li>
<p> they are typically much more efficient, i.e. they show (sometimes dramatically) better 
mean squared error,
</p>
</li>
<li>
<p> the estimated covariance and correlation matrices are always  positive definite
and well conditioned (so that there are no numerical problems when computing their inverse),
</p>
</li>
<li>
<p>  they are inexpensive to compute, and
</p>
</li>
<li>
<p> they are fully automatic and  do not require any
tuning parameters (as the shrinkage intensity is analytically estimated from the data), and
</p>
</li>
<li>
<p> they assume nothing about the underlying distributions, except for the existence of
the first two moments.</p>
</li>
</ol>
<p>These properties also carry over to derived quantities, such as partial variances and
partial correlations (<code>pvar.shrink</code> and  <code>pcor.shrink</code>).
</p>
<p>As an extra benefit, the shrinkage estimators have a form that can be <em>very</em> efficiently inverted, 
especially if the number of variables is large and the sample size is small.   Thus, instead of 
inverting the matrix output by <code>cov.shrink</code> and <code>cor.shrink</code> please use the functions
<code>invcov.shrink</code> and <code>invcor.shrink</code>, respectively.
</p>


<h3>Value</h3>

<p><code>var.shrink</code> returns a vector with estimated variances.
</p>
<p><code>cov.shrink</code> returns a covariance matrix.
</p>
<p><code>cor.shrink</code> returns the corresponding correlation matrix. 
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\"afer,
Rainer Opgen-Rhein,
and Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., and K. Strimmer. 2007. Accurate ranking of 
differentially expressed genes by a distribution-free shrinkage 
approach.    Statist. Appl. Genet. Mol. Biol. <b>6</b>:9.
&lt;DOI:10.2202/1544-6115.1252&gt;
</p>
<p>Sch\"afer, J., and K. Strimmer. 2005.  A shrinkage approach to large-scale
covariance estimation and implications for functional genomics. 
Statist. Appl. Genet. Mol. Biol. <b>4</b>:32.
&lt;DOI:10.2202/1544-6115.1175&gt;
</p>


<h3>See Also</h3>

<p><code>invcov.shrink</code>, <code>pcor.shrink</code>, <code>cor2pcor</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># load corpcor library
library("corpcor")

# small n, large p
p = 100
n = 20

# generate random pxp covariance matrix
sigma = matrix(rnorm(p*p),ncol=p)
sigma = crossprod(sigma)+ diag(rep(0.1, p))

# simulate multinormal data of sample size n  
sigsvd = svd(sigma)
Y = t(sigsvd$v %*% (t(sigsvd$u) * sqrt(sigsvd$d)))
X = matrix(rnorm(n * ncol(sigma)), nrow = n) %*% Y


# estimate covariance matrix
s1 = cov(X)
s2 = cov.shrink(X)


# squared error
sum((s1-sigma)^2)
sum((s2-sigma)^2)


# compare positive definiteness
is.positive.definite(sigma)
is.positive.definite(s1)
is.positive.definite(s2)


# compare ranks and condition
rank.condition(sigma)
rank.condition(s1)
rank.condition(s2)

# compare eigenvalues
e0 = eigen(sigma, symmetric=TRUE)$values
e1 = eigen(s1, symmetric=TRUE)$values
e2 = eigen(s2, symmetric=TRUE)$values
m = max(e0, e1, e2)
yl = c(0, m)

par(mfrow=c(1,3))
plot(e1,  main="empirical")
plot(e2,  ylim=yl, main="full shrinkage")
plot(e0,  ylim=yl, main="true")
par(mfrow=c(1,1))

</code></pre>


</div>