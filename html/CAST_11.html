<div class="container">

<table style="width: 100%;"><tr>
<td>geodist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate euclidean nearest neighbor distances in geographic space or feature space</h2>

<h3>Description</h3>

<p>Calculates nearest neighbor distances in geographic space or feature space between training data as well as between training data and prediction locations.
Optional, the nearest neighbor distances between training data and test data or between training data and CV iterations is computed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geodist(
  x,
  modeldomain = NULL,
  type = "geo",
  cvfolds = NULL,
  cvtrain = NULL,
  testdata = NULL,
  preddata = NULL,
  samplesize = 2000,
  sampling = "regular",
  variables = NULL,
  timevar = NULL,
  time_unit = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class sf, training data locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeldomain</code></td>
<td>
<p>SpatRaster, stars or sf object defining the prediction area (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>"geo" or "feature". Should the distance be computed in geographic space or in the normalized multivariate predictor space (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvfolds</code></td>
<td>
<p>optional. list or vector. Either a list where each element contains the data points used for testing during the cross validation iteration (i.e. held back data).
Or a vector that contains the ID of the fold for each training point. See e.g. ?createFolds or ?CreateSpacetimeFolds or ?nndm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvtrain</code></td>
<td>
<p>optional. List of row indices of x to fit the model to in each CV iteration. If cvtrain is null but cvfolds is not, all samples but those included in cvfolds are used as training data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testdata</code></td>
<td>
<p>optional. object of class sf: Point data used for independent validation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preddata</code></td>
<td>
<p>optional. object of class sf: Point data indicating the locations within the modeldomain to be used as target prediction points. Useful when the prediction objective is a subset of
locations within the modeldomain rather than the whole area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplesize</code></td>
<td>
<p>numeric. How many prediction samples should be used?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling</code></td>
<td>
<p>character. How to draw prediction samples? See spsample. Use sampling = "Fibonacci" for global applications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p>character vector defining the predictor variables used if type="feature. If not provided all variables included in modeldomain are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timevar</code></td>
<td>
<p>optional. character. Column that indicates the date. Only used if type="time".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_unit</code></td>
<td>
<p>optional. Character. Unit for temporal distances See ?difftime.Only used if type="time".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The modeldomain is a sf polygon or a raster that defines the prediction area. The function takes a regular point sample (amount defined by samplesize) from the spatial extent.
If type = "feature", the argument modeldomain (and if provided then also the testdata and/or preddata) has to include predictors. Predictor values for x, testdata and preddata are optional if modeldomain is a raster.
If not provided they are extracted from the modeldomain rasterStack. If some predictors are categorical (i.e., of class factor or character), gower distances will be used.
W statistic describes the match between the distributions. See Linnenbrink et al (2023) for further details.
</p>


<h3>Value</h3>

<p>A data.frame containing the distances. Unit of returned geographic distances is meters. attributes contain W statistic between prediction area and either sample data, CV folds or test data. See details.
</p>


<h3>Note</h3>

<p>See Meyer and Pebesma (2022) for an application of this plotting function
</p>


<h3>Author(s)</h3>

<p>Hanna Meyer, Edzer Pebesma, Marvin Ludwig, Jan Linnenbrink
</p>


<h3>See Also</h3>

<p><code>nndm</code> <code>knndm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(CAST)
library(sf)
library(terra)
library(caret)
library(rnaturalearth)
library(ggplot2)

data(splotdata)
studyArea &lt;- rnaturalearth::ne_countries(continent = "South America", returnclass = "sf")

########### Distance between training data and new data:
dist &lt;- geodist(splotdata, studyArea)
# With density functions
plot(dist)
# Or ECDFs (relevant for nndm and knnmd methods)
plot(dist, stat="ecdf")

########### Distance between training data, new data and test data (here Chile):
plot(splotdata[,"Country"])
dist &lt;- geodist(splotdata[splotdata$Country != "Chile",], studyArea,
                testdata = splotdata[splotdata$Country == "Chile",])
plot(dist)

########### Distance between training data, new data and CV folds:
folds &lt;- createFolds(1:nrow(splotdata), k=3, returnTrain=FALSE)
dist &lt;- geodist(x=splotdata, modeldomain=studyArea, cvfolds=folds)
# Using density functions
plot(dist)
# Using ECDFs (relevant for nndm and knnmd methods)
plot(dist, stat="ecdf")

########### Distances in the feature space:
predictors &lt;- terra::rast(system.file("extdata","predictors_chile.tif", package="CAST"))
dist &lt;- geodist(x = splotdata,
                modeldomain = predictors,
                type = "feature",
                variables = c("bio_1","bio_12", "elev"))
plot(dist)

dist &lt;- geodist(x = splotdata[splotdata$Country != "Chile",],
                modeldomain = predictors, cvfolds = folds,
                testdata = splotdata[splotdata$Country == "Chile",],
                type = "feature",
                variables=c("bio_1","bio_12", "elev"))
plot(dist)

############Distances in temporal space
library(lubridate)
library(ggplot2)
data(cookfarm)
dat &lt;- st_as_sf(cookfarm,coords=c("Easting","Northing"))
st_crs(dat) &lt;- 26911
trainDat &lt;- dat[dat$altitude==-0.3&amp;lubridate::year(dat$Date)==2010,]
predictionDat &lt;- dat[dat$altitude==-0.3&amp;lubridate::year(dat$Date)==2011,]
trainDat$week &lt;- lubridate::week(trainDat$Date)
cvfolds &lt;- CreateSpacetimeFolds(trainDat,timevar = "week")

dist &lt;- geodist(trainDat,preddata = predictionDat,cvfolds = cvfolds$indexOut,
   type="time",time_unit="days")
plot(dist)+ xlim(0,10)


############ Example for a random global dataset
############ (refer to figure in Meyer and Pebesma 2022)

### Define prediction area (here: global):
ee &lt;- st_crs("+proj=eqearth")
co &lt;- ne_countries(returnclass = "sf")
co.ee &lt;- st_transform(co, ee)

### Simulate a spatial random sample
### (alternatively replace pts_random by a real sampling dataset (see Meyer and Pebesma 2022):
sf_use_s2(FALSE)
pts_random &lt;- st_sample(co.ee, 2000, exact=FALSE)

### See points on the map:
ggplot() + geom_sf(data = co.ee, fill="#00BFC4",col="#00BFC4") +
  geom_sf(data = pts_random, color = "#F8766D",size=0.5, shape=3) +
  guides(fill = "none", col = "none") +
  labs(x = NULL, y = NULL)

### plot distances:
dist &lt;- geodist(pts_random,co.ee)
plot(dist) + scale_x_log10(labels=round)





## End(Not run)
</code></pre>


</div>