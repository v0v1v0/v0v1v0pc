<div class="container">

<table style="width: 100%;"><tr>
<td>choicemodelr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Choice Modeling in R</h2>

<h3>Description</h3>

<p>Estimates coefficients of a Hierarchical Bayes Multinomial Logit Model
</p>


<h3>Usage</h3>

<pre><code class="language-R">choicemodelr(data, xcoding, demos, prior, mcmc, constraints, options, directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Required.  A data frame.  The column variables of the data frame are as follows, where natts is the number of attributes; i.e., independent variables:
</p>
<p>UnitID     Set    Alt    X_1 ... X_natts    y<br></p>
<p>The first column contains the ID of the unit (e.g. customer or survey respondent).  The second column contains the choice set number for the unit, where each choice set is an observation for the unit.  The third column contains the alternative number within the choice set.  The last column contains the dependent variable.<br></p>
<p>If the dependent variable y is discrete, then the dependent variable takes a non-zero value only in the first row of the choice set data, and takes a value from 1 to the number of alternatives in the choice set.<br></p>
<p>For example, the following 4 rows of the data frame “data” shows 2 choice sets for unitID=103322 , 3 alternatives per choice set (note that the “none” alternative is excluded in this example), 3 independent variables X1 to X3, and a dependent variable y indicating choice of alternative 2 in the first choice set and alternative 3 in the second choice set.<br></p>

<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  1  1  4  6  1  2</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  1  2  1  1  1  0</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  2  1  3  6  1  3</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  2  2  4  8  1  0</td>
</tr>
</table>
<p>The next example is identical to the first example, except that the dependent variable is a share, indicating 30 percent and 40 percent for alternatives 1 and 2 of choice set 1.<br></p>
<p>For a share dependent variable, the “none” alternative must be explicitly included in the data.<br></p>

<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  1  1  4  6  1  0.3</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  1  2  1  1  1  0.4</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  1  0  0  0  0  0.3</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  2  1  3  6  1  0.5</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  2  2  4  8  1  0.5</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 103322  2  0  0  0  0  0.0</td>
</tr>
</table>
<p>If the dependent variable is a share, then the dependent variable must have a nonzero value in at least one row for each choice set.<br></p>
<p>If the dependent variable is a share and there is a “none” alternative, then set none=FALSE in the options list (see options below). Do not specify none=TRUE for share data.<br></p>
<p>If the dependent variable is a share, the values of the dependent variable need not sum to one as choicemodeler automatically renormalizes the values of the dependent variable to one and then multiplies by wgt (see options below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xcoding</code></td>
<td>
<p>Required.  A vector that specifies the way in which each attribute will be coded:
</p>
<p>0 = categorical (effects coded; a value of zero for a categorical attribute is ignored, i.e. is not used in coefficient estimation)<br>
1 = continuous (the program mean centers the variable across the levels appearing in the data)
</p>
<p>The order of attributes in xcoding must match the order of the attributes appearing in the data file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demos</code></td>
<td>
<p>An “ni by nz” matrix of demographic variables or unit characteristics, where “ni” is the number of units and “nz” is the number of unit-level demographic or descriptor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>list(mubar, Amu, df, v, deltabar, Ad)
</p>
<p>mubar = prior mean of the distribution of mu; must be a vector of length equal to the number of attributes (default is a vector of zeros)
</p>
<p>Amu  =  precision parameter (default is 0.01)
</p>
<p>df = prior degrees of freedom (default is 5, must be <code class="reqn">\ge</code> 2)
</p>
<p>v = prior variance (default is 2, must be  <code class="reqn">\ge</code> 0)
</p>
<p>deltabar = prior mean of the distribution of delta; must be a vector of length equal to the number (nz) of unit descriptor variables in the upper level model (default is a vector of zeros with length nz)
</p>
<p>Ad = precision parameter; a scalar that is inserted into a diagonal matrix with row and column dimensions equal to natts * nz (default is 0.01)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>Required.  A list with 3 arguments: list(R, use, s).
</p>
<p>R = total number of iterations of the Markov chain Monte Carlo (MCMC chain) to be performed (R is required).
</p>
<p>use = the number of iterations to be used in parameter estimation (use is required).
</p>
<p>s = a scaling parameter that is used to adjust the standard deviation of random draws of unit-level parameters during the random walk metropolis step of the MCMC chain.  Only specify s if you wish to keep a constant scaling parameter.  (By default, s = 0.1 and is adjusted at each iteration to keep acceptance of random draws of unit parameters at approximately 30 percent.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>

<p>A list of matrices containing the values 0, 1, and -1.  If specifying constraints, a constraints matrix must be specified for EVERY attribute. Simply declare a matrix of 0s for an unconstrained attribute.
</p>
<p>Each matrix must be square with dimensions equal to the number of levels of the attribute it represents.  For a continuous attribute declare a 1 x 1 matrix containing the appropriate value.  The matrices for categorical variables are interpreted as follows:
</p>

<ul>
<li>
<p> c1[i, j] = 1,  beta_i &gt; beta_j
</p>
</li>
<li>
<p> c1[i, j] = -1,  beta_i &lt; beta_j
</p>
</li>
<li>
<p> c1[i, j] = 0,  no constraint</p>
</li>
</ul>
<p>The lower-triangular and diagonal portions of the matrix have no meaning and values in these positions are ignored.<br></p>
<p>For example, for a model with 3 attributes, set constraints = list(c1, c2, c3).
</p>

<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> c1 = matrix(c(0,-1,-1,-1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,-1,-1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,-1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0), ncol = 4, byrow = TRUE)</td>
</tr>
</table>
<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> c2 = matrix(c(0,1,1,1,1,1,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,1,1,1,1,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,1,1,1,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0,1,1,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0,0,1,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0,0,0,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0,0,0,0,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0,0,0,0,0,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0,0,0,0,0,0), ncol = 9, byrow = TRUE)</td>
</tr>
</table>
<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> c3 = matrix(c(0,1,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,1,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,1,</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> 0,0,0,0), ncol = 4, byrow = TRUE)</td>
</tr>
</table>
<p>The 1 x 1 matrices for continuous variables are interpreted as follows:
</p>

<ul>
<li>
<p> c4[1, 1] = 1,  beta &gt; 0
</p>
</li>
<li>
<p> c4[1, 1] = -1,  beta &lt; 0
</p>
</li>
<li>
<p> c4[1, 1] = 0,  no constraint</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>A list with 5 possible arguments:  list(none, save, keep, wgt, restart).
</p>
<p><b>none</b>:  set to TRUE to estimate a none parameter, and the data does not include a row for “none” (i.e., no choice)  (default is FALSE). If keep&gt;1, the betas (within the choicemodelr output object) will not include those from every iteration of the Markov chain. If keep&gt;1, then the average of the saved betas, for each unit, will not necessarily equal the unit-level betas output to RBetas.csv, since the latter is an average across ALL betas after “burn in”, even when keep&gt;1.
</p>
<p><b>save</b>:  set to TRUE to save draws of betas, deltas, mu, rooti, and the log likelihood (default is FALSE).
</p>
<p><b>keep</b> = the thinning parameter defining the number of random draws to save (default is 10).
</p>
<p><b>wgt</b> = the choice-set weight parameter; possible values are 1 to 10.  This parameter only needs to be specified if estimating a model using a share dependent variable (default is 5).
</p>
<p><b>restart</b>:  Set to TRUE if restarting from a previous model estimation.  To use this option, a model estimation must have been completed prior to the current run, and the restart.txt file must be in the directory specified in the directory argument of the choicemodelr function.  All iterations from the previous run are treated as burn-in.  When restarting, keep all arguments (except for R and use) identical to those of the previous run to avoid errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directory</code></td>
<td>
<p>The directory where RBetas.csv, RLH.csv, RLog.txt, and restart.txt will be saved.  This is also the directory from which restart.txt will be read if restart = TRUE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Model:<br></p>

<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> Y_ij </td>
<td style="text-align: left;"> ~ MNL(beta_i*X_ij) for all  i units and choice sets j</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> (X_ij is nvar by 1, where nvar is the number of independent variables)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> beta_i </td>
<td style="text-align: left;"> = Z_i'delta + u_i</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> (beta_i is 1 by nvar)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> Z_i </td>
<td style="text-align: left;"> = a column vector (nz by 1) of unit characteristics variables</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> delta </td>
<td style="text-align: left;"> = a matrix (nz by nvar) of parameters where each column corresponds</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> to a column of beta_i</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> u_i </td>
<td style="text-align: left;"> ~ N(mu,Sigma), a multivariate normal distribution</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> mu </td>
<td style="text-align: left;"> = a vector of means of the distribution of heterogeneity of length nvar</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> Sigma </td>
<td style="text-align: left;"> = Covariance matrix of the distribution of heterogeneity</td>
</tr>
</table>
<p>Priors:<br></p>

<table>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> delta </td>
<td style="text-align: left;"> ~ N(deltabar, inverse(A_d))</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> mu </td>
<td style="text-align: left;"> ~ N(mubar, inverse(SigmaAmu)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> Sigma_j </td>
<td style="text-align: left;"> ~ IW(nu,V)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> deltabar </td>
<td style="text-align: left;"> = nz by nvar vector of prior means = 0</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> Ad </td>
<td style="text-align: left;"> = prior precision matrix for deltabar = .01I</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> mubar </td>
<td style="text-align: left;"> = nvar by 1 prior mean vector for mu = vector of zeros</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> V </td>
<td style="text-align: left;"> = location parameter for IW prior for Sigma (choicemodelr calculates V = V0 * nu * v)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> nu </td>
<td style="text-align: left;"> = the degrees of freedom parameter for IW prior for Sigma (nu = df + npar, where npar = number of coefficients to estimate)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> V0 </td>
<td style="text-align: left;"> = an npar by npar block diagonal matrix, such that each block is:</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> Of dimension 1 for continuous attributes</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> Of dimension (nlev-1) by (nlev-1) for categorical attributes</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> where</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> nlev = number of levels of the categorical attribute</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> diagonal elements of each block = (nlev-1)/nlev</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> off-diagonal elements of each block = -1/nlev</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> Amu </td>
<td style="text-align: left;"> = prior precision for normal mean = .01</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>betadraw</code></td>
<td>
<p>An ni by natt by floor(use/keep) array of MCMC random draws of unit-level multinomial logit model parameter estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betadraw.c</code></td>
<td>
<p>An ni by natt by floor(use/keep) array of constrained MCMC random draws of unit-level multinomial logit model parameter estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltadraw</code></td>
<td>
<p>A floor(use/keep) by nz*natt array of MCMC random draws of parameter estimates on covariates to the distribution of heterogeneity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compdraw</code></td>
<td>
<p>A list of floor(use/keep) MCMC random draws of estimates of means and roots for the multivariate normal distribution of heterogeneity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike</code></td>
<td>
<p>A floor(use/keep) vector of likelihoods for the MCMC draws of multinomial logit parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RLH</code></td>
<td>
<p>An ni-length vector of the average of floor((R-use)/keep) RLH's (geometric mean of the likelihood of the choices made across the choice sets of the unit, given the randomly drawn unit-level multinomial logit model parameter estimates)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Written to Console During Model Estimation</code></td>
<td>
<p>During model estimation, the following statistics are written to the screen after each 100 iterations.  The selection of these particular statistics was suggested by Sawtooth Software's technical paper, “The CBC/HB System for Hierarchical Bayes Estimation,” Version 5.0 Technical Paper (2009).  Following Sawtooth Software's approach for certain statistics, we use a weighted average with a weight of 0.01 for the last 100 iterations and 0.99 for previous iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Acceptance</code></td>
<td>
<p>Percent of MCMC draws accepted in the Metropolis Hastings step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RLH</code></td>
<td>
<p>nth root of the likelihood, where n is the average number of choice tasks (weighted average).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Percent Certainty</code></td>
<td>
<p>Percent difference between log likelihood and log likelihood of a chance model (weighted average).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Average Variance</code></td>
<td>
<p>Average variance of latest estimates of model coefficients across all units (weighted average).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RMS</code></td>
<td>
<p>Root mean squared of latest estimates of model coefficients across all units (weighted average).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Graphic Output</code></td>
<td>
<p>During model estimation, estimates of mu (mean of model coefficients from the distribution of heterogeneity) are plotted in the graphics window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Written to Disk</code></td>
<td>
<p>At the end of model estimation, the average of MCMC draws of unit-level model coefficients are written to RBetas.csv, and the average of each unit's RLH (the geometric mean of the likelihood of the choices made across the choice sets of the unit) are written to RLH.csv. The estimated coefficients in RBetas.csv (and the RLH's in RLH.csv) are the average across all iterations of the Markov chain, excluding the first R - use “burn in” iterations. A log file, documenting run-time output is written to Rlog.txt. Latest MCMC draws are written to restart.txt. When using estimated coefficients of continuous variables in subsequent simulations, remember that choicemodelr mean centers data for continuous attributes before estimating the coefficient. That is, the mean across all of the unique values of the continuous variable is subtracted from the value found in “data”.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For further explanation of model and priors, see rhierMnlRwMixture of the bayesm package, authored by Peter Rossi, Ph.D., Anderson School, UCLA.  For further discussion, see Rossi, Allenby and McCulloch (2005).  The model specification is identical to that in bayesm, except that (a) the step length of the random walk metropolis algorithm was simplified to use increments of covariance (s**2)(Sigma), where “s” is a scaling parameter mentioned above and “Sigma” is the current draw of the covariance matrix of the distribution of heterogeneity and (b) the distribution of heterogeneity was simplified to a normal vs. a mixture of normals.
</p>


<h3>Author(s)</h3>

<p>Ryan Sermas, assisted by John V. Colias Ph.D., at Decision Analyst, Inc.
<a href="mailto:DecisionAnalystR@decisionanalyst.com">DecisionAnalystR@decisionanalyst.com</a>
</p>


<h3>References</h3>

<p>Rossi, Peter; Allenby, Greg M.; and McCulloch, Robert (2005), <em>Bayesian Statistics and Marketing</em>, John Wiley and Sons.
</p>
<p>Sawtooth Software (2009), “The CBC/HB System for Hierarchical Bayes Estimation”, Version 5.0 Technical Paper, www.sawtoothsoftware.com.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# EXAMPLE 1: MULTINOMIAL LOGIT

# LOAD ARTIFICIAL (SIMULATED) DATA THAT WAS CREATED
# BY R CODE FOUND IN datar SECTION OF THE HELP FILES.

data(datar)
data(truebetas)

# USE choicemodelr TO ESTIMATE THE PARAMETERS OF THE CHOICE MODEL.
# FOR CONVERGENCE OF MCMC CHAIN, SET R = 4000 AND use = 2000.

xcoding = c(0, 0)
mcmc = list(R = 10, use = 10)

options = list(none=FALSE, save=TRUE, keep=1)

attlevels = c(5, 3)
constype =  c(0, 1)
constraints = vector("list", 2)

for (i in 1:length(attlevels)) {
	constraints[[i]] = diag(0, attlevels[i])
	if (constype[i] == 1) {
		constraints[[i]][upper.tri(constraints[[i]])] = -1
	}
	else if (constype[i] == 2) {
		constraints[[i]][upper.tri(constraints[[i]])] = 1
	}
}

pth = tempdir()
out = choicemodelr(datar, xcoding, mcmc = mcmc, options = options,
                   constraints = constraints, directory= pth)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN ESTIMATED AND TRUE BETAS.
estbetas = apply(out$betadraw.c,c(1,2),mean)
estbetas = cbind(estbetas[,1:4],0-apply(estbetas[,1:4],1,sum),
                 estbetas[,5:6],0-apply(estbetas[,5:6],1,sum))
colnames(estbetas) = c("A1B1", "A1B2", "A1B3", "A1B4", "A1B5", "A2B1", "A2B2", "A2B3")

MAE = mean(abs(estbetas - truebetas))
print(MAE)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN PROBABILITY
# DIFFERENCES USING ESTIMATED AND TRUE BETAS.

TrueProb = cbind(exp(truebetas[,1:5]) / apply(exp(truebetas[,1:5]),1,sum),
                 exp(truebetas[,6:8]) / apply(exp(truebetas[,6:8]),1,sum))
EstProb = cbind(exp(estbetas[,1:5]) / apply(exp(estbetas[,1:5]),1,sum),
                exp(estbetas[,6:8]) / apply(exp(estbetas[,6:8]),1,sum))
MAEProb = mean(abs(TrueProb - EstProb))

print(MAEProb)


# EXAMPLE 2: FRACTIONAL MULTINOMIAL LOGIT

# LOAD ARTIFICIAL (SIMULATED) FRACTIONAL MULTINOMIAL LOGIT DATA CREATED
# BY R CODE FOUND IN sharedatar SECTION OF THE HELP FILES.

data(sharedatar)
data(truebetas)

# USE choicemodelr TO ESTIMATE THE PARAMETERS OF THE CHOICE MODEL.
# FOR CONVERGENCE OF MCMC CHAIN, SET R = 2000 AND use = 1000.

xcoding = c(0, 0)
mcmc = list(R = 10, use = 10)

options = list(none=FALSE, save=TRUE, keep=1)

attlevels = c(5, 3)
constype =  c(0, 1)
constraints = vector("list", 2)

for (i in 1:length(attlevels)) {
	constraints[[i]] = diag(0, attlevels[i])
	if (constype[i] == 1) {
		constraints[[i]][upper.tri(constraints[[i]])] = -1
	}
	else if (constype[i] == 2) {
		constraints[[i]][upper.tri(constraints[[i]])] = 1
	}
}

pth = tempdir()
out = choicemodelr(sharedatar, xcoding, mcmc = mcmc, options = options,
                   constraints = constraints, directory=pth)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN ESTIMATED AND TRUE BETAS.
estbetas = apply(out$betadraw.c,c(1,2),mean)
estbetas = cbind(estbetas[,1:4],0-apply(estbetas[,1:4],1,sum),
                 estbetas[,5:6],0-apply(estbetas[,5:6],1,sum))
colnames(estbetas) = c("A1B1", "A1B2", "A1B3", "A1B4", "A1B5", "A2B1", "A2B2", "A2B3")

MAE = mean(abs(estbetas - truebetas))
print(MAE)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN PROBABILITY
# DIFFERENCES USING ESTIMATED AND TRUE BETAS.

TrueProb = cbind(exp(truebetas[,1:5]) / apply(exp(truebetas[,1:5]),1,sum),
                 exp(truebetas[,6:8]) / apply(exp(truebetas[,6:8]),1,sum))
EstProb = cbind(exp(estbetas[,1:5]) / apply(exp(estbetas[,1:5]),1,sum),
                exp(estbetas[,6:8]) / apply(exp(estbetas[,6:8]),1,sum))
MAEProb = mean(abs(TrueProb - EstProb))

print(MAEProb)

</code></pre>


</div>