<div class="container">

<table style="width: 100%;"><tr>
<td>cmd_path_search</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Macro for constructing target path validators</h2>

<h3>Description</h3>

<p>A common pattern in designing shell interfaces is to ask the user to give an
absolute path to the target shell utility. It is common to pass this
information from the user to R by using either R environment variables
defined in .Renviron, using options (set with option(), and got with
getOption()), having the user explicitly pass the path in the function call,
or failing this, using a default install path.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cmd_path_search(
  environment_var = NULL,
  option_name = NULL,
  default_path = NULL,
  utils = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>environment_var</code></td>
<td>
<p>name of R environment variable defining target path. Can be set in .Renviron.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>option_name</code></td>
<td>
<p>name of user-configurable option (called by getOption) which will hold path to target</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default_path</code></td>
<td>
<p>default install path of target. Can contain shell
specials like "~" which will be expanded at runtime (as opposed to build time of the search function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>utils</code></td>
<td>
<p>optional character vector containing names of valid utils inside
target path, used to populate error checking for valid install.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Another common use-case involves software packages with many tools packaged
in a single directory, and the user may want to call one or many utilities
within this common structure.
</p>
<p>For example, the software "coolpackage" is installed in "~/coolpackage", and
has two programs: "tool1", and "tool2" found in "~/coolpackage/tool1" and
~/coolpackage/tool2", respectively.
</p>
<p>To design an interface to coolpackage, this function can automate checking
and validation for not only the package, but for each desired utility in the
package.
</p>
<p>The hierarchy of path usage is: user-defined &gt; option_name &gt; environment_var &gt; default_path
</p>


<h3>Value</h3>

<p>function that returns a valid path to tool or optional utility.
</p>
<p>The returned path_search function takes as input a path or util. where path
is a user override path for the supported tool. If the user-defined path is
invalid, this will always throw an error and not search the defined defaults.
</p>
<p>util must be found within the target path, but does not have to be present in
the original "utils" call. The user will be warned if this is the case. If
<code>util</code> is set to <code>TRUE</code> will return all paths to utilities without checking
the install. This can be used for writing user-facing install checkers.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (.Platform$OS.type == "unix") {
bin_checker &lt;- cmd_path_search(default_path = "/bin", utils = c("ls", "pwd"))
# returns path to bin
bin_checker()
# returns path to bin/ls
bin_checker(util = "ls")
}
</code></pre>


</div>