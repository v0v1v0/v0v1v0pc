<div class="container">

<table style="width: 100%;"><tr>
<td>empCopula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Empirical Copula</h2>

<h3>Description</h3>

<p>Computes the empirical copula (according to a provided method) and
auxiliary tools.
</p>


<h3>Usage</h3>

<pre><code class="language-R">empCopula(X, smoothing = c("none", "beta", "checkerboard",
                           "schaake.shuffle"), offset = 0,
          ties.method = c("max", "average", "first", "last", "random", "min"))
C.n(u, X, smoothing = c("none", "beta", "checkerboard"), offset = 0,
    ties.method = c("max", "average", "first", "last", "random", "min"))
dCn(u, U, j.ind = 1:d, b = 1/sqrt(nrow(U)), ...)
F.n(x, X, offset = 0, smoothing = c("none", "beta", "checkerboard"))
Cn(x, w) ## &lt;-- deprecated!  use  C.n(w, x) instead!
toEmpMargins(U, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">(n, d)</code>-<code>matrix</code> of pseudo-observations
with <code class="reqn">d</code> columns (as <code>x</code> or <code>u</code>). Recall that a
multivariate random sample can be transformed to pseudo-observations
via <code>pobs()</code>. For <code>F.n()</code> and if <code>smoothing !=
      "none"</code>, <code>X</code> can also be a general, multivariate sample,
in which case the empirical distribution function is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u,w</code></td>
<td>
<p>an <code class="reqn">(m, d)</code>-<code>matrix</code> with elements in
<code class="reqn">[0,1]</code> whose rows contain the evaluation points of the
empirical copula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>an <code class="reqn">(n,d)</code>-<code>matrix</code> of
pseudo- (or copula-)observations (elements in <code class="reqn">[0,1]</code>,
same number <code class="reqn">d</code> of columns as <code>u</code> (for <code>dCn()</code>))
or <code>x</code> (for <code>toEmpMargins()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <code class="reqn">(m, d)</code>-<code>matrix</code> whose rows
contain the evaluation points of the empirical distribution&lt; function
(if <code>smoothing = "none"</code>) or copula (if <code>smoothing != "none"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing</code></td>
<td>
<p><code>character</code> string specifying the type of
smoothing of the empirical distribution function (for <code>F.n()</code>)
or the empirical copula (for <code>C.n()</code>). Available are:
</p>

<dl>
<dt><code>"none"</code></dt>
<dd>
<p>the original empirical distribution function
or empirical copula.</p>
</dd>
<dt><code>"beta"</code></dt>
<dd>
<p>the empirical beta smoothed distribution
function or empirical beta copula.</p>
</dd>
<dt><code>"checkerboard"</code></dt>
<dd>
<p>empirical checkerboard construction.</p>
</dd>
<dt><code>"schaake.shuffle"</code></dt>
<dd>
<p>in each dimension, <code>n</code>
(so <code>nrow(X)</code>-many) sorted standard uniforms are used
to construct a smooth sample, from which one draws with
replacement as many observations as required; only available
for the empirical copula and only for sampling.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties.method</code></td>
<td>
<p><code>character</code> string specifying how ranks should be computed if
there are ties in any of the coordinate samples of <code>x</code>; passed
to <code>pobs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j.ind</code></td>
<td>
<p><code>integer</code> vector of indices <code class="reqn">j</code> between 1
and <code class="reqn">d</code> indicating the dimensions with respect to which
first-order partial derivatives are approximated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p><code>numeric</code> giving the bandwidth for approximating
first-order partial derivatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>used in scaling the result which is of the form
<code>sum(....)/(n+offset)</code>; defaults to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>dCn()</code> or
<code>sort()</code> underlying <code>toEmpMargins()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given pseudo-observations from a distribution with continuous margins
and copula C, the <em>empirical copula</em> is the (default) empirical
distribution function of these pseudo-observations.  It is thus a
natural nonparametric estimator of C. The function <code>C.n()</code>
computes the empirical copula or two alternative smoothed versions of
it: the <em>empirical beta copula</em> or the <em>empirical
checkerboard copula</em>; see Eqs. (2.1) and (4.1) in Segers, Sibuya and
Tsukahara (2017), and the references therein. <code>empCopula()</code>
is the constructor of an object of class <code>empCopula</code>.
</p>
<p>The function <code>dCn()</code> approximates first-order partial derivatives
of the unknown copula using the empirical copula.
</p>
<p>The function <code>F.n()</code> computes the empirical distribution function
of a multivariate sample. Note that <code>C.n(u, X, smoothing="none",
  *)</code> simply calls <code>F.n(u, pobs(X), *)</code> after checking <code>u</code>.
</p>
<p>There are several asymptotically equivalent definitions of the
empirical copula. <code>C.n(, smoothing = "none")</code> is simply defined
as the empirical distribution function computed from the
pseudo-observations, that is,
</p>
<p style="text-align: center;"><code class="reqn">C_n(\bm{u})=\frac{1}{n}\sum_{i=1}^n\mathbf{1}_{\{\hat{\bm{U}}_i\le\bm{u}\}},</code>
</p>
<p> where <code class="reqn">\hat{\bm{U}}_i</code>,
<code class="reqn">i\in\{1,\dots,n\}</code>, denote the pseudo-observations and
<code class="reqn">n</code> the sample size. Internally, <code>C.n(,smoothing = "none")</code>
is just a wrapper for <code>F.n()</code> and is expected to be fed with the
pseudo-observations.
</p>
<p>The approximation for the <code class="reqn">j</code>th partial derivative of the unknown
copula <code class="reqn">C</code> is implemented as, for example, in Rémillard and Scaillet
(2009), 
and given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{\dot{C}}_{jn}(\bm{u})=\frac{C_n(u_1,..,u_{j-1},min(u_j+b,1),u_{j+1},..,u_d)-C_n(u_1,..,u_{j-1},max(u_j-b,0),u_{j+1},..,u_d)}{2b},</code>
</p>

<p>where <code class="reqn">b</code> denotes the bandwidth and <code class="reqn">C_n</code> the empirical copula.
</p>


<h3>Value</h3>

<p><code>empCopula()</code> is the constructor for objects of class
<code>empCopula</code>.
</p>
<p><code>C.n()</code> returns the empirical copula of the pseudo-observations
<code>X</code> evaluated at <code>u</code> (or a smoothed version of it).






</p>
<p><code>dCn()</code> returns a vector (<code>length(j.ind)</code> is 1) or a matrix
(with number of columns equal to <code>length(j.ind)</code>), containing
the approximated first-order partial derivatives of the unknown
copula at <code>u</code> with respect to the arguments in <code>j.ind</code>.
</p>
<p><code>F.n()</code> returns the empirical distribution function of <code>X</code>
evaluated at <code>x</code> if <code>smoothing = "none"</code>, the empirical beta
copula evaluated at <code>x</code> if <code>smoothing = "beta"</code> and the empirical
checkerboard copula evaluated at <code>x</code> if <code>smoothing =
    "checkerboard"</code>.





</p>
<p><code>toEmpMargins()</code> transforms the copula sample <code>U</code> to the
empirical margins based on the sample <code>x</code>.
</p>


<h3>Note</h3>

<p>The first version of our empirical copula implementation, <code>Cn()</code>,
had its two arguments <em>reversed</em> compared to <code>C.n()</code>, and is
deprecated now.  You <b>must</b> swap its arguments to transform to
new code.
</p>
<p>The use of the two smoothed versions assumes implicitly no
ties in the component samples of the data.
</p>


<h3>References</h3>

<p>Rüschendorf, L. (1976).  Asymptotic distributions of
multivariate rank order statistics,
<em>Annals of Statistics</em> <b>4</b>, 912–923.
</p>
<p>Deheuvels, P. (1979).  La fonction de dépendance empirique et ses
propriétés: un test non paramétrique d'indépendance,
<em>Acad. Roy. Belg. Bull. Cl. Sci.</em>, 5th Ser. <b>65</b>, 274–292.
</p>
<p>Deheuvels, P. (1981).  A non parametric test for independence,
<em>Publ. Inst. Statist. Univ. Paris</em> <b>26</b>, 29–50.
</p>
<p>Clark, M., Gangopadhyay, S., Hay, L., Rajagopalan, B. and Wilby,
R. (2004). The Schaake Shuffle: A Method for Reconstructing Space-Time
Variability in Forecasted Precipitation and Temperature Fields.
<em>Journal of Hydrometeorology</em>, pages 243-262.
</p>
<p>Rémillard, B. and Scaillet, O. (2009). Testing for equality
between two copulas. <em>Journal of Multivariate Analysis</em>, 100(3),
pages 377-386.
</p>
<p>Segers, J., Sibuya, M. and Tsukahara, H. (2017). The Empirical Beta
Copula. <em>Journal of Multivariate Analysis</em>, 155, pages 35–51,
<a href="https://arxiv.org/abs/1607.04430">https://arxiv.org/abs/1607.04430</a>.
</p>
<p>Kiriliouk, A., Segers, J. and Tsukahara, H. (2020).
Resampling Procedures with Empirical Beta Copulas.
<a href="https://arxiv.org/abs/1905.12466">https://arxiv.org/abs/1905.12466</a>.
</p>





<h3>See Also</h3>

<p><code>pobs()</code> for computing pseudo-observations.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate data X (from a meta-Gumbel model with N(0,1) margins)
n &lt;- 100
d &lt;- 3
family &lt;- "Gumbel"
theta &lt;- 2
cop &lt;- onacopulaL(family, list(theta=theta, 1:d))
set.seed(1)
X &lt;- qnorm(rCopula(n, cop)) # meta-Gumbel data with N(0,1) margins

## Evaluate empirical copula
u &lt;- matrix(runif(n*d), n, d) # random points were to evaluate the empirical copula
ec &lt;- C.n(u, X = X)

## Compare the empirical copula with the true copula
pc &lt;- pCopula(u, copula = cop)
mean(abs(pc - ec)) # ~= 0.012 -- increase n to decrease this error

## The same for the two smoothed versions
beta &lt;- C.n(u, X, smoothing = "beta")
mean(abs(pc - beta))
check &lt;- C.n(u, X, smoothing = "checkerboard")
mean(abs(pc - check))

## Compare the empirical copula with F.n(pobs())
U &lt;- pobs(X) # pseudo-observations
stopifnot(identical(ec, F.n(u, X = pobs(U)))) # even identical

## Compare the empirical copula based on U at U with the Kendall distribution
## Note: Theoretically, C(U) ~ K, so K(C_n(U, U = U)) should approximately be U(0,1)
plot(ecdf(pK(C.n(U, X), cop = cop@copula, d = d)), asp = 1, xaxs="i", yaxs="i")
segments(0,0, 1,1, col=adjustcolor("blue",1/3), lwd=5, lty = 2)
abline(v=0:1, col="gray70", lty = 2)

## Compare the empirical copula and the true copula on the diagonal
C.n.diag &lt;- function(u) C.n(do.call(cbind, rep(list(u), d)), X = X) # diagonal of C_n
C.diag &lt;- function(u) pCopula(do.call(cbind, rep(list(u), d)), cop) # diagonal of C
curve(C.n.diag, from = 0, to = 1, # empirical copula diagonal
      main = paste("True vs empirical diagonal of a", family, "copula"),
      xlab = "u", ylab = quote("True C(u,..,u) and empirical"~C[n](u,..,u)))
curve(C.diag, lty = 2, add = TRUE) # add true copula diagonal
legend("bottomright", lty = 2:1, bty = "n", inset = 0.02,
       legend = expression(C, C[n]))

## Approximate partial derivatives w.r.t. the 2nd and 3rd component
j.ind &lt;- 2:3 # indices w.r.t. which the partial derivatives are computed
## Partial derivatives based on the empirical copula and the true copula
der23 &lt;- dCn(u, U = pobs(U), j.ind = j.ind)
der23. &lt;- copula:::dCdu(archmCopula(family, param=theta, dim=d), u=u)[,j.ind]
## Approximation error
summary(as.vector(abs(der23-der23.)))

## For an example of using F.n(), see help(mvdc)% ./Mvdc.Rd

## Generate a bivariate empirical copula object (various smoothing methods)
n &lt;- 10 # sample size
d &lt;- 2 # dimension
set.seed(271)
X &lt;- rCopula(n, copula = claytonCopula(3, dim = d))
ecop.orig  &lt;- empCopula(X) # smoothing = "none"
ecop.beta  &lt;- empCopula(X, smoothing = "beta")
ecop.check &lt;- empCopula(X, smoothing = "checkerboard")

## Sample from these (smoothed) empirical copulas
m &lt;- 50
U.orig  &lt;-  rCopula(m, copula = ecop.orig)
U.beta  &lt;-  rCopula(m, copula = ecop.beta)
U.check &lt;-  rCopula(m, copula = ecop.check)

## Plot
wireframe2(ecop.orig,  FUN = pCopula, draw.4.pCoplines = FALSE)
wireframe2(ecop.beta,  FUN = pCopula)
wireframe2(ecop.check, FUN = pCopula)
## Density (only exists when smoothing = "beta")
wireframe2(ecop.beta,  FUN = dCopula)

## Transform a copula sample to empirical margins
set.seed(271)
X &lt;- qexp(rCopula(1000, copula = claytonCopula(2))) # multivariate distribution
U &lt;- rCopula(917, copula = gumbelCopula(2)) # new copula sample
X. &lt;- toEmpMargins(U, x = X) # tranform U to the empirical margins of X
plot(X.) # Gumbel sample with empirical margins of X
</code></pre>


</div>