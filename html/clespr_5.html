<div class="container">

<table style="width: 100%;"><tr>
<td>func.cle.prop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Composite Likelihood Estimation for Spatial Proportional Data</h2>

<h3>Description</h3>

<p><code>func.cle.prop</code> performs composite likelihood estimation of parameters and their standard errors in a spatial Tobit model by maximizing its composite log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class="language-R">func.cle.prop(vec.yobs, mat.X, mat.lattice, radius, n.sim = 100,
  parallel = TRUE, n.core = max(detectCores()/2, 1), output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vec.yobs</code></td>
<td>
<p>a vector of observed responses for all N sites.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat.X</code></td>
<td>
<p>regression (design) matrix, including intercepts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat.lattice</code></td>
<td>
<p>a data matrix containing geographical information of sites. The i-th row constitutes a set of geographical coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>weight radius.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p>number of simulations used for calculate the Godambe matrix (default: 100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical flag indicating using parallel processing (default: <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.core</code></td>
<td>
<p>number of physical cores used for parallel processing (when <code>parallel</code> is <code>TRUE</code>), default value is <code>max(detectCores()/2,1)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>logical flag indicates whether printing out result (default: <code>TRUE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given the design matrix, the vector of observed responses, spatial lattice data, weight radius, and the prespecified number of simulated vectors of responses used in estimating the Godambe information matrix, this function assumes initial values of <code class="reqn">\beta</code> as the estimates from the standard Type I Tobit model with independent responses. The initial value of <code class="reqn">\alpha</code> and the right limit of the Tobit model are equally set to 1. Since there is only one cutoff point to be estimated, reparameterization is unnecessary. The function first estimates parameters of interest by maximizing the composite log-likelihood using <code>optim(...,method = "L-BFGS-B")</code>, then computes the simulated based standard error and asymptotic covariance matrix.
</p>


<h3>Value</h3>

<p><code>func.cle.prop</code> returns a list containing:
</p>
<p><code>vec.par</code>: a vector of estimator for <code class="reqn">\theta=(\alpha,\beta,\sigma^2,\rho)</code>;
</p>
<p><code>vec.se</code>: a vector of standard error for the estimator;
</p>
<p><code>mat.asyvar</code>: estimated asymptotic covariance matrix <code class="reqn">H^{-1}(\theta)J(\theta)H^{-1}(\theta)</code> for the estimator; and
</p>
<p><code>vec.comp</code>: a vector of computational time for parameter and standard error estimation.
</p>
<p><code>CLIC</code>: Composite likelihood information criterion proposed by Varin and Vidoni (2005), i.e. <code class="reqn">-2*logCL(\theta) + 2*trace(H^{-1}(\theta)J(\theta))</code>
</p>


<h3>References</h3>

<p>Feng, Xiaoping, Zhu, Jun, Lin, Pei-Sheng, and Steen-Adams, Michelle M. (2014) Composite likelihood Estimation for Models of Spatial Ordinal Data and Spatial Proportional Data with Zero/One values. <em>Environmetrics</em> 25(8): 571â€“583.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># True parameter
alpha &lt;- 4; vec.beta &lt;- c(1, 2, 1, 0, -1); sigmasq &lt;- 0.8; rho &lt;- 0.6; radius &lt;- 5
vec.par &lt;- c(alpha, vec.beta, sigmasq, rho)

# Coordinate matrix
n.lati &lt;- 30; n.long &lt;- 30
n.site &lt;- n.lati * n.long
mat.lattice &lt;- cbind(rep(1:n.lati, n.long), rep(1:n.long, each=n.lati))
mat.dist &lt;- as.matrix(dist(mat.lattice, upper=TRUE, diag=TRUE))
mat.cov &lt;- sigmasq * rho^mat.dist

set.seed(1228)

# Generate regression (design) matrix with intercept
mat.X &lt;- cbind(rep(1, n.site),scale(matrix(rnorm(n.site*(length(vec.beta)-1)),nrow=n.site)))
vec.Z &lt;- t(chol(mat.cov)) %*% rnorm(n.site) + mat.X %*% vec.beta
vec.epsilon &lt;- diag(sqrt(1-sigmasq), n.site) %*% rnorm(n.site)
vec.ylat &lt;- as.numeric(vec.Z + vec.epsilon)

# Convert to the vector of observation
vec.yobs &lt;- func.obs.prop(vec.ylat, alpha=alpha)

# With parallel computing

## Not run: 
prop.example &lt;- func.cle.prop(vec.yobs, mat.X, mat.lattice, radius,
n.sim=100, parallel = TRUE, n.core = 2)

round(prop.example$vec.par,4)
# alpha   beta0   beta1   beta2   beta3   beta4 sigma^2     rho
# 3.8259  0.9921  1.9679  0.9455  0.0148 -0.9871  0.8386  0.5761

round(prop.example$vec.se ,4)
# alpha   beta0   beta1   beta2   beta3   beta4 sigma^2     rho
# 0.1902  0.1406  0.1103  0.0744  0.0385  0.0652  0.1527  0.1151

## End(Not run)

# Without parallel computing

## Not run: 
prop.example2 &lt;- func.cle.prop(vec.yobs, mat.X, mat.lattice, radius, n.sim=100, parallel = FALSE)

## End(Not run)

</code></pre>


</div>