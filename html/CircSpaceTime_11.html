<div class="container">

<table style="width: 100%;"><tr>
<td>ProjSpTi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Samples from the posterior distribution of the Projected Normal spatial model</h2>

<h3>Description</h3>

<p><code>ProjSpTi</code> produces samples from the posterior distribution of the spatial
projected normal model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ProjSpTi(x = x, coords = coords, times = c(), start = list(alpha =
  c(1, 1, 0.5, 0.5), tau = c(0.1, 0.5), rho_sp = c(0.1, 0.5), rho_t =
  c(0.1, 0.5), sep_par = c(0.1, 0.5), sigma2 = c(0.1, 0.5), r = sample(1,
  length(x), replace = T)), priors = list(tau = c(8, 14), rho_sp = c(8,
  14), rho_t = c(8, 14), sep_par = c(8, 14), sigma2 = c(), alpha_mu = c(1,
  1), alpha_sigma = c()), sd_prop = list(sigma2 = 0.5, tau = 0.5, rho_sp
  = 0.5, rho_t = 0.5, sep_par = 0.5, sdr = sample(0.05, length(x), replace
  = T)), iter = 1000, BurninThin = c(burnin = 20, thin = 10),
  accept_ratio = 0.234, adapt_param = c(start = 1, end = 1e+07, exp =
  0.9, sdr_update_iter = 50), n_chains = 2, parallel = FALSE,
  n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>
If they are not in <code class="reqn">[0,2\pi)</code>, the function will tranform
the data in the right interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>an n vector with the times of ....</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a vector with <code>n_chains</code> elements
</p>

<ul>
<li>
<p>     alpha the 2-d vector of the means of the Gaussian bi-variate distribution,
</p>
</li>
<li>
<p>  tau the correlation of the two components of the linear representation,
</p>
</li>
<li>
<p>  rho_sp the spatial decay parameter,
</p>
</li>
<li>
<p>  rho_t the temporal decay parameter,
</p>
</li>
<li>
<p>  sigma2 the process variance,
</p>
</li>
<li>
<p>  sep_par the separation parameter,
</p>
</li>
<li>
<p>  r the vector of <code>length(x)</code>,  latent variable
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list of 7 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha_mu</dt>
<dd>
<p>a vector of 2 elements, the means of  the bivariate Gaussian distribution,</p>
</dd>
<dt>alpha_sigma</dt>
<dd>
<p>a 2x2 matrix, the covariance matrix of the bivariate Gaussian distribution,</p>
</dd>
<dt>rho_sp</dt>
<dd>
<p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>rho_t</dt>
<dd>
<p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>tau</dt>
<dd>
<p> vector of 2 elements defining the minimum and maximum of a uniform distribution with the constraints min(tau) &gt;= -1 and max(tau) &lt;= 1,</p>
</dd>
<dt>sep_par</dt>
<dd>
<p>a vector of 2 elements defining the two parameters of a beta distribution,</p>
</dd>
<dt>sigma2</dt>
<dd>
<p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_prop</code></td>
<td>
<p>=list of 4 elements. To run the MCMC for the rho_sp, tau and sigma2 parameters and r vector we use an adaptive metropolis and in sd_prop we build a list of initial guesses for these three parameters and the r vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>iter number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt_param</code></td>
<td>
<p>a vector of 4 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes. The last element (sdr_update_iter) must be a positive integer defining every how many iterations there is the update of the sd  (vector) of  (vector) r.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>it returns a list of <code>n_chains</code> lists each with elements
</p>

<dl>
<dt>
<code>tau</code>, <code>rho_sp</code>, <code>rho_t</code>, <code>sigma2</code>
</dt>
<dd>
<p>vectors with the thinned chains</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>a matrix with <code>nrow=2</code> and <code>ncol=</code> the length of thinned chains</p>
</dd>
<dt><code>r</code></dt>
<dd>
<p>a matrix with <code>nrow=length(x)</code> and <code>ncol=</code> the length of thinned chains</p>
</dd>
</dl>
<h3>References</h3>

<p>G. Mastrantonio, G.Jona Lasinio,
A. E. Gelfand, "Spatio-temporal circular models with
non-separable covariance structure", TEST 25 (2016), 331â€“350.
</p>
<p>F. Wang, A. E.   Gelfand,
"Modeling space and space-time directional data using projected Gaussian processes",
Journal of the American Statistical Association,109 (2014), 1565-1580
</p>
<p>T. Gneiting,  "Nonseparable, Stationary Covariance Functions for Space-Time
Data", JASA 97 (2002), 590-600
</p>


<h3>See Also</h3>

<p><code>ProjKrigSpTi</code> for spatio-temporal prediction under the spatio-temporal projected  normal model,
<code>WrapSpTi</code> to sample from the posterior distribution of the  spatio-temporal
Wrapped Normal model and <code>WrapKrigSpTi</code> for spatio-temporal prediction under the
same model
</p>
<p>Other spatio-temporal models: <code>WrapSpTi</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(CircSpaceTime)
#### simulated example
## auxiliary functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov) {
  d &lt;- if (is.matrix(varcov)) {
    ncol(varcov)
  } else {
    1
  }
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}
####
# Simulation using a gneiting covariance function
####
set.seed(1)
n &lt;- 20

coords &lt;- cbind(runif(n, 0, 100), runif(n, 0, 100))
coordsT &lt;- cbind(runif(n, 0, 100))
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho &lt;- 0.05
rhoT &lt;- 0.01
sep_par &lt;- 0.1
sigma2 &lt;- 1
alpha &lt;- c(0.5)
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist / (rhoT * DistT^2 + 1)^(sep_par / 2))
tau &lt;- 0.2

Y &lt;- rmnorm(
  1, rep(alpha, times = n),
  kronecker(SIGMA, matrix(c(sigma2, sqrt(sigma2) * tau, sqrt(sigma2) * tau, 1), nrow = 2))
)
theta &lt;- c()
for (i in 1:n) {
  theta[i] &lt;- atan2(Y[(i - 1) * 2 + 2], Y[(i - 1) * 2 + 1])
}
theta &lt;- theta %% (2 * pi) ## to be sure we have values in (0,2pi)
rose_diag(theta)
################ some useful quantities
rho_sp.min &lt;- 3 / max(Dist)
rho_sp.max &lt;- rho_sp.min + 0.5
rho_t.min &lt;- 3 / max(DistT)
rho_t.max &lt;- rho_t.min + 0.5
### validation set 20% of the data
val &lt;- sample(1:n, round(n * 0.2))

set.seed(200)

mod &lt;- ProjSpTi(
  x = theta[-val],
  coords = coords[-val, ],
  times = coordsT[-val],
  start = list(
    "alpha" = c(0.66, 0.38, 0.27, 0.13),
    "rho_sp" = c(0.29, 0.33),
    "rho_t" = c(0.25, 0.13),
    "sep_par" = c(0.56, 0.31),
    "tau" = c(0.71, 0.65),
    "sigma2" = c(0.47, 0.53),
    "r" = abs(rnorm(length(theta[-val])))
  ),
  priors = list(
    "rho_sp" = c(rho_sp.min, rho_sp.max), # Uniform prior in this interval
    "rho_t" = c(rho_t.min, rho_t.max), # Uniform prior in this interval
    "sep_par" = c(1, 1), # Beta distribution
    "tau" = c(-1, 1), ## Uniform prior in this interval
    "sigma2" = c(10, 3), # inverse gamma
    "alpha_mu" = c(0, 0), ## a vector of 2 elements,
    ## the means of the bivariate Gaussian distribution
    "alpha_sigma" = diag(10, 2) # a 2x2 matrix, the covariance matrix of the
    # bivariate Gaussian distribution,
  ),
  sd_prop = list(
    "sep_par" = 0.1, "sigma2" = 0.1, "tau" = 0.1, "rho_sp" = 0.1, "rho_t" = 0.1,
    "sdr" = sample(.05, length(theta), replace = TRUE)
  ),
  iter = 4000,
  BurninThin = c(burnin = 2000, thin = 2),
  accept_ratio = 0.234,
  adapt_param = c(start = 155000, end = 156000, exp = 0.5),
  n_chains = 2,
  parallel = TRUE,
)
check &lt;- ConvCheck(mod)
check$Rhat ### convergence has been reached when the values are close to 1
#### graphical checking
#### recall that it is made of as many lists as the number of chains and it has elements named
#### as the model's parameters
par(mfrow = c(3, 3))
coda::traceplot(check$mcmc)
par(mfrow = c(1, 1))
# move to prediction once convergence is achieved using ProjKrigSpTi
</code></pre>


</div>