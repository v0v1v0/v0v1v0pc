<div class="container">

<table style="width: 100%;"><tr>
<td>deparse_call</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Deparse a language object</h2>

<h3>Description</h3>

<p>An alternative to <code>base::deparse()</code> and <code>rlang::expr_deparse()</code> that
handles additional corner cases and fails when encountering tokens other than
symbols and syntactic literals where cited alternatives would produce non syntactic code.<br><br></p>


<h3>Usage</h3>

<pre><code class="language-R">deparse_call(
  call,
  one_liner = FALSE,
  pipe = FALSE,
  style = TRUE,
  collapse = !style,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>A call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>one_liner</code></td>
<td>
<p>Boolean. Whether to collapse multi-line expressions on a single line using
semicolons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pipe</code></td>
<td>
<p>Boolean. Whether to use the base pipe to disentangle nested calls. This
works best on simple calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>style</code></td>
<td>
<p>Boolean. Whether to give a class "constructive_code" on the output
for pretty printing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single string,
won't be directly visible if <code>style</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unicode_representation</code></td>
<td>
<p>By default "ascii", which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. "latin" is more lax and uses all latin characters
(code point &lt; 256). "character" shows all characters, but not emojis. Finally
"unicode" displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pedantic_encoding</code></td>
<td>
<p>Boolean. Whether to mark strings with the "unknown" encoding
rather than an explicit native encoding ("UTF-8" or "latin1") when it's
necessary to reproduce the binary representation exactly. This detail is
normally of very little significance. The reason why we're not pedantic by default is that
the constructed code might be different in the console and in snapshot
tests and reprexes due to the latter rounding some angles, and it would
be confusing for users.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a string or a character vector, with a class "constructive_code" for pretty
printing if <code>style</code> is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">expr &lt;- quote(foo(bar({this; that}, 1)))
deparse_call(expr)
deparse_call(expr, one_liner = TRUE)
deparse_call(expr, pipe = TRUE)
deparse_call(expr, style = FALSE)
</code></pre>


</div>