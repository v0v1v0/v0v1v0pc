<div class="container">

<table style="width: 100%;"><tr>
<td>get_distance_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute all shortest distance between origin and destination nodes.</h2>

<h3>Description</h3>

<p>Compute all shortest distance between origin and destination nodes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_distance_matrix(
  Graph,
  from,
  to,
  algorithm = "phast",
  aggregate_aux = FALSE,
  allcores = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Graph</code></td>
<td>
<p>An object generated by makegraph, cpp_simplify or cpp_contract function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>A vector of one or more vertices from which distances are calculated (origin).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Character. Only for contracted graph, <code>mch</code> for Many to many CH, <code>phast</code> for PHAST algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate_aux</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the additional weight is summed along shortest paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allcores</code></td>
<td>
<p>Logical (deprecated). If <code>TRUE</code>, all cores are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If graph is not contracted, <code>get_distance_matrix()</code> recursively perform Dijkstra algorithm for each <code>from</code> nodes.
If graph is contracted, the user has the choice between : </p>

<ul>
<li>
<p> many to many contraction hierarchies (<code>mch</code>) : optimal for square matrix.
</p>
</li>
<li>
<p> PHAST (<code>phast</code>) : outperform mch on rectangular matrix
</p>
</li>
</ul>
<p>Shortest path is always computed according to the main edge weights, corresponding to the 3rd column of <code>df</code> argument in <code>makegraph()</code> function.
If <code>aggregate_aux</code> argument is <code>TRUE</code>, the values returned are the sum of auxiliary weights along shortest paths.
</p>
<p>All algorithms are <strong>multithreaded.</strong> <code>allcores</code> argument is deprecated, please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>See details in package website : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p>Matrix of shortest distances.
</p>


<h3>Note</h3>

<p>It is not possible to aggregate auxiliary weights on a Graph object coming from cpp_simplify function.
</p>


<h3>See Also</h3>

<p>get_distance_pair, get_multi_paths
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges &lt;- data.frame(from_vertex = c(0,0,1,1,2,2,3,4,4),
                    to_vertex = c(1,3,2,4,4,5,1,3,5),
                    time = c(9,2,11,3,5,12,4,1,6),
                    dist = c(5,3,4,7,5,5,5,8,7))

#Construct directed  graph with travel time as principal weight, and distance as secondary weight
graph &lt;- makegraph(edges[,1:3], directed=TRUE, aux = edges$dist)

#Get all nodes IDs
nodes &lt;- graph$dict$ref

# Get matrix of shortest times between all nodes : the result are in time unit
time_mat &lt;- get_distance_matrix(graph, from = nodes, to = nodes)

# Get matrix of distance according shortest times : the result are in distance unit
dist_mat &lt;- get_distance_matrix(graph, from = nodes, to = nodes, aggregate_aux = TRUE)

print(time_mat)
print(dist_mat)
</code></pre>


</div>