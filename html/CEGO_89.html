<div class="container">

<table style="width: 100%;"><tr>
<td>optimEA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evolutionary Algorithm for Combinatorial Optimization</h2>

<h3>Description</h3>

<p>A basic implementation of a simple Evolutionary Algorithm for Combinatorial Optimization. Default evolutionary operators
aim at permutation optimization problems.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optimEA(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Optional start individual(s) as a list. If NULL (default), <code>creationFunction</code> (in <code>control</code> list) is used to create initial design. 
If <code>x</code> has less individuals than the population size, creationFunction will fill up the rest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>target function to be minimized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>(list), with the options:
</p>

<dl>
<dt><code>budget</code></dt>
<dd>
<p>The limit on number of target function evaluations (stopping criterion) (default: 1000).</p>
</dd>
<dt><code>popsize</code></dt>
<dd>
<p>Population size (default: 100).</p>
</dd>
<dt><code>generations</code></dt>
<dd>
<p>Number of generations (stopping criterion) (default: Inf).</p>
</dd>
<dt><code>targetY</code></dt>
<dd>
<p>Target function value (stopping criterion) (default: -Inf).</p>
</dd>
<dt><code>vectorized</code></dt>
<dd>
<p>Boolean. Defines whether target function is vectorized (takes a list of solutions as argument) or not (takes single solution as argument). Default: FALSE.</p>
</dd>
<dt><code>verbosity</code></dt>
<dd>
<p>Level of text output during run. Defaults to 0, no output.</p>
</dd>
<dt><code>plotting</code></dt>
<dd>
<p>Plot optimization progress during run (TRUE) or not (FALSE). Default is FALSE.</p>
</dd>
<dt><code>archive</code></dt>
<dd>
<p>Whether to keep all candidate solutions and their fitness in an archive (TRUE) or not (FALSE). Default is TRUE. New solutions that are identical to an archived one, will not be evaluated. Instead, their fitness is taken from the archive.</p>
</dd>
<dt><code>recombinationFunction</code></dt>
<dd>
<p>Function that performs recombination, default: <code>recombinationPermutationCycleCrossover</code>, which is cycle crossover for permutations.</p>
</dd>
<dt><code>recombinationRate</code></dt>
<dd>
<p>Number of offspring, defined by the fraction of the population (popsize) that will be recombined.</p>
</dd>
<dt><code>mutationFunction</code></dt>
<dd>
<p>Function that performs mutation, default: <code>mutationPermutationSwap</code>, which is swap mutation for permutations.</p>
</dd>
<dt><code>parameters</code></dt>
<dd>
<p>Default parameter list for the algorithm, e.g., mutation rate, etc.</p>
</dd>
<dt><code>selection</code></dt>
<dd>
<p>Survival selection process: "tournament" (default) or "truncation".</p>
</dd>
<dt><code>tournamentSize</code></dt>
<dd>
<p>Tournament size (default: 2).</p>
</dd>
<dt><code>tournamentProbability</code></dt>
<dd>
<p>Tournament probability (default: 0.9).</p>
</dd>
<dt><code>localSearchFunction</code></dt>
<dd>
<p>If specified, this function is used for a local search step. Default is NULL. </p>
</dd>
<dt><code>localSearchRate</code></dt>
<dd>
<p>Specifies on what fraction of the population local search is applied. Default is zero. Maximum is 1 (100 percent).</p>
</dd>
<dt><code>localSearchSettings</code></dt>
<dd>
<p>List of settings passed to the local search function control parameter.</p>
</dd>
<dt><code>stoppingCriterionFunction</code></dt>
<dd>
<p>Custom additional stopping criterion. Function evaluated on the population, receiving all individuals (list) and their fitness (vector). If the result is FALSE, the algorithm stops.</p>
</dd>
<dt><code>verbosity</code></dt>
<dd>
<p>&gt;0 for text output.</p>
</dd>
<dt><code>creationFunction</code></dt>
<dd>
<p>Function to create individuals/solutions in search space. Default is a function that creates random permutations of length 6.</p>
</dd>
<dt><code>selfAdaption</code></dt>
<dd>
<p>An optional ParamHelpers object, that describes parameters of the optimization (see <code>parameters</code>) which are subject to self-adaption. An example is given in mutationSelfAdapt.</p>
</dd>
<dt><code>selfAdaptTau</code></dt>
<dd>
<p>Positive numeric value, that controls the learning rate of numerical/integer self-adaptive parameters.</p>
</dd>
<dt><code>selfAdaptP</code></dt>
<dd>
<p>Value in [0,1]. A probability of mutation for all categorical, self-adaptive parameters.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list:
</p>

<dl>
<dt><code>xbest</code></dt>
<dd>
<p>best solution found.</p>
</dd>
<dt><code>ybest</code></dt>
<dd>
<p>fitness of the best solution.</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>history of all evaluated solutions.</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>corresponding target function values f(x).</p>
</dd>
<dt><code>count</code></dt>
<dd>
<p>number of performed target function evaluations.</p>
</dd>
<dt><code>message</code></dt>
<dd>
<p>Termination message: Which stopping criterion was reached.</p>
</dd>
<dt><code>population</code></dt>
<dd>
<p>Last population.</p>
</dd>
<dt><code>fitness</code></dt>
<dd>
<p>Fitness of last population.</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>optimCEGO</code>, <code>optimRS</code>, <code>optim2Opt</code>, <code>optimMaxMinDist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#First example: permutation optimization
seed=0
#distance
dF &lt;- distancePermutationHamming
#mutation
mF &lt;- mutationPermutationSwap
#recombination
rF &lt;-  recombinationPermutationCycleCrossover 
#creation
cF &lt;- function()sample(5)
#objective function
lF &lt;- landscapeGeneratorUNI(1:5,dF)
#start optimization
set.seed(seed)
res &lt;- optimEA(,lF,list(creationFunction=cF,mutationFunction=mF,recombinationFunction=rF,
	popsize=6,budget=60,targetY=0,verbosity=1,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
res$xbest 
#Second example: binary string optimization
#number of bits
N &lt;- 50
#target function (simple example)
f &lt;- function(x){
 sum(x)
}
#function to create random Individuals
cf &lt;- function(){
		sample(c(FALSE,TRUE),N,replace=TRUE)
}
#control list
cntrl &lt;- list(
	budget = 100,
	popsize = 5,
	creationFunction = cf,
	vectorized = FALSE, #set to TRUE if f evaluates a list of individuals
	recombinationFunction = recombinationBinary2Point,
	recombinationRate = 0.1,
	mutationFunction = mutationBinaryBitFlip,
	parameters=list(mutationRate = 1/N),
	archive=FALSE #recommended for larger budgets. do not change.
)
#start algorithm
set.seed(1)
res &lt;- optimEA(fun=f,control=cntrl)
res$xbest
res$ybest

</code></pre>


</div>