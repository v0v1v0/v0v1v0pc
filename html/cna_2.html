<div class="container">

<table style="width: 100%;"><tr>
<td>allCombs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate all logically possible value configurations of a given set of factors
</h2>

<h3>Description</h3>

<p>The function <code>allCombs</code> generates a data frame of all possible value configurations of <code>length(x)</code> factors, the first factor having <code>x[1]</code> values, the second <code>x[2]</code> values etc. The factors are labeled using capital letters. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">allCombs(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Integer vector with values &gt;0</p>
</td>
</tr></table>
<h3>Details</h3>

<p>In combination with <code>selectCases</code>. <code>makeFuzzy</code>, and <code>is.submodel</code>, <code>allCombs</code> is useful for simulating data, which are needed for inverse search trials benchmarking the output of <code>cna</code>. In a nutshell, <code>allCombs</code> generates the space of all logically possible configurations of the factors in an analyzed factor set, <code>selectCases</code> selects those configurations from this space that are compatible with a given data generating causal structure (i.e. the ground truth, which can be randomly generated using <code>randomConds</code>), <code>makeFuzzy</code> fuzzifies those data, and <code>is.submodel</code> checks whether the models returned by <code>cna</code> are true of the ground truth.
</p>
<p>The <span class="pkg">cna</span> package provides another function to the same effect, <code>full.ct</code>, which is more flexible than <code>allCombs</code>.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p><code>selectCases</code>, <code>makeFuzzy</code>, <code>is.submodel</code>, <code>randomConds</code>, <code>full.ct</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate all logically possible configurations of 5 dichotomous factors named "A", "B",
# "C", "D", and "E". 
allCombs(c(2, 2, 2, 2, 2)) - 1
# allCombs(c(2, 2, 2, 2, 2)) generates the value space for values 1 and 2, but as it is
# conventional to use values 0 and 1 for Boolean factors, 1 must be subtracted from
# every value output by allCombs(c(2, 2, 2, 2, 2)) to yield a Boolean data frame.

# Generate all logically possible configurations of 5 multi-value factors named "A", "B",
# "C", "D", and "E", such that A can take on 3 values {1,2,3}, B 4 values {1,2,3,4},
# C 3 values etc.
dat0 &lt;- allCombs(c(3, 4, 3, 5, 3))
head(dat0)
nrow(dat0) # = 3*4*3*5*3

# Generate all configurations of 5 dichotomous factors that are compatible with the causal
# chain (A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E).
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
(dat2 &lt;- selectCases("(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", dat1))

# Generate all configurations of 5 multi-value factors that are compatible with the causal
# chain (A=2*B=1 + A=3*B=3 &lt;-&gt; C=1)*(C=1*D=2 + C=4*D=4 &lt;-&gt; E=3).
dat1 &lt;- allCombs(c(3, 3, 4, 4, 3))
dat2 &lt;- selectCases("(A=2*B=1 + A=3*B=3 &lt;-&gt; C=1)*(C=1*D=2 + C=4*D=4 &lt;-&gt; E=3)", dat1)
nrow(dat1)
nrow(dat2)                    

# Generate all configurations of 5 fuzzy-set factors that are compatible with the causal
# structure A*b + C*D &lt;-&gt; E, such that con = .8 and cov = .8.
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = seq(0, 0.45, 0.01))
(dat3 &lt;- selectCases1("A*b + C*D &lt;-&gt; E", con = .8, cov = .8, dat2))

# Inverse search for the data generating causal structure A*b + a*B + C*D &lt;-&gt; E from
# fuzzy-set data with non-perfect consistency and coverage scores.
set.seed(3)
groundTruth &lt;- "A*b + a*B + C*D &lt;-&gt; E"
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = 0:4/10)
dat3 &lt;- selectCases1(groundTruth, con = .8, cov = .8, dat2)
ana1 &lt;- cna(dat3, outcome = "E", con = .8, cov = .8)
any(is.submodel(asf(ana1)$condition, groundTruth))
</code></pre>


</div>