<div class="container">

<table style="width: 100%;"><tr>
<td>kde2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multi-dimensional adaptive kernel density estimation</h2>

<h3>Description</h3>

<p>Produces a 2D kernel density estimation on a 2D grid from a D-dimensional (D&gt;=2) point set
</p>


<h3>Usage</h3>

<pre><code class="language-R">kde2(
  x,
  w = NULL,
  nx = 300,
  xlim = NULL,
  ylim = NULL,
  smoothing = 1,
  sigma = NULL,
  sigma.min = 0,
  sigma.max = Inf,
  reflect = "",
  algorithm = "kdenn",
  probability = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>N-by-D vector of x-coordinates or N-by-2 matrix of (x,y)-coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>optional N-element vector with weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>integer specifying the number of equally space grid cells along the x-axis; the number ny of pixels along the y-axis is determined automatically from xlim and ylim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>2-element vector specifying the x-range</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>2-element vector specifying the y-range; if needed, this range is slightly adjusted to allow for an integer number of pixels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing</code></td>
<td>
<p>positive linear smoothing factor; the larger, the smoother the density field</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>optional N-vector, specifying the blurring of each pixel individually in length units of x; only used if algorithm=4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.min</code></td>
<td>
<p>optional value, specifying the minimum blurring of any pixel, expressed in standard deviations in length units of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.max</code></td>
<td>
<p>optional value, specifying the maximum blurring of any pixel, expressed in standard deviations in length units of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reflect</code></td>
<td>
<p>vector of strings c('left','right','bottom','top') specifying the edges, where the data should be reflected to avoid probability density leaking outside the window</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>integer value or character string specifying the smoothing altorithm:<br><code>basic (0):</code> basic nearest-neighbor gridding algorithm without smoothing
<code>blur (1):</code> simple Gaussian blur of gridded density field
<code>kdefast (2):</code> 2D smoothing method that ignores higher dimensional information and applies a smoothing size to each pixel that depends on the number of objects in each pixel
<code>kdennnn  (3):</code> sophisticated Kernel density estimator that uses D-dimensional nearest neighbor separations to smooth each data point individually
<code>manual (4):</code> smooths each data point individually using a Gaussian Kernel with point-dependent standard deviations given in the optional vector <code>sigma</code><br><br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probability</code></td>
<td>
<p>logical flag. If TRUE, the output field is normalized such that sum(field)dpixel^2=1. If FALSE (default), the field is such that sum(field)dpixel^2 equals the effective number of particles (or effective mass, if weights are given) in the range specified by xlim and ylim, including particle fractions that have been smoothed into the field and excluding particle fractions that have been smoothed out of it.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list of items
</p>
<table>
<tr style="vertical-align: top;">
<td><code>field</code></td>
<td>
<p>2D array of smoothed density field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>nx-element vector of cell-center x-coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>ny-element vector of cell-center y-coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xbreak</code></td>
<td>
<p>(nx+1)-element vector of cell-edge x-coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ybreak</code></td>
<td>
<p>(ny+1)-element vector of cell-edge y-coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dpixel</code></td>
<td>
<p>grid spacing along x-coordinate and y-coordinate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>name of algorithm in use.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code>griddata</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># make a mock sample of n d-dimensional points from
# three different components (1D line, 2D square, d-D normal distr)
d = 3 # number of dimensions of mock point set; try to choose different values 2, 3, 4, ...
n = 1e4 # number of particles per component
set.seed(1)
x = rbind(cbind(array(rep(runif(n,-1,1),2),c(n,2)),array(0,c(n,d-2))),
          cbind(array(runif(2*n),c(n,2)),array(0,c(n,d-2))),
          array(rnorm(d*n),c(n,d)))

# grid total projected probability density
npixels = 500 # number of pixels along a grid side
q = midseq(-3,3,npixels)
f1 = outer(dnorm(q),dnorm(q),'*')/3+outer(dunif(q),dunif(q),'*')/3
q = seq(round(npixels/3),round(npixels*2/3))
f1[q+npixels*(q-1)] = f1[q+npixels*(q-1)]+(npixels/6)^2/length(q)/3

# recover 2D projected pdf from 3D point sample using different methods
f2 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='basic', probability=TRUE)$field
f3 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='kdefast', probability=TRUE)$field
f4 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='kdenn', probability=TRUE)$field

# plot the 2D fields
img = function(f,x,y,title) {
  graphics::rasterImage(rasterflip(lim(f)^0.3),x,y,x+0.99,y+0.99)
  graphics::text(x+0.05,y+0.9,title,col='orange',pos=4)
}
oldpar = graphics::par(mar=rep(0.1,4))
nplot(c(0,2),c(0,2),asp=1)
img(f1,0,1,'Input pdf')
img(f2,1,1,'Random sample ("basic")')
img(f3,0,0,'Recovered pdf ("kdefast")')
img(f4,1,0,'Recovered pdf ("kdenn")')
graphics::par(oldpar)

</code></pre>


</div>