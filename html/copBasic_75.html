<div class="container">

<table style="width: 100%;"><tr>
<td>joint.curvesCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Coordinates of the Marginal Probabilities given joint AND or OR Probabilities</h2>

<h3>Description</h3>

<p>Compute the coordinates of the bivariate marginal probabilities for variables <code class="reqn">U</code> and <code class="reqn">V</code> given selected probabilities levels <code class="reqn">t</code> for a copula <code class="reqn">\mathbf{C}(u,v)</code> for <code class="reqn">v</code> with respect to <code class="reqn">u</code>. For the case of a <b>joint and</b> probability, symbolically the solution is
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Pr}[U \le v,\ V \le v] = t = \mathbf{C}(u,v)\mbox{,}</code>
</p>

<p>where <code class="reqn">U \mapsto [t_i, u_{j}, u_{j+1}, \cdots, 1; \Delta t]</code> (an irregular sequence of <code class="reqn">u</code> values from the <code class="reqn">i</code>th value of <code class="reqn">t_i</code> provided through to unity) and thus
</p>
<p style="text-align: center;"><code class="reqn">t_i \mapsto \mathbf{C}(u=U, v)\mbox{,}</code>
</p>

<p>and solving for the sequence of <code class="reqn">v</code>. The index <code class="reqn">j</code> is to indicate that a separate loop is involved and is distinct from <code class="reqn">i</code>. The pairings <code class="reqn">\{u(t_i), v(t_i)\}</code> for each <code class="reqn">t</code> are packaged as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code>. This operation is very similiar to the plotting capabilities in <code>level.curvesCOP</code> for <em>level curves</em> (Nelsen, 2006, pp. 12–13) but implemented in the function <code>joint.curvesCOP</code> for alternative utility.
</p>
<p>For the case of a <b>joint or</b> probability, the <em>dual of a copula (function)</em> or <code class="reqn">\tilde{\mathbf{C}}(u,v)</code> from a copula (Nelsen, 2006, pp. 33–34) is used and symbolically the solution is:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Pr}[U \le v \mathrm{\ or\ } V \le v] = t = \tilde{\mathbf{C}}(u,v) = u + v - \mathbf{C}(u,v)\mbox{,}</code>
</p>

<p>where <code class="reqn">U \mapsto [0, u_j, u_{j+1}, \cdots, t_i; \Delta t]</code> (an irregular sequence of <code class="reqn">u</code> values from zero through to the <code class="reqn">i</code>th value of <code class="reqn">t</code>) and thus
</p>
<p style="text-align: center;"><code class="reqn">t_i \mapsto \tilde{\mathbf{C}}(u=U, v)\mbox{,}</code>
</p>

<p>and solving for the sequence of <code class="reqn">v</code>.  The index <code class="reqn">j</code> is to indicate that a separate loop is involved and is distinct from <code class="reqn">i</code>. The pairings <code class="reqn">\{u(t_i), v(t_i)\}</code> for each <code class="reqn">t</code> are packaged as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">joint.curvesCOP(cop=NULL, para=NULL, type=c("and", "or"),
                probs=c(0.5, 0.8, 0.90, 0.96, 0.98, 0.99, 0.995, 0.998),
                zero2small=TRUE, small=1E-6, divisor=100, delu=0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>What type of joint probability is to be computed;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>The joint probabilities <code class="reqn">t_i</code> from which to compute the coordinates. The default values represent especially useful annual return period equivalents that are useful in hydrologic risk analyses;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero2small</code></td>
<td>
<p>A logical controlling whether exactly zero value for probability are converted to a <code>small</code> value and exactly unity values for probability are converted to the value <code>1 - small</code>; this logical is useful if transformation from probability space into standard normal variates or <em>Gumbel reduced variates</em> (see function <code>prob2grv()</code> in package <span class="pkg">lmomco</span>) is later desired by the user for attendant graphics (see <b>Examples</b> section);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small</code></td>
<td>
<p>The value for <em>small</em> described for <code>zero2small</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>divisor</code></td>
<td>
<p>A divisor on a computation of a <code class="reqn">\Delta t</code> for incrementing through the irregularly-spaced <code class="reqn">u</code> domain as part of the coordinate computation (see source code);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delu</code></td>
<td>
<p>A <code class="reqn">\Delta u</code> for setup of the incrementing through the irregularly-space <code class="reqn">u</code> domain as part of the coordinate computation (see source code); and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the <code>duCOP</code> function of <span class="pkg">copBasic</span> or <code>uniroot()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> is returned with elements each of the given <code>probs</code>.
</p>


<h3>Note</h3>

<p>The arguments <code>divisor</code> and <code>delu</code> provide flexibility to obtain sufficient smoothness in the coordinate curvatures for a given <code class="reqn">t</code>. The pairings <code class="reqn">\{u(t_i), v(t_i)\}</code> for each <code class="reqn">t</code> packaged as <code>data.fame</code>s within the returned <code>list</code> each have their own unique length, and this is the reason that a single “master” <code>data.frame</code> is not returned by this function.
</p>
<p><em>Extended Example</em>—The code below shows both types of joint probability being computed using the default <code>probs</code>. The plotting is made in <em>Gumbel reduced variates</em> (GRV; see <code>prob2grv</code> in package <span class="pkg">lmomco</span>). This transformation is somewhat suitable for the magnitude variation in and at tail depth of the <code>probs</code>. Also with transformation is being used, the <code>zero2small</code> logical is kept at <code>TRUE</code>, which is appropriate. The <code>zero2small</code> being set is also useful if standard normal variate transformation (by the <code>qnorm()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>) were used instead.
</p>
<p>The <em>Gumbel–Hougaard</em> copula (<code>GHcop</code>) and a reversed Gumbel–Hougaard copula <code>rGH</code> are composited together by <code>composite2COP</code>. These were chosen so that some asymmetry in the solutions by <code>joint.curvesCOP</code> could be seen. We begin by specifying symmetrical plotting limits for later use and then creating a function for the reversed Gumbel–Hougaard and setting the parameters and composition weights:
</p>
<pre>
  grvlim &lt;- lmomco::prob2grv(c(0.25,0.999)) # out to 1,000 years
  "rGHcop" &lt;- function(u,v, ...) { u + v - 1 + GHcop(1-u, 1-v, ...) }
  para &lt;- list(alpha=0.16, beta=0.67, cop1 =GHcop, cop2 =rGHcop,
                                      para1=4.5,   para2=2.2)
  tau    &lt;- tauCOP(    cop=composite2COP, para=para) # Tau    = 0.351219
  nuskew &lt;- nuskewCOP(cop=composite2COP, para=para)  # Nuskew = 0.084262
  UV &lt;- simCOP(n=1000,  cop=composite2COP, para=para, snv=TRUE)
</pre>
<p>The code also computed the <em>Kendall Tau</em> (<code>tauCOP</code>) and <em>Nu-Skew</em> (<code>nuskewCOP</code>) and the results shown. The code finishes with a simulation by <code>simCOP</code> of the copula composition just for reference.
</p>
<p>Next, we compute and plot the joint probability curves. The <code>tol</code>erance for the <code>uniroot</code> calls is reset from the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> defaults because slight wooble in the numerical solutions exists otherwise.  The <code>AND</code> and <code>OR</code> <code>lists</code> each provide <code>data.frame</code>s from which successive graphic calls plot the lines. The second <code>plot()</code> call is commented out so that both sets of joint probability curves are drawn on the same plot.
</p>
<pre>
  AND &lt;- joint.curvesCOP(cop=composite2COP, para=para, type="and",
                         divisor=1000, tol=.Machine$double.eps)
  plot(grvlim, grvlim, type="n",
       xlab="GUMBEL REDUCED VARIATE IN U", ylab="GUMBEL REDUCED VARIATE IN V")
  for(t in sort(as.numeric(names(AND)))) {
      UV &lt;- get(as.character(t), AND)
      lines(lmomco::prob2grv(UV$U),         lmomco::prob2grv(       UV$V))
      text( lmomco::prob2grv(median(UV$U)), lmomco::prob2grv(median(UV$V)),
           as.character(round(1/(1-t)), digits=0))
  }

  OR &lt;- joint.curvesCOP(cop=composite2COP, para=para, type="or",
                        divisor=1000, tol=.Machine$double.eps)
  for(t in sort(as.numeric(names(OR)))) {
     UV &lt;- get(as.character(t), OR)
     lines(lmomco::prob2grv(UV$U), lmomco::prob2grv(UV$V), col=2)
     text( lmomco::prob2grv(median(UV$U)), lmomco::prob2grv(median(UV$V)),
          as.character(round(1/(1-t)), digits=0), col=2)
  }
  mtext("Return Periods: black=cooperative risk, red=dual risk")
  abline(0,1, lty=2) # dash line is simply and equal value line
</pre>
<p><em>Black Curves</em>—The black curves represent the nonexceedance <b>joint and</b> condition. The black curves are a form of <em>level curve</em> (see <code>level.curvesCOP</code>), but it seems appropriate to not name them as such because Nelsen's examples and others usually have the level curves on an even step interval of probability such as 10-percent level curves. The complement of nonexceedance <b>joint and</b> is the probability level that either or both random variables (say “hazards”) <code class="reqn">U</code> or <code class="reqn">V</code> causes “failure” at the respective return period.
</p>
<p><em>Red Curves</em>—The red curves represent the nonexceedance <b>joint or</b> (inclusive) condition. The complement of nonexceedance <b>joint or</b> (inclusive) is the probability level that both random variables (say “hazards”) <code class="reqn">U</code> or <code class="reqn">V</code> must simultaneously (or dually) occur for “failure” at the respective return period. Note, there is obviously asymmetry in the <b>joint or</b> curves.
</p>
<p><em>Interpretation</em>—Because the two hazards can “cooperate” to cause failure (see <code>coCOP</code>) for an equal level of protection (say 500-year event) relative to the complement of nonexceedance <b>joint or</b> (inclusive) condition (see <code>surCOP</code>), the marginal probabilities must be considerably higher. Users are encouraged to review <code>copBasic-package</code> and the figure therein.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>diagCOPatf</code>, <code>duCOP</code>, <code>jointCOP</code>, <code>joint.curvesCOP2</code>, <code>level.curvesCOP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See Note section
</code></pre>


</div>