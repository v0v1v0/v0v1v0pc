<div class="container">

<table style="width: 100%;"><tr>
<td>eigenmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial Eigenvector Maps</h2>

<h3>Description</h3>

<p>Function to calculate spatial eigenvector maps of a set of locations
in a space with an arbitrary number of dimension.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eigenmap(
  x,
  alt.coord = NA,
  weighting = wf.sqrd,
  boundaries,
  wpar,
  tol = .Machine$double.eps^0.5
)

eigenmap.score(emap, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A set of coordinates defined in one (numeric vector) or many (a
coordinate x dimension matrix) dimensions or, alternatively, a distance
matrix provided by <code>dist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt.coord</code></td>
<td>
<p>Coordinates to be used when a distance matrix is
provided as x. Used for plotting purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighting</code></td>
<td>
<p>The function to obtain the edge weighting matrix (see
details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundaries</code></td>
<td>
<p>When required by argument <code>weighting</code>, a two-element
numeric vector containing the lower and upper threshold values used to obtain
the connectivity matrix (see weighting-functions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wpar</code></td>
<td>
<p>Shape parameter for argument <code>weignting</code> (optional).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The smallest absolute eigenvalue for a spatial eigenfunctions to
be considered as a suitable predictor. Default:
<code>.Machine$double.eps^0.5</code> (a machine-dependent value).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emap</code></td>
<td>
<p>An eigenmap-class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>A (generally rectangular) distance matrix between a set of
target locations for which spatially-explicit predictions are being made
(rows), and the reference locations given to function <code>eigenmap</code>
(columns). See example 2.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When function <code>eigenmap</code> is given coordinates as its argument
<code>x</code>, they are treated as Cartesian coordinates and the distances between
them are assumed to be Euclidean. Otherwise (e.g., when geodesic distances
are used), distances have to be provided as the argument <code>x</code> and
plotting coordinates have to be supplied as argument <code>alt.coord</code>.
</p>
<p>The weighting function (see weighting-functions) must have the
distances as its first argument, optionally an argument named
<code>boundaries</code> giving the boundaries within which locations are regarded
as neighbours and/or an argument <code>wpar</code> containing any other weighting
function parameters.
</p>
<p>Default values for argument <code>boundaries</code> are 0 for the minimum value and
<code>NA</code> for the maximum. For weighting functions with an argument
<code>bounraries</code>, The upper value <code>NA</code> indicates the function to take
the minimum value that allow every locations to form a single cluster
following single linkage clustering as a maximum value (obtained internally
from a call to <code>hclust</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>eigenmap()</code>: Main function for generating an eigenmap-class object from Cartesian
coordinates or pairwise distances.
</p>
</li>
<li> <p><code>eigenmap.score()</code>: Generate scores for arbitrary locations within the scope of an existing
eigenvector map.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Borcard, D. and Legendre, P. 2002. All-scale spatial analysis of ecological
data by means of principal coordinates of neighbour matrices. Ecol. Model.
153: 51-68
</p>
<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English edition.
Elsevier Science B.V., Amsterdam, The Netherlands.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example 1: A linear transect.
data(salmon)

## A warning is issued when no boundaries are provided for a function that
## requires them.
## Example:
map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.binary)
map
## plot(map)

## In the following examples, boundaries are provided; they are needed by the
## functions.
map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.binary,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.Drayf1,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.Drayf2,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.Drayf3,
                boundaries = c(0,20), wpar = 2)
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.PCNM,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.sqrd)
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.RBF, wpar = 0.001)
map
## plot(map)

### Example 2: Using predictor scores

smpl &lt;- c(4,7,10,14,34,56,61,64)  # A sample to be discarded
map &lt;- eigenmap(x = salmon[-smpl,"Position"], weighting = wf.sqrd)
scr &lt;- eigenmap.score(
         map, target = as.matrix(dist(salmon[,"Position"]))[,-smpl]
       )
## Scores of sampling points are the eigenvectors
scr[smpl,]

wh &lt;- 5L   # You can try with other vectors.
plot(map$U[,wh] ~ salmon[-smpl,"Position"], ylab = expression(U[5]),
     xlab = "Position along transect")
points(y = scr[smpl,wh], x = salmon[smpl,"Position"], pch = 21L,
       bg = "black")

map &lt;- eigenmap(x = salmon[-smpl,"Position"], weighting = wf.binary,
                boundaries = c(0,20))
scr &lt;- eigenmap.score(
         map, target = as.matrix(dist(salmon[,"Position"]))[smpl,-smpl])

## Plot the 8 prediction sites along particular eigenvectors, here
## eigenvector #1:
wh &lt;- 1L   # One could try the other vectors.
plot(map$U[,wh] ~ salmon[-smpl,"Position"], ylab = expression(U[1L]),
     xlab = "Position along transect (m)")
points(y = scr[,wh], x = salmon[smpl,"Position"], pch=21L, bg = "black")

map &lt;- eigenmap(x = salmon[-smpl,"Position"], weighting = wf.PCNM,
                boundaries = c(0,100))
scr &lt;- eigenmap.score(
         map, target = as.matrix(dist(salmon[,"Position"]))[smpl,-smpl]
       )

wh &lt;- 1L   # You can try with other vectors.
plot(map$U[,wh] ~ salmon[-smpl,"Position"], ylab = expression(U[1]),
     xlab = "Position along transect (m)")
points(y = scr[,wh], x = salmon[smpl,"Position"], pch = 21L, bg = "black")

### Example 3: A unevenly sampled surface.

data(mite)

## Example using the principal coordinates of the square root of the
## (Euclidean) distances:
map &lt;- eigenmap(x = as.matrix(mite.geo), weighting = wf.sqrd)
map
## plot(map)

## Example using the radial basis functions (RBF):
map &lt;- eigenmap(x = as.matrix(mite.geo), weighting = wf.RBF)
map
## plot(map)

</code></pre>


</div>