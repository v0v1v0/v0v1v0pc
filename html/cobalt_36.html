<div class="container">

<table style="width: 100%;"><tr>
<td>balance-summary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Balance and Summary Statistics for Covariates</h2>

<h3>Description</h3>

<p>These functions quickly compute balance statistics for the given covariates. These functions are used in <code>bal.tab()</code>, but they are available for use in programming without having to call <code>bal.tab()</code> to get them.
</p>

<ul>
<li>
<p><code>col_w_mean()</code> computes the (weighted) means for a set of covariates and weights and is essentially a weighted version of <code>colMeans()</code>.
</p>
</li>
<li>
<p><code>col_w_sd()</code> computes the (weighted) standard deviations for a set of covariates and weights.
</p>
</li>
<li>
<p><code>col_w_smd()</code> computes the (weighted) (absolute) (standardized) difference in means for a set of covariates, a binary treatment, and weights.
</p>
</li>
<li>
<p><code>col_w_vr()</code> computes the (weighted) variance ratio for a set of covariates, a binary treatment, and weights.
</p>
</li>
<li>
<p><code>col_w_ks()</code> computes the (weighted) Kolmogorov-Smirnov (KS) statistic for a set of covariates, a binary treatment, and weights.
</p>
</li>
<li>
<p><code>col_w_ovl()</code> computes the complement of the (weighted) overlapping coefficient compliment for a set of covariates, a binary treatment, and weights (based on Franklin et al, 2014).
</p>
</li>
<li>
<p><code>col_w_cov()</code> and <code>col_w_corr()</code> compute the (weighted) (absolute) treatment-covariate covariance or correlation for a set of covariates, a continuous treatment, and weights.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">col_w_mean(
  mat,
  weights = NULL,
  s.weights = NULL,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_sd(
  mat,
  weights = NULL,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_smd(
  mat,
  treat,
  weights = NULL,
  std = TRUE,
  s.d.denom = "pooled",
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  weighted.weights = weights,
  na.rm = TRUE,
  ...
)

col_w_vr(
  mat,
  treat,
  weights = NULL,
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_ks(
  mat,
  treat,
  weights = NULL,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_ovl(
  mat,
  treat,
  weights = NULL,
  s.weights = NULL,
  bin.vars,
  integrate = FALSE,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_cov(
  mat,
  treat,
  weights = NULL,
  type = "pearson",
  std = FALSE,
  s.d.denom = "all",
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  weighted.weights = weights,
  na.rm = TRUE,
  ...
)

col_w_corr(
  mat,
  treat,
  weights = NULL,
  type = "pearson",
  s.d.denom = "all",
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  weighted.weights = weights,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>a numeric matrix or a data frame containing the covariates for which the statistic is to be computed. If a data frame, <code>splitfactor()</code> with <code>drop.first = "if2"</code> will be called if any character or factor variables are present. This can slow down the function, so it's generally best to supply a numeric matrix. If a numeric vector is supplied, it will be converted to a 1-column matrix first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p><code>numeric</code>; an optional set of weights used to compute the weighted statistics. If sampling weights are supplied through <code>s.weights</code>, the <code>weights</code> should not incorporate these weights, as <code>weights</code> and <code>s.weights</code> will be multiplied together prior to computing the weighted statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.weights</code></td>
<td>
<p><code>numeric</code>; an optional set of sampling weights used to compute the weighted statistics. If weights are supplied through <code>weights</code>, <code>weights</code> and <code>s.weights</code> will be multiplied together prior to computing the weighted statistics. Some functions use <code>s.weights</code> in a particular way; for others, supplying <code>weights</code> and <code>s.weights</code> is equivalent to supplying their product to either <code>weights</code> or <code>s.weights</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a <code>logical</code> vector with length equal to the number of rows of <code>mat</code> used to subset the data. See Details for notes on its use with <code>col_w_smd()</code>, <code>col_w_cov()</code>, and <code>col_w_corr()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p><code>logical</code>; whether <code>NA</code>s should be ignored or not. If <code>FALSE</code>, any variable with any <code>NA</code>s will have its corresponding statistic returned as <code>NA</code>. If <code>TRUE</code>, any variable with any <code>NA</code>s will have its corresponding statistic computed as if the missing value were not there.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for all functions, additional arguments supplied to <code>splitfactor()</code> when <code>mat</code> is a data.frame. <code>data</code>, <code>var.name</code>, <code>drop.first</code>, and <code>drop.level</code> are ignored; <code>drop.first</code> is automatically set to <code>"if2"</code>. For <code>col_w_ovl()</code> and <code>col_w_ent()</code>, other arguments passed to <code>density()</code> besides <code>x</code> and <code>weights</code>. Note that the default value for <code>bw</code> when unspecified is <code>"nrd"</code> rather than the default in <code>density()</code>, which is <code>"nrd0"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin.vars</code></td>
<td>
<p>a vector used to denote whether each variable is binary or not. Can be a <code>logical</code> vector with length equal to the number of columns of <code>mat</code> or a vector of numeric indices or character names of the binary variables. If missing (the default), the function will figure out which covariates are binary or not, which can increase computation time. If <code>NULL</code>, it will be assumed no variables are binary. All functions other than <code>col_w_mean()</code> treat binary variables different from continuous variables. If a factor or character variable is in <code>mat</code>, all the dummies created will automatically be marked as binary, but it should still receive an entry when <code>bin.vars</code> is supplied as <code>logical</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat</code></td>
<td>
<p>a vector of treatment status for each individual. For <code>col_w_smd()</code>, <code>col_w_vr()</code>, <code>col_w_ks()</code>, and <code>col_w_ovl()</code>, <code>treat</code> should have exactly two unique values. For <code>col_w_cov()</code> and <code>col_w_corr()</code>, <code>treat</code> should be a many-valued numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std</code></td>
<td>
<p><code>logical</code>; for <code>col_w_smd()</code>, whether the computed mean differences for each variable should be standardized; for <code>col_w_cov()</code>, whether treatment-covariate correlations should be computed (<code>TRUE</code>) rather than covariances (<code>FALSE</code>). Can be either length 1, whereby all variables will be standardized or not, or length equal to the number of columns of <code>mat</code>, whereby only variables with a value of <code>TRUE</code> will be standardized. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.d.denom</code></td>
<td>
<p>for <code>col_w_smd()</code> and <code>col_w_cov()</code> when <code>std</code> is <code>TRUE</code> for some variables, and for <code>col_w_corr()</code>, how the standardization factor should be computed. For <code>col_w_smd()</code> (i.e., when computing standardized mean differences), allowable options include
</p>

<ul>
<li>
<p><code>"treated"</code> - uses the standard deviation of the variable in the treated group
</p>
</li>
<li>
<p><code>"control"</code> - uses the standard deviation of the variable in the control group
</p>
</li>
<li>
<p><code>"pooled"</code> - uses the square root of the average of the variances of the variable in the treated and control groups
</p>
</li>
<li>
<p><code>"all"</code> - uses the standard deviation of the variable in the full sample
</p>
</li>
<li>
<p><code>"weighted"</code> - uses the standard deviation of the variable in the full sample weighted by <code>weighted.weights</code>
</p>
</li>
<li>
<p><code>"hedges"</code> - uses the small-sample corrected version of Hedge's G described in the WWC Procedures Handbook (see References)
</p>
</li>
<li>
<p>the name of one of the treatment values - uses the standard deviation of the variable in that treatment group.
</p>
</li>
</ul>
<p>For <code>col_w_cov()</code> and <code>col_w_corr()</code>, only <code>"all"</code> and <code>"weighted"</code> are allowed. Abbreviations allowed. This can also be supplied as a numeric vector of standard deviations with length equal to the number of columns of <code>mat</code>; the values will be used as the standardization factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs</code></td>
<td>
<p><code>logical</code>; for <code>col_w_smd()</code>, <code>col_w_cov()</code>, and <code>col_w_corr()</code>, whether the returned statistics should be in absolute value (<code>TRUE</code>) or not. For <code>col_w_vr()</code>, whether the ratio should always include the larger variance in the numerator, so that the ratio is always greater than or equal to 1. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted.weights</code></td>
<td>
<p>for <code>col_w_smd()</code>, <code>col_w_cov()</code>, and <code>col_w_corr()</code>, when <code>std = TRUE</code> and <code>s.d.denom = "weighted"</code>, a vector of weights to be applied to the computation of the denominator standard deviation. If not specified, will use the argument to <code>weights</code>. When <code>s.d.denom</code> is not <code>"weighted"</code>, this is ignored. The main purpose of this is to allow <code>weights</code> to be <code>NULL</code> while weighting the denominator standard deviations for assessing balance in the unweighted sample but using the standard deviations of the weighted sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integrate</code></td>
<td>
<p><code>logical</code>; for <code>col_w_ovl()</code>, whether to use <code>integrate()</code> to calculate the area of overlap or the distance between the densities, respectively. If <code>FALSE</code>, a midpoint Riemann sum with 1000 partitions will be used instead. The Riemann sum is a little slower and very slightly imprecise (unnoticibly in most contexts), but the integral can fail sometimes and thus is less stable. The default is to use the Riemann sum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>for <code>col_w_cov()</code> and <code>col_w_corr()</code>, the type of covariance/correlation to be computed. Allowable options include <code>"pearson"</code> and <code>"spearman"</code>. When <code>"spearman"</code> is requested, the covariates and treatment are first turned into ranks using <code>rank()</code> with <code>na.last = "keep"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>col_w_mean()</code> computes column weighted means for a matrix of variables. It is similar to <code>colMeans()</code> but (optionally) incorporates weights. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. This could be used to compute the weighted means of each covariate in the general population to examine the degree to which a weighting method has left the weighted samples resembling the original population.
</p>
<p><code>col_w_sd()</code> computes column weighted standard deviations for a matrix of variables. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. The variance of binary variables is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula; the standard deviation is the square root of this variance.
</p>
<p><code>col_w_smd()</code> computes the mean difference for each covariate between treatment groups defined by <code>treat</code>. These mean differences can optionally be weighted, standardized, and/or in absolute value. The standardization factor is computed using the unweighted standard deviation or variance when <code>s.weights</code> are absent, and is computed using the <code>s.weights</code>-weighted standard deviation or variance when <code>s.weights</code> are present, except when <code>s.d.denom = "weighted"</code>, in which case the product of <code>weighted.weights</code> and <code>s.weights</code> (if present) are used to weight the standardization factor. The standardization factor is computed using the whole sample even when <code>subset</code> is used. Note that unlike <code>bal.tab()</code>, <code>col_w_smd()</code> requires the user to specify whether each individual variable should be standardized using <code>std</code> rather than relying on <code>continuous</code> or <code>binary</code>. The weighted mean difference is computed using the product of <code>weights</code> and <code>s.weights</code>, if specified. The variance of binary variables is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula.
</p>
<p><code>col_w_vr()</code> computes the variance ratio for each covariate between treatment groups defined by <code>treat</code>. When <code>abs = TRUE</code>, <code>pmax(out, 1/out)</code> is applied to the output so that the ratio is always greater than or equal to 1. For binary variables, the variance is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula. Note that in <code>bal.tab()</code>, variance ratios are not computed for binary variables, while here, they are (but likely should not be interpreted). <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. Because of how the weighted variance is computed, exactly balanced groups may have variance ratios that differ slightly from 1.
</p>
<p><code>col_w_ks()</code> computes the KS statistic for each covariate using the method implemented in <span class="pkg">twang</span>. The KS statistics can optionally be weighted. For binary variables, the KS statistic is just the difference in proportions. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them.
</p>
<p><code>col_w_ovl()</code> computes the complement of the overlapping coefficient as described by Franklin et al. (2014). It does so by computing the density of the covariate in the treated and control groups, then finding the area where those density overlap, and subtracting that number from 1, yielding a value between 0 and 1 where 1 indicates complete imbalance, and 0 indicates perfect balance. <code>density()</code> is used to model the density in each group. The bandwidth of the covariate in the smaller treatment group is used for both groups. The area of overlap can be computed using <code>integrate</code>, which quickly and accurately computes the integral, or using a midpoint Riemann sum with 1000 partitions, which approximates the area more slowly. A reason to prefer the Riemann sum is that <code>integrate</code> can fail for unknown reasons, though Riemann sums will fail with some extreme distributions. When either method fails, the resulting value will be <code>NA</code>. For binary variables, the complement of the overlapping coefficient is just the difference in proportions. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. The weights are used to compute the weighted density by supplying them to the <code>weights</code> argument of <code>density</code>.
</p>
<p><code>col_w_cov()</code> computes the covariance between a continuous treatment and the covariates to assess balance for continuous treatments as recommended in Austin (2019). These covariance can optionally be weighted or in absolute value or can be requested as correlations (i.e., standardized covariances). The correlations are computed as the covariance between the treatment and covariate divided by a standardization factor, which is equal to the square root of the product of the variance of treatment and the variance of the covariate. The standardization factor is computed using the unweighted variances when <code>s.weights</code> are absent, and is computed using the sampling weighted variances when <code>s.weights</code> are present, except when <code>s.d.denom = "weighted"</code>, in which case the product of <code>weighted.weights</code> and <code>s.weights</code> (if present) are used to weight the standardization factor. For this reason, the computed correlation can be greater than 1 or less than -1. The standardization factor is always computed using the whole sample even when <code>subset</code> is used. The covariance is computed using the product of <code>weights</code> and <code>s.weights</code>, if specified. The variance of binary variables is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula.
</p>
<p><code>col_w_corr()</code> is a wrapper for <code>col_w_cov</code> with <code>std</code> set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A vector of balance statistics, one for each variable in <code>mat</code>. If <code>mat</code> has column names, the output will be named as well.
</p>


<h3>References</h3>

<p>Austin, P. C. (2019). Assessing covariate balance when using the generalized propensity score with quantitative or continuous exposures. <em>Statistical Methods in Medical Research</em>, 28(5), 1365–1377. <a href="https://doi.org/10.1177/0962280218756159">doi:10.1177/0962280218756159</a>
</p>
<p>Franklin, J. M., Rassen, J. A., Ackermann, D., Bartels, D. B., &amp; Schneeweiss, S. (2014). Metrics for covariate balance in cohort studies of causal effects. <em>Statistics in Medicine</em>, 33(10), 1685–1699. <a href="https://doi.org/10.1002/sim.6058">doi:10.1002/sim.6058</a>
</p>
<p>What Works Clearinghouse. (2020). WWC Procedures Handbook (Version 4.1). Retrieved from
<a href="https://ies.ed.gov/ncee/wwc/Handbooks">https://ies.ed.gov/ncee/wwc/Handbooks</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>bal.tab()</code>
</p>
</li>
<li> <p><code>bal.compute()</code>
</p>
</li>
<li> <p>balance-statistics
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
data("lalonde", package = "cobalt")

treat &lt;- lalonde$treat
covs &lt;- subset(lalonde, select = -c(treat, re78))
covs0 &lt;- splitfactor(covs, drop.first = "if2")
bin.vars &lt;- c(FALSE, FALSE, TRUE, TRUE, TRUE,
              TRUE, TRUE, FALSE, FALSE)
W &lt;- WeightIt::weightit(treat ~ covs, method = "glm", 
                        estimand = "ATE")
weights &lt;- W$weights

round(data.frame(
    m0 = col_w_mean(covs0, weights = weights, subset = treat == 0),
    sd0 = col_w_sd(covs0, weights = weights,
                   bin.vars = bin.vars, subset = treat == 0),
    m1 = col_w_mean(covs0, weights = weights, subset = treat == 1),
    sd1 = col_w_sd(covs0, weights = weights,
                   bin.vars = bin.vars, subset = treat == 1),
    smd = col_w_smd(covs0, treat = treat, weights = weights,
                    std = TRUE, bin.vars = bin.vars),
    vr = col_w_vr(covs0, treat = treat, weights = weights,
                  bin.vars = bin.vars),
    ks = col_w_ks(covs0, treat = treat, weights = weights,
                  bin.vars = bin.vars),
    row.names = colnames(covs0)
), 4)

# Compare to bal.tab():
bal.tab(covs, treat = treat, weights = weights,
        disp = c("m", "sd"), stats = c("m", "v", "ks"),
        estimand = "ATE", method = "weighting",
        binary = "std")


</code></pre>


</div>