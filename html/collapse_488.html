<div class="container">

<table style="width: 100%;"><tr>
<td>qsu</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast (Grouped, Weighted) Summary Statistics for Cross-Sectional and Panel Data
</h2>

<h3>Description</h3>

<p><code>qsu</code>, shorthand for quick-summary, is an extremely fast summary command inspired by the (xt)summarize command in the STATA statistical software.
</p>
<p>It computes a set of 7 statistics (nobs, mean, sd, min, max, skewness and kurtosis) using a numerically stable one-pass method generalized from Welford's Algorithm. Statistics can be computed weighted, by groups, and also within-and between entities (for panel data, see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">qsu(x, ...)

## Default S3 method:
qsu(x, g = NULL, pid = NULL, w = NULL, higher = FALSE,
    array = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'matrix'
qsu(x, g = NULL, pid = NULL, w = NULL, higher = FALSE,
    array = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'data.frame'
qsu(x, by = NULL, pid = NULL, w = NULL, cols = NULL, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'grouped_df'
qsu(x, pid = NULL, w = NULL, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
qsu(x, g = NULL, w = NULL, effect = 1L, higher = FALSE,
    array = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'pdata.frame'
qsu(x, by = NULL, w = NULL, cols = NULL, effect = 1L, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)

# Methods for compatibility with sf:

## S3 method for class 'sf'
qsu(x, by = NULL, pid = NULL, w = NULL, cols = NULL, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)


## S3 method for class 'qsu'
as.data.frame(x, ..., gid = "Group", stringsAsFactors = TRUE)

## S3 method for class 'qsu'
print(x, digits = .op[["digits"]] + 2L, nonsci.digits = 9, na.print = "-",
      return = FALSE, print.gap = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector, matrix, data frame, 'indexed_series' ('pseries') or 'indexed_frame' ('pdata.frame').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a factor, <code>GRP</code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code>GRP</code> object) used to group <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p><em>(p)data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1 + group2</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pid</code></td>
<td>
<p>same input as <code>g/by</code>: Specify a panel-identifier to also compute statistics on between- and within- transformed data. Data frame method also supports one- or two-sided formulas, grouped_df method supports expressions evaluated in the data environment. Transformations are taken independently from grouping with <code>g/by</code> (grouped statistics are computed on the transformed data if <code>g/by</code> is also used). However, passing any LHS variables to <code>pid</code> will overwrite any <code>LHS</code> variables passed to <code>by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a vector of (non-negative) weights. Adding weights will compute the weighted mean, sd, skewness and kurtosis, and transform the data using weighted individual means if <code>pid</code> is used. Data frame method supports formula, grouped_df method supports expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>select columns to summarize using column names, indices, a logical vector or a function (e.g. <code>is.numeric</code>). Two-sided formulas passed to <code>by</code> or <code>pid</code> overwrite <code>cols</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>higher</code></td>
<td>
<p>logical. Add higher moments (skewness and kurtosis).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>array</code></td>
<td>
<p>logical. If computations have more than 2 dimensions (up to a maximum of 4D: variables, statistics, groups and panel-decomposition) <code>TRUE</code> returns an array, while <code>FALSE</code> returns a (nested) list of matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stable.algo</code></td>
<td>
<p>logical. <code>FALSE</code> uses a faster but less stable method to calculate the standard deviation (see Details of <code>fsd</code>). Only available if <code>w = NULL</code> and <code>higher = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>logical <code>TRUE</code> or a function: to display variable labels in the summary. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect</code></td>
<td>
<p><em>plm</em> methods: Select which panel identifier should be used for between and within transformations of the data. 1L takes the first variable in the index, 2L the second etc.. Index variables can also be called by name using a character string. More than one variable can be supplied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gid</code></td>
<td>
<p>character. Name assigned to the group-id column, when summarising variables by groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stringsAsFactors</code></td>
<td>
<p>logical. Make factors from dimension names of 'qsu' array. Same as option to <code>as.data.frame.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of digits to print after the comma/dot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonsci.digits</code></td>
<td>
<p>the number of digits to print before resorting to scientific notation (default is to print out numbers with up to 9 digits and print larger numbers scientifically).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.print</code></td>
<td>
<p>character string to substitute for missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p>logical. Don't print but instead return the formatted object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.gap</code></td>
<td>
<p>integer. Spacing between printed columns. Passed to <code>print.default</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm used to compute statistics is well described <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">here</a> [see sections <em>Welford's online algorithm</em>, <em>Weighted incremental algorithm</em> and <em>Higher-order statistics</em>. Skewness and kurtosis are calculated as described in <em>Higher-order statistics</em> and are mathematically identical to those implemented in the <em>moments</em> package. Just note that <code>qsu</code> computes the kurtosis (like <code>momens::kurtosis</code>), not the excess-kurtosis (=  kurtosis - 3) defined in <em>Higher-order statistics</em>. The <em>Weighted incremental algorithm</em> described can easily be generalized to higher-order statistics].
</p>
<p>Grouped computations specified with <code>g/by</code> are carried out extremely efficiently as in <code>fsum</code> (in a single pass, without splitting the data).
</p>
<p>If <code>pid</code> is used, <code>qsu</code> performs a panel-decomposition of each variable and computes 3 sets of statistics: Statistics computed on the 'Overall' (raw) data, statistics computed on the 'Between' - transformed (pid - averaged) data, and statistics computed on the 'Within' - transformed (pid - demeaned) data.
</p>
<p>More formally, let <b><code>x</code></b> (bold) be a panel vector of data for <code>N</code> individuals indexed by <code>i</code>, recorded for <code>T</code> periods, indexed by <code>t</code>. <code>xit</code> then denotes a single data-point belonging to individual <code>i</code> in time-period <code>t</code> (<code>t/T</code> must not represent time). Then <code>xi.</code> denotes the average of all values for individual <code>i</code> (averaged over <code>t</code>), and by extension <b><code>xN.</code></b> is the vector (length <code>N</code>) of such averages for all individuals. If no groups are supplied to <code>g/by</code>, the 'Between' statistics are computed on <b><code>xN.</code></b>, the vector of individual averages. (This means that for a non-balanced panel or in the presence of missing values, the 'Overall' mean computed on <b><code>x</code></b> can be slightly different than the 'Between' mean computed on <b><code>xN.</code></b>, and the variance decomposition is not exact). If groups are supplied to <code>g/by</code>, <b><code>xN.</code></b> is expanded to the vector <b><code>xi.</code></b> (length <code>N x T</code>) by replacing each value <code>xit</code> in <b><code>x</code></b> with <code>xi.</code>, while preserving missing values in <b><code>x</code></b>. Grouped Between-statistics are then computed on <b><code>xi.</code></b>, with the only difference that the number of observations ('Between-N') reported for each group is the number of distinct non-missing values of <b><code>xi.</code></b> in each group (not the total number of non-missing values of <b><code>xi.</code></b> in each group, which is already reported in 'Overall-N'). See Examples.
</p>
<p>'Within' statistics are always computed on the vector <b><code>x - xi. + x..</code></b>, where <b><code>x..</code></b> is simply the 'Overall' mean computed from <b><code>x</code></b>, which is added back to preserve the level of the data. The 'Within' mean computed on this data will always be identical to the 'Overall' mean. In the summary output, <code>qsu</code> reports not 'N', which would be identical to the 'Overall-N', but 'T', the average number of time-periods of data available for each individual obtained as 'T' = 'Overall-N / 'Between-N'. See Examples.
</p>
<p>Apart from 'N/T' and the extrema, the standard-deviations ('SD') computed on between- and within- transformed data are extremely valuable because they indicate how much of the variation in a panel-variable is between-individuals and how much of the variation is within-individuals (over time). At the extremes, variables that have common values across individuals (such as the time-variable(s) 't' in a balanced panel), can readily be identified as individual-invariant because the 'Between-SD' on this variable is 0 and the 'Within-SD' is equal to the 'Overall-SD'. Analogous, time-invariant individual characteristics (such as the individual-id 'i') have a 0 'Within-SD' and a 'Between-SD' equal to the 'Overall-SD'. See Examples.
</p>
<p>For data frame methods, if <code>labels = TRUE</code>, <code>qsu</code> uses <code>function(x) paste(names(x), setv(vlabels(x), NA, ""), sep = ": ")</code> to combine variable names and labels for display. Alternatively, the user can pass a custom function which will be applied to the data frame, e.g. using <code>labels = vlabels</code> just displays the labels. See also <code>vlabels</code>.
</p>
<p><code>qsu</code> comes with its own print method which by default writes out up to 9 digits at 4 decimal places. Larger numbers are printed in scientific format. for numbers between 7 and 9 digits, an apostrophe (') is placed after the 6th digit to designate the millions. Missing values are printed using '-'.
</p>
<p>The <em>sf</em> method simply ignores the geometry column.
</p>


<h3>Value</h3>

<p>A vector, matrix, array or list of matrices of summary statistics. All matrices and arrays have a class 'qsu' and a class 'table' attached.
</p>


<h3>Note</h3>

<p>In weighted summaries, observations with missing or zero weights are skipped, and thus do not affect any of the calculated statistics, including the observation count. This also implies that a logical vector passed to <code>w</code> can be used to efficiently summarize a subset of the data.
</p>


<h3>Note</h3>

<p>If weights <code>w</code> are used together with <code>pid</code>, transformed data is computed using weighted individual means i.e. weighted <b><code>xi.</code></b> and weighted <b><code>x..</code></b>. Weighted statistics are subsequently computed on this weighted-transformed data.
</p>


<h3>References</h3>

<p>Welford, B. P. (1962). Note on a method for calculating corrected sums of squares and products. <em>Technometrics</em>. 4 (3): 419-420. doi:10.2307/1266577.
</p>


<h3>See Also</h3>

<p><code>descr</code>, Summary Statistics, Fast Statistical Functions, Collapse Overview  
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## World Development Panel Data
# Simple Summaries -------------------------
qsu(wlddev)                                 # Simple summary
qsu(wlddev, labels = TRUE)                  # Display variable labels
qsu(wlddev, higher = TRUE)                  # Add skewness and kurtosis

# Grouped Summaries ------------------------
qsu(wlddev, ~ region, labels = TRUE)        # Statistics by World Bank Region
qsu(wlddev, PCGDP + LIFEEX ~ income)        # Summarize GDP per Capita and Life Expectancy by
stats &lt;- qsu(wlddev, ~ region + income,     # World Bank Income Level
             cols = 9:10, higher = TRUE)    # Same variables, by both region and income
aperm(stats)                                # A different perspective on the same stats

# Grouped summary
wlddev |&gt; fgroup_by(region) |&gt; fselect(PCGDP, LIFEEX) |&gt; qsu()

# Panel Data Summaries ---------------------
qsu(wlddev, pid = ~ iso3c, labels = TRUE)   # Adding between and within countries statistics
# -&gt; They show amongst other things that year and decade are individual-invariant,
# that we have GINI-data on only 161 countries, with only 8.42 observations per country on average,
# and that GDP, LIFEEX and GINI vary more between-countries, but ODA received varies more within
# countries over time.

# Let's do this manually for PCGDP:
x &lt;- wlddev$PCGDP
g &lt;- wlddev$iso3c

# This is the exact variance decomposion
all.equal(fvar(x), fvar(B(x, g)) + fvar(W(x, g)))

# What qsu does is calculate
r &lt;- rbind(Overall = qsu(x),
           Between = qsu(fmean(x, g)), # Aggregation instead of between-transform
           Within = qsu(fwithin(x, g, mean = "overall.mean"))) # Same as qsu(W(x, g) + fmean(x))
r[3, 1] &lt;- r[1, 1] / r[2, 1]
print.qsu(r)
# Proof:
qsu(x, pid = g)

# Using indexed data:
wldi &lt;- findex_by(wlddev, iso3c, year)   # Creating a Indexed Data Frame frame from this data
qsu(wldi)                                # Summary for pdata.frame -&gt; qsu(wlddev, pid = ~ iso3c)
qsu(wldi$PCGDP)                          # Default summary for Panel Series
qsu(G(wldi$PCGDP))                       # Summarizing GDP growth, see also ?G

# Grouped Panel Data Summaries -------------
qsu(wlddev, ~ region, ~ iso3c, cols = 9:12) # Panel-Statistics by region
psr &lt;- qsu(wldi, ~ region, cols = 9:12)     # Same on indexed data
psr                                         # -&gt; Gives a 4D array
psr[,"N/T",,]                               # Checking out the number of observations:
# In North america we only have 3 countries, for the GINI we only have 3.91 observations on average
# for 45 Sub-Saharan-African countries, etc..
psr[,"SD",,]                                # Considering only standard deviations
# -&gt; In all regions variations in inequality (GINI) between countries are greater than variations
# in inequality within countries. The opposite is true for Life-Expectancy in all regions apart
# from Europe, etc..

# Again let's do this manually for PDGCP:
d &lt;- cbind(Overall = x,
           Between = fbetween(x, g),
           Within = fwithin(x, g, mean = "overall.mean"))

r &lt;- qsu(d, g = wlddev$region)
r[,"N","Between"] &lt;- fndistinct(g[!is.na(x)], wlddev$region[!is.na(x)])
r[,"N","Within"] &lt;- r[,"N","Overall"] / r[,"N","Between"]
r

# Proof:
qsu(wlddev, PCGDP ~ region, ~ iso3c)

# Weighted Summaries -----------------------
n &lt;- nrow(wlddev)
weights &lt;- abs(rnorm(n))                    # Generate random weights
qsu(wlddev, w = weights, higher = TRUE)     # Computed weighted mean, SD, skewness and kurtosis
weightsNA &lt;- weights                        # Weights may contain missing values.. inserting 1000
weightsNA[sample.int(n, 1000)] &lt;- NA
qsu(wlddev, w = weightsNA, higher = TRUE)   # But now these values are removed from all variables

# Grouped and panel-summaries can also be weighted in the same manner

# Alternative Output Formats ---------------
# Simple case
as.data.frame(qsu(mtcars))
# For matrices can also use qDF/qDT/qTBL to assign custom name and get a character-id
qDF(qsu(mtcars), "car")
# DF from 3D array: do not combine with aperm(), might introduce wrong column labels
as.data.frame(stats, gid = "Region_Income")
# DF from 4D array: also no aperm()
as.data.frame(qsu(wlddev, ~ income, ~ iso3c, cols = 9:10), gid = "Region")

# Output as nested list
psrl &lt;- qsu(wlddev, ~ income, ~ iso3c, cols = 9:10, array = FALSE)
psrl

# We can now use unlist2d to create a tidy data frame
unlist2d(psrl, c("Variable", "Trans"), row.names = "Income")
</code></pre>


</div>