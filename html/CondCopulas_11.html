<div class="container">

<table style="width: 100%;"><tr>
<td>CKT.hCV.l1out</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Choose the bandwidth for kernel estimation of
conditional Kendall's tau using cross-validation</h2>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal here is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
For this, a kernel-based estimator is used, as described in
(Derumigny &amp; Fermanian (2019)).
These functions aims at finding the best bandwidth <code>h</code> among a given
<code>range_h</code> by cross-validation. They use either:
</p>

<ul>
<li> <p><strong>leave-one-out</strong> cross-validation:
function <code>CKT.hCV.l1out</code>
</p>
</li>
<li>
<p> or <strong>K-folds</strong> cross-validation:
function <code>CKT.hCV.Kfolds</code>
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">CKT.hCV.l1out(
  X1 = NULL,
  X2 = NULL,
  Z = NULL,
  range_h,
  matrixSignsPairs = NULL,
  nPairs = 10 * length(X1),
  typeEstCKT = "wdm",
  kernel.name = "Epa",
  progressBar = TRUE,
  verbose = FALSE,
  observedX1 = NULL,
  observedX2 = NULL,
  observedZ = NULL
)

CKT.hCV.Kfolds(
  X1,
  X2,
  Z,
  ZToEstimate,
  range_h,
  matrixSignsPairs = NULL,
  typeEstCKT = "wdm",
  kernel.name = "Epa",
  Kfolds = 5,
  progressBar = TRUE,
  verbose = FALSE,
  observedX1 = NULL,
  observedX2 = NULL,
  observedZ = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p>a vector of <code>n</code> observations of the first variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>a vector of <code>n</code> observations of the second variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>vector of observed values of Z.
If Z is multivariate, then this is a matrix whose rows correspond
to the observations of Z</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range_h</code></td>
<td>
<p>vector containing possible values for the bandwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrixSignsPairs</code></td>
<td>
<p>square matrix of signs of all pairs,
produced by <code>computeMatrixSignPairs(observedX1, observedX2)</code>.
Only needed if <code>typeEstCKT</code> is not the default 'wdm'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nPairs</code></td>
<td>
<p>number of pairs used in the cross-validation criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.name</code></td>
<td>
<p>name of the kernel used for smoothing.
Possible choices are <code>"Gaussian"</code> (Gaussian kernel)
and <code>"Epa"</code> (Epanechnikov kernel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressBar</code></td>
<td>
<p>if <code>TRUE</code>, a progressbar for each h is displayed
to show the progress of the computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the score of each h during the procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observedX1, observedX2, observedZ</code></td>
<td>
<p>old parameter names for <code>X1</code>,
<code>X2</code>, <code>Z</code>. Support for this will be removed at a later version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZToEstimate</code></td>
<td>
<p>vector of fixed conditioning values at which
the difference between the two conditional Kendall's tau should be computed.
Can also be a matrix whose lines are the conditioning vectors at which
the difference between the two conditional Kendall's tau should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kfolds</code></td>
<td>
<p>number of subsamples used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Both functions return a list with two components:
</p>

<ul>
<li> <p><code>hCV</code>: the chosen bandwidth
</p>
</li>
<li> <p><code>scores</code>: vector of the same length as range_h giving the
value of the CV criteria for each of the h tested.
Lower score indicates a better fit.
</p>
</li>
</ul>
<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
On kernel-based estimation of conditional Kendallâ€™s tau:
finite-distance bounds and asymptotic behavior.
Dependence Modeling, 7(1), 292-321.
Page 296, Equation (4).
<a href="https://doi.org/10.1515/demo-2019-0016">doi:10.1515/demo-2019-0016</a>
</p>


<h3>See Also</h3>

<p><code>CKT.kernel</code> for the corresponding
estimator of conditional Kendall's tau by kernel smoothing.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># We simulate from a conditional copula
set.seed(1)
N = 200
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
range_h = 3:10

resultCV &lt;- CKT.hCV.l1out(X1 = X1, X2 = X2, Z = Z,
                          range_h = range_h, nPairs = 100)

resultCV &lt;- CKT.hCV.Kfolds(X1 = X1, X2 = X2, Z = Z,
                           range_h = range_h, ZToEstimate = newZ)

plot(range_h, resultCV$scores, type = "b")

</code></pre>


</div>