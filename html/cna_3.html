<div class="container">

<table style="width: 100%;"><tr>
<td>condTbl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Extract conditions and solutions from an object of class “cna”
</h2>

<h3>Description</h3>

<p>Given a solution object <code>x</code> produced by <code>cna</code>, <code>msc(x)</code> extracts all minimally sufficient conditions, <code>asf(x)</code> all atomic solution formulas, and <code>csf(x, n.init)</code> builds approximately <code>n.init</code> complex solution formulas. All solution attributes (<code>details</code>) that are saved in <code>x</code> are recovered as well. The three functions return a data frame with the additional class attribute <code>condTbl</code>.
</p>
<p><code>as.condTbl</code> reshapes the output produced by <code>condition</code> in such a way as to make it identical to the output returned by <code>msc</code>, <code>asf</code>, and <code>csf</code>.
</p>
<p><code>condTbl</code> executes <code>condition</code> and returns a concise summary table featuring consistencies and coverages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">msc(x, details = x$details, cases = FALSE)
asf(x, details = x$details, warn_details = TRUE)
csf(x, n.init = 1000, details = x$details,
    asfx = asf(x, details, warn_details = FALSE),
    inus.only = x$inus.only, minimalizeCsf = inus.only,
    acyclic.only = x$acyclic.only, cycle.type = x$cycle.type,
    verbose = FALSE)
## S3 method for class 'condTbl'
print(x, n = 20, digits = 3, quote = FALSE, row.names = TRUE, ...)
## S3 method for class 'condTbl'
as.data.frame(x, ...)

condTbl(...)
as.condTbl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class “cna”. In <code>as.condTbl</code>, <code>x</code> is a list of evaluated conditions as returned by <code>condition</code>. In <code>print</code>, <code>x</code> is an object returned by <code>msc</code>, <code>asf</code>, or <code>csf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>Either <code>TRUE/FALSE</code> or a character vector specifying which solution attributes to print (see <code>cna</code>). Note that <code>msc</code> and <code>asf</code> can only display attributes that are saved in <code>x</code>, i.e. those that have been requested in the <code>details</code> argument within the call of <code>cna</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, an additional column listing the cases where the msc is instantiated in combination with the outcome is added to the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn_details</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a warning is issued when some attribute requested in <code>details</code> is not available in <code>x</code> (parameter for internal use).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.init</code></td>
<td>
<p>Integer capping the amount of initial asf combinations. Default at 1000. Serves to control the computational complexity of the csf building process. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asfx</code></td>
<td>
<p>Object of class “condTbl” produced by the <code>asf</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inus.only</code></td>
<td>
<p>Either <code>TRUE</code>/<code>FALSE</code> or a character string with possible values "implication" or "equivalence". The strings can be abbreviated. If <code>TRUE</code>, csf are freed of structural redundancies and only csf not featuring partial structural redundancies are retained  (see the fourth stage of <code>cna</code>'s search algorithm; see also <code>is.inus</code>). Defaults to <code>x$inus.only</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimalizeCsf</code></td>
<td>
<p>Logical; if <code>TRUE</code>, csf are freed of structural redundancies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acyclic.only</code></td>
<td>
<p>Logical; if <code>TRUE</code>, csf featuring a cyclic substructure are not returned. <code>FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycle.type</code></td>
<td>
<p>Character string specifying what type of cycles to be detected: <code>"factor"</code> (the default) or <code>"value"</code> (cf. <code>cyclic</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, some details on the csf building process are printed. <code>FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Maximal number of msc, asf, or csf to be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to print in consistency, coverage, exhaustiveness, faithfulness, and coherence scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quote, row.names</code></td>
<td>
<p>As in <code>print.data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>All arguments in <code>condTbl</code> are passed on to <code>condition</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depending on the processed data, the solutions (models) output by <code>cna</code> are often ambiguous, to the effect that many atomic and complex solutions fit the data equally well. To facilitate the inspection of the <code>cna</code> output, however, the latter standardly returns only 5 minimally sufficient conditions (msc), 5 atomic solution formulas (asf), and 5 complex solution formulas (csf) for each outcome. <code>msc</code> can be used to extract <em>all</em> msc from an object <code>x</code> of class “cna”, <code>asf</code> to extract <em>all</em> asf, and <code>csf</code> to build approximately <code>n.init</code> csf from the asf stored in <code>x</code>. All solution attributes (<code>details</code>) that are saved in <code>x</code> are recovered as well.
The outputs of <code>msc</code>, <code>asf</code>, and <code>csf</code> can be further processed by the <code>condition</code> function.
</p>
<p>While <code>msc</code> and <code>asf</code> merely extract information stored in <code>x</code>, <code>csf</code> builds csf from the inventory of asf recovered at the end of the third stage of the <code>cna</code> algorithm. That is, the <code>csf</code> function implements the fourth stage of that algorithm. It proceeds in a stepwise manner as follows.
</p>
<ol>
<li> <p><code>n.init</code> possible conjunctions featuring one asf of every outcome are built. </p>
</li>
<li>
<p>  If <code>inus.only = TRUE</code> or <code>minimalizeCsf = TRUE</code>, the solutions resulting from step 1 are freed of structural redundancies (cf. Baumgartner and Falk 2023). 
</p>
</li>
<li>
<p> If <code>inus.only = TRUE</code>, tautologous and contradictory solutions as well as solutions with partial structural redundancies and constant factors are eliminated. 
[If <code>inus.only = FALSE</code> and <code>minimalizeCsf = TRUE</code>, only structural redundancies are eliminated, meaning only step 2, but not step 3, is executed.]
</p>
</li>
<li>
<p> If <code>acyclic.only = TRUE</code>, solutions with cyclic substructures are eliminated. </p>
</li>
<li>
<p> For those solutions that were modified in the previous steps, consistency and coverage are re-calculated and solutions that no longer reach <code>con</code> or <code>cov</code> are eliminated. 
</p>
</li>
<li>
<p> The remaining solutions are returned as csf, ordered by complexity and the product of consistency and coverage.</p>
</li>
</ol>
<p>The argument <code>digits</code> applies to the <code>print</code> method. It determines how many digits of consistency, coverage, exhaustiveness, faithfulness, and coherence scores are printed. The default value is 3.
</p>
<p>The function <code>as.condTbl</code> takes a list of objects of class “cond” that are returned by the <code>condition</code> function as input, and reshapes these objects in such a way as to make them identical to the output returned by <code>msc</code>, <code>asf</code>, and <code>csf</code>.
</p>
<p><code>condTbl(...)</code> is identical with <code>as.condTbl(condition(...))</code>.
</p>


<h3>Value</h3>

<p><code>msc</code>, <code>asf</code>, <code>csf</code>, and <code>as.condTbl</code> return objects of class “condTbl”, a <code>data.frame</code> which features the following components:
</p>

<table>
<tr>
<td style="text-align: right;">
<code>outcome</code>: </td>
<td style="text-align: left;"> the outcomes</td>
</tr>
<tr>
<td style="text-align: right;">
<code>condition</code>:</td>
<td style="text-align: left;"> the relevant conditions or solutions</td>
</tr>
<tr>
<td style="text-align: right;">
<code>consistency</code>:</td>
<td style="text-align: left;"> the consistency scores </td>
</tr>
<tr>
<td style="text-align: right;">
<code>coverage</code>: </td>
<td style="text-align: left;"> the coverage scores  </td>
</tr>
<tr>
<td style="text-align: right;">
<code>complexity</code>: </td>
<td style="text-align: left;"> the complexity scores</td>
</tr>
<tr>
<td style="text-align: right;">
<code>inus</code>: </td>
<td style="text-align: left;"> whether the solutions have INUS form</td>
</tr>
<tr>
<td style="text-align: right;">
<code>exhaustiveness</code>: </td>
<td style="text-align: left;"> the exhaustiveness scores</td>
</tr>
<tr>
<td style="text-align: right;">
<code>faithfulness</code>: </td>
<td style="text-align: left;"> the faithfulness scores</td>
</tr>
<tr>
<td style="text-align: right;">
<code>coherence</code>: </td>
<td style="text-align: left;"> the coherence scores</td>
</tr>
<tr>
<td style="text-align: right;">
<code>redundant</code>: </td>
<td style="text-align: left;"> whether the csf contain redundant proper parts</td>
</tr>
<tr>
<td style="text-align: right;">
<code>cyclic</code>: </td>
<td style="text-align: left;"> whether the csf contain cyclic substructures
</td>
</tr>
</table>
<p>The latter five measures are optional and will be appended to the table according to the setting of the argument <code>details</code>.
</p>


<h3>Contributors</h3>

<p>Falk, Christoph: development, testing
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. “Boolean Difference-Making: A Modern Regularity Theory of Causation”. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>
<p>Lam, Wai Fung, and Elinor Ostrom. 2010.
“Analyzing the Dynamic Complexity of Development Interventions: Lessons
from an Irrigation Experiment in Nepal.”
<em>Policy Sciences</em> 43 (2):1-25.
</p>


<h3>See Also</h3>

<p><code>cna</code>, <code>configTable</code>, <code>condition</code>, <code>minimalizeCsf</code>, <code>d.irrigate</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Crisp-set data from Lam and Ostrom (2010) on the impact of development interventions
# ------------------------------------------------------------------------------------
# CNA with causal ordering that corresponds to the ordering in Lam &amp; Ostrom (2010); coverage 
# cut-off at 0.9 (consistency cut-off at 1).
cna.irrigate &lt;- cna(d.irrigate, ordering = "A, R, F, L, C &lt; W", cov = .9,
                    maxstep = c(4, 4, 12), details = TRUE)
cna.irrigate

# The previous function call yields a total of 12 complex solution formulas, only
# 5 of which are returned in the default output. 
# Here is how to extract all 12 complex solution formulas along with all 
# solution attributes.
csf(cna.irrigate)
# With only the standard attributes plus exhaustiveness and faithfulness.
csf(cna.irrigate, details = c("e", "f"))

# Extract all atomic solution formulas.
asf(cna.irrigate)

# Extract all minimally sufficient conditions.
msc(cna.irrigate) # capped at 20 rows
print(msc(cna.irrigate), n = Inf) # prints all rows
# Add cases featuring the minimally sufficient conditions combined 
# with the outcome.
(msc.table &lt;- msc(cna.irrigate, cases = TRUE))
# Render as data frame.
as.data.frame(msc.table)

# Extract only the conditions (solutions).
csf(cna.irrigate)$condition
asf(cna.irrigate)$condition
msc(cna.irrigate)$condition

# A CNA of d.irrigate without outcome specification and ordering is even more
# ambiguous.
cna2.irrigate &lt;- cna(d.irrigate, cov = .9, maxstep = c(4,4,12), details = TRUE)

# To speed up the construction of complex solution formulas, first extract asf
# and then pass these asf to csf.
cna2.irrigate.asf &lt;- asf(cna2.irrigate)
csf(cna2.irrigate, asfx = cna2.irrigate.asf, details = FALSE)
# Reduce the initial asf combinations.
csf(cna2.irrigate, asfx = cna2.irrigate.asf, n.init = 50)
# Print the first 20 csf.
csf(cna2.irrigate, asfx = cna2.irrigate.asf, n.init = 50)[1:20, ]
# Also extract exhaustiveness scores.
csf(cna2.irrigate, asfx = cna2.irrigate.asf, n.init = 50,
    details = "e")[1:20, ]

# Print details about the csf building process.
csf(cna.irrigate, verbose = TRUE)

# Return solution attributes with 5 digits.
print(cna2.irrigate.asf, digits = 5)
 

# Further examples
# ----------------
# An example generating structural redundancies.
target &lt;- "(A*B + C &lt;-&gt; D)*(c + a &lt;-&gt; E)"
dat1 &lt;- selectCases(target)
ana1 &lt;- cna(dat1, maxstep = c(3, 4, 10))
# Run csf with elimination of structural redundancies.
csf(ana1, verbose = TRUE)
# Run csf without elimination of structural redundancies. 
csf(ana1, verbose = TRUE, inus.only = FALSE)

# An example generating partial structural redundancies.
dat2 &lt;- data.frame(A=c(0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
        1),B=c(0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1),C=c(1,
        1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0),D=c(0,1,1,1,
        0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,0,1,0),E=c(1,0,0,0,0,1,1,
        1,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1),F=c(1,1,1,1,1,0,0,0,0,0,
        0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0),G=c(1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,1,1))
ana2 &lt;- cna(dat2, con = .8, cov = .8, maxstep = c(3, 3, 10))
# Run csf without elimination of partial structural redundancies.
csf(ana2, inus.only = FALSE, verbose = TRUE)
# Run csf with elimination of partial structural redundancies.
csf(ana2, verbose = TRUE)
# Prior to version 3.6.0, the "equivalence" definition of partial structural
# redandancy was used by default (see ?is.inus() for details). Now, the 
# "implication" definition is used. To replicate old behavior
# set inus.only to "equivalence".
csf(ana2, verbose = TRUE, inus.only = "equivalence")
# The two definitions only come apart in case of cyclic structures.
# Build only acyclic models.
csf(ana2, verbose = TRUE, acyclic.only = TRUE)

# Feed the outputs of msc, asf, and csf into the condition function to further inspect the 
# properties of minimally sufficient conditions and atomic and complex solution formulas.
head(condition(msc(ana2)$condition, dat2), 3) # (showing output for first 3 only)
head(condition(asf(ana2)$condition, dat2), 3)
head(condition(csf(ana2)$condition, dat2), 3)

# Reshape the output of the condition function in such a way as to make it identical to the
# output returned by msc, asf, and csf.
head(condition(msc(ana2)$condition, dat2), 3)
head(condition(asf(ana2)$condition, dat2), 3)
head(condition(csf(ana2)$condition, dat2), 3)

head(condTbl(csf(ana2)$condition, dat2), 3) # Same as preceding line
</code></pre>


</div>