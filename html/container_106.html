<div class="container">

<table style="width: 100%;"><tr>
<td>ContainerS3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Container - Enhancing R's list</h2>

<h3>Description</h3>

<p>A container is a data structure with typical member
functions to insert, delete and access elements from the container
object. It can be considered as a base R list with
extended functionality. The Container class also serves as the base
class for Deque, Set, and Dict objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">container(...)

cont(...)

as.container(x)

as.cont(x)

is.container(x)

## S3 method for class 'Container'
as.list(x, ...)

## S3 method for class 'Container'
length(x)

## S3 method for class 'Container'
names(x)

## S3 replacement method for class 'Container'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(possibly named) elements to be put into or removed from the
Container, or additional arguments passed from and to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>R</code> object of <code>ANY</code> type for as.container and is.container
or of class Container for the <code>S3</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p><code>character</code> vector of names.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Methods that alter Container objects usually come in two versions
providing either copy or reference semantics where the latter start with
<code>'ref_'</code> to note the reference semantic, for example, <code>add()</code> and <code>ref_add()</code>.
</p>

<ul><li> <p><code>container(...)</code> initializes and returns a Container object.
</p>
</li></ul>
<ul><li> <p><code>cont(...)</code> is a short cut for <code>container(...)</code>.
</p>
</li></ul>
<ul><li> <p><code>as.container(x)</code> or <code>as.cont(x)</code> coerce <code>x</code> to a Container
</p>
</li></ul>
<ul><li> <p><code>is.container(x)</code> check if <code>x</code> is a Container
</p>
</li></ul>
<ul><li> <p><code>as.list(x)</code> converts container <code>x</code> to a base R list. All of
the container's elements are copied (deeply) during the conversion.
</p>
</li></ul>
<ul><li> <p><code>length(x)</code> return the number of elements contained in <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>names(x)</code> return the names of the elements contained in <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>names(x) &lt;- value</code> sets the names of <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>x + y</code> combines <code>x</code> and <code>y</code> into a new container by appending <code>y</code>
to <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>x - y</code> element-wise discards all items of <code>y</code> from <code>x</code>, given
the element was contained in <code>x</code>. The result is always a container.
</p>
</li></ul>
<ul><li> <p><code>x == y</code> is <code>TRUE</code> if the contents of <code>x</code> and <code>y</code> are
lexicographically <em>equal</em>.
</p>
</li></ul>
<ul><li> <p><code>x != y</code> is <code>TRUE</code> if the contents of <code>x</code> and <code>y</code> are
not equal.
</p>
</li></ul>
<ul><li> <p><code>x &lt; y</code> is <code>TRUE</code> if the contents of x are lexicographically
<em>less</em> than the contents of y.
</p>
</li></ul>
<ul><li> <p><code>x &lt;= y</code> is <code>TRUE</code> if the contents of x are lexicographically
<em>less</em> than or <em>equal</em> to the contents of y.
</p>
</li></ul>
<ul><li> <p><code>add(.x, ...)</code> and <code>ref_add(.x, ...)</code> add elements to <code>.x</code>.
</p>
</li></ul>
<ul><li> <p><code>at(.x, ...,)</code> returns the value at the given indices. Indices
can be letters or numbers or both. All indices must exist.
</p>
</li></ul>
<ul><li> <p><code>at2(x, index)</code> returns the value at the given index or signals an error
if not found.
</p>
</li></ul>
<ul><li> <p><code>clear(x)</code> and <code>ref_clear(x)</code> remove all elements from <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>clone(x)</code> create a copy of <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>count(x, elem)</code> count how often <code>elem</code> occurs in <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>delete(.x, ...)</code> and <code>ref_delete(.x, ...)</code> find and remove elements.
If one or more elements don't exist, an error is signaled.
</p>
</li></ul>
<ul><li> <p><code>delete_at(.x, ...)</code> and <code>ref_delete_at(.x, ...)</code> find and remove values at
given indices. If any given index is invalid, an error is signaled.
</p>
</li></ul>
<ul><li> <p><code>discard(.x, ...)</code> and <code>ref_discard(.x, ...)</code> find and discard elements.
Elements that don't exist, are ignored.
</p>
</li></ul>
<ul><li> <p><code>discard_at(.x, ...)</code> and <code>ref_discard_at(.x, ...)</code> find and discard values
at given indices. Invalid indices are ignored.
</p>
</li></ul>
<ul><li> <p><code>has(x, elem)</code> <code>TRUE</code> if element is in <code>x</code> and otherwise <code>FALSE</code>.
</p>
</li></ul>
<ul><li> <p><code>has_name(x, name)</code> check if <code>name</code> is in <code>x</code>
</p>
</li></ul>
<ul><li> <p><code>is_empty(x)</code> <code>TRUE</code> if object is empty otherwise <code>FALSE</code>
</p>
</li></ul>
<ul><li> <p><code>peek_at(x, ..., .default = NULL)</code> returns the value at the given indices
or (if not found) the given default value.
</p>
</li></ul>
<ul><li> <p><code>peek_at2(x, index, default)</code> returns the value at the given index or (if
not found) the given default value.
</p>
</li></ul>
<ul><li> <p><code>ref_pop(.x, index)</code> return element at given index and remove it
from the <code>container</code> object.
</p>
</li></ul>
<ul><li> <p><code>rename(.x, old, new)</code> and <code>ref_rename(.x, old, new)</code> rename one or more keys
from <code>old</code> to <code>new</code>, respectively, by copy and in place (i.e. by reference).
</p>
</li></ul>
<ul><li> <p><code>replace(.x, old, new, add = FALSE)</code> and
<code>ref_replace(.x, old, new, add = FALSE)</code> try to find element <code>old</code> and
replace it with element <code>new</code>. If <code>old</code> does not exist, an error is raised,
unless <code>add</code> was set to <code>TRUE</code>.
</p>
</li></ul>
<ul><li> <p><code>replace_at(.x, .., .add = FALSE)</code> and <code>ref_replace_at(.x, ..., .add = FALSE)</code>
replace values at given indices. If a given index is invalid, an error is
signaled unless <code>.add</code> was set to <code>TRUE</code>.
</p>
</li></ul>
<h3>See Also</h3>

<p>For the class documentation see Container.
Objects of the derived classes can be created by deque, setnew, and
dict.
</p>


<h3>Examples</h3>

<pre><code class="language-R">co = container(1:5, c = container("a", 1), l = list())
is.container(co)
print(co)
length(co)
names(co)

unpack(co)   # flatten recursively similar to unlist

# Math
co = container(1, 2, -(3:5))
co
abs(co)
cumsum(co)
round(co)
exp(co)

# Summary
range(co)
min(co)
max(co)

# Arithmetic
c1 = container(1, 1:2)
c2 = container(2, 1:2)
c1 + c2     # same as c(c1, c2)
c2 + c1     # same as c(c2, c1)

c1 - c2
c2 - c1
c1 - c1

# Comparison
c1 = container(1, 2, 3)
c2 = container(1, 3, 2)
c1 == c1            # TRUE
c1 != c2            # TRUE
c1 &lt;= c1            # TRUE
c1 == c2            # FALSE
c1 &lt; c2             # TRUE
c1 &lt; container(2)   # TRUE
c1 &lt; container()    # FALSE

# Extract or replace
co = container(a = 1, b = 2, c = 3, d = 4)
co[1:2]
co[1, 4]
co["d", 2]
co[list("d", 2)]
co[0:10]

co = container(a = 1, b = 2)
co[[1]]
co[["a"]]
co[["x"]]
co = container(a = 1, b = "bar")
(co[1:2] &lt;- 1:2)

try({
co[3] &lt;- 3 # index out of range
})
(co[list(1, "b")] &lt;- 3:4)   # mixed numeric/character index

co = container(a = 1, b = 2)
co[[1]] &lt;- 9
co[["b"]] &lt;- 8
co[["x"]] &lt;- 7
co$z &lt;- 99
print(co)

# Replace 8 by 0
co[[{8}]] &lt;- 0
print(co)


co = container(a = 1, b = "bar")
co$f &lt;- 3
co$b &lt;- 2
co


co = container(1)
add(co, 1, b = 2, c = container(1:3))


co = container(a = 1, 2, b = 3, 4)
at(co, 1:3)
at(co, "a", "b", 2)
try(at(co, "x"))     # index 'x' not found
try(at(co, 1:10))    # index 5 exceeds length of Container

co = container(a = 1, 2, b = 3, 4)
at2(co, 1)
at2(co, "a")
at2(co, 2)
try(at2(co, "x"))     # index 'x' not found
try(at2(co, 5))       # index 5 exceeds length of Container

co = container(1, 2, mean)
clear(co)
print(co)    # Original was not touched
ref_clear(co)   # Clears original
print(co)

co = container(1, 2, 3)
co2 = clone(co)
co == co2

co = container("a", "b", "a", mean, mean)
count(co, "a")
count(co, mean)
count(co, "c")

co = container("a", 1:3, iris)
print(co)
delete(co, 1:3, "a")
delete(co, iris)
try({
delete(co, "b")   # "b" is not in Container
})

co = container(a = 1, b = 2, 3)
delete_at(co, "a", "b")          # [3]
delete_at(co, 1:2)               # [3]
delete_at(co, "a", 3)            # [b = 2]
try({
 delete_at(co, 4)                 # index out of range
 delete_at(co, "x")               # names(s) not found: 'x'
})

co = container("a", num = 1:3, data = iris)
print(co)
discard(co, 1:3, "a")
discard(co, iris)
discard(co, "b")  # ignored

co = container(a = 1, b = 2, 3)
discard_at(co, "a", "b")         # [3]
discard_at(co, 1:2)              # [3]
discard_at(co, "a", 3)           # [b = 2]
discard_at(co, "x")              # ignored

co = container(1, 2, mean)
has(co, 1)                   # TRUE
has(co, mean)                # TRUE
has(co, 1:2)                 # FALSE

co = container(a = 1, 2, f = mean)
has_name(co, "a")    # TRUE
has_name(co, "f")    # TRUE
has_name(co, "2")    # FALSE

co = container(1, 2)
is_empty(co)
is_empty(clear(co))

co = container(a = 1, 2, b = 3, 4)
peek_at(co, 1)
peek_at(co, "a")
peek_at(co, "x")
peek_at(co, "x", .default = 0)
peek_at(co, "a", "x", 2, 9, .default = -1)

co = container(a = 1, 2, b = 3, 4)
peek_at2(co, 1)
peek_at2(co, "a")
peek_at2(co, "x")
peek_at2(co, "x", default = 0)

co = container(a = 1, b = 1:3, d = "foo")
ref_pop(co, "b")
ref_pop(co, 1)

try({
ref_pop(co, "x")  # index 'x' not found
})
co = container(a = 1, b = 2, 3)
rename(co, c("a", "b"), c("a1", "y"))
print(co)
ref_rename(co, c("a", "b"), c("a1", "y"))
print(co)

co = container("x", 9)
replace(co, 9, 0)
replace(co, "x", 0)
try({
replace(co, "z", 0)              # old element ("z") is not in Container
})
replace(co, "z", 0, add = TRUE)  # ok, adds the element

co = container(a = 0, b = "z")
replace_at(co, a = 1, b = 2)
replace_at(co, 1:2, 1:2)                 # same
replace_at(co, c("a", "b"), list(1, 2))  # same

try({
replace_at(co, x = 1)                    # names(s) not found: 'x'
})
replace_at(co, x = 1, .add = TRUE)       # ok (adds x = 1)
</code></pre>


</div>