<div class="container">

<table style="width: 100%;"><tr>
<td>run_camodel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a cellular automata</h2>

<h3>Description</h3>

<p>Run a pre-defined stochastic cellular automaton
</p>


<h3>Usage</h3>

<pre><code class="language-R">run_camodel(mod, initmat, times, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>A stochastic cellular automaton model defined using <code>camodel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initmat</code></td>
<td>
<p>An initial matrix to use for the simulation, possibly created using
<code>generate_initmat</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>A numeric vector describing the time sequence for which output is
wanted. Time will always start at zero but output will only be saved at the time
steps specified in this vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a named list with settings to alter the way the simulation is run (see
full list of settings in 'Details' section)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>run_camodel()</code> is the workhorse function to run cellular automata. It runs the
simulation and outputs the results at the time steps specified by the <code>times</code>
argument, starting from the initial landscape <code>initmat</code> (a matrix typically
created by <code>generate_initmat</code>).
</p>
<p>Note that the simulation is run for all time steps, but output is only
provided for the time steps specified in <code>times</code>.
</p>
<p>The <code>control</code> list must have named elements, and allows altering the
way the simulation is run, including the live display of covers or
landscapes (see <code>trace_plotter</code> or
<code>landscape_plotter</code>).
</p>
<p>Possible options are the following:
</p>

<ol>
<li> <p><code>save_covers_every</code> By default, global covers are saved for each time step
specified in <code>times</code>. Setting this argument to values higher than one will
skip some time steps (thinning). For example, setting it to 2 will make
<code>run_camodel</code> save covers only every two values specified in <code>times</code>.
Set to 0 to skip saving covers. This value must be an integer.
</p>
</li>
<li> <p><code>save_snapshots_every</code> In the same way as covers, landscape snapshots
can be saved every set number of values in <code>times</code>. By default, only the
initial and final landscape are saved. Set to one to save the landscape for each
value specified in <code>times</code>. Higher values will skip elements in <code>times</code>
by the set number. Set to zero to turn off the saving of snapshots. This
value must be an integer.
</p>
</li>
<li> <p><code>console_output_every</code> Set the number of iterations between which
progress report is printed on the console. Set to zero to turn off progress
report. The default option is to print progress five times during the simulation.
</p>
</li>
<li> <p><code>custom_output_fun</code> A custom function can be passed using this
argument to compute something on the landscape as the simulation is being run.
This function can return anything, but needs to take two arguments, the first
one being the current time in the simulation (single numeric value), and the
other one the current landscape (a matrix). This can be used to plot the
simulation results as it is being run, see <code>landscape_plotter</code> and
<code>trace_plotter</code> for such use case.
</p>
</li>
<li> <p><code>custom_output_every</code> If <code>custom_output_fun</code> is specified, then
it will be called for every time step specified in the <code>times</code> vector.
Increase this value to skip some time points, in a similar way to covers
and snapshots above.
</p>
</li>
<li> <p><code>substeps</code> Stochastic CA can run into issues where the probabilities
of transitions are above one. A possible solution to this is to run the model
in 'substeps', i.e. an iteration is divided in several substeps, and
the substeps are run subsequently with probabilities divided by this amount. For
example, a model run with 4 substeps means that each iteration will be divided
in 4 'sub-iterations', and probabilities of transitions are divided by 4 for
each of those sub-iterations.
</p>
</li>
<li> <p><code>engine</code> The engine used to run the simulations. Accepted values
are 'cpp' to use the C++ engine, or 'compiled', to emit and compile the model
code on the fly. Default is to use the C++ engine. Note that the 'compiled'
engine uses its own random number generator, and for this reason may produce
simulations that are different from the C++ engine (it does respect the R seed
however). You will need a compiler to use the 'compiled' engine, which
may require you to install
<a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a> on Windows
systems.
</p>
</li>
<li> <p><code>precompute_probas</code> (Compiled engine only) Set to <code>TRUE</code> to
precompute probabilities of transitions for all possible combinations of
neighborhood. When working with a model with a low number of states
(typically 3 or 4), this can increase simulation speed dramatically.
By default, a heuristic is used to decide whether to enable
precomputation or not.
</p>
</li>
<li> <p><code>verbose_compilation</code> (Compiled engine only) Set to <code>TRUE</code> to print
Rcpp messages when compiling the model. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>force_compilation</code> (Compiled engine only) <code>chouca</code> has a
cache system to avoid recompiling similar models. Set this
argument to <code>TRUE</code> to force compilation every time the model is run.
</p>
</li>
<li> <p><code>write_source</code> (Compiled engine only) A file name to which
the C++ code used to run the model will be written (mostly for
debugging purposes).
</p>
</li>
<li> <p><code>cores</code> (Compiled engine only) The number of threads to use
to run the model. This provides a moderate speedup in most cases, and
is sometimes counter-productive on small landscapes. If you plan on
running multiple simulations, you are probably better off parallelizing
at a higher level. See also the 'Performance' section in the vignette, 
accessible using the command <code>vignette("chouca-package")</code>.
</p>
</li>
</ol>
<h3>Value</h3>

<p>A <code>ca_model_result</code> objects, which is a list with the following
components:
</p>

<ol>
<li> <p><code>model</code> The original model used for the model run (see 
return value of <code>camodel</code> for more details about these objects).
</p>
</li>
<li> <p><code>initmat</code> The initial landscape (matrix) used for the model run, 
such as what is returned by <code>generate_initmat</code>. 
</p>
</li>
<li> <p><code>times</code> The time points vector at which output is saved
</p>
</li>
<li> <p><code>control</code> The control list used for the model run, containing the options
used for the run
</p>
</li>
<li> <p><code>output</code> A named list containing the simulation outputs. The 'covers'
component contains a matrix with the first column containing the time step, and the
other columns the proportions of cells in a given state. The 'snapshots' component
contains the landscapes recorded as matrices(<code>camodel_initmat</code> objects), with 
a 't' attribute indicating the corresponding time step of the model run. The 
'custom' component contains the results from calling a custom function provided 
as 'custom_output_fun' in the control list (see examples below).
</p>
</li>
</ol>
<h3>See Also</h3>

<p>camodel, generate_initmat, trace_plotter, landscape_plotter, run_meanfield
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Run a model with default parameters
mod &lt;- ca_library("musselbed")
im  &lt;- generate_initmat(mod, c(0.4, 0.6, 0), nrow = 100, ncol = 50)
out &lt;- run_camodel(mod, im, times = seq(0, 100))
plot(out)

# Disable console output 
opts &lt;- list(console_output_every = 0) 
out &lt;- run_camodel(mod, im, times = seq(0, 100), control = opts)

# 



# Run the same model with the 'compiled' engine, and save snapshots. This
# requires a compiler on your computer (typically available by installing
# 'Rtools' on Windows)
ctrl &lt;- list(engine = "compiled", save_covers_every = 1, save_snapshots_every = 100)
run &lt;- run_camodel(mod, im, times = seq(0, 100), control = ctrl)
plot(run)

# 
oldpar &lt;- par(mfrow = c(1, 2))
image(run, snapshot_time = 0)
image(run, snapshot_time = 100)
par(oldpar)

# Disable console output
ctrl &lt;- list(console_output_every = 0)
run &lt;- run_camodel(mod, im, times = seq(0, 100), control = ctrl)
plot(run)

# Very verbose console output (display compilation information, etc.)
ctrl &lt;- list(console_output_every = 1,
             verbose_compilation = TRUE,
             engine = "compiled",
             force_compilation = TRUE)
run &lt;- run_camodel(mod, im, times = seq(0, 100), control = ctrl)

# Turn on or off the memoisation of transition probabilities (mind the speed
# difference)
ctrl &lt;- list(engine = "compiled", precompute_probas = FALSE)
run &lt;- run_camodel(mod, im, times = seq(0, 256), control = ctrl)
ctrl2 &lt;- list(engine = "compiled", precompute_probas = TRUE)
run2 &lt;- run_camodel(mod, im, times = seq(0, 256), control = ctrl2)

# Use a custom function to compute statistics while the simulation is running
fun &lt;- function(t, mat) {
  # Disturbed cell to mussel cell ratio
  ratio &lt;- mean(mat == "DISTURB") / mean(mat == "MUSSEL")
  data.frame(t = t, ratio = ratio)
}
ctrl &lt;- list(custom_output_fun = fun, custom_output_every = 1)

run &lt;- run_camodel(mod, im, times = seq(0, 256), control = ctrl)
stats &lt;- do.call(rbind, run[["output"]][["custom"]])
plot(stats[ ,1], stats[ ,2], ylab = "DISTURB/MUSSEL ratio", xlab = "time", type = "l")


</code></pre>


</div>