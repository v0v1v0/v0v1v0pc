<div class="container">

<table style="width: 100%;"><tr>
<td>cfc.tbasis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cause-specific competing-risk survival analysis in time denomination
</h2>

<h3>Description</h3>

<p>Constructing cumulative incidence and event-free probability functions from cause-specific survival probabilities evaluated at fixed time points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cfc.tbasis(p1, p2, unity.tol = 1e-06, diff.tol = 0.01,
  diff.tol.policy = c("mean", "all"), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>Multi-dimensional array containing survival probabilities for cause 1 (i.e. exponential of the negative integral of hazard function). First dimension must correspond to time points at which probabilities are calculated. Elements with same time, but distributed in the space of remaining dimensions, are treated independently. These diemensions can correspond, e.g., to observations or samples (in Bayesian frameworks).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p2</code></td>
<td>
<p>Multi-dimensional array containing survival probabilities for cause 2. See note for <code>p1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unity.tol</code></td>
<td>
<p>Tolerance for difference of survival probabilities from 1.0 at time=0.0, which is the first 'row' of arrays <code>p1</code> and <code>p2</code>. For example, for two-dimensional arrays, we need <code>all(abs(p1[1,]-1.0) &lt; unity.tol)</code>, and a similar condition for <code>p2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff.tol</code></td>
<td>
<p>Tolerance for change in survival probabilities from one time point to the next. Large changes lead to higher errors during numerical integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff.tol.policy</code></td>
<td>
<p>If <code>"mean"</code>, then average change in survival probabilities are compared to <code>diff.tol</code>. If <code>"all"</code>, each values is compared. The latter is more strict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>Boolean flag indicating whether or not to check probability arrays for validity. Current validity checks are: 1) ensuring all probabilities are between 0.0 and 1.0, 2) all probabilities at time=0.0 are equal to 1.0 (see <code>unity.tol</code>), 3) No changes in probabilities from one time point to next are too large (see <code>diff.tol</code>). Dimensional consistency between <code>p1</code> and <code>p2</code> is always checked regardless of the value of this flag.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Assuming one-dimensional <code>p1</code> and <code>p2</code> for clarity, the algorithm calculates cumulative incidence function for cuase 1 using a recursive formula: <code>ci1[n+1] = ci1[n] + dci1[n]</code>, where <code>dci1[n] = 0.5*(p2[n] + p2[n+1])*(p1[n] - p1[n+1])</code>. The increment in cumulative incidence function for cause 2 is similarly calculated, <code>dci2[n] = 0.5*(p1[n] + p1[n+1])*(p2[n] - p2[n+1])</code>. These equations guarantee that <code>dci1[n] + dci2[n] = p1[n]*p2[n] - p1[n+1]*p2[n+1]</code>. Event-free probability is simply calculated as codeefp[n] = p1[n]*p2[n]. Taken together, this numerical integration ensures that <code>efp[n+1] - efp[n] + dci1[n] + dci2[n] = 0</code>.
</p>


<h3>Value</h3>

<p>If <code>p1</code> and <code>p2</code> are one-dimensional arrays (i.e. vectors), a matrix with columns named <code>"ci1"</code>, <code>"ci2"</code> and <code>"efp"</code> is returned, representing the cummulative incidence functions for cause 1 and cause 2 and the event-free probability, evaluated at same time points as <code>p1</code> and <code>p2</code> are provided. If <code>p1</code> and <code>p2</code> are multi-dimensional arrays, a list is returned with elements <code>"ci1"</code>, <code>"ci2"</code> and <code>"efp"</code>, each one with the same interpretation, and all of the same dimensions as <code>p1</code> and <code>p2</code>.
</p>


<h3>Note</h3>

<p>The integration algorithm described above does not require knowledge of time step. (Alternatively, using hazard functions for integration would have required specification of time step.) Since <code>p1</code> and <code>p2</code> are integrals (followed by exponentiation) of cause-specific hazard functions, using them directly adds to robustness of numerical integration and avoids error accumulation. The returned cumulative incidence and event-free probabilities correspond to the same time points assumed for input cause-specific probabilities.
</p>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>
<p>Prentice et al (1978). The analysis of failure times in the presence of competing risks. Biometrics, 541-554.
</p>


<h3>See Also</h3>

<p><code>cfc.pbasis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# prepare data for cause-specific competing-risk analysis
data(bmt)
bmt$status1 &lt;- 1*(bmt$cause==1)
bmt$status2 &lt;- 1*(bmt$cause==2)
f1 &lt;- Surv(time, status1) ~ platelet + age + tcell
f2 &lt;- Surv(time, status2) ~ platelet + age + tcell

# sample-based bayesian weibull regression
library(BSGW)
reg1 &lt;- bsgw(f1, bmt, ordweib = TRUE, control = bsgw.control(iter = 500, burnin = 100, nskip = 50))
reg2 &lt;- bsgw(f2, bmt, ordweib = TRUE, control = bsgw.control(iter = 500, burnin = 100, nskip = 50))

# prediction on a uniform grid of 100 time points
# (use first 50 observations for speed)
pred1 &lt;- predict(reg1, newdata = bmt[1:50,], tvec = 100)
pred2 &lt;- predict(reg2, newdata = bmt[1:50,], tvec = 100)

# permuting dimensions of survival objects to conform with cfc
S1 &lt;- aperm(pred1$smp$S, c(2,1,3))
S2 &lt;- aperm(pred2$smp$S, c(2,1,3))

# cause-specific competing risk analysis - time mode
my.cfc &lt;- cfc.tbasis(S1, S2)

# calculating averages across observations (e.g. patients in the study)
my.summ &lt;- summary(my.cfc, MARGIN = c(1,2))

# plotting mean CI and event-free functions
# as well as their sampled-based confidence intervals
plot(my.summ, t = pred1$tvec)



## End(Not run)
</code></pre>


</div>