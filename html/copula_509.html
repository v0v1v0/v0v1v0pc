<div class="container">

<table style="width: 100%;"><tr>
<td>Sibuya</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sibuya Distribution - Sampling and Probabilities</h2>

<h3>Description</h3>

<p>The Sibuya distribution <code class="reqn">\mathrm{Sib}(\alpha)</code> can be
defined by its Laplace transform
</p>
<p style="text-align: center;"><code class="reqn">1-(1-\exp(-t))^\alpha,\ t\in[0,\infty),</code>
</p>

<p>its distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(k)=1-(-1)^k{\alpha-1\choose k}=1-\frac{1}{kB(k,1-\alpha)},\
    k\in\mathbf{N}</code>
</p>

<p>(where <code class="reqn">B</code> denotes the beta function) or its probability
mass function </p>
<p style="text-align: center;"><code class="reqn">p_k={\alpha\choose k}(-1)^{k-1},\ k\in\mathbf{N},
  </code>
</p>

<p>where <code class="reqn">\alpha\in(0,1]</code>.
</p>
<p><code>pSibuya</code> evaluates the distribution function.
</p>
<p><code>dSibuya</code> evaluates the probability mass function.
</p>
<p><code>rSibuya</code> generates random variates from
<code class="reqn">\mathrm{Sib}(\alpha)</code> with
the algorithm described in Hofert (2011), Proposition 3.2.
</p>
<p><code>dsumSibuya</code> gives the probability mass function of the
<code class="reqn">n</code>-fold convolution of Sibuya variables, that is, the sum of <code class="reqn">n</code>
independent Sibuya random variables,
<code class="reqn">S = \sum_{i=1}^n X_i</code>, where
<code class="reqn">X_i \sim \mathrm{Sib}(\alpha)</code>.
</p>
<p>This probability mass function can be shown (see Hofert
(2010, pp. 99)) to be
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^n{n\choose j}{j\alpha\choose k} (-1)^{k-j},\
    k\in\{n,n+1,\dots\}.</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">rSibuya(n, alpha)
dSibuya(x, alpha, log=FALSE)
pSibuya(x, alpha, lower.tail=TRUE, log.p=FALSE)

dsumSibuya(x, n, alpha,
           method=c("log", "direct", "diff", "exp.log",
                    "Rmpfr", "Rmpfr0", "RmpfrM", "Rmpfr0M"),
           mpfr.ctrl = list(minPrec = 21, fac = 1.25, verbose=TRUE),
           log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>for <code>rSibuya</code>: sample size, that is, length of the resulting
vector of random variates.
<br>
for <code>dsumSibuya</code>: the number <code class="reqn">n</code> of summands.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>parameter in <code class="reqn">(0,1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of <code>integer</code> values (“quantiles”)
<code class="reqn">x</code> at which to compute the probability mass or cumulative probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log, log.p</code></td>
<td>
<p><code>logical</code>; if TRUE, probabilities p are
given as log(p).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p><code>logical</code>; if TRUE (the default), probabilities
are <code class="reqn">P(X \le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string specifying which computational method is to be
applied.  Implemented are:
</p>

<dl>
<dt><code>"log"</code></dt>
<dd>
<p>evaluates the logarithm of the sum
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^n {n\choose j}{j\alpha\choose x} (-1)^{x-j}</code>
</p>

<p>in a numerically stable way;</p>
</dd>
<dt><code>"direct"</code></dt>
<dd>
<p>directly evaluates the sum;</p>
</dd>
<dt><code>"Rmpfr*"</code></dt>
<dd>
<p>are as <code>method="direct"</code> but use
high-precision arithmetic; <code>"Rmpfr"</code> and <code>"Rmpfr0"</code> return
<code>double</code>s whereas <code>"RmpfrM"</code> and <code>"Rmpfr0M"</code> give
<code>mpfr</code> high-precision numbers.
Whereas <code>"Rmpfr"</code> and <code>"RmpfrM"</code> each adapt to high
enough precision, the <code>"Rmpfr0*"</code> ones do not adapt.<br>


For all <code>"Rmpfr*"</code> methods, <code>alpha</code> can be set to a
<code>mpfr</code> number of specified
precision and this will determine the precision of all parts of
the internal computations.
</p>
</dd>
<dt><code>"diff"</code></dt>
<dd>
<p>interprets the sum as a forward difference
and computes it via <code>diff</code>;</p>
</dd>
<dt><code>"exp.log"</code></dt>
<dd>
<p>is as <code>method="log"</code> but without
numerically stable evaluation (not recommended, use with care).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mpfr.ctrl</code></td>
<td>
<p>for <code>method = "Rmpfr"</code> or <code>"RmpfrM"</code> only: a
list of
<br><code>minPrec</code>: minimal (estimated) precision in bits,
<br><code>fac</code>: factor with which current precision is multiplied if
it is not sufficient.
<br><code>verbose</code>: determining if and how much is printed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Sibuya distribution has <b>no</b> finite moments, that is, specifically
infinite mean and variance.
</p>
<p>For documentation and didactical purposes, <code>rSibuyaR</code> is a pure-<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
implementation of <code>rSibuya</code>, of course slower than <code>rSibuya</code>
as the latter is implemented in C.
</p>
<p>Note that the sum to evaluate for <code>dsumSibuya</code> is numerically
highly challenging, even already for small
<code class="reqn">\alpha</code> values (for example, <code class="reqn">n \ge 10</code>),
and therefore should be used with care.  It may require high-precision
arithmetic which can be accessed with <code>method="Rmpfr"</code> (and the
<a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> package).
</p>


<h3>Value</h3>


<dl>
<dt>rSibuya:</dt>
<dd>
<p>A vector of positive <code>integer</code>s of
length <code>n</code> containing the generated random variates.</p>
</dd>
<dt>dSibuya, pSibuya:</dt>
<dd>
<p>a vector of
probabilities of the same length as <code>x</code>.</p>
</dd>
<dt>dsumSibuya:</dt>
<dd>
<p>a vector of probabilities, positive if and only if
<code>x &gt;= n</code> and of the same length as <code>x</code> (or <code>n</code> if
that is longer).</p>
</dd>
</dl>
<h3>References</h3>

<p>Hofert, M. (2010).
<em>Sampling Nested Archimedean Copulas with Applications to CDO Pricing</em>.
Südwestdeutscher Verlag fuer Hochschulschriften AG &amp; Co. KG.
</p>
<p>Hofert, M. (2011).
Efficiently sampling nested Archimedean copulas.
<em>Computational Statistics &amp; Data Analysis</em> <b>55</b>, 57–70.
</p>


<h3>See Also</h3>

<p><code>rFJoe</code> and <code>rF01Joe</code> (where <code>rSibuya</code> is
applied).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Sample n random variates from a Sibuya(alpha) distribution and plot a
## histogram
n &lt;- 1000
alpha &lt;- .4
X &lt;- rSibuya(n, alpha)
hist(log(X), prob=TRUE); lines(density(log(X)), col=2, lwd=2)
</code></pre>


</div>