<div class="container">

<table style="width: 100%;"><tr>
<td>ctmleGlmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Collaborative Targeted Maximum Likelihood Estimation for hyper-parameter tuning of LASSO</h2>

<h3>Description</h3>

<p>This function computes the Collaborative Maximum Likelihood Estimation for hyper-parameter tuning of LASSO.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ctmleGlmnet(Y, A, W, Wg = W, Q, lambdas = NULL, ctmletype, V = 5,
  folds = NULL, alpha = 0.995, family = "gaussian", gbound = 0.025,
  like_type = "RSS", fluctuation = "logistic", verbose = FALSE,
  detailed = FALSE, PEN = FALSE, g1W = NULL, g1WPrev = NULL,
  stopFactor = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>continuous or binary outcome variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>binary treatment indicator, 1 for treatment, 0 for control</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for Q bar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wg</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for propensity score model (defaults to W if not supplied by user)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>n by 2 matrix of initial values for Q0W, Q1W in columns 1 and 2, respectively. Current version does not support SL for automatic initial estimation of Q bar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>numeric vector of lambdas (regularization parameter) for glmnet estimation of propensity score, with decreasing order. We recommend the
first lambda is selected by external cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctmletype</code></td>
<td>
<p>1, 2 or 3. Type of general C-TMLE. Type 1 uses cross-validation to select best gn, Type 3 directly solves extra clever covariates,
and Type 2 uses both cross-validation and extra covariate. See more details in !!!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>Number of folds. Only used if folds is not specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>The list of indices for cross-validation step. We recommend the cv-splits in C-TMLE matchs that in gn_candidate_cv</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>used to keep predicted initial values bounded away from (0,1) for logistic fluctuation, 0.995 (default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>family specification for working regression models,
generally 'gaussian' for continuous outcomes (default), 'binomial' for binary outcomes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gbound</code></td>
<td>
<p>bound on P(A=1|W), defaults to 0.025</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>like_type</code></td>
<td>
<p>'RSS' or 'loglike'. The metric to use for forward selection and cross-validation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fluctuation</code></td>
<td>
<p>'logistic' (default) or 'linear', for targeting step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print status messages if TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detailed</code></td>
<td>
<p>boolean number. If it is TRUE, return more detailed results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PEN</code></td>
<td>
<p>boolean. If true, penalized loss is used in cross-validation step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g1W</code></td>
<td>
<p>Only used when type is 3. a user-supplied propensity score estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g1WPrev</code></td>
<td>
<p>Only used when type is 3. a user-supplied propensity score estimate, with small fluctuation compared to g1W.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopFactor</code></td>
<td>
<p>Numerical value with default 1e6. If the current empirical likelihood is stopFactor times larger than the best previous one, the construction would stop</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>best_k  the index of estimate that selected by cross-validation
</p>
<p>est estimate of psi_0
</p>
<p>CI  IC-based 95
</p>
<p>pvalue pvalue for the null hypothesis that Psi = 0
</p>
<p>likelihood sum of squared residuals, based on selected estimator evaluated on all obs or,
logistic loglikelihood if like_type != 'RSS'
</p>
<p>varIC empirical variance of the influence curve adjusted for estimation of g
</p>
<p>varDstar empirical variance of the influence curve
</p>
<p>var.psi variance of the estimate
</p>
<p>varIC.cv cross-validated variance of the influence curve
</p>
<p>penlikelihood.cv penalized cross-validatedlikelihood
</p>
<p>cv.res all cross-validation results for each fold
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(123)
N &lt;- 1000
p = 10
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tau &lt;- 2
gcoef &lt;- matrix(c(-1,-1,rep(0,(p)-2)),ncol=1)
Wm &lt;- as.matrix(Wmat)
g &lt;- 1/(1+exp(Wm%*%gcoef / 3))
A &lt;- rbinom(N, 1, prob = g)
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tau * A + epsilon
# ctmleGlmnet must provide user-specified Q
W_tmp &lt;- data.frame(Wm[,1:3])
treated&lt;- W_tmp[which(A==1),]
untreated&lt;-W_tmp[which(A==0),]
Y1&lt;-Y[which(A==1)]
Y0&lt;-Y[which(A==0)]
# Initial Q-estimate
beta1hat &lt;- predict(lm(Y1~.,data=treated),newdata=W_tmp)
beta0hat &lt;- predict(lm(Y0~., data=untreated),newdata=W_tmp)
Q &lt;- matrix(c(beta0hat,beta1hat),ncol=2)
W = Wm
glmnet_fit &lt;- cv.glmnet(y = A, x = Wm,
                       family = 'binomial', nlambda = 40)
start = which(glmnet_fit$lambda==glmnet_fit$lambda.min))
end = length(glmnet_fit$lambda)
lambdas &lt;-glmnet_fit$lambda[start:end]
ctmle_fit1 &lt;- ctmleGlmnet(Y=Y, A=A,
                         W=data.frame(W=W),
                         Q = Q, lambdas = lambdas,
                         ctmletype=1, alpha=.995,
                         family="gaussian",
                         gbound=0.025,like_type="loglik" ,
                         fluctuation="logistic",
                         verbose=FALSE,
                         detailed=FALSE, PEN=FALSE,
                         V=5, stopFactor=10^6)

## End(Not run)
</code></pre>


</div>