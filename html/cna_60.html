<div class="container">

<table style="width: 100%;"><tr>
<td>is.inus</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Check whether expressions in the syntax of CNA solutions have INUS form
</h2>

<h3>Description</h3>

<p><code>is.inus</code> checks for each element of a character vector of disjunctive normal forms (DNFs) or expressions in the syntax of CNA solution formulas whether it has INUS form, meaning whether it is free of redundancies in necessary or sufficient conditions, free of structural redundancies and partial structural redundancies, whether it has constant factors or identical outcomes, and whether it is tautologous or contradictory.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.inus(cond, x = NULL, csf.info = FALSE, def = c("implication", "equivalence"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>

<p>Character vector of DNFs or expressions in the syntax of CNA solutions (i.e. asf or csf). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An optional argument providing a <code>configTable</code>, a data frame, or a list specifying the factors' value ranges if <code>cond</code> contains multi-value factors; if <code>x</code> is not <code>NULL</code>, <code>is.inus</code> tests whether <code>cond</code> has INUS form relative to <code>full.ct(x)</code>, otherwise relative to <code>full.ct(cond)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csf.info</code></td>
<td>
<p>Logical; if <code>TRUE</code> and <code>cond</code> has the syntax of a csf, details about the performed INUS checks are printed. If <code>cond</code> does not have the syntax of a csf, <code>csf.info</code> has no effect.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>def</code></td>
<td>
<p>Character string specifying the definition of partial structural redundancy (PSR) to be applied. If <code>def = "implication"</code> (default), <code>cond</code> is treated as containing a PSR iff <code>cond</code> logically implies a proper submodel of itself. If <code>def = "equivalence"</code>, a PSR obtains iff  <code>cond</code> is logically equivalent with a proper submodel of itself. The character string can be abbreviated. <b>Note:</b> To reproduce results produced by versions of the package prior to 3.6.0, def may have to be set to <code>"equivalence"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A Boolean dependency structure is not interpretable in terms of a deterministic causal structure if it contains at least one of the following (cf. the “Examples” section for examples): </p>
 <ol>
<li>
<p> redundancies in necessary or sufficient conditions, </p>
</li>
<li>
<p> structural redundancies,</p>
</li>
<li>
<p> partial structural redundancies, </p>
</li>
<li>
<p> constant factors, </p>
</li>
<li>
<p>  tautologous or contradictory substructures, </p>
</li>
<li>
<p> multiple instances of the same outcome. </p>
</li>
</ol>
<p>The function <code>is.inus</code> takes a character vector <code>cond</code> specifying Boolean disjunctive normal forms (DNFs) or expressions in the syntax of CNA solution formulas as input and runs a series of checks on <code>cond</code>; one for each of the conditions (1) to (6). For instance, whenever <code>cond</code> logically implies a syntactic proper part of itself, the surplus in <code>cond</code> is redundant, meaning that it violates condition (1) and is not causally interpretable. To illustrate, “A + a*B &lt;-&gt; C” implies and is even logically equivalent to “A + B &lt;-&gt; C”. Hence, "a" is redundant in the first expression, which is not causally interpretable due to a violation of condition (1).
Or the first asf in “(a + C &lt;-&gt; D)*(D + G &lt;-&gt; A)” implies that whenever "a" is given, so is "D", while the second asf implies that whenever "D" is given, so is "A". It follows that "a" cannot ever be given, meaning that the factor A takes the constant value 1 and, hence, violates condition (4). As constant factors can neither be causes nor effects, “(a + C &lt;-&gt; D)*(D + G &lt;-&gt; A)” is not a well-formed causal structure.
</p>
<p>If an expression passes the <code>is.inus</code>-check it can be interpreted as a causal structure according to Mackie's (1974) INUS-theory of causation or modern variants thereof (e.g. Grasshoff and May 2001; Baumgartner and Falk 2023). In other words, such an expression has the form of an INUS structure, i.e. it has <em>INUS form</em>, for short.
</p>
<p>In the function's default call with <code>x = NULL</code>, the INUS checks are performed relative to <code>full.ct(cond)</code>; if <code>x</code> is not <code>NULL</code>, the checks are performed relative to <code>full.ct(x)</code>. As <code>full.ct(cond)</code> and <code>full.ct(x)</code> coincide in case of binary factors, the argument <code>x</code> has no effect in the crisp-set and fuzzy-set cases. In case of multi-value factors, however, the argument <code>x</code> should be specified in order to define the factors' value ranges (see examples below).
</p>
<p>If the argument <code>csf.info</code> is set to its non-default value <code>TRUE</code> and <code>cond</code> has the syntax of a csf, the results of the individual checks of conditions (1) to (6) are printed (in that order) to the console.
</p>
<p>In its default setting, the <code>cna</code> function does not output solutions that do not have INUS form. But when <code>cna</code> is called with <code>inus.only = FALSE</code>, non-INUS solutions may be returned. The function <code>is.inus</code> is standardly called from within the <code>cna</code> function to determine whether its output has INUS form. 
<code>is.inus</code> also serves an important purpose in the context of benchmark tests. Not any Boolean expression can be interpreted to represent a causal structure; only expressions in INUS form can. That means when simulating data on randomly drawn target structures, it must be ensured that the latter have INUS form. An expression as “A + a*B &lt;-&gt; C”, which has a logically equivalent proper part and, hence, does not have INUS form, is not a well-formed causal structure that could be used as a search target in a benchmark test.
</p>


<h3>Value</h3>

<p>Logical vector of the same length as <code>cond</code>; if <code>cond</code> is a csf and <code>is.inus</code> is called with <code>csf.info = TRUE</code>, an attribute “csf.info” is added.
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. “Boolean Difference-Making: A Modern Regularity Theory of Causation”. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. doi:10.1093/bjps/axz047.
</p>
<p>Grasshoff, Gerd and Michael May. 2001. “Causal Regularities.” In W Spohn, M Ledwig, M Esfeld (eds.), <em>Current Issues in Causation</em>, pp. 85-114. Mentis, Paderborn.
</p>
<p>Mackie, John L. 1974. <em>The Cement of the Universe: A Study of Causation</em>. Oxford: Oxford University Press.
</p>


<h3>See Also</h3>

<p><code>condition</code>, <code>full.ct</code>, <code>redundant</code>, <code>minimalize</code>, <code>cna</code>, <code>minimalizeCsf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Crisp-set case
# --------------
# Testing disjunctive normal forms. 
is.inus(c("A", "A + B", "A + a*B", "A + a", "A*a", "A*a + B"))
  
# Testing expressions in the syntax of atomic solution formulas.
is.inus(c("A + B &lt;-&gt; C", "A + B &lt;-&gt; c", "A + a*B &lt;-&gt; C", "A*a + B &lt;-&gt; C", "A + a &lt;-&gt; C", 
          "F*G + f*g + H &lt;-&gt; E", "F*G + f*g + H*F + H*G &lt;-&gt; E")) 

# Testing expressions in the syntax of complex solution formulas.
is.inus(c("(A + B &lt;-&gt; C)*(c + E &lt;-&gt; D)", "(A &lt;-&gt; B)*(B &lt;-&gt; C)", "(A &lt;-&gt; B)*(B &lt;-&gt; C)*(C &lt;-&gt; D)", 
          "(A &lt;-&gt; B)*(B &lt;-&gt; a)", "(A*B + c &lt;-&gt; D)*(E + f &lt;-&gt; D)",
          "(A + B &lt;-&gt; C)*(B*c + E &lt;-&gt; D)"))

# A redundancy in necessary or sufficient conditions, i.e. 
# a non-INUS asf in a csf.
is.inus("(A + A*B &lt;-&gt; C)*(B + D &lt;-&gt; E)", csf.info = TRUE)

# A structural redundancy in a csf.
cond1 &lt;- "(e + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(a + c &lt;-&gt; E)"
is.inus("(e + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(a + c &lt;-&gt; E)", csf.info = TRUE)
# The first asf in cond1 is redundant.
minimalizeCsf(cond1, selectCases(cond1))

# A partial structural redundancy in a csf.
cond2 &lt;- "(A + B*c + c*E &lt;-&gt; D)*(B + C &lt;-&gt; E)"
is.inus(cond2, csf.info = TRUE)
# The second or third disjunct in the first asf of cond2 is redundant.
cna(selectCases(cond2))
# The notion of a partial structural redundancy (PSR) can be defined in two 
# different ways. To illustrate, consider the following two csfs.
cond2b &lt;- "(B + F*C &lt;-&gt; A)*(A*e*f &lt;-&gt; B)"
cond2c &lt;- "(B + F*C &lt;-&gt; A)*(A*f &lt;-&gt; B)"
# cond2c is a proper submodel of cond2b, and cond2b logically implies cond2c,
# but the two csfs are not logically equivalent (i.e. cond2c does not 
# imply cond2b). If a PSR is said to obtain when one csf logically implies 
# a proper submodel of itself, then cond2b contains a PSR. If a csf has to be
# logically equivalent to a proper submodel of itself in order for a PSR to 
# obtain, then cond2b does not contain a PSR. This difference is implemented
# in the argument def of is.inus(). The default is def = "implication".
is.inus(cond2b, csf.info = TRUE, def = "implication")
is.inus(cond2b, csf.info = TRUE, def = "equivalence")
# The two definitions of PSR only come apart in case of cyclic structures.
# In versions of cna prior to 3.6.0, is.inus() implemented the "equivalence" 
# definition of PSR. That is, to reproduce results of earlier versions, def may
# have to be set to "equivalence". 

# A csf entailing that one factor is constant.
is.inus("(a + C &lt;-&gt; D)*(D + G &lt;-&gt; A)", csf.info = TRUE)

# A contradictory (i.e. logically constant) csf.
is.inus("(A &lt;-&gt; B)*(B &lt;-&gt; a)", csf.info = TRUE)

# A csf with multiple identical outcomes.
is.inus("(A + C &lt;-&gt; B)*(C + E &lt;-&gt; B)", csf.info = TRUE)


# Multi-value case
# ----------------
# In case of multi-value data, is.inus() needs to be given a dataset x determining
# the value ranges of the factors in cond.
mvdata &lt;- configTable(setNames(allCombs(c(2, 3, 2, 3)) -1, c("C", "F", "V", "O")))
is.inus("C=1 + F=2*V=0 &lt;-&gt; O=2", mvdata)
# x can also be given to is.inus() as a list.
is.inus("C=1 + F=2*V=0 &lt;-&gt; O=2", list(C=0:1, F=0:2, V=0:1, O=0:2))
# When x is NULL, is.inus() is applied to full.ct("C=1 + F=2*V=0"), which has only
# one single row. That row is then interpreted to be the only possible configuration, 
# in which case C=1 + F=2*V=0 is tautologous and, hence, non-INUS.
is.inus("C=1 + F=2*V=0 &lt;-&gt; O=2") 
        
is.inus("C=1 + C=0*C=2", configTable(d.pban))    # contradictory
is.inus("C=0 + C=1 + C=2", configTable(d.pban))  # tautologous

# A redundancy in necessary or sufficient conditions, i.e. a 
# non-INUS asf in a csf.
fullDat &lt;- full.ct(list(A=1:3, B=1:3, C=1:3, D=1:3, E=1:3))
is.inus("(A=1 + A=1*B=2 &lt;-&gt; C=3)*(B=2 + D=3 &lt;-&gt; E=1)", fullDat, csf.info = TRUE)

# A structural redundancy in a csf.
cond3 &lt;- "(E=2 + C=1*D=3 &lt;-&gt; A=1)*(A=3*E=1 + C=2*D=2 &lt;-&gt; B=3)*(A=1*E=3 + D=2*E=3 &lt;-&gt; C=1)*
          (A=1*C=2 + A=1*C=3 &lt;-&gt; E=2)"
is.inus(cond3, fullDat, csf.info = TRUE)
# The last asf in cond3 is redundant.
minimalizeCsf(cond3, selectCases(cond3, fullDat))

# A partial structural redundancy in a csf.
cond4 &lt;- "(B=2*C=3 + C=2*D=1 + B=2*C=1*D=2*E=1 &lt;-&gt; A=2)*(D=2*E=1 + D=3*E=1 &lt;-&gt; B=1)"
is.inus(cond4, fullDat, csf.info = TRUE)
# The third disjunct in the first asf of cond4 is redundant.
cna(selectCases(cond4, fullDat))

# A csf entailing that one factor is constant. (I.e. D is constantly ~(D=1).)
cond5 &lt;- "(A=1 + B=2 + E=3 &lt;-&gt;C=3)*(A=1*C=1 + B=2*C=1 &lt;-&gt; D=1)"
is.inus(cond5, fullDat, csf.info = TRUE)

# A contradictory csf.
is.inus("(A=1 &lt;-&gt; C=1)*(A=1 &lt;-&gt; C=2)*(A=1 &lt;-&gt; C=3)", fullDat, csf.info = TRUE)

# A csf with multiple identical outcomes.
is.inus("(A=1 + B=2 + D=3 &lt;-&gt; C=1)*(A=2 + B=3 + D=2 &lt;-&gt; C=1)", fullDat, csf.info = TRUE)


# Fuzzy-set case 
# --------------
fsdata &lt;- configTable(d.jobsecurity)
conds &lt;- csf(cna(fsdata, con = 0.85, cov = 0.85, inus.only = FALSE))$condition
# Various examples of different types.
is.inus(conds[1:10], fsdata, csf.info = TRUE)
is.inus(c("S + s", "S + s*R", "S*s"), fsdata)

# A redundancy in necessary or sufficient conditions, i.e. a 
# non-INUS asf in a csf.
is.inus("(S + s*L &lt;-&gt; JSR)*(R + P &lt;-&gt; V)", fsdata, csf.info = TRUE)

# A structural redundancy in a csf.
is.inus("(s + l*R &lt;-&gt; C)*(C + L*V &lt;-&gt; R)*(l + c &lt;-&gt; S)", fsdata, csf.info = TRUE)

# A partial structural redundancy in a csf.
is.inus("(S + L*c + c*R &lt;-&gt; P)*(L + C &lt;-&gt; R)", fsdata, csf.info = TRUE)

# A csf entailing that one factor is constant.
is.inus("(S + L &lt;-&gt; P)*(L*p &lt;-&gt; JSR)", csf.info = TRUE)

# A contradictory csf.
is.inus("(S &lt;-&gt; JSR)*(JSR &lt;-&gt; s)", fsdata, csf.info = TRUE)

# A csf with multiple identical outcomes.
is.inus("(S*C + V &lt;-&gt; JSR)*(R + P &lt;-&gt; JSR)", fsdata, csf.info = TRUE)
</code></pre>


</div>