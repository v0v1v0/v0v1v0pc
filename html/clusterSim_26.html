<div class="container">

<table style="width: 100%;"><tr>
<td>index.DB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculates Davies-Bouldin's index</h2>

<h3>Description</h3>

<p>Calculates Davies-Bouldin's cluster separation measure</p>


<h3>Usage</h3>

<pre><code class="language-R">index.DB(x, cl, d=NULL, centrotypes="centroids", p=2, q=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>vector of integers indicating the cluster to which each object is allocated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>optional distance matrix, used for calculations if centrotypes="medoids"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centrotypes</code></td>
<td>
<p>"centroids" or "medoids"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the power of the Minkowski distance between centroids or medoids of clusters: p=1 - Manhattan distance; p=2 - Euclidean distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>the power of dispersion measure of a cluster: q=1 - the average distance of objects in the r-th cluster to the centroid or medoid
of the r-th cluster; q=2 - the standard deviation of the distance of objects in the r-th cluster to the centroid or medoid of the r-th cluster</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See file <a href="../doc/indexDB_details.pdf">../doc/indexDB_details.pdf</a> for further details
</p>
<p>Thanks to prof. Christian Hennig <a href="mailto:c.hennig@ucl.ac.uk">c.hennig@ucl.ac.uk</a> for finding and fixing the "immutable p" error  
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>DB</code></td>
<td>
<p>Davies-Bouldin's index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>vector of maximal R values for each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>R matrix <code class="reqn">(S_r+S_s)/d_{rs}</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>matrix of distances between centroids or medoids of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>vector of dispersion measures for each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>coordinates of centroids or medoids for all clusters</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Davies, D.L., Bouldin, D.W. (1979), <em>A cluster separation measure</em>, IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, 224-227. Available at: <a href="https://doi.org/10.1109/TPAMI.1979.4766909">doi:10.1109/TPAMI.1979.4766909</a>.
</p>


<h3>See Also</h3>

<p><code>index.G1</code>, <code>index.G2</code>, <code>index.G3</code>, <code>index.C</code>,
<code>index.S</code>, <code>index.H</code>, <code>index.Gap</code>, <code>index.KL</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1
library(clusterSim)
data(data_ratio)
cl1 &lt;- pam(data_ratio, 4)
d&lt;-dist(data_ratio)
print(index.DB(data_ratio, cl1$clustering,d, centrotypes="medoids"))

# Example 2
library(clusterSim)
data(data_ratio)
cl2 &lt;- pam(data_ratio, 5)
print(index.DB(data_ratio, cl2$clustering, centrotypes="centroids"))

# Example 3
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="euclidean")
# nc - number_of_clusters
min_nc=2
max_nc=8
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
hc &lt;- hclust(md, method="complete")
cl2 &lt;- cutree(hc, k=nc)
res[nc-min_nc+1, 2] &lt;- DB &lt;- index.DB(data_ratio, cl2, centrotypes="centroids")$DB
clusters &lt;- rbind(clusters, cl2)
}
print(paste("min DB for",(min_nc:max_nc)[which.min(res[,2])],"clusters=",min(res[,2])))
print("clustering for min DB")
print(clusters[which.min(res[,2]),])
#write.table(res,file="DB_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="DB", xaxt="n")
axis(1, c(min_nc:max_nc))

# Example 4
library(clusterSim)
data(data_ordinal)
md &lt;- dist.GDM(data_ordinal, method="GDM2")
# nc - number_of_clusters
min_nc=2
max_nc=6
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
hc &lt;- hclust(md, method="complete")
cl2 &lt;- cutree(hc, k=nc)
res[nc-min_nc+1,2] &lt;- DB &lt;- index.DB(data_ordinal,cl2,d=md,centrotypes="medoids")$DB
clusters &lt;- rbind(clusters, cl2)
}
print(paste("min DB for",(min_nc:max_nc)[which.min(res[,2])],"clusters=",min(res[,2])))
print("clustering for min DB")
print(clusters[which.min(res[,2]),])
#write.table(res,file="DB_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="DB", xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>


</div>