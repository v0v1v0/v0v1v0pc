<div class="container">

<table style="width: 100%;"><tr>
<td>get_tag_word</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Words of Some Certain Tags through Pos-Tagging</h2>

<h3>Description</h3>

<p>Given a group of Chinese texts, this function manages to extract words of some specified types. For example, sometimes
you want to collect all verbs that are used in your texts. Note: this function uses <code>jiebaR::tagging</code> to segment
texts and do pos-tagging. The types assigned are not all correct. So, alternatively, you can first pos-tag your texts with
other methods and then use this function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_tag_word(
  x,
  tag = NULL,
  tag_pattern = NULL,
  mycutter = DEFAULT_cutter,
  type = "word",
  each = TRUE,
  only_unique = FALSE,
  keep_name = FALSE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>it must be a list of character vectors, even when the list contains only one element. 
Each element of the list is either a length 1 character vector of a text, or 
a length &gt;= 1 character vector which is the result of former tagging work. It should not contain <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag</code></td>
<td>
<p>one or more tags should be specified. Words with these tags will be chosen. Possible tags are "v", "n", 
"vn", etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag_pattern</code></td>
<td>
<p>should be a length 1 regular expression. You can specify tags by this pattern rather than directly 
provide tag names. For example, you can specify tag names starting with "n" by <code>tag_pattern = "^n"</code>.
At least and at most one of tag and tag_pattern should be <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mycutter</code></td>
<td>
<p>a cutter created with package jiebaR and
given by users to tag texts. If your texts have already been pos-tagged, you
can set this to <code>NULL</code>.
By default, a <code>DEFAULT_cutter</code> is used, which is 
assigned as <code>worker(write = FALSE)</code> when loading the package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>if it is "word" (default), then extract the words that match your tags. If it is "position", only the positions
of the words are returned. Note: if it is "positions", argument <code>each</code> (see below) will always be set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>each</code></td>
<td>
<p>if this is <code>TRUE</code> (default), the return will be a list, each element of which is a extraction result of a text.
If it is <code>FALSE</code>, the return will be a character vector with extracted words. See detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only_unique</code></td>
<td>
<p>if it is <code>TRUE</code>, only unique words are returned. The default is <code>FALSE</code>. See detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_name</code></td>
<td>
<p>whether to keep the tag names of the extracted words. The default is <code>FALSE</code>. Note: if 
<code>only_unique = TRUE</code>, all tag names will be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checks</code></td>
<td>
<p>whether to check the correctness of arguments. The default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Argument each and only_unique decide what kind of return you can get.
</p>

<ul>
<li>
<p> if <code>each = TRUE</code> and <code>only_unique = FALSE</code>, you can get a list, each element of which 
contains words extracted. This is the default.
</p>
</li>
<li>
<p> if <code>each = TRUE</code> and <code>only_unique = TRUE</code>, each element of the list only contains unique words.
</p>
</li>
<li>
<p> if <code>each = FALSE</code> and <code>only_unique = FALSE</code>, all words extracted will be put into a single vector.
</p>
</li>
<li>
<p> if <code>each = FALSE</code> and <code>only_unique = TRUE</code>, words extracted will be put into a single vector, but 
only unique words will be returned.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># No Chinese, so use English instead.
x1 &lt;- c(v = "drink", xdrink = "coffee", v = "drink", xdrink = "cola", v = "eat", xfood = "banana")
x2 &lt;- c(v = "drink", xdrink = "tea", v = "buy", x = "computer")
x &lt;- list(x1, x2)
get_tag_word(x, tag = "v", mycutter = NULL)
get_tag_word(x, tag = "v", mycutter = NULL, only_unique = TRUE)
get_tag_word(x, tag_pattern = "^x", mycutter = NULL)
get_tag_word(x, tag_pattern = "^x", mycutter = NULL, keep_name = TRUE)
get_tag_word(x, tag = "v", mycutter = NULL, each = FALSE)
get_tag_word(x, tag = "v", mycutter = NULL, each = FALSE, only_unique = TRUE)
get_tag_word(x, tag = "v", mycutter = NULL, type = "position")
</code></pre>


</div>