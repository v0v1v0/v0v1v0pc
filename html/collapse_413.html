<div class="container">

<table style="width: 100%;"><tr>
<td>indexing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast Indexed Time Series and Panels
</h2>

<h3>Description</h3>

<p>A fast and flexible indexed time series and panel data class that inherits from <em>plm</em>'s 'pseries' and 'pdata.frame', but is more rigorous, natively handles irregularity, can be superimposed on any data.frame/list, matrix or vector, and supports ad-hoc computations inside data masking functions and model formulas.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Create an 'indexed_frame' containing 'indexed_series'
findex_by(.X, ..., single = "auto", interact.ids = TRUE)
iby(.X, ..., single = "auto", interact.ids = TRUE)  # Shorthand

## Retrieve the index ('index_df') from an 'indexed_frame' or 'indexed_series'
findex(x)
ix(x)     # Shorthand

## Remove index from 'indexed_frame' or 'indexed_series' (i.e. get .X back)
unindex(x)

## Reindex 'indexed_frame' or 'indexed_series' (or index vectors / matrices)
reindex(x, index = findex(x), single = "auto")

## Check if 'indexed_frame', 'indexed_series', index or time vector is irregular
is_irregular(x, any_id = TRUE)

## Convert 'indexed_frame'/'indexed_series' to normal 'pdata.frame'/'pseries'
to_plm(x, row.names = FALSE)

# Subsetting &amp; replacement methods: [(&lt;-) methods call NextMethod().
# Also methods for fsubset, funique and roworder(v), na_omit (internal).

## S3 method for class 'indexed_series'
x[i, ..., drop.index.levels = "id"]

## S3 method for class 'indexed_frame'
x[i, ..., drop.index.levels = "id"]

## S3 replacement method for class 'indexed_frame'
x[i, j] &lt;- value

## S3 method for class 'indexed_frame'
x$name

## S3 replacement method for class 'indexed_frame'
x$name &lt;- value

## S3 method for class 'indexed_frame'
x[[i, ...]]

## S3 replacement method for class 'indexed_frame'
x[[i]] &lt;- value

# Index subsetting and printing: optimized using ss()

## S3 method for class 'index_df'
x[i, j, drop = FALSE, drop.index.levels = "id"]

## S3 method for class 'index_df'
print(x, topn = 5, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.X</code></td>
<td>
<p>a data frame or list-like object of equal-length columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an 'indexed_frame' or 'indexed_series'. <code>findex</code> also works with 'pseries' and 'pdata.frame's created with <em>plm</em>. For <code>is_irregular</code> <code>x</code> can also be an index (inherits 'pindex') or a vector representing time. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for <code>findex_by</code>: variables identifying the individual (id) and/or time dimensions of the data. Passed either as unquoted comma-separated column names or (tagged) expressions involving columns, or as a vector of column names, indices, a logical vector or a selector function. The time variable must enter last. See Examples. Otherwise: further arguments passed to <code>NextMethod()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>single</code></td>
<td>
<p>character. If only one indexing variable is supplied, this can be declared as <code>"id"</code> or <code>"time"</code> variable. <code>"auto"</code> chooses <code>"id"</code> if the variable has <code>anyDuplicated</code> values.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interact.ids</code></td>
<td>
<p>logical. If <code>n &gt; 2</code> indexing variables are passed, <code>TRUE</code> calls <code>finteraction</code> on the first <code>n-1</code> of them (<code>n</code>'th variable must be time). <code>FALSE</code> keeps all variables in the index. The latter slows down computations of lags / differences etc. because ad-hoc interactions need to be computed, but gives more flexibility for scaling / centering / summarising over different data dimensions.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>and index (inherits 'pindex'), or an atomic vector or list of factors matching the data dimensions. Atomic vectors or lists with 1 factor will must be declared, see <code>single</code>. Atomic vectors will additionally be grouped / turned into time-factors. See Details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.index.levels</code></td>
<td>
<p>character. Subset methods also subset the index (= a data.frame of factors), and this argument regulates which factor levels should be dropped: either <code>"all"</code>, <code>"id"</code>, <code>"time"</code> or <code>"none"</code>. The default <code>"id"</code> only drops levels from id's. <code>"all"</code> or <code>"time"</code> should be used with caution because time-factors may contain levels for missing time periods (gaps in irregular sequences, or periods within a sequence removed through subsetting), and dropping those levels would create a variable that is ordinal but no longer represents time. The benefit of dropping levels is that it can speed-up subsequent computations by reducing the size of intermediate vectors created in C++.   </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>any_id</code></td>
<td>
<p>logical. For panel series: <code>FALSE</code> returns the irregularity check performed for each id, <code>TRUE</code> calls <code>any</code> on those checks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>logical. <code>TRUE</code> creates descriptive row-names (or names for pseries) as in <code>plm</code>. This can be expensive and is usually not required for <code>plm</code> models to work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topn</code></td>
<td>
<p>integer. The number of first and last rows to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i, j, name, drop, value</code></td>
<td>
<p>Arguments passed to <code>NextMethod</code>, or as in the data.frame methods. Note that for index subsetting to work, <code>i</code> needs to be integer or logical (or an expression evaluation to integer or logical if <code>x</code> is a <em>data.table</em>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The first thing to note about these new 'indexed_frame', 'indexed_series' and 'index_df' classes is that they inherit <em>plm</em>'s 'pdata.frame', 'pseries' and 'pindex' classes, respectively. They add, improve, and, in some cases, remove functionality offered by <em>plm</em>, with the aim of striking an optimal balance of flexibility and performance. The inheritance means that all 'pseries' and 'pdata.frame' methods in <em>collapse</em>, and also some methods in <em>plm</em>, apply to them. Where compatibility or performance considerations allow for it, <em>collapse</em> will continue to create methods for <em>plm</em>'s classes instead of the new classes.
</p>
<p>The use of these classes does not require much knowledge of <em>plm</em>, but as a basic background: A 'pdata.frame' is a data.frame with an index attribute: a data.frame of 2 factors identifying the individual and time-dimension of the data. When pulling a variable out of the pdata.frame using a method like <code>$.pdata.frame</code> or <code>[[.pdata.frame</code> (defined in <em>plm</em>), a 'pseries' is created by transferring the index attribute to the vector. Methods defined for functions like <code>lag</code> / <code>flag</code> etc. use the index for correct computations on this panel data, also inside <em>plm</em>'s estimation commands.
</p>
<p><b>Main Features and Enhancements</b>
</p>
<p>The 'indexed_frame' and 'indexed_series' classes extend and enhance 'pdata.frame' and 'pseries' in a number of critical dimensions. Most notably they:
</p>

<ul>
<li>
<p> Support <b>both time series and panel data</b>, by allowing indexation of data with one, two or more variables.
</p>
</li>
<li>
<p> Are <b>class-agnostic</b>: any data.frame/list (such as data.table, tibble, tsibble, sf etc.) can become an 'indexed_frame' and continue to function as usual for most use cases. Similarly, any vector or matrix (such as ts, mts, xts) can become an 'indexed_series'. This also allows for transient workflows e.g. <code>some_df |&gt; findex_by(...) |&gt; 'do something using collapse functions' |&gt; unindex() |&gt; 'continue working with some_df'</code>.
</p>
</li>
<li>
<p> Have a comprehensive and efficient set of <b>methods for subsetting and manipulation</b>, including methods for <code>fsubset</code>, <code>funique</code>, <code>roworder(v)</code> (internal) and <code>na_omit</code> (internal, <code>na.omit</code> also works but is slower). It is also possible to group indexed data with <code>fgroup_by</code> for transformations e.g. using <code>fmutate</code>, but aggregation requires <code>unindex()</code>ing.
</p>
</li>
<li> <p><b>Natively handle irregularity</b>: time objects (such as 'Date', 'POSIXct' etc.) are passed to <code>timeid</code>, which efficiently determines the temporal structure by finding the greatest common divisor (GCD), and creates a time-factor with levels corresponding to a complete time-sequence. The latter is also done with plain numeric vectors, which are assumed to represent unit time steps (GDC = 1) and coerced to integer (but can also be passed through <code>timeid</code> if non-unitary). Character time variables are converted to factor, which might also capture irregular gaps in panel series. Using this time-factor in the index, <em>collapse</em>'s functions efficiently perform correct computations on irregular sequences and panels without the need to 'expand' the data / fill gaps. <code>is_irregular</code> can be used to check for irregularity in the entire sequence / panel or separately for each individual in panel data.
</p>
</li>
<li>
<p> Support computations inside <b>data-masking functions and formulas</b>, by virtue of "<b>deep indexation</b>": Each variable inside an 'indexed_frame' is an 'indexed_series' which contains in its 'index_df' attribute an external pointer to the 'index_df' attribute of the frame. Functions operating on 'indexed_series' stored inside the frame (such as <code>with(data, flag(column))</code>) can fetch the index from this pointer. This allows worry-free application inside arbitrary data masking environments (<code>with</code>, <code>%$%</code>, <code>attach</code>, etc..) and estimation commands (<code>glm</code>, <code>feols</code>, <code>lmrob</code> etc..) without duplication of the index in memory. A limitation is that external pointers are only valid during the present R session, thus when saving an 'indexed_frame' and loading it again, you need to call <code>data = reindex(data)</code> before computing on it.
</p>
</li>
</ul>
<p>Indexed series also have simple Math and Ops methods, which apply the operation to the unindexed series and shallow copy the attributes of the original object to the result, unless the result it is a logical vector (from operations like <code>!</code>, <code>==</code> etc.). For Ops methods, if the LHS object is an 'indexed_series' its attributes are taken, otherwise the attributes of the RHS object are taken.
</p>
<p><b>Limits to plm Compatibility</b>
</p>
<p>In contrast to 'pseries' and 'pdata.frame's, 'indexed_series' and 'indexed_frames' do not have descriptive "names" or "row.names" attributes attached to them, mainly for efficiency reasons.
</p>
<p>Furthermore, the index is stored in an attribute named 'index_df' (same as the class name), not 'index' as in <em>plm</em>, mainly to make these classes work with <em>data.table</em>, <em>tsibble</em> and <em>xts</em>, which also utilize 'index' attributes. This for the most part poses no problem to plm compatibility because plm source code fetches the index using <code>attr(x, "index")</code>, and <code>attr</code> by default performs partial matching. 
</p>
<p>A much greater obstacle in working with <em>plm</em> is that some internal <em>plm</em> code is hinged on there being no <code>[.pseries</code> method, and the existence of <code>[.indexed_series</code> limits the use of these classes in most <em>plm</em> estimation commands. Therefore the <code>to_plm</code> function is provided to efficiently coerce the classes to ordinary plm objects before estimation. See Examples.
</p>
<p>Overall these classes don't really benefit <em>plm</em>, especially given that collapse's plm methods also support native plm objects. However, they work very well inside other models and software, including <em>stats</em> models, <em>fixest</em> / <em>lfe</em>, and a whole bunch of time series and ML models. See Examples.
</p>
<p><b>Performance Considerations</b>
</p>
<p>When indexing long time-series or panels with a single variable, setting <code>single = "id" or "time"</code> avoids a potentially expensive call to <code>anyDuplicated</code>. Note also that when panel-data are regular and sorted, omitting the time variable in the index can bring &gt;= 2x performance improvements in operations like lagging and differencing (alternatively use <code>shift = "row"</code> argument to <code>flag</code>, <code>fdiff</code> etc.) .
</p>
<p>When dealing with long Date or POSIXct time sequences, it may also be that the internal processing by <code>timeid</code> is slow simply because calling <code>strftime</code> on these sequences to create factor levels is slow. In this case you may choose to generate an index factor with integer levels by passing <code>timeid(t)</code> to <code>findex_by</code> or <code>reindex</code> (which by default generates a 'qG' object which is internally converted to factor using <code>as_factor_qG</code>. The lazy evaluation of expressions like <code>as.character(seq_len(nlev))</code> in modern R makes this extremely efficient).
</p>
<p>With multiple id variables e.g. <code>findex_by(data, id1, id2, id3, time)</code>, the default call to <code>finteraction()</code> can be expensive because of pasting the levels together. In this case, users may gain performance by manually invoking <code>finteraction()</code> (or its shorthand <code>itn()</code>) with argument <code>factor = FALSE</code> e.g. <code>findex_by(data, ids = itn(id1, id2, id3, factor = FALSE), time)</code>. This will generate a factor with integer levels instead.
</p>
<p><b>Print Method</b>
</p>
<p>The print methods for 'indexed_frame' and 'indexed_series' first call <code>print(unindex(x), ...)</code>, followed by the index variables with the number of categories (index factor levels) in square brackets. If the time factor contains unused levels (= irregularity in the sequence), the square brackets indicate the number of used levels (periods), followed by the total number of levels (periods in the sequence) in parentheses.
</p>


<h3>See Also</h3>

<p><code>timeid</code>,
Time Series and Panel Series, Collapse Overview</p>


<h3>Examples</h3>

<pre><code class="language-R">oldopts &lt;- options(max.print = 70)
# Indexing panel data ----------------------------------------------------------

wldi &lt;- findex_by(wlddev, iso3c, year)
wldi
wldi[1:100,1]                 # Works like a data frame
POP &lt;- wldi$POP               # indexed_series
qsu(POP)                      # Summary statistics
G(POP)                        # Population growth
STD(G(POP, c(1, 10)))         # Within-standardized 1 and 10-year growth rates
psmat(POP)                    # Panel-Series Matrix
plot(psmat(log10(POP)))

POP[30:5000]                  # Subsetting indexed_series
Dlog(POP[30:5000])            # Log-difference of subset
psacf(identity(POP[30:5000])) # ACF of subset
L(Dlog(POP[30:5000], c(1, 10)), -1:1) # Multiple computations on subset

# Fast Statistical Functions don't have dedicated methods
# Thus for aggregation we need to unindex beforehand ...
fmean(unindex(POP))
wldi |&gt; unindex() |&gt;
  fgroup_by(iso3c) |&gt; num_vars() |&gt; fmean()

library(magrittr)
# ... or unindex after taking group identifiers from the index
fmean(unindex(fgrowth(POP)), ix(POP)$iso3c)
wldi |&gt; num_vars() %&gt;%
  fgroup_by(iso3c = ix(.)$iso3c) |&gt;
  unindex() |&gt; fmean()

# With matrix methods it is easier as most attributes are dropped upon aggregation.
G(POP, c(1, 10)) %&gt;% fmean(ix(.)$iso3c)

# Example of index with multiple ids
GGDC10S |&gt; findex_by(Variable, Country, Year) |&gt; head() # default is interact.ids = TRUE
GGDCi &lt;- GGDC10S |&gt; findex_by(Variable, Country, Year, interact.ids = FALSE)
head(GGDCi)
findex(GGDCi)
# The benefit is increased flexibility for summary statistics and data transformation
qsu(GGDCi, effect = "Country")
STD(GGDCi$SUM, effect = "Variable")            # Standardizing by variable
STD(GGDCi$SUM, effect = c("Variable", "Year")) # ... by variable and year
# But time-based operations are a bit more expensive because of the necessary interactions
D(GGDCi$SUM)

# Panel-Data modelling ---------------------------------------------------------

# Linear model of 5-year annualized growth rates of GDP on Life Expactancy + 5y lag
lm(G(PCGDP, 5, p = 1/5) ~ L(G(LIFEEX, 5, p = 1/5), c(0, 5)), wldi) # p abbreviates "power"

# Same, adding time fixed effects via plm package: need to utilize to_plm function
plm::plm(G(PCGDP, 5, p = 1/5) ~ L(G(LIFEEX, 5, p = 1/5), c(0, 5)), to_plm(wldi), effect = "time")

# With country and time fixed effects via fixest
fixest::feols(G(PCGDP, 5, p=1/5) ~ L(G(LIFEEX, 5, p=1/5), c(0, 5)), wldi, fixef = .c(iso3c, year))
## Not run:  
# Running a robust MM regression without fixed effects
robustbase::lmrob(G(PCGDP, 5, p = 1/5) ~ L(G(LIFEEX, 5, p = 1/5), c(0, 5)), wldi)

# Running a robust MM regression with country and time fixed effects
wldi |&gt; fselect(PCGDP, LIFEEX) |&gt;
  fgrowth(5, power = 1/5) |&gt; ftransform(LIFEEX_L5 = L(LIFEEX, 5)) |&gt;
  # drop abbreviates drop.index.levels (not strictly needed here but more consistent)
  na_omit(drop = "all") |&gt; fhdwithin(na.rm = FALSE) |&gt; # For TFE use fwithin(effect = "year")
  unindex() |&gt; robustbase::lmrob(formula = PCGDP ~.)    # using lm() gives same result as fixest

# Using a random forest model without fixed effects
# ranger does not support these kinds of formulas, thus we need some preprocessing...
wldi |&gt; fselect(PCGDP, LIFEEX) |&gt;
  fgrowth(5, power = 1/5) |&gt; ftransform(LIFEEX_L5 = L(LIFEEX, 5)) |&gt;
  unindex() |&gt; na_omit() |&gt; ranger::ranger(formula = PCGDP ~.)

## End(Not run)

# Indexing other data frame based classes --------------------------------------

library(tibble)
wlditbl &lt;- qTBL(wlddev) |&gt; findex_by(iso3c, year)
wlditbl[,2] # Works like a tibble...
wlditbl[[2]]
wlditbl[1:1000, 10]
head(wlditbl)

library(data.table)
wldidt &lt;- qDT(wlddev) |&gt; findex_by(iso3c, year)
wldidt[1:1000]      # Works like a data.table...
wldidt[year &gt; 2000]
wldidt[, .(sum_PCGDP = sum(PCGDP, na.rm = TRUE)), by = country] # Aggregation unindexes the result
wldidt[, lapply(.SD, sum, na.rm = TRUE), by = country, .SDcols = .c(PCGDP, LIFEEX)]
# This also works but is a bit inefficient since the index is subset and then dropped
# -&gt; better unindex beforehand
wldidt[year &gt; 2000, .(sum_PCGDP = sum(PCGDP, na.rm = TRUE)), by = country]
wldidt[, PCGDP_gr_5Y := G(PCGDP, 5, power = 1/5)]  # Can add Variables by reference
# Note that .SD is a data.table of indexed_series, not an indexed_frame, so this is WRONG!
wldidt[, .c(PCGDP_gr_5Y, LIFEEX_gr_5Y) := G(slt(.SD, PCGDP, LIFEEX), 5, power = 1/5)]
# This gives the correct outcome
wldidt[, .c(PCGDP_gr_5Y, LIFEEX_gr_5Y) := lapply(slt(.SD, PCGDP, LIFEEX), G, 5, power = 1/5)]

## Not run: 
library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
nci &lt;- findex_by(nc, SID74)
nci[1:10, "AREA"]
st_centroid(nci) # The geometry column is never indexed, thus sf computations work normally
st_coordinates(nci)
fmean(st_area(nci))

library(tsibble)
pedi &lt;- findex_by(pedestrian, Sensor, Date_Time)
pedi[1:5, ]
findex(pedi) # Time factor with 17k levels from POSIXct
# Now here is a case where integer levels in the index can really speed things up
ix(iby(pedestrian, Sensor, timeid(Date_Time)))
library(microbenchmark)
microbenchmark(descriptive_levels = findex_by(pedestrian, Sensor, Date_Time),
               integer_levels = findex_by(pedestrian, Sensor, timeid(Date_Time)))
# Data has irregularity
is_irregular(pedi)
is_irregular(pedi, any_id = FALSE) # irregularity in all sequences
# Manipulation such as lagging with tsibble/dplyr requires expanding rows and grouping
# Collapse can just compute correct lag on indexed series or frames
library(dplyr)
microbenchmark(
  dplyr = fill_gaps(pedestrian) |&gt; group_by_key() |&gt; mutate(Lag_Count = lag(Count)),
  collapse = fmutate(pedi, Lag_Count = flag(Count)), times = 10)

## End(Not run)
# Indexing Atomic objects ---------------------------------------------------------

## ts
print(AirPassengers)
AirPassengers[-(20:30)]        # Ts class does not support irregularity, subsetting drops class
G(AirPassengers[-(20:30)], 12) # Annual Growth Rate: Wrong!
# Now indexing AirPassengers (identity() is a trick so that the index is named time(AirPassengers))
iAP &lt;- reindex(AirPassengers, identity(time(AirPassengers)))
iAP
findex(iAP)    # See the index
iAP[-(20:30)]  # Subsetting
G(iAP[-(20:30)], 12)                # Annual Growth Rate: Correct!
L(G(iAP[-(20:30)], c(0,1,12)), 0:1) # Lagged level, period and annual growth rates...
 
## xts
library(xts)
library(zoo) # Needed for as.yearmon() and index() functions
X &lt;- wlddev |&gt; fsubset(iso3c == "DEU", date, PCGDP:POP) %&gt;% {
  xts(num_vars(.), order.by = as.yearmon(.$date))
  } |&gt; ss(-(30:40)) %&gt;% reindex(identity(index(.))) # Introducing a gap
# plot(G(unindex(X)))
diff(unindex(X))    # diff.xts gixes wrong result
fdiff(X)            # fdiff gives right result

# But xts range-based subsets do not work...
## Not run: 
X["1980/"]

## End(Not run)
# Thus a better way is not to index and perform ad-hoc omputations on the xts index
X &lt;- unindex(X)
X["1980/"] %&gt;% fdiff(t = index(.)) # xts index is internally processed by timeid()

## Of course you can also index plain vectors / matrices...
options(oldopts)
</code></pre>


</div>