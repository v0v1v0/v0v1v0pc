<div class="container">

<table style="width: 100%;"><tr>
<td>clme_em_fixed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constrained EM algorithm for linear fixed or mixed effects models.</h2>

<h3>Description</h3>

<p><code>clme_em_fixed</code> performs a constrained EM algorithm for linear fixed effects models.
</p>
<p><code>clme_em_mixed</code> performs a constrained EM algorithm for linear mixed effects models.
</p>
<p><code>clme_em</code> is the general function, it will call the others.
These Expectation-maximization (EM) algorithms estimate model parameters and 
compute a test statistic.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clme_em_fixed(
  Y,
  X1,
  X2 = NULL,
  U = NULL,
  Nks = dim(X1)[1],
  Qs = dim(U)[2],
  constraints,
  mq.phi = NULL,
  tsf = lrt.stat,
  tsf.ind = w.stat.ind,
  mySolver = "LS",
  em.iter = 500,
  em.eps = 1e-04,
  all_pair = FALSE,
  dvar = NULL,
  verbose = FALSE,
  ...
)

clme_em_mixed(
  Y,
  X1,
  X2 = NULL,
  U = NULL,
  Nks = dim(X1)[1],
  Qs = dim(U)[2],
  constraints,
  mq.phi = NULL,
  tsf = lrt.stat,
  tsf.ind = w.stat.ind,
  mySolver = "LS",
  em.iter = 500,
  em.eps = 1e-04,
  all_pair = FALSE,
  dvar = NULL,
  verbose = FALSE,
  ...
)

clme_em(
  Y,
  X1,
  X2 = NULL,
  U = NULL,
  Nks = nrow(X1),
  Qs = ncol(U),
  constraints,
  mq.phi = NULL,
  tsf = lrt.stat,
  tsf.ind = w.stat.ind,
  mySolver = "LS",
  em.iter = 500,
  em.eps = 1e-04,
  all_pair = FALSE,
  dvar = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code class="reqn">N \times 1</code> vector of response data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p><code class="reqn">N \times p_1</code> design matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>optional <code class="reqn">N \times p_2</code> matrix of covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>optional <code class="reqn">N \times c</code> matrix of random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nks</code></td>
<td>
<p>optional <code class="reqn">K \times 1</code> vector of group sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qs</code></td>
<td>
<p>optional <code class="reqn">Q \times 1</code> vector of group sizes for random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>list containing the constraints. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mq.phi</code></td>
<td>
<p>optional MINQUE estimates of variance parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tsf</code></td>
<td>
<p>function to calculate the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tsf.ind</code></td>
<td>
<p>function to calculate the test statistic for individual constrats. See Details for further information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mySolver</code></td>
<td>
<p>solver to use in isotonization (passed to <code>activeSet</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>em.iter</code></td>
<td>
<p>maximum number of iterations permitted for the EM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>em.eps</code></td>
<td>
<p>criterion for convergence for the EM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_pair</code></td>
<td>
<p>logical, whether all pairwise comparisons should be considered (constraints will be ignored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dvar</code></td>
<td>
<p>fixed values to replace bootstrap variance of 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, function prints messages on progress of the EM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>space for additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Argument <code>constraints</code> is a list including at least the elements <code>A</code>, <code>B</code>, and <code>Anull</code>. This argument can be generated by function <code>create.constraints</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the elements:
</p>

<ul>
<li>
<p><code>theta</code> coefficient estimates.
</p>
</li>
<li>
<p><code>theta.null</code> vector of coefficient estimates under the null hypothesis.
</p>
</li>
<li>
<p><code>ssq</code> estimate of residual variance term(s).
</p>
</li>
<li>
<p><code>tsq</code> estimate of variance components for any random effects.
</p>
</li>
<li>
<p><code>cov.theta</code> covariance matrix of the unconstrained coefficients. 
</p>
</li>
<li>
<p><code>ts.glb</code> test statistic for the global hypothesis.
</p>
</li>
<li>
<p><code>ts.ind</code> test statistics for each of the constraints.
</p>
</li>
<li>
<p><code>mySolver</code> the solver used for isotonization.
</p>
</li>
</ul>
<h3>Note</h3>

<p>There are few error catches in these functions. If only the EM estimates are desired, 
users are recommended to run <code>clme</code> setting <code>nsim=0</code>.
</p>
<p>By default, homogeneous variances are assumed for the residuals and (if included) 
random effects. Heterogeneity can be induced using the arguments <code>Nks</code> and <code>Qs</code>,
which refer to the vectors <code class="reqn"> (n_{1}, n_{2}, \ldots, n_{k}) </code> and
<code class="reqn"> (c_{1}, c_{2}, \ldots, c_{q}) </code>, respectively. See 
<code>CLME-package</code> for further explanation the model and these values.
</p>
<p>See <code>w.stat</code> and <code>lrt.stat</code> for more details on using custom 
test statistics.
</p>


<h3>See Also</h3>

<p><code>CLME-package</code>
<code>clme</code>
<code>create.constraints</code>
<code>lrt.stat</code>
<code>w.stat</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data( rat.blood )

model_mats &lt;- model_terms_clme( mcv ~ time + temp + sex + (1|id), data = rat.blood )

Y  &lt;- model_mats$Y
X1 &lt;- model_mats$X1
X2 &lt;- model_mats$X2
U  &lt;- model_mats$U

cons &lt;- list(order = "simple", decreasing = FALSE, node = 1 )

clme.out &lt;- clme_em(Y = Y, X1 = X1, X2 = X2, U = U, constraints = cons)

</code></pre>


</div>