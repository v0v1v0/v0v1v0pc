<div class="container">

<table style="width: 100%;"><tr>
<td>condition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Uncover relevant properties of msc, asf, and csf in a data frame or <code>configTable</code>
</h2>

<h3>Description</h3>

<p>The <code>condition</code> function provides assistance to inspect the properties of msc, asf, and csf (as returned by <code>cna</code>) in a data frame or <code>configTable</code>, but also of any other Boolean function. <code>condition</code> reveals which configurations and cases instantiate a given msc, asf, or csf and lists consistency and coverage scores. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">condition(x, ...)

## Default S3 method:
condition(x, ct, type, add.data = FALSE,
          force.bool = FALSE, rm.parentheses = FALSE, ..., tt)
## S3 method for class 'condTbl'
condition(x, ct, ...)

## S3 method for class 'condList'
print(x, ...)
## S3 method for class 'cond'
print(x, digits = 3, print.table = TRUE, 
      show.cases = NULL, add.data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character vector specifying a Boolean expression as <code>"A + B*C -&gt; D"</code>, where <code>"A"</code>, <code>"B"</code>, <code>"C"</code>, <code>"D"</code> are factor values appearing in <code>ct</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ct</code></td>
<td>
<p>Data frame or <code>configTable</code> (see <code>configTable</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.data</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>ct</code> is attached to the output. Alternatively, <code>ct</code> can be requested by the <code>add.data</code> argument in <code>print.cond</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.bool</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>x</code> is interpreted as a mere Boolean function, not as a causal model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.parentheses</code></td>
<td>
<p>Logical; if <code>TRUE</code>, parentheses around <code>x</code> are removed prior to evaluation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to print in consistency and coverage scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.table</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the table assigning configurations and cases to conditions is printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the attribute “cases” of the <code>configTable</code> is printed; same default behavior as in <code>print.configTable</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tt</code></td>
<td>
<p>Argument <code>tt</code> is deprecated in <code>condition()</code>; use <code>ct</code> instead.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depending on the processed data frame or <code>configTable</code>, the solutions output by <code>cna</code> are often ambiguous; that is, it can happen that many solution formulas fit the data equally well. If that happens, the data alone are insufficient to single out one solution. While <code>cna</code> simply lists the possible solutions, the <code>condition</code> function is intended to provide assistance in comparing different minimally sufficient conditions (msc), atomic solution formulas (asf), and complex solution formulas (csf) in order to have a better basis for selecting among them. 
</p>
<p>Most importantly, the output of the <code>condition</code> function highlights in which configurations and cases in the data an msc, asf, and csf is instantiated. Thus, if the user has independent causal knowledge about particular configurations or cases, the information received from <code>condition</code> may be helpful in selecting the solutions that are consistent with that knowledge. Moreover, the <code>condition</code> function allows for directly contrasting consistency and coverage scores or frequencies of different conditions contained in returned asf. 
</p>
<p>The <code>condition</code> function is independent of <code>cna</code>. That is, any msc, asf, or csf—irrespective of whether they are output by <code>cna</code>—can be given as input to <code>condition</code>. Even Boolean expressions that do not have the syntax of CNA solution formulas can be passed to <code>condition</code>. 
</p>
<p>The first required input <code>x</code> of <code>condition</code> is a character vector consisting of Boolean formulas composed of factor values that appear in <code>ct</code>, which is the second required input. <code>ct</code> can be a <code>configTable</code> or a data frame. If <code>ct</code> is a data frame and the <code>type</code> argument has its default value <code>"auto"</code>, <code>condition</code> first determines the data type and then converts the data frame to a <code>configTable</code>. The data type can also be manually specified by giving the <code>type</code> argument one of the values <code>"cs"</code>, <code>"mv"</code>, or <code>"fs"</code>.


</p>
<p>Conjunction can be expressed by “<code>*</code>” or “<code>&amp;</code>”, disjunction by “<code>+</code>” or “<code>|</code>”, negation can be expressed by “<code>-</code>” or “<code>!</code>” or, in case of crisp-set or fuzzy-set data, by changing upper case into lower case letters and vice versa, implication by “<code>-&gt;</code>”, and equivalence by “<code>&lt;-&gt;</code>”. Examples are </p>

<ul>
<li> <p><code>A*b -&gt; C, A+b*c+!(C+D),  A*B*C + -(E*!B), C -&gt; A*B + a*b</code>
</p>
</li>
<li> <p><code>(A=2*B=4 + A=3*B=1 &lt;-&gt; C=2)*(C=2*D=3 + C=1*D=4 &lt;-&gt; E=3)</code>
</p>
</li>
<li> <p><code>(A=2*B=4*!(A=3*B=1)) | !(C=2|D=4)*(C=2*D=3 + C=1*D=4 &lt;-&gt; E=3)</code>
</p>
</li>
</ul>
<p>Three types of conditions are distinguished:
</p>

<ul>
<li>
<p> The type <em>boolean</em> comprises Boolean expressions that do not have the syntactic form of causal models, meaning the corresponding character strings in the argument <code>x</code> do not have an “<code>-&gt;</code>” or “<code>&lt;-&gt;</code>” as main operator. Examples: <code>"A*B + C"</code> or <code>"-(A*B + -(C+d))"</code>. The expression is evaluated and written into a data frame with one column. Frequency is attached to this data frame as an attribute. 
</p>
</li>
<li>
<p> The type <em>atomic</em> comprises expressions that have the syntactic form of atomic causal models, i.e. asf, meaning the corresponding character strings in the argument <code>x</code> have an “<code>-&gt;</code>” or “<code>&lt;-&gt;</code>” as main operator. Examples: <code>"A*B + C -&gt; D"</code> or <code>"A*B + C &lt;-&gt; D"</code>. The expressions on both sides of “<code>-&gt;</code>” and “<code>&lt;-&gt;</code>” are evaluated and written into a data frame with two columns. Consistency and coverage are attached to these data frames as attributes.
</p>
</li>
<li>
<p> The type <em>complex</em> represents complex causal models, i.e. csf. Example:<br><code>"(A*B + a*b &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)"</code>. Each component must be a causal model of type <em>atomic</em>. These components are evaluated separately and the results stored in a list. Consistency and coverage of the complex expression are then attached to this list.
</p>
</li>
</ul>
<p>The types of the character strings in the input <code>x</code> are automatically discerned and thus do not need to be specified by the user.
</p>
<p>If <code>force.bool = TRUE</code>, expressions with “<code>-&gt;</code>” or “<code>&lt;-&gt;</code>” are treated as type <em>boolean</em>, i.e. only their frequencies are calculated. Enclosing a character string representing a causal model in parentheses has the same effect as specifying <code>force.bool = TRUE</code>. <code>rm.parentheses = TRUE</code> removes parentheses around the expression prior to evaluation, and thus has the reverse effect of setting <code>force.bool = TRUE</code>.
</p>
<p>If <code>add.data = TRUE</code>, <code>ct</code> is appended to the output such as to facilitate the analysis and evaluation of a model on the case level.
</p>
<p>The <code>digits</code> argument of the <code>print</code> method determines how many digits of consistency and coverage scores are printed. If <code>print.table = FALSE</code>, the table assigning conditions to configurations and cases is omitted, i.e. only frequencies or consistency and coverage scores are returned. <code>row.names = TRUE</code> also lists the row names in <code>ct</code>. If rows in a <code>ct</code> are instantiated by many cases, those cases are not printed by default. They can be recovered by <code>show.cases = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>condition</code> returns a nested list of objects, each of them corresponding to one element of the input vector <code>x</code>. The list has a class attribute “condList”, the list elements (i.e., the individual conditions) are of class “cond” and have a more specific class label “booleanCond”, “atomicCond” or “complexCond”, relfecting the type of condition. The components of class “booleanCond” or “atomicCond” are amended data frames, those of class “complexCond” are lists of amended data frames.
</p>


<h3>
<code>print</code> method</h3>

<p><code>print.condList</code> essentially executes <code>print.cond</code> (the method printing a single condition)
successively for each list element/condition. All arguments in <code>print.condList</code> are thereby passed to <code>print.cond</code>, i.e. <code>digits</code>, <code>print.table</code>, <code>show.cases</code>, <code>add.data</code> can also be specified when printing the complete list of conditions.
</p>
<p>The option “spaces” controls how the conditions are rendered in certain contexts. The current setting is queried by typing <code>getOption("spaces")</code>. The option specifies characters that will be printed with a space before and after them. The default is <code>c("&lt;-&gt;","-&gt;","+")</code>. A more compact output is obtained with <code>option(spaces = NULL)</code>. 
</p>


<h3>References</h3>

<p>Emmenegger, Patrick. 2011. “Job Security Regulations in Western Democracies: 
A Fuzzy Set Analysis.” <em>European Journal of Political Research</em> 50(3):336-64.
</p>
<p>Lam, Wai Fung, and Elinor Ostrom. 2010.
“Analyzing the Dynamic Complexity of Development Interventions: Lessons
from an Irrigation Experiment in Nepal.”
<em>Policy Sciences</em> 43 (2):1-25.
</p>
<p>Ragin, Charles. 2008.
<em>Redesigning Social Inquiry: Fuzzy Sets and Beyond</em>. Chicago, IL:
University of Chicago Press.
</p>


<h3>See Also</h3>

<p><code>condList-methods</code> describes methods and functions processing the output of <code>condition</code>; see, in particular, the related <code>summary</code> and <code>as.data.frame</code> methods.
</p>
<p><code>cna</code>, <code>configTable</code>, <code>condTbl</code>, <code>as.data.frame.condList</code>, <code>d.irrigate</code>, <code>shortcuts</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Crisp-set data from Lam and Ostrom (2010) on the impact of development interventions 
# ------------------------------------------------------------------------------------
# Build the configuration table for d.irrigate.
irrigate.ct &lt;- configTable(d.irrigate)

# Any Boolean functions involving values of the factors "A", "R", "F", "L", "C", "W" in 
# d.irrigate can be tested by condition().
condition("A*r + L*C", irrigate.ct)
condition(c("A*r + !(L*C)", "A*-(L | -F)", "C -&gt; A*R + C*l"), irrigate.ct)
condition(c("A*r + L*C -&gt; W", "!(A*L*R -&gt; W)", "(A*R + C*l &lt;-&gt; F)*(W*a -&gt; F)"),
          irrigate.ct)

# Group expressions with "-&gt;" by outcome.
irrigate.con &lt;- condition(c("A*r + L*C -&gt; W", "A*L*R -&gt; W", "A*R + C*l -&gt; F", "W*a -&gt; F"),
                          irrigate.ct)
group.by.outcome(irrigate.con)

# Pass minimally sufficient conditions inferred by cna() to condition().
irrigate.cna1 &lt;- cna(d.irrigate, ordering = "A, R, L &lt; F, C &lt; W", con = .9)
condition(msc(irrigate.cna1)$condition, irrigate.ct)

# Pass atomic solution formulas inferred by cna() to condition().
irrigate.cna1 &lt;- cna(d.irrigate, ordering = "A, R, L &lt; F, C &lt; W", con = .9)
condition(asf(irrigate.cna1)$condition, irrigate.ct)

# Group by outcome.
irrigate.cna1.msc &lt;- condition(msc(irrigate.cna1)$condition, irrigate.ct)
group.by.outcome(irrigate.cna1.msc)

irrigate.cna2 &lt;- cna(d.irrigate, con = .9)
irrigate.cna2a.asf &lt;- condition(asf(irrigate.cna2)$condition, irrigate.ct)
group.by.outcome(irrigate.cna2a.asf)

# Return as regular data frame.
as.data.frame(irrigate.cna2a.asf)

# Add data.
(irrigate.cna2b.asf &lt;- condition(asf(irrigate.cna2)$condition, irrigate.ct, 
                                     add.data = TRUE))

# No spaces before and after "+".
options(spaces = c("&lt;-&gt;", "-&gt;" ))
irrigate.cna2b.asf

# No spaces at all.
options(spaces = NULL)
irrigate.cna2b.asf

# Restore the default spacing.
options(spaces = c("&lt;-&gt;", "-&gt;", "+"))

# Print only consistency and coverage scores.
print(irrigate.cna2a.asf, print.table = FALSE)
summary(irrigate.cna2a.asf)

# Print only 2 digits of consistency and coverage scores.
print(irrigate.cna2b.asf, digits = 2)

# Instead of a configuration table as output by configTable(), it is also possible to provide 
# a data frame as second input. 
condition("A*r + L*C", d.irrigate)
condition(c("A*r + L*C", "A*L -&gt; F", "C -&gt; A*R + C*l"), d.irrigate)
condition(c("A*r + L*C -&gt; W", "A*L*R -&gt; W", "A*R + C*l -&gt; F", "W*a -&gt; F"), d.irrigate)
          
          
# Fuzzy-set data from Emmenegger (2011) on the causes of high job security regulations
# ------------------------------------------------------------------------------------
# Compare the CNA solution for outcome JSR to the solution presented by Emmenegger
# S*R*v + S*L*R*P + S*C*R*P + C*L*P*v -&gt; JSR (p. 349), which he generated by fsQCA as
# implemented in the fs/QCA software, version 2.5.
jobsecurity.cna &lt;- cna(d.jobsecurity, outcome = "JSR", con = .97, cov= .77,
                         maxstep = c(4, 4, 15))
compare.sol &lt;- condition(c(asf(jobsecurity.cna)$condition, "S*R*v + S*L*R*P + S*C*R*P + 
                         C*L*P*v -&gt; JSR"), d.jobsecurity)
summary(compare.sol)
print(compare.sol, add.data = d.jobsecurity)
group.by.outcome(compare.sol)

# There exist even more high quality solutions for JSR.
jobsecurity.cna2 &lt;- cna(d.jobsecurity, outcome = "JSR", con = .95, cov= .8,
                          maxstep = c(4, 4, 15))
compare.sol2 &lt;- condition(c(asf(jobsecurity.cna2)$condition, "S*R*v + S*L*R*P + S*C*R*P + 
                         C*L*P*v -&gt; JSR"), d.jobsecurity)
summary(compare.sol2)
group.by.outcome(compare.sol2)


# Simulate multi-value data
# -------------------------
library(dplyr)
# Define the data generating structure.
groundTruth &lt;- "(A=2*B=1 + A=3*B=3 &lt;-&gt; C=1)*(C=1*D=2 + C=2*D=3 &lt;-&gt; E=3)"
# Generate ideal data on groundTruth.
fullData &lt;- allCombs(c(3, 3, 2, 3, 3))
idealData &lt;- ct2df(selectCases(groundTruth, fullData))
# Randomly add 15% inconsistent cases.
inconsistentCases &lt;- setdiff(fullData, idealData)
realData &lt;- rbind(idealData, inconsistentCases[sample(1:nrow(inconsistentCases), 
                                               nrow(idealData)*0.15), ])
# Determine model fit of groundTruth and its submodels. 
condition(groundTruth, realData)
condition("A=2*B=1 + A=3*B=3 &lt;-&gt; C=1", realData)
condition("A=2*B=1 + A=3*B=3 &lt;-&gt; C=1", realData, force.bool = TRUE)
condition("(C=1*D=2 + C=2*D=3 &lt;-&gt; E=3)", realData)
condition("(C=1*D=2 + C=2*D=3 &lt;-&gt; E=3)", realData, rm.parentheses = TRUE)
condition("(C=1*D=2 +!(C=2*D=3 + A=1*B=1) &lt;-&gt; E=3)", realData)
# Manually calculate unique coverages, i.e. the ratio of an outcome's instances
# covered by individual msc alone (for details on unique coverage cf.
# Ragin 2008:63-68).
summary(condition("A=2*B=1 * -(A=3*B=3) &lt;-&gt; C=1", realData)) # unique coverage of A=2*B=1
summary(condition("-(A=2*B=1) * A=3*B=3 &lt;-&gt; C=1", realData)) # unique coverage of A=3*B=3

# Note that expressions must feature factor VALUES contained in the data, they may not 
# contain factor NAMES. The following calls produce errors.
condition("C*D &lt;-&gt; E", realData)
condition("A=2*B=1 + C=23", realData)
# In case of mv expressions, negations of factor values must be written with brackets.
condition("!(A=2)", realData)
# The following produces an error.
condition("!A=2", realData)
</code></pre>


</div>