<div class="container">

<table style="width: 100%;"><tr>
<td>multiNode.getNodeRanks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate multi-node node rankings ("adaptive" walk)</h2>

<h3>Description</h3>

<p>This function calculates the node rankings starting from a given node in a
subset of nodes in a given network, G.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multiNode.getNodeRanks(S,G,p1,thresholdDiff,adj_mat,num.misses=NULL,
                                verbose=FALSE,out_dir="",useLabels=FALSE,
                                coords=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>- A character vector of the node names for the subset of nodes you
want to encode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>- A list of probabilities with list names being the node names of
the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>- The probability that is preferentially distributed between
network nodes by the probability diffusion algorithm based
solely on network connectivity. The remaining probability, 1-p1,
is uniformally distributed between network nodes, regardless of
connectivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholdDiff</code></td>
<td>
<p>- When the probability diffusion algorithm exchanges
this amount or less between nodes, the algorithm 
returns up the call stack.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj_mat</code></td>
<td>
<p>- The adjacency matrix that encodes the edge weights for the
network, G.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.misses</code></td>
<td>
<p>- The number of "misses" the network walker will tolerate
before switching to fixed length codes for remaining
nodes to be found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>- If TRUE, print statements will execute as progress is made.
Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out_dir</code></td>
<td>
<p>- If specified, a image sequence will generate in the
output directory specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useLabels</code></td>
<td>
<p>- If TRUE, node names will display next to their respective
nodes in the network. If FALSE, node names will not
display. Only relevant if out_dir is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>- The x and y coordinates for each node in the network, to
remain static between images.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>ranks - A list of character vectors of node names in the order they
were drawn by the probability diffusion algorithm, from each starting node
in S.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Read in any network via its adjacency matrix
adj_mat=rbind(c(0,1,2,0,0,0,0,0,0), #A's neighbors
                c(1,0,3,0,0,0,0,0,0), #B's neighbors
                c(2,3,0,0,1,0,0,0,0), #C's neighbors
                c(0,0,0,0,0,0,1,1,0), #D's neighbors
                c(0,0,1,0,0,1,0,0,0), #E's neighbors
                c(0,0,0,0,1,0,0,0,0), #F's neighbors
                c(0,0,0,1,0,0,0,1,0), #G's neighbors
                c(0,0,0,1,0,0,1,0,0), #H's neighbors
                c(0,0,0,0,0,0,0,0,0) #I's neighbors
                )
rownames(adj_mat)=c("A","B","C","D","E","F","G","H","I")
colnames(adj_mat)=c("A","B","C","D","E","F","G","H","I")
G=vector(mode="list", length=ncol(adj_mat))
names(G)=colnames(adj_mat)
S=names(G)[seq_len(3)]
ranks=multiNode.getNodeRanks(S, G, p1=0.9, thresholdDiff=0.01, adj_mat)
</code></pre>


</div>