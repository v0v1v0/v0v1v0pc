<div class="container">

<table style="width: 100%;"><tr>
<td>rankBySlidingWindow</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine the norm scores of the participants by sliding window</h2>

<h3>Description</h3>

<p>The function retrieves all individuals in the predefined age range (x +/- width/2)
around each case and ranks that individual based on this individually drawn sample.
This function can be directly used with a continuous age variable in order to avoid
grouping. When collecting data on the basis of a continuous age variable, cases
located far from the mean age of the group receive distorted percentiles when building
discrete groups and generating percentiles with the traditional approach. The distortion
increases with distance from the group mean and this effect can be avoided by the
sliding window. Nonetheless, please ensure, that the optional grouping variable in fact
represents the correct mean age of the respective age groups, as this variable is
later on used for displaying the manifest data in the percentile plots.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rankBySlidingWindow(
  data = NULL,
  age = "age",
  raw = "raw",
  weights = NULL,
  width,
  method = 4,
  scale = "T",
  descend = FALSE,
  descriptives = TRUE,
  nGroup = 0,
  group = NA,
  na.rm = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data.frame with norm sample data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>age</code></td>
<td>
<p>the continuous age variable. Setting 'age' to FALSE inhibits computation of
powers of age and the interactions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>name of the raw value variable (default 'raw')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Vector or variable name in the dataset with weights for each individual case. It can be used
to compensate for moderate imbalances due to insufficient norm data stratification. Weights should be numerical
and positive. It can be resource intense when applied to the sliding window. Please use the 'computeWeights' function for this purpose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>the width of the sliding window</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Ranking method in case of bindings, please provide an index,
choosing from the following methods: 1 = Blom (1958), 2 = Tukey (1949),
3 = Van der Warden (1952), 4 = Rankit (default), 5 = Levenbach (1953),
6 = Filliben (1975), 7 = Yu &amp; Huang (2001)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>type of norm scale, either T (default), IQ, z or percentile (= no
transformation); a double vector with the mean and standard deviation can as well,
be provided f. e. c(10, 3) for Wechsler scale index points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>descend</code></td>
<td>
<p>ranking order (default descent = FALSE): inverses the
ranking order with higher raw scores getting lower norm scores; relevant
for example when norming error scores, where lower scores mean higher
performance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>descriptives</code></td>
<td>
<p>If set to TRUE (default), information in n, mean, median and
standard deviation per group is added to each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nGroup</code></td>
<td>
<p>If set to a positive value, a grouping variable is created with the desired number of
equi distant groups, named by the group mean age of each group. It creates the
column 'group' in the data.frame and in case, there is already one with that name,
overwrites it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Optional parameter for providing the name of the grouping variable (if present; overwritten
if ngroups is used)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>remove values, where the percentiles could not be estimated,
most likely happens in the context of weighting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>set to TRUE to suppress messages</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In case of bindings, the function uses the medium rank and applies the algorithms
already described in the <code>rankByGroup</code> function. At the upper and lower end of the
data sample, the sliding stops and the sample is drawn from the interval min + width and
max - width, respectively.
</p>


<h3>Value</h3>

<p>the dataset with the individual percentiles and norm scores
</p>


<h3>Remarks on using covariates</h3>

<p>So far the inclusion of a binary covariate is experimental and far from optimized.
The according variable name has to be specified in the ranking procedure
and the modeling includes this in the further process. At the moment, during ranking
the data are split into the according degrees of the covariate and the ranking is done
separately. This may lead to small sample sizes. Please take care to have enough cases in each combination. Additionally,
covariates can lead to unstable modeling solutions. The question, if it is really
reasonable to include covariates when norming a test is a decision beyond the pure data
modeling. Please use with care or alternatively split the dataset into the two groups
beforehand and model them separately.
</p>
<p>The functions <code>rankBySlidingWindow</code>, <code>rankByGroup</code>, <code>bestModel</code>,
<code>computePowers</code> and <code>prepareData</code> are usually not called directly, but accessed
through other functions like <code>cnorm</code>.
</p>


<h3>See Also</h3>

<p>rankByGroup, computePowers, computeWeights, weighted.rank, weighted.quantile
</p>
<p>Other prepare: 
<code>computePowers()</code>,
<code>prepareData()</code>,
<code>rankByGroup()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Transformation using a sliding window
data.elfe2 &lt;- rankBySlidingWindow(relfe, raw = "raw", age = "group", width = 0.5)

# Comparing this to the traditional approach should give us exactly the same
# values, since the sample dataset only has a grouping variable for age
data.elfe &lt;- rankByGroup(elfe, group = "group")
mean(data.elfe$normValue - data.elfe2$normValue)

## End(Not run)
</code></pre>


</div>