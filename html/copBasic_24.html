<div class="container">

<table style="width: 100%;"><tr>
<td>copBasic.fitpara</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Single or Multi-Parameter Optimization Engine (Beta Version)</h2>

<h3>Description</h3>

<p>An example of a general implementation of a parameter optimization scheme using core features of the <span class="pkg">copBasic</span> package. Because of the general complexity of the objectives for this function, the interface shown here is considered an “beta version” and nomenclature is subject to possibly sweeping changes in the future.
</p>


<h3>Usage</h3>

<pre><code class="language-R">copBasic.fitpara.beta(uv=NULL, popstat=NULL, statf=NULL, cop=NULL,
                      paradim=1, interval=NULL, par.init=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>uv</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> two column <code>matrix</code> or <code>data.frame</code> of a sample of nonexceedance probabilities <code class="reqn">u</code> and <code class="reqn">v</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popstat</code></td>
<td>
<p>The population statistic(s) that will be used if <code>uv</code> is <code>NULL</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statf</code></td>
<td>
<p>A function responsible at the minimum for computation of the theoretical values of the population statistic(s) that the optimization will revolve around; This function, if supporting an <code>as.sample</code> interface (<em>e.g.</em> <code>hoefCOP</code>) and if <code>uv</code> has been provided, will be dispatched to compute the population statistic(s);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function that is passed along to <code>statf</code> though of course the <code>statf</code> function can decide whether to use this argument or not;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paradim</code></td>
<td>
<p>The dimension of the parameters. In reality, the default triggers uni-dimensional root solving using the <code>uniroot()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> or otherwise the <code>optim()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is used for multi-dimensional minimization with subtle changes in setup (see source code). Alternative logic could be have been used but it is felt that this is the most logical for future adaptations;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>The <code>interval</code> argument by the same name for the <code>uniroot()</code> function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.init</code></td>
<td>
<p>The initial parameter vector for the <code>optim()</code> function; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of the values for the parameter variable is returned
</p>


<h3>Note</h3>

<p><em>One-Parameter Optimization</em>—A demonstration of one-dimensional parameter optimimization using the <em>Gini Gamma</em> (<code>giniCOP</code>), which is a measure of bivariate association. There is no native support for Gini Gamma (and most of the other measures of association) in regards to being a parameter estimator at the copula function interface level in <span class="pkg">copBasic</span>. (A converse example is one provided internally by the <code>GHcop</code> copula.)
</p>
<pre>
  set.seed(24); n &lt;- 230 # sample size to draw from Galambos copula but a
  # different copula was chosen for the fitting.
  sampleUV &lt;- simCOP(n=n, cop=GLcop, para=1.5) # a random sample
  para &lt;- copBasic.fitpara.beta(uv=sampleUV, statf=giniCOP,
                                interval=c(.1,200), cop=HRcop) # 1.959521
</pre>
<p><em>Three-Parameter Optimization</em>—A demonstration of multi-dimensional parameter optimimization using the Gini Gamma (<code>giniCOP</code>), <em>Nu-Skew</em> (<code>nuskewCOP</code>), and <em>Nu-Star</em> (<code>nustarCOP</code>). This is substantially more complicated to implement. The <em>Hüsler–Reiss copula</em> (<code>HRcop</code>) is chosen both as part of the sample simulation for the study as well as the copula as part of the modeling.  Using composition by the <code>composite1COP</code>, first establish a parent three parameter copula and simulate from it to create a bivariate sample in <code>sampleUV</code> that will be used for demonstration. A standard normal variate graphic of the simulation is generated by <code>simCOP</code> as well—later, additional results will be superimposed.
</p>
<pre>
  n &lt;- 610; set.seed(1999) # Seed value will be used again (see below)
  pop.para &lt;- list(cop1=HRcop, para1=4, alpha=0.14, beta=0.35)
  sampleUV &lt;- simCOP(n=n, cop=composite1COP, para=pop.para, col=3, snv=TRUE)
</pre>
<p>A custom objective function <code>objfunc</code> to serve as the <code>statf</code> for the <code>copBasic.fitpara.beta</code> call. The objective function has the <code>as.sample</code> interface (<em>e.g.</em> <code>giniCOP</code>) implemented for sample estimation. The most subtle feature of function presumably is the use of the <code>pnorm()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> for the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> parameters to keep each parameter in the range <code class="reqn">\alpha, \beta \in (0,1)</code>. Another subtly, which affects the choice of other copulas from <code>HRcop</code>, is how the parameter range of <code class="reqn">\Theta</code> (the <code>para[1]</code> variable) is controlled—here the parameter remains untransformed but the lower domain edge is truncated by the return of infinity (<code>return(Inf)</code>). The <code>getstat</code> argument is only for short circuiting the objective so that <code>objfunc</code> can be used to compute the three statistics after the optimal parameters are found.
</p>
<pre>
  "objfunc" &lt;- function(para, stat=NA, as.sample=FALSE, getstat=FALSE, ...) {
      if(as.sample) {
         return(c(  giniCOP(para=para, as.sample=TRUE),
                  nuskewCOP(para=para, as.sample=TRUE),
                  nustarCOP(para=para, as.sample=TRUE)))
      }
      para[1]   &lt;- ifelse(para[1] &lt; 0, return(Inf), para[1]) # edge check
      para[2:3] &lt;-  pnorm(para[2:3]) # detransform
      para &lt;- list(cop1=HRcop, para1=para[1], alpha=para[2], beta=para[3])
      hp &lt;- c(  giniCOP(composite1COP, para),
              nuskewCOP(composite1COP, para),
              nustarCOP(composite1COP, para))
      if(getstat) return(hp) # short circuit to get the statistics out
      dv &lt;- stat; dv[dv == 0] &lt;- 1 # changing dv "adapts" the error to
      return(sqrt(sum(((stat-hp)/dv)^2))) # trap division by zero
  }
</pre>
<p>The parameter estimation proceeds in the following code. The sample statistics (or <code>target.stats</code>) are computed and subsequently passed to the optimization using the <code>popstat</code> argument. Notice also the use of the <code>qnorm()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> to transform the initial guess <code class="reqn">\alpha = \beta = 1/2</code> into a domain more easily handled by the optimizer (<code>optim()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>). The transformed optimal parameters are computed, and then the values of the three statistics for the fit are computed. Lastly, a <span class="pkg">copBasic</span> parameter object <code>fit.para</code> is created, which can be used for later comparisons.
</p>
<pre>
  txt &lt;- c("GiniGamma", "NuSkew", "NuStar")
  target.stats &lt;- objfunc(sampleUV, as.sample=TRUE); names(target.stats) &lt;- txt
  raw.fit.para &lt;- copBasic.fitpara.beta(popstat=target.stats, statf=objfunc,
         par.init=c(1, qnorm(0.5), qnorm(0.5)), cop=composite1COP, paradim=3)
  fit.stats &lt;- objfunc(raw.fit.para, getstat=TRUE); names(fit.stats) &lt;- txt
  fit.para &lt;- list(cop1=HRcop, para1=raw.fit.para[1],
                   alpha=pnorm(raw.fit.para[2]), beta=pnorm(raw.fit.para[3]))
</pre>
<p>The optimization is completed. It is informative to see what the simulation of the fitted copula looks like. Note: this particular example suffers from identifiability problems between the parameters—meaning that local minima exist or that satisfactory solutions using different parameters than used to generate the random sample can occur. The same seed is used so that one-to-one comparison of points can visually be made with the <code>simCOP</code> function call.
</p>
<pre>
  set.seed(1999) # This value will be used again (see below)
  sampleUV &lt;- simCOP(n=n, cop=composite1COP, para=fit.para,
                ploton=FALSE, pch=16, cex=0.5, col=2, snv=TRUE) # red dots
</pre>
<p>The visual comparison is qualitative. The tabular comparison of the sample statistics to those of the fitted model shows that perhaps an acceptable local minima has been attained in terms of “fit” but the subsequent comparison of the parameters of the population used to generate the sample and those of the fitted model seemingly depart substantially in the <code class="reqn">\alpha \rightarrow 0</code> parameter of the copula composition. The tail dependency parameters are similar, but further goodness-of-fit check is not made.
</p>
<pre>
                       #   GiniGamma        NuSkew       NuStar
  print(target.stats)  #   0.5219027    -0.1940361    0.6108319
  print(fit.stats)     #   0.5182858    -0.1938848    0.6159566

                          # Parameter  Alpha       Beta
  print(ls.str(pop.para)) #      4.00   0.14      0.350  # given
  print(ls.str(fit.para)) #     11.2    0.187     0.427  # one solution

                                               # Tail Dependency Parameters
  taildepCOP(cop=composite1COP, para=pop.para) # lower=0 : upper=0.5838
  taildepCOP(cop=composite1COP, para=fit.para) # lower=0 : upper=0.5714(est.)
</pre>
<p>The demonstration ends with the comparison of the two asymmetrical density contours.
</p>
<pre>
  densityCOPplot(cop=composite1COP, para=pop.para, contour.col=3)
  densityCOPplot(cop=composite1COP, para=fit.para, contour.col=2,
                                    ploton=FALSE)
</pre>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>Examples</h3>

<pre><code class="language-R"># See the Note section
</code></pre>


</div>