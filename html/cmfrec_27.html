<div class="container">

<table style="width: 100%;"><tr>
<td>predict.cmfrec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict entries in the factorized 'X' matrix</h2>

<h3>Description</h3>

<p>Predict entries in the 'X' matrix according to the model
at the combinations [row,column] given by the entries in
'user' and 'item' (e.g. passing 'user=c(1,2,3), item=c(1,1,1)' will predict
X[1,1], X[2,1], X[3,1]).
</p>
<p>Alternatively, might pass a sparse matrix, in which case it will make
predictions for all of its non-missing entries.
</p>
<p>Invalid combinations (e.g. rows and columns outside of the range of 'X' to
which the model was fit) will be filled with global mean plus biases if applicable
for 'CMF_explicit', and with NAs for the other models.
</p>
<p>For example usage, see the main section fit_models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cmfrec'
predict(object, user, item = NULL, nthreads = object$info$nthreads, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A collective matrix factorization model from this package - see
fit_models for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user</code></td>
<td>
<p>The user IDs for which to make predictions. If 'X' to which the model
was fit was a 'data.frame', should pass IDs matching to the first column of 'X'
(the user indices, should be a character vector),
otherwise should pass row numbers for 'X', with numeration
starting at 1 (should be an integer vector).
</p>
<p>If passing a single entry for 'user' and 'item' has more entries, will
predict all the entries in 'item' for that single 'user.'
</p>
<p>Alternatively, might instead pass a sparse matrix in COO/triplets formats,
for which the <b>non-missing</b> entries will be predicted, in which case it
its not necessary to pass 'item'.
</p>
<p>If passing a sparse matrix, can be from package 'Matrix' (class 'dgTMatrix' or 'ngTMatrix')
or from package 'SparseM' (class 'matrix.coo'). If using the package 'softImpute',
its objects of class 'incomplete' might be convertable to 'Matrix' objects through
e.g. 'as(as(X, "TsparseMatrix"), "nMatrix")'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>The item IDs for which to make predictions - see the documentation
about 'user' for details about the indexing.
</p>
<p>If passing a single entry for 'item' and 'user' has more entries, will
predict all the entries in 'user' for that single 'item'.
</p>
<p>If passing a sparse matrix as 'user', 'item' will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector with the predicted values at the requested combinations.
If the 'user' passed was a sparse matrix, and it was not of class 'ngTMatrix',
will instead return a sparse matrix of the same format, with the non-missing entries
set to the predicted values.
</p>


<h3>See Also</h3>

<p>predict_new topN
</p>


</div>