<div class="container">

<table style="width: 100%;"><tr>
<td>wrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wrapper functions for some previous methods</h2>

<h3>Description</h3>

<p>These functions provide an uniform interface to three existing methods: SVA, RUV, LEAPP
The wrapper functions transform the data into desired forms and call the corresponding functions in the package
sva, ruv, leapp
</p>


<h3>Usage</h3>

<pre><code class="language-R">sva.wrapper(
  formula,
  X.data = NULL,
  Y,
  r,
  sva.method = c("irw", "two-step"),
  B = 5
)

ruv.wrapper(
  formula,
  X.data = NULL,
  Y,
  r,
  nc,
  lambda = 1,
  ruv.method = c("RUV2", "RUV4", "RUVinv")
)

leapp.wrapper(
  formula,
  X.data = NULL,
  Y,
  r,
  search.tuning = F,
  ipod.method = c("hard", "soft")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula indicating the known covariates including both primary variables and nuisance variables, which are seperated by <code>|</code>. The variables before <code>|</code> are primary variables and the variables after <code>|</code> are nuisance variables. It's OK if there is no nuisance variables, then <code>|</code> is not needed and <code>formula</code> becomes a typical formula with all the covariates considered primary. When there is confusion about where the intercept should be put, <code>cate</code> will include it in X.nuis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.data</code></td>
<td>
<p>the data frame used for <code>formula</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>outcome, n*p matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of latent factors, can be estimated using the function <code>est.confounder.num</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sva.method</code></td>
<td>
<p>parameter for <code>sva</code>.
whether to use an iterative reweighted algorithm (irw) or a two-step algorithm (two-step).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>parameter for <code>sva</code>. the number of iterations of the irwsva algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>parameter for ruv functions: position of the negative controls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>parameter for <code>RUVinv</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ruv.method</code></td>
<td>
<p>either using <code>RUV2</code>, <code>RUV4</code> or
<code>RUVinv</code> functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search.tuning</code></td>
<td>
<p>logical parameter for <code>leapp</code>, whether using BIC to search for tuning parameter of IPOD.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ipod.method</code></td>
<td>
<p>parameter for <code>leapp</code>. "hard": hard thresholding in the IPOD algorithm;
"soft": soft thresholding in the IPOD algorithm</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>beta.p.values</code> returned is a length <code>p</code> vector, each for the overall effects of all the primary variables.
</p>
<p>Only 1 variable of interest is allowed for <code>leapp.wrapper</code>. The method can be slow.
</p>


<h3>Value</h3>

<p>All functions return <code>beta.p.value</code> which are the p-values after adjustment.
For the other returned objects, refer to cate for their meaning.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## this is the simulation example in Wang et al. (2015).
n &lt;- 100
p &lt;- 1000
r &lt;- 2
set.seed(1)
data &lt;- gen.sim.data(n = n, p = p, r = r,
                     alpha = rep(1 / sqrt(r), r),
                     beta.strength = 3 * sqrt(1 + 1) / sqrt(n),
                     Gamma.strength = c(seq(3, 1, length = r)) * sqrt(p),
                     Sigma = 1 / rgamma(p, 3, rate = 2),
                     beta.nonzero.frac = 0.05)
X.data &lt;- data.frame(X1 = data$X1)
sva.results &lt;- sva.wrapper(~ X1 | 1, X.data, data$Y,
                           r = r, sva.method = "irw")
ruv.results &lt;- ruv.wrapper(~ X1 | 1, X.data, data$Y, r = r,
                           nc = sample(data$beta.zero.pos, 30), ruv.method = "RUV4")
leapp.results &lt;- leapp.wrapper(~ X1 | 1, X.data, data$Y, r = r)
cate.results &lt;- cate(~ X1 | 1, X.data, data$Y, r = r)

## p-values after adjustment
par(mfrow = c(2, 2))
hist(sva.results$beta.p.value)
hist(ruv.results$beta.p.value)
hist(leapp.results$beta.p.value)
hist(cate.results$beta.p.value)

## type I error
mean(sva.results$beta.p.value[data$beta.zero.pos] &lt; 0.05)

## power
mean(sva.results$beta.p.value[data$beta.nonzero.pos] &lt; 0.05)

## false discovery proportion for sva
discoveries.sva &lt;- which(p.adjust(sva.results$beta.p.value, "BH") &lt; 0.2)
fdp.sva &lt;- length(setdiff(discoveries.sva, data$beta.nonzero.pos)) / max(length(discoveries.sva), 1)
fdp.sva

</code></pre>


</div>