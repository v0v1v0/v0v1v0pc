<div class="container">

<table style="width: 100%;"><tr>
<td>score_and_hessian_matrix_functions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Score and hessian matrix based on the estimating functions.</h2>

<h3>Description</h3>

<p>Functions to compute the score and hessian matrices of the parameters
based on the estimating functions, under the GLM and AFT setting for
the analysis of a normally-distributed or censored time-to-event
primary outcome. The score and hessian matrices are further used in
the functions <code>sandwich_se</code>, <code>ciee</code> and
<code>ciee_loop</code> to obtain robust sandwich error estimates of the
parameter estimates of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the GLM setting and
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the AFT setting.
</p>


<h3>Usage</h3>

<pre><code class="language-R">deriv_obj(setting = "GLM", logL1 = NULL, logL2 = NULL, Y = NULL,
  X = NULL, K = NULL, L = NULL, C = NULL, estimates = NULL)

scores(derivobj = NULL)

hessian(derivobj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether the matrices are computed under the GLM or AFT setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logL1</code></td>
<td>
<p>Expression of the function <code>logL1</code> generated by
the <code>est_funct_expr</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logL2</code></td>
<td>
<p>Expression of the function <code>logL2</code> generated by
the <code>est_funct_expr</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric input vector for the exposure variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>Numeric input vector for the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimates</code></td>
<td>
<p>Numeric input vector with point estimates of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2,</code>
<code class="reqn">\alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the GLM setting and of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the AFT setting. Under the AFT setting,
<code>estimates</code> must also contain the mean of the estimated
true survival times <code>"y_adj_bar"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivobj</code></td>
<td>
<p>Output of the <code>deriv_obj</code> function used as input in
the <code>scores</code> and <code>hessian</code> functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the computation of the score and hessian matrices, first, the help function
<code>deriv_obj</code> is used. In a first step, the expression of all first
and second derivatives of the parameters is computed using the expressions of
<code>logL1</code> and <code>logL2</code> from the <code>est_funct_expr</code> as input.
Then, the numerical values of all first and second derivatives are obtained
for the observed data <code>Y</code>, <code>X</code>, <code>K</code>, <code>L</code> (and <code>C</code> under
the AFT setting) and point estimates (<code>estimates</code>) of the parameters,
for all observed individuals.
</p>
<p>Second, the functions <code>scores</code> and <code>hessian</code> are used
to extract the relevant score and hessian matrices with respect to <code>logL1</code>
and <code>logL2</code> from the output of <code>deriv_obj</code> and piece them together.
For further details, see the vignette.
</p>


<h3>Value</h3>

<p>The <code>deriv_obj</code> function returns a list with
objects <code>logL1_deriv</code>, <code>logL2_deriv</code> which
contain the score and hessian matrices based on <code>logL1</code>,
<code>logL2</code>, respectively.
</p>
<p>The <code>scores</code> function returns the <code class="reqn">(n \times 8)</code>
score matrix.
</p>
<p>The <code>hessian</code> function returns the <code class="reqn">(n \times 8 \times 8)</code>
hessian matrix.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Generate data including Y, K, L, X under the GLM setting
dat &lt;- generate_data(setting = "GLM")

# Obtain estimating functions' expressions
estfunct &lt;- est_funct_expr(setting = "GLM")

# Obtain point estimates of the parameters
estimates &lt;- get_estimates(setting = "GLM", Y = dat$Y, X = dat$X,
                           K = dat$K, L = dat$L)

# Obtain matrices with all first and second derivatives
derivobj &lt;- deriv_obj(setting = "GLM", logL1 = estfunct$logL1,
                      logL2 = estfunct$logL2, Y = dat$Y, X = dat$X,
                      K = dat$K, L = dat$L, estimates = estimates)
names(derivobj)
head(derivobj$logL1_deriv$gradient)

# Obtain score and hessian matrices
scores(derivobj)
hessian(derivobj)

</code></pre>


</div>