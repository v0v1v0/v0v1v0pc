<div class="container">

<table style="width: 100%;"><tr>
<td>mantel.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform one or more Mantel permutation tests.</h2>

<h3>Description</h3>

<p>Perform correlation tests between pairs of distance matrices. The Mantel
test is different from classical correlation tests (such as those
implemented by <code>cor.test</code>) in that the null distribution
(and significance level) are obtained through randomisation. The null
distribution is generated by shuffling the locations (matrix rows and
columns) of one of the matrices to calculate an empirical null distribution
for the given data set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mantel.test(x, y, ...)

## Default S3 method:
mantel.test(x, y, plot = FALSE, method = c("spearman",
  "kendall", "pearson"), trials = 9999, omitzerodistances = FALSE, ...)

## S3 method for class 'formula'
mantel.test(x, y, groups = NULL,
  stringdistfun = utils::adist, meaningdistfun = hammingdists, ...)

## S3 method for class 'list'
mantel.test(x, y, plot = FALSE, ...)

## S3 method for class 'mantel'
plot(x, xlab = "generation", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a formula, distance matrix, or list of distance matrices (see below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a data frame, distance matrix, or list of distance matrices of the
same length as <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments which are passed on to the default method (in
particular <code>plot</code>, <code>method</code>, <code>trials</code> and <code>omitzerodistances</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical: immediately produce a plot of the test results (default:
<code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>correlation coefficient to be computed. Passed on to
<code>cor</code>, so one of <code>"spearman"</code>, <code>"kendall"</code>, or, inadvisable
in the case of ties: <code>"pearson"</code>. Following Dietz (1983), <code>"spearman"</code> is
used as a default that is both powerful and robust across different
distance measures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trials</code></td>
<td>
<p>integer: maximum number of random permutations to be computed
(see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omitzerodistances</code></td>
<td>
<p>logical: if <code>TRUE</code>, the calculation of the
correlation coefficient omits pairs of off-diagonal cells which contain a
0 in the <em>second</em> distance matrix argument. (For the formula
interface, this is the matrix which specifies the meaning distances.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>when <code>x</code> is a formula: column name by which the data in <code>y</code> is
split into separate data sets to run several Mantel tests on</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stringdistfun</code></td>
<td>
<p>when <code>x</code> is a formula: edit distance function used to
compute the distance matrix from the specified string column. Supports any
edit distance function that returns a distance matrix from a vector or
list of character strings. Default is Levenshtein distance
(<code>adist</code>), other options from this package include
<code>normalisedlevenshteindists()</code> and <code>orderinsensitivedists()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meaningdistfun</code></td>
<td>
<p>when <code>x</code> is a formula: meaning distance function used
to compute the distance matrix from the specified meaning columns.
Defaults to Hamming distances between meanings (<code>hammingdists()</code>), custom
meaning functions can be created easily using
<code>wrap.meaningdistfunction()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>the x axis label used when plotting the result of several Mantel
tests next to each other</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the number of possible permutations of the matrices is reasonably close
to the number of permutations specified by the <code>trials</code> parameter, a
deterministic enumeration of all the permutations will be carried out
instead of random sampling: such a deterministic test will return an exact
p-value.
</p>
<p><code>plot()</code> called on a data frame of class <code>mantel</code> plots a
visualisation of the test results (in particular, the distribution of
the permutated samples against the veridical correlation coefficient). If
the veridical correlation coefficient is plotted in blue it means
that it was higher than all other coefficients generated by random
permutations of the data. When the argument contains the result of more than
one Mantel tests, a side-by-side boxplot visualisation shows the mean and
standard deviation of the randomised samples (see examples). Additional
parameters <code>...</code> to <code>plot()</code> are passed on to
<code>plot.default</code>.
</p>


<h3>Value</h3>

<p>A dataframe of class <code>mantel</code>, with one row per Mantel test carried
out, containing the following columns:
</p>

<dl>
<dt><code>method</code></dt>
<dd>
<p>Character string: type of correlation coefficient used</p>
</dd>
<dt><code>statistic</code></dt>
<dd>
<p>The veridical correlation coefficient between
the entries in the two distance matrices</p>
</dd>
<dt><code>rsample</code></dt>
<dd>
<p>A list of correlation coefficients calculated
from the permutations of the input matrices</p>
</dd>
<dt><code>mean</code></dt>
<dd>
<p>Average correlation coefficient produced by the permutations</p>
</dd>
<dt><code>sd</code></dt>
<dd>
<p>Standard deviation of the sampled correlation coefficients</p>
</dd>
<dt><code>p.value</code></dt>
<dd>
<p>Empirical p-value computed from the Mantel
test: let <code>ngreater</code> be the number of correlation coefficients
in <code>rsample</code> greater than or equal to <code>statistic</code>, then
<code>p.value</code> is <code>(ngreater+1)/(length(rsample)+1</code></p>
</dd>
<dt><code>p.approx</code></dt>
<dd>
<p>The theoretical p-value that would correspond
to the standard <code>z</code> score as calculated above.</p>
</dd>
<dt><code>is.unique.max</code></dt>
<dd>
<p>Logical, <code>TRUE</code> iff the veridical
correlation coefficient is greater than any of the coefficients
calculated for the permutations. If this is true, then
<code>p.value == 1 / (length(rsample)+1)</code></p>
</dd>
</dl>
<p>Multiple <code>mantel</code> objects can easily be combined by calling
<code>rbind(test1, test2, ...)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Perform Mantel correlation test on two distance
matrices. The distance matrices can either be of type
<code>dist</code>, plain R matrices or any object that can be
interpreted by <code>check.dist</code>. The order of the two matrices does
not matter unless <code>omitzerodistances = TRUE</code>, in which case cells with
a 0 in the <em>second</em> matrix are omitted from the calculation of the
correlation coefficient. For consistency it is therefore recommended to
always pass the string distance matrix first, meaning distance matrix second.
</p>
</li>
<li> <p><code>formula</code>: This function can be called with raw experimental
result data frames, distance matrix calculation is taken care of internally.
<code>x</code> is a formula of the type <code>s ~ m1 + m2 + ...</code> where <code>s</code>
is the column name of the character strings in data frame or matrix <code>y</code>,
while <code>m1</code> etc. are the column names specifying the different meaning
dimensions. To calculate the respective distances, the function
<code>stringdistfun</code> is applied to the strings, <code>meaningdistfun</code> to the
meaning columns.
</p>
</li>
<li> <p><code>list</code>: When <code>x</code> is a list of distance matrices, and
<code>y</code> is either a single distance matrix or a list of distance matrices
the same length as <code>x</code>: runs a Mantel test for every pairwise
combination of distance matrices in <code>x</code> and <code>y</code> and returns a
<code>mantel</code> object with as many rows.
</p>
</li>
</ul>
<h3>References</h3>

<p>Dietz, E. J. 1983 “Permutation Tests for Association
Between Two Distance Matrices.” <em>Systematic Biology</em> 32 (1): 21-–26.
<a href="https://doi.org/10.1093/sysbio/32.1.21">https://doi.org/10.1093/sysbio/32.1.21</a>.
</p>
<p>North, B. V., D. Curtis and P. C. Sham. 2002 “A Note on the Calculation of
Empirical P Values from Monte Carlo Procedures.” <em>The American Journal of
Human Genetics</em> 71 (2): 439-–41. <a href="https://doi.org/10.1086/341527">https://doi.org/10.1086/341527</a>.
</p>


<h3>See Also</h3>

<p><code>cor</code>,
<code>adist</code>, <code>hammingdists</code>,
<code>normalisedlevenshteindists</code>,
<code>orderinsensitivedists</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># small distance matrix, Mantel test run deterministically
mantel.test(dist(1:7), dist(1:7))


## Not run: 
# run test on smallest distance matrix which requires a random
# permutation test, and plot it
plot(mantel.test(dist(1:8), dist(1:8), method="kendall"))

## End(Not run)

## Not run: 
# 2x2x2x2 design
mantel.test(hammingdists(enumerate.meaningcombinations(c(2, 2, 2, 2))),
  dist(1:16), plot=TRUE)

## End(Not run)

# using the formula interface in combination with a data frame:
print(data &lt;- cbind(word=c("aa", "ab", "ba", "bb"),
  enumerate.meaningcombinations(c(2, 2))))

mantel.test(word ~ Var1 + Var2, data)

## Not run: 
# pass a list of distance matrices as the first argument, but just one
# distance matrix as the second argument: this runs separate tests on
# the pairwise combinations of the first and second argument
result &lt;- mantel.test(list(dist(1:8), dist(sample(8:1)), dist(runif(8))),
  hammingdists(enumerate.meaningcombinations(c(2, 2, 2))))

# print the result of the three independently run permutation tests
print(result)

# show the three test results in one plot
plot(result, xlab="group")

## End(Not run)
</code></pre>


</div>