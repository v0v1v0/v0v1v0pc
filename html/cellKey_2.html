<div class="container">

<table style="width: 100%;"><tr>
<td>ck_class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 Class defining statistical tables that can be perturbed</h2>

<h3>Description</h3>

<p>This class allows to define statistical tables and perturb both
count and numerical variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ck_setup(x, rkey, dims, w = NULL, countvars = NULL, numvars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object coercible to a <code>data.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rkey</code></td>
<td>
<p>either a column name within <code>x</code> referring to a variable containing record keys
or a single integer(ish) number &gt; <code>5</code> that referns to the number of digits for record keys that
will be generated internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>a list containing slots for each variable that should be
tabulated. Each slot consists should be created/modified using <code>sdcHierarchies::hier_create()</code>,
<code>sdcHierarchies::hier_add()</code> and other functionality from package <code>sdcHierarchies</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>(character) a scalar character referring to a variable in <code>x</code> holding sampling
weights. If <code>w</code> is <code>NULL</code> (the default), all weights are assumed to be <code>1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>countvars</code></td>
<td>
<p>(character) an optional vector containing names of binary (0/1 coded)
variables withing <code>x</code> that should be included in the problem instance.
These variables can later be perturbed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numvars</code></td>
<td>
<p>(character) an optional vector of numerical variables that can later be tabulated.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Such objects are typically generated using <code>ck_setup()</code>.
</p>


<h3>Value</h3>

<p>A new <code>cellkey_obj</code> object. Such objects (internally) contain the fully computed
statistical tables given input microdata (<code>x</code>), the hierarchical definitionals (<code>dims</code>) as
well as the remaining inputs. Intermediate results are stored internally and can only be
modified / accessed via the exported public methods described below.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-cellkey_obj-new"><code>ck_class$new()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-perturb"><code>ck_class$perturb()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-freqtab"><code>ck_class$freqtab()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-numtab"><code>ck_class$numtab()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-measures_cnts"><code>ck_class$measures_cnts()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-measures_nums"><code>ck_class$measures_nums()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-allvars"><code>ck_class$allvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-cntvars"><code>ck_class$cntvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-numvars"><code>ck_class$numvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-hierarchy_info"><code>ck_class$hierarchy_info()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-mod_cnts"><code>ck_class$mod_cnts()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-mod_nums"><code>ck_class$mod_nums()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_freq"><code>ck_class$supp_freq()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_val"><code>ck_class$supp_val()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_cells"><code>ck_class$supp_cells()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_p"><code>ck_class$supp_p()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_pq"><code>ck_class$supp_pq()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_nk"><code>ck_class$supp_nk()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_cnts_get"><code>ck_class$params_cnts_get()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_cnts_set"><code>ck_class$params_cnts_set()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-reset_cntvars"><code>ck_class$reset_cntvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-reset_numvars"><code>ck_class$reset_numvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-reset_allvars"><code>ck_class$reset_allvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_nums_get"><code>ck_class$params_nums_get()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_nums_set"><code>ck_class$params_nums_set()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-summary"><code>ck_class$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-print"><code>ck_class$print()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-cellkey_obj-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new table instance
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$new(x, rkey, dims, w = NULL, countvars = NULL, numvars = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>an object coercible to a <code>data.frame</code></p>
</dd>
<dt><code>rkey</code></dt>
<dd>
<p>either a column name within <code>x</code> referring to a variable containing record keys
or a single integer(ish) number &gt; <code>5</code> that referns to the number of digits for record keys that
will be generated internally.</p>
</dd>
<dt><code>dims</code></dt>
<dd>
<p>a list containing slots for each variable that should be
tabulated. Each slot consists should be created/modified using <code>sdcHierarchies::hier_create()</code>,
<code>sdcHierarchies::hier_add()</code> and other functionality from package <code>sdcHierarchies</code>.</p>
</dd>
<dt><code>w</code></dt>
<dd>
<p>(character) a scalar character referring to a variable in <code>x</code> holding sampling
weights. If <code>w</code> is <code>NULL</code> (the default), all weights are assumed to be <code>1</code></p>
</dd>
<dt><code>countvars</code></dt>
<dd>
<p>(character) an optional vector containing names of binary (0/1 coded)
variables withing <code>x</code> that should be included in the problem instance.
These variables can later be perturbed.</p>
</dd>
<dt><code>numvars</code></dt>
<dd>
<p>(character) an optional vector of numerical variables that can later be tabulated.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>cellkey_obj</code> object. Such objects (internally) contain the fully computed
statistical tables given input microdata (<code>x</code>), the hierarchical definitionals (<code>dims</code>) as
well as the remaining inputs. Intermediate results are stored internally and can only be
modified / accessed via the exported public methods described below.
</p>


<hr>
<a id="method-cellkey_obj-perturb"></a>



<h4>Method <code>perturb()</code>
</h4>

<p>Perturb a count- or magnitude variable
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$perturb(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>name(s) of count- or magnitude variables that should be perturbed.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. Updated data can be accessed using other exported
methods like <code style="white-space: pre;">⁠$freqtab()⁠</code> or <code style="white-space: pre;">⁠$numtab()⁠</code>.
</p>


<hr>
<a id="method-cellkey_obj-freqtab"></a>



<h4>Method <code>freqtab()</code>
</h4>

<p>Extract results from already perturbed count variables as a
<code>data.table</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$freqtab(v = NULL, path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a vector of variable names for count variables. If <code>NULL</code>
(the default), the results are returned for all available count
variables. For variables that have not yet perturbed, columns
<code>puwc</code> and <code>pwc</code> are filled with <code>NA</code>.</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>if not <code>NULL</code>, a scalar character defining a (relative
or absolute) path to which the result table should be written. A <code>csv</code>
file will be generated and, if specified, <code>path</code> must have
".csv" as file-ending</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns a <code>data.table</code> containing all combinations of the dimensional variables in
the first n columns. Additionally, the following columns are shown:
</p>

<ul>
<li> <p><code>vname</code>: name of the perturbed variable
</p>
</li>
<li> <p><code>uwc</code>: unweighted counts
</p>
</li>
<li> <p><code>wc</code>: weighted counts
</p>
</li>
<li> <p><code>puwc</code>: perturbed unweighted counts or <code>NA</code> if <code>vname</code> was not yet perturbed
</p>
</li>
<li> <p><code>pwc</code>: perturbed weighted counts or <code>NA</code> if <code>vname</code> was not yet perturbed
</p>
</li>
</ul>
<hr>
<a id="method-cellkey_obj-numtab"></a>



<h4>Method <code>numtab()</code>
</h4>

<p>Extract results from already perturbed continuous variables
as a <code>data.table</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$numtab(v = NULL, mean_before_sum = FALSE, path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a vector of variable names of continuous variables. If <code>NULL</code>
(the default), the results are returned for all available numeric variables.</p>
</dd>
<dt><code>mean_before_sum</code></dt>
<dd>
<p>(logical); if <code>TRUE</code>, the perturbed values are adjusted
by a factor <code style="white-space: pre;">⁠((n+p))⁄n⁠</code> with
</p>

<ul>
<li> <p><code>n</code>: the original weighted cell value
</p>
</li>
<li> <p><code>p</code>: the perturbed cell value
</p>
</li>
</ul>
<p>This makes sense if the the accuracy of the variable mean is considered to be
more important than accuracy of sums of the variable. The default value is
<code>FALSE</code> (no adjustment is done)</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>if not <code>NULL</code>, a scalar character defining a (relative or absolute)
path to which the result table should be written. A <code>csv</code> file will be generated
and, if specified, <code>path</code> must have ".csv" as file-ending</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns a <code>data.table</code> containing all combinations of the
dimensional variables in the first n columns. Additionally, the following
columns are shown:
</p>

<ul>
<li> <p><code>vname</code>: name of the perturbed variable
</p>
</li>
<li> <p><code>uws</code>: unweighted sum of the given variable
</p>
</li>
<li> <p><code>ws</code>: weighted cellsum
</p>
</li>
<li> <p><code>pws</code>: perturbed weighted sum of the given cell or <code>NA</code> if <code>vname</code>
has not not perturbed
</p>
</li>
</ul>
<hr>
<a id="method-cellkey_obj-measures_cnts"></a>



<h4>Method <code>measures_cnts()</code>
</h4>

<p>Utility measures for perturbed count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$measures_cnts(v, exclude_zeros = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>name of a count variable for which utility measures
should be computed.</p>
</dd>
<dt><code>exclude_zeros</code></dt>
<dd>
<p>should empty (zero) cells in the original values
be excluded when computing distance measures</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns a <code>list</code> containing a set of utility
measures based on some distance functions. For a detailed description
of the computed measures, see <code>ck_cnt_measures()</code>
</p>


<hr>
<a id="method-cellkey_obj-measures_nums"></a>



<h4>Method <code>measures_nums()</code>
</h4>

<p>Utility measures for continuous variables (not yet implemented)
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$measures_nums(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>name of a continuous variable for which utility measures
should be computed.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>for (now) an empty list; In future versions of the package, the
Method will return utility measures for perturbed magnitude tables.
</p>


<hr>
<a id="method-cellkey_obj-allvars"></a>



<h4>Method <code>allvars()</code>
</h4>

<p>Names of variables that can be perturbed / tabulated
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$allvars()</pre></div>



<h5>Returns</h5>

<p>returns a <code>list</code> with the following two elements:
</p>

<ul>
<li> <p><code>cntvars</code>: character vector with names of available count
variables for perturbation
</p>
</li>
<li> <p><code>numvars</code>: character vector with names of available numerical
variables for perturbation
</p>
</li>
</ul>
<hr>
<a id="method-cellkey_obj-cntvars"></a>



<h4>Method <code>cntvars()</code>
</h4>

<p>Names of count variables that can be perturbed
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$cntvars()</pre></div>



<h5>Returns</h5>

<p>a character vector containing variable names
</p>


<hr>
<a id="method-cellkey_obj-numvars"></a>



<h4>Method <code>numvars()</code>
</h4>

<p>Names of continuous variables that can be perturbed
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$numvars()</pre></div>



<h5>Returns</h5>

<p>a character vector containing variable names
</p>


<hr>
<a id="method-cellkey_obj-hierarchy_info"></a>



<h4>Method <code>hierarchy_info()</code>
</h4>

<p>Information about hierarchies
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$hierarchy_info()</pre></div>



<h5>Returns</h5>

<p>a <code>list</code> (for each dimensional variable) with
information on the hierarchies. This may be used to restrict output tables to
specific levels or codes. Each list element is a <code>data.table</code> containing
the following variables:
</p>

<ul>
<li> <p><code>code</code>: the name of a code within the hierarchy
</p>
</li>
<li> <p><code>level</code>: number defining the level of the code; the higher the number,
the lower the hierarchy with <code>1</code> being the overall total
</p>
</li>
<li> <p><code>is_leaf</code>: if <code>TRUE</code>, this code is a leaf node which means no other codes
contribute to it
</p>
</li>
<li> <p><code>parent</code>: name of the parent code
</p>
</li>
</ul>
<hr>
<a id="method-cellkey_obj-mod_cnts"></a>



<h4>Method <code>mod_cnts()</code>
</h4>

<p>Modifications applied to count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$mod_cnts()</pre></div>



<h5>Returns</h5>

<p>a <code>data.table</code> containing modifications applied to count variables
</p>


<hr>
<a id="method-cellkey_obj-mod_nums"></a>



<h4>Method <code>mod_nums()</code>
</h4>

<p>Modifications applied to numerical variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$mod_nums()</pre></div>



<h5>Returns</h5>

<p>a <code>data.table</code> containing modifications applied to numerical variables
</p>


<hr>
<a id="method-cellkey_obj-supp_freq"></a>



<h4>Method <code>supp_freq()</code>
</h4>

<p>Identify sensitive cells based on minimum frequency rule
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_freq(v, n, weighted = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>a number defining the threshold. All cells <code style="white-space: pre;">⁠&lt;= n⁠</code> are considered as unsafe.</p>
</dd>
<dt><code>weighted</code></dt>
<dd>
<p>if <code>TRUE</code>, the weighted number of contributors to a cell are compared to
the threshold specified in <code>n</code> (default); else the unweighted number of contributors is used.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_val"></a>



<h4>Method <code>supp_val()</code>
</h4>

<p>Identify sensitive cells based on weighted or unweighted cell value
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_val(v, n, weighted = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>a number defining the threshold. All cells <code style="white-space: pre;">⁠&lt;= n⁠</code> are considered as unsafe.</p>
</dd>
<dt><code>weighted</code></dt>
<dd>
<p>if <code>TRUE</code>, the weighted cell value of variable <code>v</code> is compared to
the threshold specified in <code>n</code> (default); else the unweighted number is used.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_cells"></a>



<h4>Method <code>supp_cells()</code>
</h4>

<p>Identify sensitive cells based on their <code>names</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_cells(v, inp)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>inp</code></dt>
<dd>
<p>a <code>data.frame</code> where each colum represents a dimensional variable. Each row of
this input is then used to compute the relevant cells to be identified as sensitive where
<code>NA</code>-values are possible and used to match any characteristics of the dimensional variable.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_p"></a>



<h4>Method <code>supp_p()</code>
</h4>

<p>Identify sensitive cells based on the p%-rule rule. Please note that this rule
can only be applied to positive-only variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_p(v, p)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>a number defining a percentage between <code>1</code> and <code>99</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_pq"></a>



<h4>Method <code>supp_pq()</code>
</h4>

<p>Identify sensitive cells based on the pq-rule. Please note that this rule
can only be applied to positive-only variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_pq(v, p, q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>a number defining a percentage between <code>1</code> and <code>99</code>.</p>
</dd>
<dt><code>q</code></dt>
<dd>
<p>a number defining a percentage between <code>1</code> and <code>99</code>. This value must be larger than <code>p</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_nk"></a>



<h4>Method <code>supp_nk()</code>
</h4>

<p>Identify sensitive cells based on the nk-dominance rule. Please note that this rule
can only be applied to positive-only variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_nk(v, n, k)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>an integerish number <code style="white-space: pre;">⁠&gt;= 2⁠</code></p>
</dd>
<dt><code>k</code></dt>
<dd>
<p>a number defining a percentage between <code>1</code> and <code>99</code>. All cells to which the top <code>n</code>
contributers contribute more than <code style="white-space: pre;">⁠k%⁠</code> is considered unsafe</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-params_cnts_get"></a>



<h4>Method <code>params_cnts_get()</code>
</h4>

<p>Return perturbation parameters of count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_cnts_get()</pre></div>



<h5>Returns</h5>

<p>a named list in which each list-element contains the
active perturbation parameters for the specific count variable
defined by the list-name.
</p>


<hr>
<a id="method-cellkey_obj-params_cnts_set"></a>



<h4>Method <code>params_cnts_set()</code>
</h4>

<p>Set perturbation parameters for count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_cnts_set(val, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt>
<dd>
<p>a perturbation object created with <code>ck_params_cnts()</code></p>
</dd>
<dt><code>v</code></dt>
<dd>
<p>a character vector (or <code>NULL</code>). If <code>NULL</code> (the default),
the perturbation parameters provided in <code>val</code> are set for all
count variables; otherwise one may specify the names of
the count variables for which the parameters should be set.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-reset_cntvars"></a>



<h4>Method <code>reset_cntvars()</code>
</h4>

<p>reset results and parameters for already perturbed
count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$reset_cntvars(v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>if <code>v</code> equals <code>NULL</code> (the default), the results are reset
for all perturbed count variables; otherwise it is possible to specify
the names of already perturbed count variables.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code> or <code style="white-space: pre;">⁠$freqtab()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-reset_numvars"></a>



<h4>Method <code>reset_numvars()</code>
</h4>

<p>reset results and parameters for already perturbed
numerical variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$reset_numvars(v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>if <code>v</code> equals <code>NULL</code> (the default), the results are reset for all perturbed
numerical variables; otherwise it is possible to specify the names of already
perturbed continuous variables.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code> or <code style="white-space: pre;">⁠$numtab()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-reset_allvars"></a>



<h4>Method <code>reset_allvars()</code>
</h4>

<p>reset results and parameters for all already perturbed variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$reset_allvars()</pre></div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>, <code style="white-space: pre;">⁠$freqtab()⁠</code> or <code style="white-space: pre;">⁠$numtab()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-params_nums_get"></a>



<h4>Method <code>params_nums_get()</code>
</h4>

<p>Return perturbation parameters of continuous variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_nums_get()</pre></div>



<h5>Returns</h5>

<p>a named list in which each list-element contains the
active perturbation parameters for the specific continuous variable
defined by the list-name.
</p>


<hr>
<a id="method-cellkey_obj-params_nums_set"></a>



<h4>Method <code>params_nums_set()</code>
</h4>

<p>set perturbation parameters for continuous variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_nums_set(val, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt>
<dd>
<p>a perturbation object created with <code>ck_params_nums()</code></p>
</dd>
<dt><code>v</code></dt>
<dd>
<p>a character vector (or <code>NULL</code>); if <code>NULL</code> (the default), the
perturbation parameters provided in <code>val</code> are set for all continuous
variables; otherwise one may specify the names of the numeric variables for
which the parameters should be set.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">⁠$perturb()⁠</code>).
</p>


<hr>
<a id="method-cellkey_obj-summary"></a>



<h4>Method <code>summary()</code>
</h4>

<p>some aggregated summary statistics about perturbed variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$summary()</pre></div>



<h5>Returns</h5>

<p>invisible <code>NULL</code>
</p>


<hr>
<a id="method-cellkey_obj-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>prints information about the current table
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$print()</pre></div>



<h5>Returns</h5>

<p>invisible <code>NULL</code>
</p>




<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- ck_create_testdata()

# create some 0/1 variables that should be perturbed later
x[, cnt_females := ifelse(sex == "male", 0, 1)]
x[, cnt_males := ifelse(sex == "male", 1, 0)]
x[, cnt_highincome := ifelse(income &gt;= 9000, 1, 0)]
# a variable with positive and negative contributions
x[, mixed := sample(-10:10, nrow(x), replace = TRUE)]

# create record keys
x$rkey &lt;- ck_generate_rkeys(dat = x)

# define required inputs

# hierarchy with some bogus codes
d_sex &lt;- hier_create(root = "Total", nodes = c("male", "female"))
d_sex &lt;- hier_add(d_sex, root = "female", "f")
d_sex &lt;- hier_add(d_sex, root = "male", "m")

d_age &lt;- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
d_age &lt;- hier_add(d_age, root = "age_group1", "ag1a")
d_age &lt;- hier_add(d_age, root = "age_group2", "ag2a")

# define the cell key object
countvars &lt;- c("cnt_females", "cnt_males", "cnt_highincome")
numvars &lt;- c("expend", "income", "savings", "mixed")
tab &lt;- ck_setup(
  x = x,
  rkey = "rkey",
  dims = list(sex = d_sex, age = d_age),
  w = "sampling_weight",
  countvars = countvars,
  numvars = numvars)

# show some information about this table instance
tab$print() # identical with print(tab)

# information about the hierarchies
tab$hierarchy_info()

# which variables have been defined?
tab$allvars()

# count variables
tab$cntvars()

# continuous variables
tab$numvars()

# create perturbation parameters for "total" variable and
# write to yaml-file

# create a ptable using functionality from the ptable-pkg
f_yaml &lt;- tempfile(fileext = ".yaml")
p_cnts1 &lt;- ck_params_cnts(
  ptab = ptable::pt_ex_cnts(),
  path = f_yaml)

# read parameters from yaml-file and set them for variable `"total"`
p_cnts1 &lt;- ck_read_yaml(path = f_yaml)

tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters by specifying parameters
para2 &lt;- ptable::create_cnt_ptable(
  D = 8, V = 3, js = 2, create = FALSE)

p_cnts2 &lt;- ck_params_cnts(ptab = para2)

# use these ptable it for the remaining variables
tab$params_cnts_set(val = p_cnts2, v = countvars)

# perturb a variable
tab$perturb(v = "total")

# multiple variables can be perturbed as well
tab$perturb(v = c("cnt_males", "cnt_highincome"))

# return weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# numerical variables (positive variables using flex-function)
# we also write the config to a yaml file
f_yaml &lt;- tempfile(fileext = ".yaml")

# create a ptable using functionality from the ptable-pkg
# a single ptable for all cells
ptab1 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = FALSE)

# a single ptab for all cells except for very small ones
ptab2 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = TRUE)

# different ptables for cells with even/odd number of contributors
# and very small cells
ptab3 &lt;- ptable::pt_ex_nums(parity = FALSE, separation = TRUE)

p_nums1 &lt;- ck_params_nums(
  ptab = ptab1,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.30, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 3),
  mu_c = 2,
  same_key = FALSE,
  use_zero_rkeys = FALSE,
  path = f_yaml)

# we read the parameters from the yaml-file
p_nums1 &lt;- ck_read_yaml(path = f_yaml)

# for variables with positive and negative values
p_nums2 &lt;- ck_params_nums(
  ptab = ptab2,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.15, 0.02),
    epsilon = c(1, 0.4, 0.15),
    q = 3),
  mu_c = 2,
  same_key = FALSE)

# simple perturbation parameters (not using the flex-function approach)
p_nums3 &lt;- ck_params_nums(
  ptab = ptab3,
  type = "mean",
  mult_params = ck_simpleparams(p = 0.25),
  mu_c = 2,
  same_key = FALSE)

# use `p_nums1` for all variables
tab$params_nums_set(p_nums1, c("savings", "income", "expend"))

# use different parameters for variable `mixed`
tab$params_nums_set(p_nums2, v = "mixed")

# identify sensitive cells to which extra protection (`mu_c`) is added.
tab$supp_p(v = "income", p = 85)
tab$supp_pq(v = "income", p = 85, q = 90)
tab$supp_nk(v = "income", n = 2, k = 90)
tab$supp_freq(v = "income", n = 14, weighted = FALSE)
tab$supp_val(v = "income", n = 10000, weighted = TRUE)
tab$supp_cells(
  v = "income",
  inp = data.frame(
    sex = c("female", "female"),
    "age" = c("age_group1", "age_group3")
  )
)

# perturb variables
tab$perturb(v = c("income", "savings"))

# extract results
tab$numtab("income", mean_before_sum = TRUE)
tab$numtab("income", mean_before_sum = FALSE)
tab$numtab("savings")

# results can be resetted, too
tab$reset_cntvars(v = "cnt_males")

# we can then set other parameters and perturb again
tab$params_cnts_set(val = p_cnts1, v = "cnt_males")

tab$perturb(v = "cnt_males")

# write results to a .csv file
tab$freqtab(
  v = c("total", "cnt_males"),
  path = file.path(tempdir(), "outtab.csv")
)

# show results containing weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# utility measures for a count variable
tab$measures_cnts(v = "total", exclude_zeros = TRUE)

# modifications for perturbed count variables
tab$mod_cnts()

# display a summary about utility measures
tab$summary()

</code></pre>


</div>