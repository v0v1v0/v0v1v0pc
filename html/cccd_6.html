<div class="container">

<table style="width: 100%;"><tr>
<td>cccd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Class Cover Catch Digraph
</h2>

<h3>Description</h3>

<p>Constructs a class cover catch digraph from points or interpoint distance matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cccd(x = NULL, y = NULL, dxx = NULL, dyx = NULL, method = NULL, 
     k = NA, algorithm = 'cover_tree')
cccd.rw(x=NULL,y=NULL,dxx=NULL,dyx=NULL,method=NULL,m=1,d=2)
cccd.classifier(x,y,dom.method='greedy',proportion=1,...)
cccd.classify(data, C,method=NULL)
cccd.classifier.rw(x,y,m=1,d=2)
cccd.multiclass.classifier(data, classes, dom.method='greedy',proportion=1,...)
cccd.multiclass.classify(data,C,method=NULL)
## S3 method for class 'cccd'
plot(x, ..., plot.circles = FALSE, dominate.only = FALSE, 
          D = NULL, vertex.size = 2, vertex.label = NA, 
			 vertex.color = "SkyBlue2", dom.color = "Blue", 
			 ypch = 20, ycex = 1.5, ycol = 2, 
			 use.circle.radii = FALSE, balls = FALSE, 
			 ball.color = gray(0.8), square = FALSE, xlim, ylim)
## S3 method for class 'cccdClassifier'
plot(x, ..., xcol=1,ycol=2,xpch=20,ypch=xpch,
                                balls=FALSE,add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>

<p>the target class and non-target class points. Either x,y
or dxx,dyx must be provided. In the case of <code>plot</code>, x is
an object of class cccd.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dxx,dyx</code></td>
<td>

<p>interpoint distances (x against x and y against x). If these
are not provided they are computed using x and y.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> the method used for the distance. 
See <code>dist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dom.method,proportion</code></td>
<td>
<p> the method used for the domination set 
computation, and the proportion of points required to dominate.  
See <code>dominate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>If given, <code>get.knn</code> is used from FNN to approximate
the class cover catch graph. Each x covers no more than the <code>k</code> 
nearest neighbors to it.
This will be much faster and use less memory for large data sets, but 
is an approximation unless <code>k</code> is sufficiently large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>See <code>get.knn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>slope of the null hypothesis curve</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data to be classified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>dimension of the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>class labels of the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>cccd object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.circles</code></td>
<td>
<p> logical. Plot the circles around the points if TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dominate.only</code></td>
<td>
<p> logical. Only plot the digraph induced by the
dominating set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p> a dominating set. Only used if dominate.only is TRUE. If
dominate.only is TRUE and D is NULL, then <code>dominate</code>
is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.size,vertex.color,vertex.label, dom.color</code></td>
<td>
<p>parameters controling
the plotting of the vertices. <code>dom.color</code> is the color
of the vertices in the dominating set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balls, ball.color</code></td>
<td>
<p>if <code>balls</code>=TRUE, the cover is plotted
as filled balls, with
<code>ball.color</code> controling their color. In the cass of
<code>cccdClassifier</code>, <code>balls</code> can be "x" or "y" indicating
that only one of the balls should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ypch,ycex,ycol</code></td>
<td>
<p> parameters for plotting the non-target points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xpch,xcol</code></td>
<td>
<p>parameters for plotting the first class points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>logical. Should the classifier plot be added to an existing plot?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.circle.radii</code></td>
<td>
<p> logical. Ensure that the circles fit
within the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>square</code></td>
<td>
<p>logical. Make the plot square.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim,ylim</code></td>
<td>
<p>if present, these control the plotting region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments passed to <code>cccd</code> or <code>plot</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The class cover catch digraph is a graph with vertices defined by the
points of <code>x</code> and edges defined according to the balls
<code class="reqn">B(x,d(x,Y))</code>. There is an edge between vertices
<code class="reqn">x_1,x_2</code> if <code class="reqn">x_2\in B(x_1,d(x_1,Y))</code>. If <code>dyx</code> is not
given and the method is 'euclidean', then <code>get.knnx</code> is used to
find the nearest <code>y</code> to each x. If <code>k</code> is given, only
the <code>k</code> nearest neighbors to each point are candidates for
covering. Thus the cccd will be approximate, but the computation will
(generally) be faster. Since <code>get.knn</code> uses Euclidean distance,
these choices will only be valid for this distance metric.
Since the graph will tend to be larger than
otherwise, the dominating set computation will be slower, so one
should trade-off speed of calculation, approximation, and the 
<code>proportion</code> option to the dominating set (which can make that
calculation faster at the cost of returning a subset of the dominating
set).
</p>


<h3>Value</h3>

<p>an object of class igraph. In addition, it contains the attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>a vector of radii.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>the y vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layout</code></td>
<td>
<p>the x vectors.</p>
</td>
</tr>
</table>
<p>In the case of the classifier, the attributes are:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Rx,Ry</code></td>
<td>
<p>vectors of radii.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cx,Cy</code></td>
<td>
<p>the ball centers.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The plotting assumes the cccd used Euclidean distance, and so the
balls/circles will be Euclidean balls/circles. If the 
method used in the distance was some other metric, you'll have
to plot the balls/circles yourself if you want them to be correct
on the plot.
</p>


<h3>Author(s)</h3>

<p>David J. Marchette, david.marchette@navy.mil
</p>


<h3>References</h3>

<p>D.J. Marchette,
"Class Cover Catch Digraphs",
Wiley Interdisciplinary Reviews: Computational Statistics, 
2, 171-177, 2010.
</p>
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>
<p>C.E. Priebe, D.J. Marchette, J. DeVinney and D. Socolinsky, 
"Classification Using Class Cover Catch Digraphs",
Journal of Classification,
20, 3-23, 2003.
</p>


<h3>See Also</h3>

<p><code>ccd</code>, <code>rng</code>, <code>gg</code>, <code>dist</code>,
<code>get.knn</code>
<code>dominate</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(456330)
z &lt;- matrix(runif(1000),ncol=2)
ind &lt;- which(z[,1]&lt;.5 &amp; z[,2]&lt;.5)
x &lt;- z[ind,]
y &lt;- z[-ind,]
g &lt;- cccd(x,y)
C &lt;- cccd.classifier(x,y)
z2 &lt;- matrix(runif(1000),ncol=2)
ind &lt;- which(z2[,1]&lt;.5 &amp; z2[,2]&lt;.5)
cls &lt;- rep(0,nrow(z2))
cls[ind] &lt;- 1
out &lt;- cccd.classify(z2,C)
sum(out != cls)/nrow(z2)
## Not run: 
plot(g,plot.circles=TRUE,dominate.only=TRUE)
points(z2,col=2*(1-cls)+1,pch=20)

## End(Not run)
</code></pre>


</div>