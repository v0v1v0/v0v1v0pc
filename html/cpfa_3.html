<div class="container">

<table style="width: 100%;"><tr>
<td>cpm.all</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Wrapper for Calculating Classification Performance Measures
</h2>

<h3>Description</h3>

<p>Applies function <code>cpm</code> to multiple sets of class labels. Each set of class labels is evaluated against the same set of predicted labels. Works with output from function <code>predict.tunecpfa</code> and calculates classification performance measures for multiple classifiers or numbers of components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cpm.all(x, y,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A data frame where each column contains a set of known class labels of class numeric, factor, or integer. If a set is of class factor, that set is converted to class integer in the order of factor levels with integers beginning at 0 (i.e., for binary classification, factor levels become 0 and 1; for multiclass, levels become 0, 1, 2, etc.). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Predicted class labels of class numeric, factor, or integer. If factor, converted to class integer in order of factor levels with integers beginning at 0 (i.e., for binary classification, factor levels become 0 and 1; for multiclass, 0, 1, 2, etc.).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments to be passed to function <code>cpm</code> for calculating classification performance measures.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Wrapper function that applies function <code>cpm</code> to multiple sets of class labels and one set of predicted labels. See help file for function <code>cpm</code> for additional details.
</p>


<h3>Value</h3>

<p>Returns a list with the following two elements: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cm.list</code></td>
<td>

<p>A list of confusion matrices, denoted <code>cm</code>, where each confusion matrix is associated with one comparison.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpms</code></td>
<td>

<p>A data frame containing classification performance measures where each row contains measures for one comparison.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matthew Snodgress &lt;snodg031@umn.edu&gt;
</p>


<h3>References</h3>

<p>Sokolova, M. and Lapalme, G. (2009). A systematic analysis of performance measures for classification tasks. Information Processing and Management, 45(4), 427-437.
</p>


<h3>Examples</h3>

<pre><code class="language-R">########## Parafac example with 3-way array and binary response ##########

# set seed and specify dimensions of a three-way tensor
set.seed(3)
mydim &lt;- c(10, 11, 80)
nf &lt;- 3

# create correlation matrix between response and third mode's weights 
rho.cc &lt;- .35 
rho.cy &lt;- .75 
cormat.values &lt;- c(1, rho.cc, rho.cc, rho.cy, rho.cc, 1, rho.cc, rho.cy, 
                   rho.cc, rho.cc, 1, rho.cy, rho.cy, rho.cy, rho.cy, 1)
cormat &lt;- matrix(cormat.values, nrow = (nf + 1), ncol = (nf + 1))

# sample from a multivariate normal with specified correlation structure
ymean &lt;- Cmean &lt;- 2
mu &lt;- as.matrix(c(Cmean, Cmean, Cmean, ymean))
eidecomp &lt;- eigen(cormat, symmetric = TRUE)
L.sqrt &lt;- diag(eidecomp$values^0.5)
cormat.sqrt &lt;- eidecomp$vectors %*% L.sqrt %*% t(eidecomp$vectors)
Z &lt;- matrix(rnorm(mydim[3] * (nf + 1)), nrow = mydim[3], ncol = (nf + 1))
Xw &lt;- rep(1, mydim[3]) %*% t(mu) + Z %*% cormat.sqrt
Cmat &lt;- Xw[, 1:nf]

# create a random three-way data tensor with C weights related to a response
Amat &lt;- matrix(rnorm(mydim[1] * nf), nrow = mydim[1], ncol = nf)
Bmat &lt;- matrix(runif(mydim[2] * nf), nrow = mydim[2], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))  
X &lt;- Xmat + Emat

# create a binary response by dichotomizing at the specified response mean
y &lt;- factor(as.numeric(Xw[ , (nf + 1)] &gt; ymean))

# initialize
alpha &lt;- seq(0, 1, length = 2)
gamma &lt;- c(0, 0.01)
cost &lt;- c(1, 2)
method &lt;- c("PLR", "SVM")
family &lt;- "binomial"
parameters &lt;- list(alpha = alpha, gamma = gamma, cost = cost)
model &lt;- "parafac"
nfolds &lt;- 3
nstart &lt;- 3

# constrain first mode weights to be orthogonal
const &lt;- c("orthog", "uncons", "uncons")

# fit Parafac models and use third mode to tune classification methods
tune.object &lt;- tunecpfa(x = X, y = y, model = model, nfac = nf, 
                        nfolds = nfolds, method = method, family = family, 
                        parameters = parameters, parallel = FALSE, 
                        const = const, nstart = nstart)
                         
# create new data with Parafac structure and C weights related to response
mydim.new &lt;- c(10, 11, 20)
Znew &lt;- matrix(rnorm(mydim.new[3] * (nf + 1)), 
               nrow = mydim.new[3], ncol = (nf + 1))
Xwnew &lt;- rep(1, mydim.new[3]) %*% t(mu) + Znew %*% cormat.sqrt
Cmatnew &lt;- Xwnew[, 1:nf]
Xnew0 &lt;- tcrossprod(Amat, krprod(Cmatnew, Bmat))
Xnew0 &lt;- array(Xnew0, dim = mydim.new)
Ematnew &lt;- array(rnorm(prod(mydim.new)), dim = mydim.new)
Ematnew &lt;- nscale(Ematnew, 0, ssnew = sumsq(Xnew0))  
Xnew &lt;- Xnew0 + Ematnew

# create new random class labels for two levels
newlabel &lt;- as.numeric(Xwnew[, (nf + 1)] &gt; ymean)

# predict class labels
predict.labels &lt;- predict(object = tune.object, newdata = Xnew, 
                          type = "response")
                        
# calculate performance measures for predicted class labels
evalmeasure &lt;- cpm.all(x = predict.labels, y = newlabel)

# print performance measures
evalmeasure
</code></pre>


</div>