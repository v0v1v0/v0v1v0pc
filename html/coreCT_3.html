<div class="container">

<table style="width: 100%;"><tr>
<td>convert</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert a matrix of semi-processed DICOM images to mass and volume of material classes</h2>

<h3>Description</h3>

<p>Converts raw CT units to material classes for each CT slice. This version accommodates calibration curves with &gt;4 calibrants, and uses density thresholds converted to Hounsfield Units using the calibration curve (rather than direct calibration rod values) to partition sediment components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">convert(mat.list, upperLim = 3045, lowerLim = -1025, 
pixelA, thickness = 0.625, # all in mm 
means     = c(-850.3233, 63.912, 271.7827, 1345.0696),
sds       = c(77.6953, 14.1728, 39.2814, 45.4129),
densities = c(0.0012, 1, 1.23, 2.2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat.list</code></td>
<td>
<p>list of DICOM images for a sediment core (values in Hounsfield Units)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upperLim</code></td>
<td>
<p>upper bound cutoff for pixels (Hounsfield Units)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowerLim</code></td>
<td>
<p>lower bound cutoff for pixels (Hounsfield Units)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixelA</code></td>
<td>
<p>pixel area (mm2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thickness</code></td>
<td>
<p>slice thickness for computed tomography image series (mm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>mean values (units = Hounsfield Units) for calibration rods used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sds</code></td>
<td>
<p>standard deviations (units = Hounsfield Units) for calibration rods used. Must be in the same order as <code>means</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Must be in the same order as <code>means</code> and <code>sds</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculates average Hounsfield units, cross-sectional areas (cm2), volumes (cm3), and masses (g) of material classes for each CT slice. This function assumes that core walls and all non-sediment material have been removed from the raw DICOM imagery. This function converts data from raw x-ray attenuation values to Hounsfield Units, and then uses user-defined calibration rod inputs to categorize sediment components: air, roots and rhizomes, peat, water, particulates, sand, and rock/shell. The input style for calibration rods ensures sediment components are partitioned following the density divisions in Davey et al. 2011. Calibration rods and are used to develop the calibration curve. Separately, the densities used for partitioning in Davey et al. 2011 (0.0012, 1, 1.23, 2.2 g/cm3) are converted to Hounsfield Units and used for partitioning sediment components. The standard deviation for the calibration rod nearest to the target value is used for the standard deviation for the division between two sediment components.
</p>


<h3>Value</h3>

<p>value <code>convert</code> returns a dataframe with one row per CT slice. Values returned are the average Hounsfield Unit value, the area (cm2), volume (cm3), and mass (grams) of 7 material classes: gas, peat, roots and rhizomes, particulates, sand, water, and rock/shell. If &lt;code&gt;rootData = TRUE&lt;/code&gt;, data for specified root size classes are also returned. See &lt;code&gt;getRoots&lt;/code&gt; for more detail on those values.
</p>


<h3>See Also</h3>

<p><code>getRoots</code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class="language-R">ct.slope &lt;- unique(extractHeader(core_426$hdr, "RescaleSlope"))
ct.int   &lt;- unique(extractHeader(core_426$hdr, "RescaleIntercept")) 
# convert raw units to Hounsfield units
HU_426 &lt;- lapply(core_426$img, function(x) x*ct.slope + ct.int)

materials &lt;- convert(HU_426, pixelA = 0.0596)

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
mass.long &lt;- reshape2::melt(materials, id.vars = c("depth"), 
   measure.vars = grep(".g", names(materials)))
ggplot2::ggplot(data = mass.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("mass per section (g)")

## End(Not run)

</code></pre>


</div>