<div class="container">

<table style="width: 100%;"><tr>
<td>cma_es</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Covariance matrix adapting evolutionary strategy</h2>

<h3>Description</h3>

<p>Global optimization procedure using a covariance matrix adapting
evolutionary strategy.</p>


<h3>Usage</h3>

<pre><code class="language-R">cma_es(par, fn, ..., lower, upper, control=list())
cmaES(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>A function to be minimized (or maximized), with first
argument the vector of parameters over which minimization is to
take place. It should return a scalar result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Lower bounds on the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>Upper bounds on the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters. See ‘Details’.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>cma_es</code>: Note that arguments after <code>...</code> must be matched exactly.
By default this function performs minimization, but it will
maximize if <code>control$fnscale</code> is negative. It can usually be
used as a drop in replacement for <code>optim</code>, but do note, that
no sophisticated convergence detection is included. Therefore you
need to choose <code>maxit</code> appropriately.
</p>
<p>If you set <code>vectorize==TRUE</code>, <code>fn</code> will be passed matrix
arguments during optimization. The columns correspond to the
<code>lambda</code> new individuals created in each iteration of the
ES. In this case <code>fn</code> must return a numeric vector of
<code>lambda</code> corresponding function values. This enables you to
do up to <code>lambda</code> function evaluations in parallel.
</p>
<p>The <code>control</code> argument is a list that can supply any of the
following components:
</p>

<dl>
<dt><code>fnscale</code></dt>
<dd>
<p>An overall scaling to be applied to the value
of <code>fn</code> during optimization. If negative,
turns the problem into a maximization problem. Optimization is
performed on <code>fn(par)/fnscale</code>.</p>
</dd>
<dt><code>maxit</code></dt>
<dd>
<p>The maximum number of iterations. Defaults to
<code class="reqn">100*D^2</code>, where <code class="reqn">D</code> is the dimension of the parameter space.</p>
</dd>
<dt><code>stopfitness</code></dt>
<dd>
<p>Stop if function value is smaller than or
equal to <code>stopfitness</code>. This is the only way for the CMA-ES
to “converge”.</p>
</dd>
<dt>keep.best</dt>
<dd>
<p>return the best overall solution and not the best
solution in the last population. Defaults to true.</p>
</dd>
<dt><code>sigma</code></dt>
<dd>
<p>Initial variance estimates. Can be a single
number or a vector of length <code class="reqn">D</code>, where <code class="reqn">D</code> is the dimension
of the parameter space.</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>Population size.</p>
</dd>
<dt><code>lambda</code></dt>
<dd>
<p>Number of offspring. Must be greater than or
equal to <code>mu</code>.</p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>Recombination weights</p>
</dd>
<dt><code>damps</code></dt>
<dd>
<p>Damping for step-size</p>
</dd>
<dt><code>cs</code></dt>
<dd>
<p>Cumulation constant for step-size</p>
</dd>
<dt><code>ccum</code></dt>
<dd>
<p>Cumulation constant for covariance matrix</p>
</dd>
<dt><code>vectorized</code></dt>
<dd>
<p>Is the function <code>fn</code> vectorized?</p>
</dd>
<dt><code>ccov.1</code></dt>
<dd>
<p>Learning rate for rank-one update</p>
</dd>
<dt><code>ccov.mu</code></dt>
<dd>
<p>Learning rate for rank-mu update</p>
</dd>
<dt><code>diag.sigma</code></dt>
<dd>
<p>Save current step size <code class="reqn">\sigma</code>
in each iteration.</p>
</dd>
<dt><code>diag.eigen</code></dt>
<dd>
<p>Save current principle components
of the covariance matrix <code class="reqn">C</code> in each iteration.</p>
</dd>
<dt><code>diag.pop</code></dt>
<dd>
<p>Save current population in each iteration.</p>
</dd>
<dt><code>diag.value</code></dt>
<dd>
<p>Save function values of the current
population in each iteration.</p>
</dd>
</dl>
<h3>Value</h3>

<p><code>cma_es</code>: A list with components: </p>

<dl>
<dt>par</dt>
<dd>
<p>The best set of parameters found.</p>
</dd>
<dt>value</dt>
<dd>
<p>The value of <code>fn</code> corresponding to <code>par</code>.</p>
</dd>
<dt>counts</dt>
<dd>
<p>A two-element integer vector giving the number of calls
to <code>fn</code>. The second element is always zero for call
compatibility with <code>optim</code>.</p>
</dd>
<dt>convergence</dt>
<dd>
<p>An integer code. <code>0</code> indicates successful
convergence. Possible error codes are </p>

<dl>
<dt><code>1</code></dt>
<dd>
<p>indicates that the iteration limit <code>maxit</code>
had been reached.</p>
</dd>
</dl>
</dd>
<dt>message</dt>
<dd>
<p>Always set to <code>NULL</code>, provided for call
compatibility with <code>optim</code>.</p>
</dd>
<dt>diagnostic</dt>
<dd>
<p>List containing diagnostic information. Possible elements
are: </p>

<dl>
<dt>sigma</dt>
<dd>
<p>Vector containing the step size <code class="reqn">\sigma</code>
for each iteration.</p>
</dd>
<dt>eigen</dt>
<dd>
<p><code class="reqn">d \times niter</code> matrix containing the
principle components of the covariance matrix <code class="reqn">C</code>.</p>
</dd>
<dt>pop</dt>
<dd>
<p>An <code class="reqn">d\times\mu\times niter</code> array
containing all populations. The last dimension is the iteration
and the second dimension the individual.</p>
</dd>
<dt>value</dt>
<dd>
<p>A <code class="reqn">niter \times \mu</code> matrix
containing the function values of each population. The first
dimension is the iteration, the second one the individual.</p>
</dd>
</dl>
<p>These are only present if the respective diagnostic control variable is
set to <code>TRUE</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Olaf Mersmann <a href="mailto:olafm@statistik.tu-dortmund.de">olafm@statistik.tu-dortmund.de</a> and
David Arnu <a href="mailto:david.arnu@tu-dortmun.de">david.arnu@tu-dortmun.de</a></p>


<h3>References</h3>

<p>Hansen, N. (2006). The CMA Evolution Strategy: A Comparing Review. In
J.A. Lozano, P. Larranga, I. Inza and E. Bengoetxea (eds.). Towards a
new evolutionary computation. Advances in estimation of distribution
algorithms. pp. 75-102, Springer</p>


<h3>See Also</h3>

<p><code>extract_population</code></p>


</div>