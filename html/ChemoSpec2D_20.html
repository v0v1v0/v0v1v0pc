<div class="container">

<table style="width: 100%;"><tr>
<td>pfacSpectra2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PARAFAC Analysis of a Spectra2D Object</h2>

<h3>Description</h3>

<p>Carry out PARAFAC analysis of a <code>Spectra2D</code> object.
Function <code>parafac</code> from <span class="pkg">multiway</span> is used.
For large data sets, computational time may be long enough that
it might desirable to run in batch mode and possibly use parallel processing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pfacSpectra2D(spectra, parallel = FALSE, setup = FALSE, nfac = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spectra</code></td>
<td>
<p>An object of S3 class <code>Spectra2D</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical.  Should parallel processing be used?
Unless you love waiting, you should use parallel processing for larger data sets.
If you are working on a shared machine and/or another process (created by you or
another user) might also try to access all or some of the cores in your CPU,
you should be careful to avoid hogging the cores.
<code>parallel::detectCores()</code> will tell you how many cores are available to everyone.
You can run <code>options(mc.cores = 2)</code> to set the number of cores this function will use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setup</code></td>
<td>
<p>Logical.  If <code>TRUE</code> the parallel environment will be automatically
configured for you.  If <code>FALSE</code>, the user must configure the environment
themselves (desirable for instance if working on Azure or AWS EC2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfac</code></td>
<td>
<p>Integer.  The number of factors/components to compute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed to function <code>parafac</code>.
You should give thought to value of <code>const</code>, allowed options can be seen in
<code>const</code>. The default is to compute an unconstrained solution.
However, in some cases one may wish to apply a non-negativity constraint.  Also,
to suppress the progress bar, you can use <code>verbose = FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>pfac</code> and <code>parafac</code>, modified to include a list
element called <code>$method</code> which is <code>parafac</code>.
</p>


<h3>Warning</h3>

<p>To get reproducible results you will need to <code>set.seed()</code>.  See the example.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University.
</p>


<h3>References</h3>

<p>R. Bro "PARAFAC. Tutorial and applications" <em>Chemometrics and Intelligent
Laboratory Systems</em> vol. 38 pgs. 149-171 (1997).
</p>
<p>A. Smilde, R. Bro and P. Geladi
"Multi-way Analysis: Applications in the Chemical Sciences" Wiley (2004).
</p>


<h3>See Also</h3>

<p>For other data reduction methods for <code>Spectra2D</code> objects, see
<code>miaSpectra2D</code> and <code>popSpectra2D</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("ggplot2")
data(MUD1)
set.seed(123)
res &lt;- pfacSpectra2D(MUD1, parallel = FALSE, nfac = 2)

# plotScores uses ggplot2 graphics

p1 &lt;- plotScores(MUD1, res, leg.loc = "topright", ellipse = "cls")
p1 &lt;- p1 + ggtitle("PARAFAC Score Plot")
p1

# plotLoadings2D uses base graphics

res1 &lt;- plotLoadings2D(MUD1, res,
  load_lvls = c(1, 5, 10, 15, 25),
  main = "PARAFAC Comp. 1 Loadings")
res2 &lt;- plotLoadings2D(MUD1, res,
  load_lvls = c(1, 5, 10, 15, 25),
  ref = 2, ref_lvls = seq(5, 35, 5),
  ref_cols = rep("black", 7),
  main = "PARAFAC Comp. 1 Loadings + Ref. Spectrum")

# Selection of loading matrix levels can be aided by the following
# Use res1$names to find the index of the loadings

inspectLvls(res1,
  which = 11, ylim = c(0, 50),
  main = "Histogram of Loadings Matrix")

</code></pre>


</div>