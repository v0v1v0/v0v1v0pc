<div class="container">

<table style="width: 100%;"><tr>
<td>combination.rule.restriction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Function for estimating portfolio weights of a restricted 8-fund rule </h2>

<h3>Description</h3>

<p>This function computes optimal portfolio weights based on a restricted 8-fund rule. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">combination.rule.restriction(ret,  HC, h0, rule, gamma=1, detailed.output=FALSE, 
		RHO.grid.size= 100, Kmax.init= 500, tail.cut.exp= 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ret</code></td>
<td>
<p> Matrix or data.frame of excess returns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HC</code></td>
<td>
<p> Scaled restriction matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h0</code></td>
<td>
<p> Scaled restriction vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>Vector of combination rule, subset of 1,2,... 7 </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Relative risk aversion parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detailed.output</code></td>
<td>
<p> If <code>FALSE</code> only the estimated portfolio weight vectors of the models are returned. If TRUE a list of the portfolio weight vectors, the combination weights, and the target rules is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RHO.grid.size</code></td>
<td>
<p>Just for convergence issues, the larger the more time-consuming, but the higher the precision of the results, only relevant if one of 5, 6 or 7 rule is included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kmax.init</code></td>
<td>
<p>See description of <code>RHO.grid.size</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tail.cut.exp</code></td>
<td>
<p>See description of <code>RHO.grid.size</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that only C=I is implemented. So HC = H. 
</p>


<h3>Value</h3>

<p>Returns matrix of estimated weights for possible combination rules. If <code>detailed.output</code>  is <code>TRUE</code> <code>TRUE</code> a list of the portfolio weight vectors, the combination weights, and the target rules is provided.
</p>


<h3>Author(s)</h3>

<p> Florian Ziel
<br><a href="mailto:florian.ziel@uni-due.de">florian.ziel@uni-due.de</a>
</p>


<h3>See Also</h3>

<p><code>combination.rule</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">##setting
ret&lt;- diff(log(EuStockMarkets))
T&lt;- dim(ret)[1]
N&lt;- dim(ret)[2]
gamma&lt;- 1
## Example Tu-Zhou(2011) on Markowitz portfolio
a1&lt;- T/(T-N-2)
rule&lt;- c(1,4) ## as. TZ on Tangency and naive  restriction index
HC&lt;- array( c(c(gamma*a1,N ) ) , dim=c(length(rule), 1) )## C^{-1} H conditions...
h0&lt;- c(1)
## plug-in estimator, theta^2-adjusted, psi^2-adjusted:
rcrule&lt;-combination.rule.restriction(ret,rule=rule,HC=HC,h0=h0,gamma=gamma,detailed.output=TRUE)
rcrule

## compare with TZ:
we&lt;- rep.int(1/N, N)
TT&lt;- T
mu&lt;- apply(ret, 2, mean)## exess return
Sigma&lt;- cov(ret) * (TT-1)/TT
Sigma.inv&lt;- solve(Sigma)
sharpe.squared&lt;- as.numeric( tcrossprod(crossprod(mu, Sigma.inv),mu) )	
Sigma.inv.unb&lt;- Sigma.inv * (TT-N-2)/TT
w.Markowitz&lt;- 1/gamma * crossprod(Sigma.inv.unb, mu) ##
weSigmawe&lt;- as.numeric( tcrossprod(crossprod(we, Sigma),we) )	 
wemu&lt;- crossprod(we,mu)
pi1&lt;- as.numeric( weSigmawe - 2/gamma * wemu + 1/gamma^2 *sharpe.squared )
bb&lt;- (TT-2)*(TT-N-2)/( (TT-N-1)*(TT-N-4) ) ##c1 in tu-zhou
pi2&lt;- (bb-1) * sharpe.squared /gamma^2 + bb/gamma^2 * N/TT
pi3&lt;- 0
delta.TZ.Markowitz&lt;- (pi1 - pi3)/(pi1 + pi2 - 2*pi3)
w.TZ.Markowitz&lt;- (1- delta.TZ.Markowitz)* we + delta.TZ.Markowitz * w.Markowitz
w.TZ.Markowitz	
rcrule$w["r:14",]

## adjusted Tu-Zhou on Markowitz
ibeta&lt;- function(x,a,b) pbeta(x,a,b) * beta(a,b) ## incomplete beta
sharpe.squared.adj&lt;- ((TT-N-2)*sharpe.squared - N)/TT + 2*(sharpe.squared^(N/2)*
	(1+ sharpe.squared)^(-(TT-2)/2))/TT/ibeta(sharpe.squared/(1+sharpe.squared),N/2,(TT-N)/2)
pi1.adj&lt;- as.numeric( weSigmawe - 2/gamma * wemu + 1/gamma^2 *sharpe.squared.adj )
pi2.adj&lt;- (bb-1) * sharpe.squared.adj /gamma^2 + bb/gamma^2 * N/TT
delta.TZ.Markowitz.adj&lt;- (pi1.adj - pi3)/(pi1.adj + pi2.adj - 2*pi3)
w.TZ.Markowitz.adj&lt;- (1- delta.TZ.Markowitz.adj)* we + delta.TZ.Markowitz.adj * w.Markowitz
w.TZ.Markowitz.adj
rcrule$w["r:1'4",]


## Example Tu-Zhou(2011) on Kan-Zhou(2007) 3-fund
cd&lt;- combination.rule(ret, detailed.output=TRUE)[[2]]["1''2",1:2] ## KZ3fund combination weights
rule&lt;- c(1,2,4) ## as. TZ on KZ3fund  restriction index
HC&lt;- array( c(c(gamma,0, N*cd[1] ), c(0, gamma, N*cd[2] )) , dim=c(length(rule), 2) )
h0&lt;- c(cd[1]/N, cd[2]/N)
combination.rule.restriction(ret, rule=rule, HC=HC, h0=h0) 

</code></pre>


</div>