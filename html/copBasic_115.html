<div class="container">

<table style="width: 100%;"><tr>
<td>prod2COP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Product of Two Copulas</h2>

<h3>Description</h3>

<p>Perform copula multiplication (so-called “<code class="reqn">\ast</code>-product” or <em>Markov Product</em>) (Darsow and others, 1992) is a continuous analog of matrix multiplication and yields another copula:
</p>
<p style="text-align: center;"><code class="reqn">\bigl(\mathbf{C}_1 \ast \mathbf{C}_2 \bigr)(u,v) = \mathbf{C}_3(u,v) = \int_\mathcal{I} \frac{\delta \mathbf{C}_1(u, t)}{\delta v} \frac{\delta \mathbf{C}_2(t, v)}{\delta u}\,\mathrm{d}t\mbox{,}</code>
</p>

<p>for copulas <code class="reqn">\mathbf{C}_1(u, v)</code> and <code class="reqn">\mathbf{C}_2(u, v)</code> are copulas whose <code class="reqn">\ast</code>-product yields copula <code class="reqn">\mathbf{C}_3(u, v)</code> in terms of partial derivatives (<code>derCOP</code> and <code>derCOP2</code>) of the other two. Nelsen (2006, p. 245) lists several identities of the <code class="reqn">\ast</code>-product involving the product (<code class="reqn">\mathbf{\Pi}</code>; <code>P</code>), lower bound (<code class="reqn">\mathbf{W}</code>; <code>W</code>), and upper bound (<code class="reqn">\mathbf{M}</code>; <code>M</code>) copulas:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{\Pi} \ast \mathbf{C} = \mathbf{C} \ast \mathbf{\Pi} = \mathbf{\Pi}\mbox{,}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{M} \ast \mathbf{C} = \mathbf{C} \ast \mathbf{M} = \mathbf{M}\mbox{,}</code>
</p>

<p style="text-align: center;"><code class="reqn">\bigl(\mathbf{W} \ast \mathbf{C}\bigr)(u,v) = v - \mathbf{C}(1-u, v)\mbox{\ and\ } \bigl(\mathbf{C} \ast \mathbf{W}\bigr)(u,v) = u - \mathbf{C}(u, 1-v)\mbox{, and}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{W} \ast \mathbf{W} = \mathbf{M}\mbox{ and } \mathbf{W} \ast \mathbf{C} \ast \mathbf{W} = \hat{\mathbf{C}}\mbox{,}</code>
</p>

<p>where <code class="reqn">\hat{\mathbf{C}}</code> is the <em>survival copula</em> (<code>surCOP</code>). The <code class="reqn">\ast</code>-product is associative:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{A} \ast (\mathbf{B} \ast \mathbf{C}) = (\mathbf{A} \ast \mathbf{B}) \ast \mathbf{C}\mbox{,}</code>
</p>

<p>but <code class="reqn">\ast</code>-product is not commutative (order independent). Nelsen (2006, p. 245) reports that “if we view <code class="reqn">\ast</code> as a binary operation on the set of copulas, then <code class="reqn">\mathbf{\Pi}</code> is the null element, and <code class="reqn">\mathbf{M}</code> is the identity.” Copula mulitiplication is closely linked to <em>Markov Processes</em> (Nelsen, 2006, pp. 244–248).
</p>
<p>For other descriptions and computations of copula combination are possible using the <span class="pkg">copBasic</span> package, see <code>convexCOP</code>, <code>convex2COP</code>, <code>composite1COP</code>, <code>composite2COP</code>, <code>composite3COP</code>, <code>glueCOP</code>, and <code>convexCOP</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prod2COP(u,v, cop1=NULL, para1=NULL, cop2=NULL, para2=NULL, para=NULL,
              pinterval=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop1</code></td>
<td>
<p>The <code class="reqn">\mathbf{C}_1(u,v; \Theta_1)</code> copula function with vectorization as in <code>asCOP</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para1</code></td>
<td>
<p>Vector of parameters or other data structures for <code class="reqn">\Theta_1</code>, if needed, to pass to copula <code class="reqn">\mathbf{C}_1(u,v; \Theta_1)</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop2</code></td>
<td>
<p>The <code class="reqn">\mathbf{C}_2(u,v; \Theta_2)</code> copula function with vectorization as in <code>asCOP</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para2</code></td>
<td>
<p>Vector of parameters or other data structures for <code class="reqn">\Theta_2</code>, if needed, to pass to copula <code class="reqn">\mathbf{C}_2(u,v; \Theta_2)</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> that can take the place of the <code>cop1</code>, <code>para1</code>, <code>cop2</code>, and <code>para2</code> arguments. These four will be populated from same named elements of the <code>list</code>, and if the other four arguments were specified through the function interface, these are silently ignored;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pinterval</code></td>
<td>
<p>An optional interval for the above integral. The default is <code class="reqn">\mathcal{I} = [0,1]</code> but the option of the user to replace exact end points with “small” numbers is possible (<em>e.g.</em> <code>interval=</code><code>c(lo, 1-lo)</code> for say <code>lo=.Machine$double.eps</code>). This interval is uniquely picked up for the interval in the above definition of <code>prod2COP</code>. The <code>pinterval</code> can also be set within the <code>para</code> and the function will pick it up from there; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copulas.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Note</h3>

<p>The <em>Farlie–Gumbel–Morgenstern copula</em> (<code class="reqn">\mathbf{FGM}(u,v; \Theta)</code>; <code>FGMcop</code>) is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{FGM}(u,v; \Theta) = uv[1+\Theta(1-u)(1-v)]\mbox{,}</code>
</p>

<p>where <code class="reqn">-1 \le \Theta \le 1</code>. Nelsen (2006, exer. 6.12, p. 249) asserts that for <code class="reqn">\mathbf{FGM}_{(\Theta = \alpha)}</code> and <code class="reqn">\mathbf{FGM}_{(\Theta = \beta)}</code> with <code class="reqn">\ast</code>-product as <code class="reqn">\mathbf{FGM}_\alpha \ast \mathbf{FGM}_\beta</code> that a closed-form solution exists and is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{FGM}_\alpha \ast \mathbf{FGM}_\beta = \mathbf{FGM}_{(\alpha\beta) / 3}\mbox{.}</code>
</p>

<p>This assertion is numerically true as readily verified using the <code>prod2COP</code> function:
</p>
<pre>
  u &lt;- c(0.41, 0.87); v &lt;- c(0.13,0.35); A &lt;- -0.532; B &lt;- 0.235
  FGMcop(  u,v, para= A*B / 3)
  # 0.0521598638574___   0.3034277347150___
  prod2COP(u,v, cop1=FGMcop, para1=A, cop2=FGMcop, para2=B)
  # 0.0521598638312605   0.3034277344807909
</pre>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Darsow, W.F., Nguyen, B., and Olsen, E.T., 1992, Copulas and Markov processes: Illinois Journal of Mathematics, v. 26, pp. 600–624, <a href="https://doi.org/10.1215/IJM/1255987328">doi:10.1215/IJM/1255987328</a>.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>COP</code>, <code>composite1COP</code>, <code>composite2COP</code>, <code>composite3COP</code>,
<code>convexCOP</code>, <code>convex2COP</code>, <code>glueCOP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Product P * N4212 ---&gt; P (by identity)
u &lt;- c(0.41, 0.87); v &lt;- c(0.13, 0.35)
prod2COP(u,v, cop1=P, cop2=N4212cop, para1=NA, para2=2.12) # 0.0533 and 0.3045
COP(u,v, cop=P)                                            # 0.0533 and 0.3045
## End(Not run)

## Not run: 
para &lt;- list(cop1=PLcop, para1=0.19, cop2=PLcop, para2=34.5)
UV &lt;- simCOP(n=1000, cop=prod2COP, para=para, resamv01=FALSE, showresamv01=FALSE)
# This is large simulation run (with a lot of numerical operations) is expected
# at least for the Placketts and chosen parameters to trigger one or more NAs
# from derCOPinv(). The simCOP() function simply continues on with ignoring the
# solution or lack thereof for certain combinations, and simCOP() will report how
# many of the simulated values for sample of size n were computed. For example,
# for one n=1000, some 965 simulated values were returned. The defaults require
# that NAs, empty simulations, remain intact. We can try resampling:
UV &lt;- simCOP(n=1000, cop=prod2COP, para=para, resamv01=TRUE, showresamv01=TRUE)
rhoCOP(cop=prod2COP, para=para) # -0.4271195 (theoretical)
rhoCOP(para=UV, as.sample=TRUE) # -0.4274703 #
## End(Not run)

## Not run: 
para &lt;- list(cop1=PLcop, para1=0.19, cop2=PLcop, para2=34.5)
# The prod2COP() might be one of the more sensitive to NAs in simulation because
# of the two partial numerical derivatives involved.
para$pinterval &lt;- c(0.4, 0.6) # totally inappropriate interval for the integral
# for the prod2COP() definition. Because the ... are used so extensively, we have
# the "pinterval" for this function so that interval itself can be passed also.
UV &lt;- simCOP(n=1000, cop=prod2COP, para=para, resamv01=TRUE, showresamv01=TRUE,
                     pinterval=c(0,   1  ))
UV &lt;- simCOP(n=1000, cop=prod2COP, para=para, resamv01=TRUE, showresamv01=TRUE,
                     pinterval=c(0.4, 0.6)) #
## End(Not run)
</code></pre>


</div>