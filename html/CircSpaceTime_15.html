<div class="container">

<table style="width: 100%;"><tr>
<td>WrapSp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Samples from the Wrapped Normal spatial model</h2>

<h3>Description</h3>

<p>The function <code>WrapSp</code> produces samples from the posterior
distribution of the wrapped normal spatial model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">WrapSp(x = x, coords = coords, start = list(alpha = c(2, 1), rho =
  c(0.1, 0.5), sigma2 = c(0.1, 0.5), k = sample(0, length(x), replace =
  T)), priors = list(alpha = c(pi, 1, -10, 10), rho = c(8, 14), sigma2 =
  c()), sd_prop = list(sigma2 = 0.5, rho = 0.5), iter = 1000,
  BurninThin = c(burnin = 20, thin = 10), accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1e+07, exp = 0.9),
  corr_fun = "exponential", kappa_matern = 0.5, n_chains = 1,
  parallel = FALSE, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>
If they are not in <code class="reqn">[0,2\pi)</code>, the function will tranform
the data in the right interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a numeric vector with <code>n_chains</code> elements
</p>

<ul>
<li>
<p>  alpha the mean which value is in <code class="reqn">[0,2\pi)</code>.
</p>
</li>
<li>
<p>  rho the spatial decay parameter
</p>
</li>
<li>
<p> sigma2 the process variance
</p>
</li>
<li>
<p> k the vector of <code>length(x)</code> winding numbers
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list of 3 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha</dt>
<dd>
<p>a vector of 2 elements the mean and the variance of  a Wrapped Gaussian distribution, default is mean <code class="reqn">\pi</code> and variance 1,</p>
</dd>
<dt>rho</dt>
<dd>
<p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>sigma2</dt>
<dd>
<p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_prop</code></td>
<td>
<p>list of 3 elements. To run the MCMC for the rho and sigma2 parameters we use an adaptive metropolis and in sd.prop we build a list of initial guesses for these two parameters and the beta parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt_param</code></td>
<td>
<p>a vector of 3 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) and it is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr_fun</code></td>
<td>
<p>characters, the name of the correlation function;
currently implemented functions are c("exponential", "matern","gaussian")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa_matern</code></td>
<td>
<p>numeric, the smoothness parameter of the Matern
correlation function, default is <code>kappa_matern = 0.5</code> (the exponential function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a list of <code>n_chains</code> lists each with elements
</p>

<ul>
<li> <p><code>alpha</code>, <code>rho</code>,<code>sigma2</code> vectors with the thinned chains,
</p>
</li>
<li> <p><code>k</code> a matrix with <code>nrow = length(x)</code> and <code>ncol = </code> the length of thinned chains
</p>
</li>
<li> <p><code>corr_fun</code> characters with the type of spatial correlation chosen.
</p>
</li>
<li> <p><code>distribution</code> characters, always "WrapSp"
</p>
</li>
</ul>
<h3>Implementation Tips</h3>

<p>To facilitate the estimations, the observations x
are centered around pi,
and the prior and starting value of alpha are changed accordingly.
After the estimations, posterior samples of alpha are changed
back to the original scale
</p>


<h3>References</h3>

<p>G. Jona Lasinio, A. Gelfand, M. Jona-Lasinio,
"Spatial analysis of wave direction data using wrapped Gaussian processes",
The Annals of Applied Statistics 6 (2013), 1478-1498
</p>


<h3>See Also</h3>

<p><code>WrapKrigSp</code> for spatial interpolation,
<code>ProjSp</code> for posterior  sampling from the
Projected Normal model and <code>ProjKrigSp</code> for
spatial interpolation under the same model
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
## graphical check
par(mfrow = c(3,1))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))
##### We move to the spatial interpolation see WrapKrigSp
</code></pre>


</div>