<div class="container">

<table style="width: 100%;"><tr>
<td>fdiff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> 
Fast (Quasi-, Log-) Differences for Time Series and Panel Data
</h2>

<h3>Description</h3>

<p><code>fdiff</code> is a S3 generic to compute (sequences of) suitably lagged / leaded and iterated differences, quasi-differences or (quasi-)log-differences. The difference and log-difference operators <code>D</code> and <code>Dlog</code> also exists as parsimonious wrappers around <code>fdiff</code>, providing more flexibility than <code>fdiff</code> when applied to data frames.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  fdiff(x, n = 1, diff = 1, ...)
      D(x, n = 1, diff = 1, ...)
   Dlog(x, n = 1, diff = 1, ...)

## Default S3 method:
fdiff(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = TRUE, ...)
## Default S3 method:
D(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1,
  stubs = .op[["stub"]], ...)
## Default S3 method:
Dlog(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
     ...)

## S3 method for class 'matrix'
fdiff(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, ...)
## S3 method for class 'matrix'
D(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1,
  stubs = .op[["stub"]], ...)
## S3 method for class 'matrix'
Dlog(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
     ...)

## S3 method for class 'data.frame'
fdiff(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, ...)
## S3 method for class 'data.frame'
D(x, n = 1, diff = 1, by = NULL, t = NULL, cols = is.numeric,
  fill = NA, rho = 1, stubs = .op[["stub"]], keep.ids = TRUE, ...)
## S3 method for class 'data.frame'
Dlog(x, n = 1, diff = 1, by = NULL, t = NULL, cols = is.numeric,
     fill = NA, rho = 1, stubs = .op[["stub"]], keep.ids = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fdiff(x, n = 1, diff = 1, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, shift = "time", ...)
## S3 method for class 'pseries'
D(x, n = 1, diff = 1, fill = NA, rho = 1, stubs = .op[["stub"]], shift = "time", ...)
## S3 method for class 'pseries'
Dlog(x, n = 1, diff = 1, fill = NA, rho = 1, stubs = .op[["stub"]], shift = "time", ...)

## S3 method for class 'pdata.frame'
fdiff(x, n = 1, diff = 1, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, shift = "time", ...)
## S3 method for class 'pdata.frame'
D(x, n = 1, diff = 1, cols = is.numeric, fill = NA, rho = 1, stubs = .op[["stub"]],
  shift = "time", keep.ids = TRUE, ...)
## S3 method for class 'pdata.frame'
Dlog(x, n = 1, diff = 1, cols = is.numeric, fill = NA, rho = 1, stubs = .op[["stub"]],
     shift = "time", keep.ids = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fdiff(x, n = 1, diff = 1, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
D(x, n = 1, diff = 1, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
  keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
Dlog(x, n = 1, diff = 1, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
     keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer. A vector indicating the number of lags or leads.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff</code></td>
<td>
<p>integer. A vector of integers &gt; 1 indicating the order of differencing / log-differencing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a factor, <code>GRP</code> object, or atomic vector / list of vectors (internally grouped with <code>group</code>) used to group <code>x</code>. <em>Note</em> that without <code>t</code>, all values in a group need to be consecutive and in the right order. See Details of <code>flag</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p><em>data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>a time vector or list of vectors. See <code>flag</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns to difference using a function, column names, indices or a logical vector. Default: All numeric variables. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>value to insert when vectors are shifted. Default is <code>NA</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical. <code>TRUE</code> computes log-differences. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>double. Autocorrelation parameter. Set to a value between 0 and 1 for quasi-differencing. Any numeric value can be supplied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stubs</code></td>
<td>
<p>logical. <code>TRUE</code> (default) will rename all differenced columns by adding prefixes "L<code>n</code>D<code>diff</code>." / "F<code>n</code>D<code>diff</code>." for differences "L<code>n</code>Dlog<code>diff</code>." / "F<code>n</code>Dlog<code>diff</code>." for log-differences and replacing "D" / "Dlog" with "QD" / "QDlog" for quasi-differences. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> or <code>"row"</code>. See <code>flag</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.ids</code></td>
<td>
<p><em>data.frame / pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all variables passed to <code>by</code> or <code>t</code> using formulas). <em>Note</em>: For 'grouped_df' / 'pdata.frame' identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, <code>fdiff/D/Dlog</code> return <code>x</code> with all columns differenced / log-differenced. Differences are computed as <code>repeat(diff) x[i] - rho*x[i-n]</code>, and log-differences as <code>log(x[i]) - rho*log(x[i-n])</code> for <code>diff = 1</code> and <code>repeat(diff-1) x[i] - rho*x[i-n]</code> is used to compute subsequent differences (usually <code>diff = 1</code> for log-differencing). If <code>rho &lt; 1</code>, this becomes quasi- (or partial) differencing, which is a technique suggested by Cochrane and Orcutt (1949) to deal with serial correlation in regression models, where <code>rho</code> is typically estimated by running a regression of the model residuals on the lagged residuals. 
It is also possible to compute forward differences by passing negative <code>n</code> values. <code>n</code> also supports arbitrary vectors of integers (lags), and <code>diff</code> supports positive sequences of integers (differences):
</p>
<p>If more than one value is passed to <code>n</code> and/or <code>diff</code>, the data is expanded-wide as follows: If <code>x</code> is an atomic vector or time series, a (time series) matrix is returned with columns ordered first by lag, then by difference. If <code>x</code> is a matrix or data frame, each column is expanded in like manor such that the output has <code>ncol(x)*length(n)*length(diff)</code> columns ordered first by column name, then by lag, then by difference.
</p>



<p>For further computational details and efficiency considerations see the help page of <code>flag</code>. 
</p>




<h3>Value</h3>

<p><code>x</code> differenced <code>diff</code> times using lags <code>n</code> of itself. Quasi and log-differences are toggled by the <code>rho</code> and <code>log</code> arguments or the <code>Dlog</code> operator. Computations can be grouped by <code>g/by</code> and/or ordered by <code>t</code>. See Details and Examples.
</p>


<h3>References</h3>

<p>Cochrane, D.; Orcutt, G. H. (1949). Application of Least Squares Regression to Relationships Containing Auto-Correlated Error Terms. <em>Journal of the American Statistical Association</em>. 44 (245): 32-61.
</p>
<p>Prais, S. J. &amp; Winsten, C. B. (1954). Trend Estimators and Serial Correlation. <em>Cowles Commission Discussion Paper No. 383.</em> Chicago.
</p>


<h3>See Also</h3>

<p><code>flag/L/F</code>, <code>fgrowth/G</code>, Time Series and Panel Series, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simple Time Series: AirPassengers
D(AirPassengers)                      # 1st difference, same as fdiff(AirPassengers)
D(AirPassengers, -1)                  # Forward difference
Dlog(AirPassengers)                   # Log-difference
D(AirPassengers, 1, 2)                # Second difference
Dlog(AirPassengers, 1, 2)             # Second log-difference
D(AirPassengers, 12)                  # Seasonal difference (data is monthly)
D(AirPassengers,                      # Quasi-difference, see a better example below
  rho = pwcor(AirPassengers, L(AirPassengers)))

head(D(AirPassengers, -2:2, 1:3))     # Sequence of leaded/lagged and iterated differences

# let's do some visual analysis
plot(AirPassengers)                   # Plot the series - seasonal pattern is evident
plot(stl(AirPassengers, "periodic"))  # Seasonal decomposition
plot(D(AirPassengers,c(1,12),1:2))    # Plotting ordinary and seasonal first and second differences
plot(stl(window(D(AirPassengers,12),  # Taking seasonal differences removes most seasonal variation
                1950), "periodic"))


## Time Series Matrix of 4 EU Stock Market Indicators, recorded 260 days per year
plot(D(EuStockMarkets, c(0, 260)))                      # Plot series and annual differnces
mod &lt;- lm(DAX ~., L(EuStockMarkets, c(0, 260)))         # Regressing the DAX on its annual lag
summary(mod)                                            # and the levels and annual lags others
r &lt;- residuals(mod)                                     # Obtain residuals
pwcor(r, L(r))                                          # Residual Autocorrelation
fFtest(r, L(r))                                         # F-test of residual autocorrelation
                                                        # (better use lmtest :: bgtest)
modCO &lt;- lm(QD1.DAX ~., D(L(EuStockMarkets, c(0, 260)), # Cochrane-Orcutt (1949) estimation
                        rho = pwcor(r, L(r))))
summary(modCO)
rCO &lt;- residuals(modCO)
fFtest(rCO, L(rCO))                                     # No more autocorrelation

## World Development Panel Data
head(fdiff(num_vars(wlddev), 1, 1,                      # Computes differences of numeric variables
             wlddev$country, wlddev$year))              # fdiff requires external inputs..
head(D(wlddev, 1, 1, ~country, ~year))                  # Differences of numeric variables
head(D(wlddev, 1, 1, ~country))                         # Without t: Works because data is ordered
head(D(wlddev, 1, 1, PCGDP + LIFEEX ~ country, ~year))  # Difference of GDP &amp; Life Expectancy
head(D(wlddev, 0:1, 1, ~ country, ~year, cols = 9:10))  # Same, also retaining original series
head(D(wlddev, 0:1, 1, ~ country, ~year, 9:10,          # Dropping id columns
       keep.ids = FALSE))

## Indexed computations:
wldi &lt;- findex_by(wlddev, iso3c, year)

# Dynamic Panel Data Models:
summary(lm(D(PCGDP) ~ L(PCGDP) + D(LIFEEX), data = wldi))            # Simple case
summary(lm(Dlog(PCGDP) ~ L(log(PCGDP)) + Dlog(LIFEEX), data = wldi)) # In log-differneces
# Adding a lagged difference...
summary(lm(D(PCGDP) ~ L(D(PCGDP, 0:1)) + L(D(LIFEEX), 0:1), data = wldi))
summary(lm(Dlog(PCGDP) ~ L(Dlog(PCGDP, 0:1)) + L(Dlog(LIFEEX), 0:1), data = wldi))
# Same thing:
summary(lm(D1.PCGDP ~., data = L(D(wldi,0:1,1,9:10),0:1,keep.ids = FALSE)[,-1]))

## Grouped data
library(magrittr)
wlddev |&gt; fgroup_by(country) |&gt;
             fselect(PCGDP,LIFEEX) |&gt; fdiff(0:1,1:2)       # Adding a first and second difference
wlddev |&gt; fgroup_by(country) |&gt;
             fselect(year,PCGDP,LIFEEX) |&gt; D(0:1,1:2,year) # Also using t (safer)
wlddev |&gt; fgroup_by(country) |&gt;                            # Dropping id's
             fselect(year,PCGDP,LIFEEX) |&gt; D(0:1,1:2,year, keep.ids = FALSE)
</code></pre>


</div>