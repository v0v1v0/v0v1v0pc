<div class="container">

<table style="width: 100%;"><tr>
<td>cxr_pm_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General optimization for population models</h2>

<h3>Description</h3>

<p>Estimates parameters of user-specified population dynamics models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cxr_pm_fit(
  data,
  focal_column = NULL,
  model_family,
  covariates = NULL,
  optimization_method = c("Nelder-Mead", "BFGS", "CG", "ucminf", "L-BFGS-B", "nlm",
    "nlminb", "Rcgmin", "Rvmmin", "spg", "bobyqa", "nmkb", "hjkb", "nloptr_CRS2_LM",
    "nloptr_ISRES", "nloptr_DIRECT_L_RAND", "DEoptimR", "GenSA"),
  alpha_form = c("none", "global", "pairwise"),
  lambda_cov_form = c("none", "global"),
  alpha_cov_form = c("none", "global", "pairwise"),
  initial_values = list(lambda = 0, alpha_intra = 0, alpha_inter = 0, lambda_cov = 0,
    alpha_cov = 0),
  lower_bounds = NULL,
  upper_bounds = NULL,
  fixed_terms = NULL,
  bootstrap_samples = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>dataframe with observations in rows and two sets of columns:
</p>

<ul>
<li>
<p> fitness: fitness metric for the focal individual
</p>
</li>
<li>
<p> neighbours: numeric columns with user-defined names, giving number of neighbours for each group
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>focal_column</code></td>
<td>
<p>optional integer or character giving the column
with neighbours from the same species as the focal one. This field is necessary if "alpha_intra" is specified
in <code>initial_values</code>, <code>lower_bounds</code>, <code>upper_bounds</code>, or <code>fixed_terms</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_family</code></td>
<td>
<p>family of model to use. Available families are BH (Beverton-Holt), LV (Lotka-Volterra),
RK (Ricker), and LW (Law-Watkinson). Users may also define their own families and models (see vignette 4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>optional named matrix or dataframe with observations (rows) of any number of environmental covariates (columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimization_method</code></td>
<td>
<p>numerical optimization method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_form</code></td>
<td>
<p>what form does the alpha parameter take? one of "none" (no alpha in the model),
"global" (a single alpha for all pairwise interactions), or "pairwise" (one alpha value for every interaction).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_cov_form</code></td>
<td>
<p>form of the covariate effects on lambda. Either "none" (no covariate effects) or "global" (one estimate per covariate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_cov_form</code></td>
<td>
<p>form of the covariate effects on alpha. One of "none" (no covariate effects), "global" (one estimate per covariate on every alpha),
or "pairwise" (one estimate per covariate and pairwise alpha)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_values</code></td>
<td>
<p>list with components "lambda","alpha_intra","alpha_inter","lambda_cov", "alpha_cov", specifying the initial values
for numerical optimization. Single values are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower_bounds</code></td>
<td>
<p>optional list with single values for "lambda","alpha_intra","alpha_inter","lambda_cov", "alpha_cov".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_bounds</code></td>
<td>
<p>optional list with single values for "lambda","alpha_intra","alpha_inter","lambda_cov", "alpha_cov".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_terms</code></td>
<td>
<p>optional list of numeric vectors specifying the value of fixed model parameters, among
"lambda","alpha_intra","alpha_inter","lambda_cov", and "alpha_cov".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap_samples</code></td>
<td>
<p>number of bootstrap samples for error calculation. Defaults to 0, i.e. no error is calculated.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of class 'cxr_pm_fit' which is a list with the following components:
</p>

<ul>
<li>
<p> model_name: string with the name of the fitness model
</p>
</li>
<li>
<p> model: model function
</p>
</li>
<li>
<p> data: data supplied
</p>
</li>
<li>
<p> focal_ID: name/ID of the focal taxa, if provided in 'focal_column'
</p>
</li>
<li>
<p> covariates: covariate data supplied
</p>
</li>
<li>
<p> optimization_method: optimization method used
</p>
</li>
<li>
<p> initial_values: list with initial values
</p>
</li>
<li>
<p> fixed_terms: list with fixed terms
</p>
</li>
<li>
<p> lambda: fitted value for lambda, or NULL if fixed
</p>
</li>
<li>
<p> alpha_intra: fitted value for intraspecific alpha, or NULL if fixed
</p>
</li>
<li>
<p> alpha_inter: fitted value for interspecific alpha, or NULL if fixed
</p>
</li>
<li>
<p> lambda_cov: fitted value(s) for lambda_cov, or NULL if fixed.
</p>
</li>
<li>
<p> alpha_cov: fitted value(s) for alpha_cov, or NULL if fixed.
These are structured as a list with one element for each covariate.
</p>
</li>
<li>
<p> lambda_standard_error: standard error for lambda, if computed
</p>
</li>
<li>
<p> alpha_intra_standard_error: standard error for intraspecific alpha, if computed
</p>
</li>
<li>
<p> alpha_inter_standard_error: standard error for interspecific alpha, if computed
</p>
</li>
<li>
<p> lambda_cov_standard_error: standard error for lambda_cov, if computed
</p>
</li>
<li>
<p> alpha_cov_standard_error: standard error for alpha_cov, if computed
</p>
</li>
<li>
<p> log_likelihood: log-likelihood of the fit
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">data("neigh_list")
my.sp &lt;- "BEMA"
# data for a single species, keep only fitness and neighbours columns
sp_data &lt;- neigh_list[[my.sp]][2:ncol(neigh_list[[1]])]

  sp_fit &lt;- cxr_pm_fit(data = sp_data,
                       focal_column = my.sp,
                       optimization_method = "bobyqa",
                       model_family = "BH",
                       alpha_form = "pairwise",
                       lambda_cov_form = "none",
                       alpha_cov_form = "none",
                       initial_values = list(lambda = 1,alpha_intra = 0.1,alpha_inter = 0.1),
                       lower_bounds = list(lambda = 0,alpha_intra = 0,alpha_inter = 0),
                       upper_bounds = list(lambda = 100,alpha_intra = 1,alpha_inter = 1),
                       bootstrap_samples = 3)
  summary(sp_fit)


</code></pre>


</div>