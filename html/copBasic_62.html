<div class="container">

<table style="width: 100%;"><tr>
<td>glueCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gluing Two Copulas</h2>

<h3>Description</h3>

<p>The <em>gluing copula</em> technique (Erdely, 2017, p. 71), given two bivariate copulas <code class="reqn">\mathbf{C}_A</code> and <code class="reqn">\mathbf{C}_B</code> and a fixed value <code class="reqn">0 \le \gamma \le 1</code> is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\gamma}(u,v) = \gamma\cdot\mathbf{C}_A(u/\gamma, v)</code>
</p>

<p>for <code class="reqn">0 \le u \le \gamma</code> and
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\gamma}(u,v) = (1-\gamma)\cdot\mathbf{C}_B((u-\gamma)
\,/\,(1-\gamma), v)</code>
</p>

<p>for <code class="reqn">\gamma \le u \le 1</code> and <code class="reqn">\gamma</code> represents the <em>gluing point</em> in <code class="reqn">u</code> (horizontal axis). The logic is simply the rescaling of <code class="reqn">\mathbf{C}_A</code> to <code class="reqn">[0,\gamma] \times [0,1]</code> and <code class="reqn">\mathbf{C}_B</code> to <code class="reqn">[\gamma,1] \times [0,1]</code>. Copula gluing is potentially useful in circumstances for which regression is non-monotone.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glueCOP(u, v, para=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>A special parameter <code>list</code> (see <b>Note</b>) with a mandatory element of <code>glue</code>  parameter <code class="reqn">\gamma</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copulas.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Note</h3>

<p>The following descriptions list in detail the structure and content of the <code>para</code> argument:
</p>

<dl>
<dt><code>glue</code></dt>
<dd>
<p>— The <code class="reqn">\gamma</code> gluing parameter;</p>
</dd>
<dt><code>cop1</code></dt>
<dd>
<p>— Function of the first copula <code class="reqn">\mathbf{A}</code>;</p>
</dd>
<dt><code>cop2</code></dt>
<dd>
<p>— Function of the second copula  <code class="reqn">\mathbf{B}</code>;</p>
</dd>
<dt><code>para1</code></dt>
<dd>
<p>— Vector of parameters <code class="reqn">\Theta_\mathbf{A}</code> for  <code class="reqn">\mathbf{A}</code>; and</p>
</dd>
<dt><code>para2</code></dt>
<dd>
<p>— Vector of parameters <code class="reqn">\Theta_\mathbf{B}</code> for  <code class="reqn">\mathbf{B}</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Erdely, A., 2017, Copula-based piecewise regression (chap. 5)  <em>in</em> Copulas and dependence models with applications—Contributions in honor of Roger B. Nelsen, <em>eds.</em> Flores, U.M., Amo Artero, E., Durante, F., Sánchez, J.F.: Springer, Cham, Switzerland, ISBN 978–3–319–64220–9, <a href="https://doi.org/10.1007/978-3-319-64221-5">doi:10.1007/978-3-319-64221-5</a>.
</p>


<h3>See Also</h3>

<p><code>COP</code>, <code>breveCOP</code>, <code>composite1COP</code>, <code>composite2COP</code>, <code>composite3COP</code>, <code>convexCOP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
para &lt;- list(cop1=PLACKETTcop, para1=.2, cop2=GLcop, para2=1.2, glue=0.6)
densityCOPplot(cop=glueCOP, para=para) # 
## End(Not run)

## Not run: 
# Concerning Nelsen (2006, exam. 3.3, pp. 59-61)
# Concerning Erdely (2017, exam. 5.1, p. 71)
# Concerning Erdely (2017, exam. 5.2, p. 75)
# Nelsen's example is a triangle with vertex at [G, 1].
# Erdley's example permits the construction using glueCOP from M and W.
"coptri" &lt;- function(u,v, para=NA, ...) {
   p &lt;- para[1]; r &lt;- 1 - (1-p)*v
   if(length(u) &gt; 1 | length(v) &gt; 1) stop("only scalars for this function")
   if(0 &lt;= u &amp; u &lt;= p*v &amp; p*v &lt;= p) {            return(u)
   } else if(  0 &lt;= p*v &amp; p*v &lt;  u &amp; u &lt;  r) {   return(p*v)
   } else if(  p &lt;= r   &amp; r   &lt;= u &amp; u &lt;= 1 ) {  return(u+v-1)
   } else { stop("should not be here in logic") }
}
"UsersCop" &lt;- function(u,v, ...) { asCOP(u,v, f=coptri, ...) }
# Demonstrate Nelsen's triangular copula    (black dots )
UV &lt;- simCOP(cop=UsersCop, para=0.35, cex=0.5, pch=16)
# Add Erdley's gluing of M() and W() copula (red circles)
para &lt;- list(cop1=M, cop2=W, para1=NA, para2=NA, glue=0.35)
UV &lt;- simCOP(cop=glueCOP,  para=para, col=2,   ploton=FALSE)
# We see in the plot that the triangular copulas are the same.

# For G = 0.5, Erdley shows Spearman Rho = 2*G-1 = 0, but
#  Schweizer-Wolff = G^2 + (G-1)^2 = 0.5, let us check these:
para &lt;- list(cop1=M, cop2=W, para1=NA, para2=NA, glue=0.5)
rhoCOP( cop=glueCOP, para=para) # -2.181726e-17
wolfCOP(cop=glueCOP, para=para) #  0.4999953
# So, rhoCOP() indicates independence, but wolfCOP() indicates
# dependence at the minimum value possible for a triangular copula. 
## End(Not run)
</code></pre>


</div>