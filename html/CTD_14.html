<div class="container">

<table style="width: 100%;"><tr>
<td>mle.getPtBSbyK</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate patient-specific bitstrings</h2>

<h3>Description</h3>

<p>This function calculates the bitstrings (1 is a hit; 0 is a miss)
associated with a network walker which tries to find all nodes in
a given subset, S, in a given network, G.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mle.getPtBSbyK(S, ranks, num.misses = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>- A character vector of node names describing the node subset
to be encoded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranks</code></td>
<td>
<p>- The list of node ranks calculated over all possible nodes,
starting with each node in subset of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.misses</code></td>
<td>
<p>- The number of misses tolerated by the network walker
before path truncation occurs.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>pt.byK - a list of bitstrings, with the names of the list elements
the node names of the encoded nodes
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Get patient bitstrings for the first 2 patients in the Miller 2015 dataset.
data("Miller2015")
data_mx=Miller2015[-c(1,grep("x - ", rownames(Miller2015))),
                    grep("IEM", colnames(Miller2015))]
data_mx=apply(data_mx[,c(1,2)], c(1,2), as.numeric)
# Build an adjacency matrix for network G
adj_mat=matrix(0, nrow=nrow(data_mx), ncol=nrow(data_mx))
rows=sample(seq_len(ncol(adj_mat)), 0.1*ncol(adj_mat))
cols=sample(seq_len(ncol(adj_mat)), 0.1*ncol(adj_mat))
for(i in rows){for (j in cols){adj_mat[i, j]=rnorm(1,0,1)}}
colnames(adj_mat)=rownames(data_mx)
rownames(adj_mat)=rownames(data_mx)
G=vector("numeric", length=ncol(adj_mat))
names(G)=colnames(adj_mat)
# Look at the top 5 metabolites for each patient. 
kmx=5
topMets_allpts=c()
for (pt in seq_len(ncol(data_mx))) { 
    topMets_allpts=c(topMets_allpts,
                    rownames(data_mx)[order(abs(data_mx[,pt]),
                                            decreasing=TRUE)[seq_len(kmx)]])}
topMets_allpts=unique(topMets_allpts)
# Use a single-node or multi-node network walker.
# Here we use a single-node network walker.
ranks=list()
for (n in seq_len(length(topMets_allpts))) { 
    ind=which(names(G)==topMets_allpts[n])
    ranks[[n]]=singleNode.getNodeRanksN(ind,G,0.9,0.01,adj_mat,
                                        topMets_allpts,log2(length(G))) 
}
names(ranks)=topMets_allpts
ptBSbyK=list()
for (pt in seq_len(ncol(data_mx))) {
    S=rownames(data_mx)[order(abs(data_mx[,pt]),
                                decreasing=TRUE)[seq_len(kmx)]]
    ptBSbyK[[pt]]=mle.getPtBSbyK(S, ranks)
}
</code></pre>


</div>