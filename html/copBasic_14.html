<div class="container">

<table style="width: 100%;"><tr>
<td>CIRCcop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Copula of Circular Uniform Distribution</h2>

<h3>Description</h3>

<p>The <em>Circular copula</em> of the coordinates <code class="reqn">(x, y)</code> of a point chosen at random on the unit circle (Nelsen, 2006, p. 56) is given by
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\mathrm{CIRC}}(u,v) = \mathbf{M}(u,v) \mathrm{\ for\ }|u-v| &gt; 1/2\mathrm{,}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\mathrm{CIRC}}(u,v) = \mathbf{W}(u,v) \mathrm{\ for\ }|u+v-1| &gt; 1/2\mathrm{,\ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\mathrm{CIRC}}(u,v) = \frac{u+v}{2} - \frac{1}{4} \mathrm{\ otherwise\ }\mathrm{.}</code>
</p>

<p>The coordinates of the unit circle are given by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{CIRC}(x,y) = \biggl(\frac{\mathrm{cos}\bigl(\pi(u-1)\bigr)+1}{2}, \frac{\mathrm{cos}\bigl(\pi(v-1)\bigr)+1}{2}\biggr)\mathrm{.}</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">CIRCcop(u, v, para=NULL, as.circ=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Optional parameter list argument that can contain the logical <code>as.circ</code> instead;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.circ</code></td>
<td>
<p>A logical, if true, to trigger the transformation <code class="reqn">u = 1 - \mathrm{acos}(2x - 1) / \pi</code> and <code class="reqn">v = 1 - \mathrm{acos}(2y - 1) / \pi</code> to convert <code class="reqn">(X,Y)</code> coordinates of a uniform unit circle to the <code class="reqn">(U,V)</code> in nonexceedance probability; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass, if ever needed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>Examples</h3>

<pre><code class="language-R">CIRCcop(0.5, 0.5) # 0.25 quarterway along the diagonal upward to right
CIRCcop(0.5, 1  ) # 0.50 halfway across in horizontal direction
CIRCcop(1  , 0.5) # 0.50 halfway across in  vertical  direction

## Not run: 
  nsim &lt;- 2000
  rtheta &lt;- runif(nsim, min=0, max=2*pi) # polar coordinate simulation
  XY &lt;- data.frame(X=cos(rtheta)/2 + 1/2, Y=sin(rtheta)/2 + 1/2)
  plot(XY, lwd=0.8, col="lightgreen", xaxs="i", yaxs="i", las=1,
           xlab="X OF UNIT CIRCLE OR NONEXCEEDANCE PROBABILITY U",
           ylab="Y OF UNIT CIRCLE OR NONEXCEEDANCE PROBABILITY V")
  UV &lt;- simCOP(nsim, cop=CIRCcop, lwd=0.8, col="salmon3", ploton=FALSE)
  theta &lt;- 3/4*pi+0.1 # select a point on the upper left of the circle
  x &lt;- cos(theta)/2 + 1/2; y &lt;- sin(theta)/2 + 1/2 # coordinates
  H &lt;- CIRCcop(x, y, as.circ=TRUE) # 0.218169  # Pr[X &lt;= x &amp; Y &lt;= y]
  points(x, y, pch=16, col="forestgreen", cex=2)
  segments(0, y, x, y, lty=2, lwd=2, col="forestgreen")
  segments(x, 0, x, y, lty=2, lwd=2, col="forestgreen")
  Hemp1 &lt;- sum(XY$X &lt;= x &amp; XY$Y &lt;= y) / nrow(XY) # about 0.22 as expected
  u &lt;- 1-acos(2*x-1)/pi; v &lt;- 1-acos(2*y-1)/pi
  segments(0, v, u, v, lty=2, lwd=2, col="salmon3")
  segments(u, 0, u, v, lty=2, lwd=2, col="salmon3")
  points(u, v, pch=16, cex=2,        col="salmon3")
  arrows(x, y, u, v, code=2, lwd=2, angle=15) # arrow points from (X,Y) coordinate
  # specified by angle theta in radians on the unit circle to the corresponding
  # coordinate in (U,V) domain of uniform circular distribution copula
  Hemp2 &lt;- sum(UV$U &lt;= u &amp; UV$V &lt;= v) / nrow(UV) # about 0.22 as expected
  # Hemp1 and Hemp2 are about equal to each other and converge as nsim
  # gets very large, but the origin of the simulations to get to each
  # are different: (1) one in polar coordinates and (2) by copula.
  # Now, draw the level curve for the empirical Hs and as nsim gets large the two
  # lines will increasingly plot on top of each other.
  lshemp1 &lt;- level.setCOP(cop=CIRCcop, getlevel=Hemp1, lines=TRUE, col="blue", lwd=2)
  lshemp2 &lt;- level.setCOP(cop=CIRCcop, getlevel=Hemp2, lines=TRUE, col="blue", lwd=2)
  txt &lt;- paste0("level curves for Pr[X &lt;= x &amp; Y &lt;= y] and\n",
                "level curves for Pr[U &lt;= u &amp; V &lt;= v],\n",
                "which equal each other as nsim gets large")
  text(0.52, 0.52, txt, srt=-46, col="blue") # 
## End(Not run)

## Not run: 
  # Nelsen (2007, ex. 3.2, p. 57) # Singular bivariate distribution with
  # standard normal margins that is not bivariate normal.
  U &lt;- runif(500); V &lt;- simCOPmicro(U, cop=CIRCcop)
  X  &lt;- qnorm(U, mean=0, sd=1);    Y &lt;- qnorm(V, mean=0, sd=1)
  plot(X,Y, main="Nelsen (2007, ex. 3.2, p. 57)", xlim=c(-4,4), ylim=c(-4,4),
            lwd=0.8, col="turquoise")
  rug(X, side=1, col=grey(0,0.5), tcl=0.5)
  rug(Y, side=2, col=grey(0,0.5), tcl=0.5) #
## End(Not run)

## Not run: 
  DX &lt;- c(5, 5, -5, -5); DY &lt;- c(5, 5, -5, -5); D &lt;- 6; R &lt;- D/2
  plot(DX, DY, type="n", xlim=c(-10, 10), ylim=c(-10,10), xlab="X", ylab="Y")
  abline(h=DX, lwd=2, col="seagreen"); abline(v=DY, lwd=2, col="seagreen")
  for(i in seq_len(length(DX))) {
    for(j in seq_len(length(DY))) {
      UV &lt;- simCOP(n=30, cop=CIRCcop, pch=16, col="darkgreen", cex=0.5, graphics=FALSE)
      points(UV[,1]-0.5, UV[,2]-0.5, pch=16, col="darkgreen", cex=0.5)
      XY &lt;- data.frame(X=DX[i]+sign(DX[i])*D*(cos(pi*(UV$U-1))+1)/2-sign(DX[i])*R,
                       Y=DY[j]+sign(DY[j])*D*(cos(pi*(UV$V-1))+1)/2-sign(DY[j])*R)
      points(XY, lwd=0.8, col="darkgreen")
    }
    abline(h=DX[i]+R, lty=2, col="seagreen"); abline(h=DX[i]-R, lty=2, col="seagreen")
    abline(v=DY[i]+R, lty=2, col="seagreen"); abline(v=DY[i]-R, lty=2, col="seagreen")
  } #
## End(Not run)

## Not run: 
  para &lt;- list(cop1=CIRCcop, para1=NULL, cop2=W, para2=NULL, alpha=0.8, beta=0.8)
  UV &lt;- simCOP(n=2000, col="darkgreen", cop=composite2COP, para=para)
  XY &lt;- data.frame(X=(cos(pi*(UV$U-1))+1)/2, Y=(cos(pi*(UV$V-1))+1)/2)
  plot(XY, type="n", xlab=paste0("X OF CIRCULAR UNIFORM DISTRIBUTION OR\n",
                                 "NONEXCEEDANCD PROBABILITY OF U"),
                     ylab=paste0("Y OF CIRCULAR UNIFORM DISTRIBUTION OR\n",
                                 "NONEXCEEDANCD PROBABILITY OF V"))
  JK &lt;- data.frame(U=1 - acos(2*XY$X - 1)/pi, V=1 - acos(2*XY$Y - 1)/pi)
  segments(x0=UV$U, y0=UV$V, x1=XY$X, y1=XY$Y, col="lightgreen", lwd=0.8)
  points(XY, lwd=0.8, col="darkgreen")
  points(JK, pch=16,  col="darkgreen", cex=0.5)

  t &lt;- seq(0.001, 0.999, by=0.001)
  t &lt;- diagCOPatf(t, cop=composite2COP, para=para)
  AB &lt;- data.frame(X=(cos(pi*(t-1))+1)/2, Y=(cos(pi*(t-1))+1)/2)
  lines(AB, lwd=4, col="seagreen") #
## End(Not run)
</code></pre>


</div>