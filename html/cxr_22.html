<div class="container">

<table style="width: 100%;"><tr>
<td>cxr_er_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General optimization for effect-response models</h2>

<h3>Description</h3>

<p>Estimates parameters of user-specified models of competitive effects and responses.
NOTE: including covariates on competitive effects is still under development, in this version it is suggested not to use that feature.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cxr_er_fit(
  data,
  model_family = c("BH"),
  covariates = NULL,
  optimization_method = c("Nelder-Mead", "BFGS", "CG", "ucminf", "L-BFGS-B", "nlm",
    "nlminb", "Rcgmin", "Rvmmin", "spg", "bobyqa", "nmkb", "hjkb", "nloptr_CRS2_LM",
    "nloptr_ISRES", "nloptr_DIRECT_L_RAND", "DEoptimR", "GenSA"),
  lambda_cov_form = c("none", "global"),
  effect_cov_form = c("none", "global"),
  response_cov_form = c("none", "global"),
  initial_values = list(lambda = 1, effect = 1, response = 1, lambda_cov = 0, effect_cov
    = 0, response_cov = 0),
  lower_bounds = NULL,
  upper_bounds = NULL,
  fixed_terms = NULL,
  bootstrap_samples = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>either a list of dataframes or a single dataframe. if 'data' is a list, each element is a dataframe with the following columns:
</p>

<ul>
<li>
<p> fitness: fitness metric for each observation
</p>
</li>
<li>
<p> neighbours: named columns giving the number of neighbours of each column
the names of the list elements are taken to be the names of the focal species.
</p>
</li>
</ul>
<p>If 'data' is a dataframe, it also needs a 'focal' column.
Regardless of the data structure, all focal species need to have the same number of observations (i.e. same number of rows),
and the set of neighbour species needs to be the same as the set of focal species, so that
the neighbours columns correspond to the names of the list elements or, if 'data' is a dataframe,
to the values of the 'focal' column. Future versions will relax this requirement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_family</code></td>
<td>
<p>family of model to use. Available families are BH (Beverton-Holt), LV (Lotka-Volterra),
RK (Ricker), and LW (Law-Watkinson). Users may also define their own families and models (see vignette 4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>a data structure equivalent to 'data', in which each column are the values of a covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimization_method</code></td>
<td>
<p>numerical optimization method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_cov_form</code></td>
<td>
<p>form of the covariate effects on lambda. Either "none" (no covariate effects) or "global" (one estimate per covariate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect_cov_form</code></td>
<td>
<p>form of the covariate effects on competitive effects.
Either "none" (no covariate effects) or "global" (one estimate per covariate)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response_cov_form</code></td>
<td>
<p>form of the covariate effects on competitive responses.
Either "none" (no covariate effects) or "global" (one estimate per covariate)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_values</code></td>
<td>
<p>list with components "lambda","effect","response", and optionally
"lambda_cov", "effect_cov", "response_cov", specifying the initial values
for numerical optimization. Single values are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower_bounds</code></td>
<td>
<p>optional list with single values for "lambda", "effect","response",
and optionally "lambda_cov", "effect_cov", "response_cov".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_bounds</code></td>
<td>
<p>optional list with single values for "lambda", "effect","response",
and optionally "lambda_cov", "effect_cov", "response_cov".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_terms</code></td>
<td>
<p>optional list specifying which model parameters are fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap_samples</code></td>
<td>
<p>number of bootstrap samples for error calculation. Defaults to 0, i.e. no error is calculated.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of class 'cxr_er_fit' which is a list with the following components:
</p>

<ul>
<li>
<p> model_name: string with the name of the fitness model
</p>
</li>
<li>
<p> model: model function
</p>
</li>
<li>
<p> data: data supplied
</p>
</li>
<li>
<p> taxa: names of the taxa fitted
</p>
</li>
<li>
<p> covariates: covariate data supplied
</p>
</li>
<li>
<p> optimization_method: optimization method used
</p>
</li>
<li>
<p> initial_values: list with initial values
</p>
</li>
<li>
<p> fixed_terms: list with fixed terms
</p>
</li>
<li>
<p> lambda: fitted values for lambdas, or NULL if fixed
</p>
</li>
<li>
<p> effect: fitted values for competitive effects, or NULL if fixed
</p>
</li>
<li>
<p> response: fitted values for competitive responses, or NULL if fixed
</p>
</li>
<li>
<p> lambda_cov: fitted values for effect of covariates on lambdas, or NULL if fixed
</p>
</li>
<li>
<p> effect_cov: fitted values for effect of covariates on competitive effects, or NULL if fixed
</p>
</li>
<li>
<p> response_cov: fitted values for effect of covariates on competitive responses, or NULL if fixed
</p>
</li>
<li>
<p> lambda_standard_error: standard errors for lambdas, if calculated
</p>
</li>
<li>
<p> effect_standard_error: standard errors for competitive effects, if calculated
</p>
</li>
<li>
<p> response_standard_error: standard errors for competitive responses, if calculated
</p>
</li>
<li>
<p> lambda_cov_standard_error: standard errors for effect of covariates on lambdas, if calculated
</p>
</li>
<li>
<p> effect_cov_standard_error: standard errors for effect of covariates on competitive effects, if calculated
</p>
</li>
<li>
<p> response_cov_standard_error: standard errors for effect of covariates on competitive responses, if calculated
</p>
</li>
<li>
<p> log_likelihood: log-likelihood of the fits
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
# fit three species at once
data("neigh_list")
# these species all have &gt;250 observations
example_sp &lt;- c("BEMA","LEMA","HOMA")
sp.pos &lt;- which(names(neigh_list) %in% example_sp)
data &lt;- neigh_list[sp.pos]
n.obs &lt;- 250
# keep only fitness and neighbours columns
for(i in 1:length(data)){
  data[[i]] &lt;- data[[i]][1:n.obs,c(2,sp.pos+2)]#2:length(data[[i]])]
}

# covariates: salinity
data("salinity_list")
salinity &lt;- salinity_list[example_sp]
# keep only salinity column
for(i in 1:length(salinity)){
  salinity[[i]] &lt;- salinity[[i]][1:n.obs,2:length(salinity[[i]])]
}

initial_values = list(lambda = 1, 
                     effect = 1, 
                     response = 1
                     # lambda_cov = 0, 
                     # effect_cov = 0, 
                     # response_cov = 0
)
lower_bounds = list(lambda = 0, 
                   effect = 0, 
                   response = 0
                   # lambda_cov = 0, 
                   # effect_cov = 0, 
                   # response_cov = 0
)
upper_bounds = list(lambda = 100, 
                    effect = 10, 
                    response = 10
                   # lambda_cov = 0, 
                   # effect_cov = 0, 
                   # response_cov = 0
)

er_3sp &lt;- cxr_er_fit(data = data,
                     model_family = "BH",
                     # fit without covariates, 
                     # as it may be very computationally expensive
                     # covariates = salinity,
                     optimization_method = "bobyqa",
                     lambda_cov_form = "none",
                     effect_cov_form = "none",
                     response_cov_form = "none",
                     initial_values = initial_values,
                     lower_bounds = lower_bounds,
                     upper_bounds = upper_bounds,
                     # syntaxis for fixed values
                     # fixed_terms = list("response"),
                     bootstrap_samples = 3)
# brief summary
summary(er_3sp)

</code></pre>


</div>