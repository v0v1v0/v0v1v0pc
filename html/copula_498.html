<div class="container">

<table style="width: 100%;"><tr>
<td>K</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kendall Distribution Function for Archimedean Copulas</h2>

<h3>Description</h3>

<p>The <em>Kendall distribution</em> of an Archimedean
copula is defined by
</p>
<p style="text-align: center;"><code class="reqn">K(u) = P(C(U_1,U_2,\dots,U_d) \le u),</code>
</p>

<p>where <code class="reqn">u \in [0,1]</code>, and the <code class="reqn">d</code>-dimensional
<code class="reqn">(U_1,U_2,\dots,U_d)</code> is distributed according
to the copula <code class="reqn">C</code>.  Note that the random variable
<code class="reqn">C(U_1,U_2,\dots,U_d)</code> is known as
“probability integral transform”.  Its distribution function
<code class="reqn">K</code> is equal to the identity if <code class="reqn">d = 1</code>, but is non-trivial for
<code class="reqn">d \ge 2</code>.
</p>
<p><code>Kn()</code> computes the empirical Kendall distribution function,
<code>pK()</code> the distribution function (so <code class="reqn">K()</code> itself),
<code>qK()</code> the quantile function, <code>dK()</code> the density, and
<code>rK()</code> random number generation from <code class="reqn">K()</code> for an Archimedean
copula.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
Kn(u, x, method = c("GR", "GNZ")) # empirical Kendall distribution function
dK(u, copula, d, n.MC = 0, log.p = FALSE) # density
pK(u, copula, d, n.MC = 0, log.p = FALSE) # df
qK(p, copula, d, n.MC = 0, log.p = FALSE, # quantile function
   method = c("default", "simple", "sort", "discrete", "monoH.FC"),
   u.grid, xtraChecks = FALSE, ...)
rK(n, copula, d) # random number generation
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>evaluation point(s) (in <code class="reqn">[0,1]</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data (in the <code class="reqn">d</code>-dimensional space) based on which the
Kendall distribution function is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copula</code></td>
<td>
<p><code>acopula</code> with specified parameter, or
(currently for <code>rK</code> only) a <code>outer_nacopula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>dimension (not used when <code>copula</code> is an
<code>outer_nacopula</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.MC</code></td>
<td>
<p><code>integer</code>, if positive, a Monte Carlo approach
is applied with sample size equal to <code>n.MC</code> to evaluate the
generator derivatives involved; otherwise
(<code>n.MC = 0</code>) the exact formula is used based on the generator
derivatives as found by Hofert et al. (2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.p</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are given as <code class="reqn">\log p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>probabilities or log-probabilities if <code>log.p</code> is true.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>for <code>qK()</code>, character string for the method how to
compute the quantile function of <code class="reqn">K</code>; available are:
</p>

<dl>
<dt>"default"</dt>
<dd>
<p>default method. Currently chooses
<code>method="monoH.FC"</code> with <code>u.grid = 0:128/128</code>. This
is fast but not too accurate (see example).</p>
</dd>
<dt>"simple"</dt>
<dd>
<p>straightforward root finding based on
<code>uniroot</code>.</p>
</dd>
<dt>"sort"</dt>
<dd>
<p>root finding based on <code>uniroot</code> but
first sorting <code>u</code>.</p>
</dd>
<dt>"discrete"</dt>
<dd>
<p>first, <code class="reqn">K</code> is evaluated at the given grid
points <code>u.grid</code> (which should contain 0 and 1). Based on these
probabilities, quantiles are computed with <code>findInterval</code>.</p>
</dd>
<dt>"monoH.FC"</dt>
<dd>
<p>first, <code class="reqn">K</code> is evaluated at the given grid points
<code>u.grid</code>.  A monotone spline is then used to approximate <code class="reqn">K</code>.
Based on this approximation, quantiles are computed with
<code>uniroot</code>.</p>
</dd>
</dl>
<p>For <code>Kn()</code>, character string indicating the method according
to which the empirical Kendall distribution is computed; available are:
</p>

<dl>
<dt>"GR"</dt>
<dd>
<p>the default. Computed as in Genest and Rivest (1993,
Equations (4) and (5)).</p>
</dd>
<dt>"GNZ"</dt>
<dd>
<p>computed as in Genest et al. (2011, Equation (19) and
Lemma 1); this is guaranteed to satisfy that the estimator lies above
the diagonal at any point in [0,1).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u.grid</code></td>
<td>
<p>(for <code>method="discrete"</code>:) The grid on which
<code class="reqn">K</code> is evaluated, a <code>numeric</code> vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xtraChecks</code></td>
<td>
<p><em>experimental</em> logical indicating if extra
checks should be done before calling <code>uniroot()</code> in some cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>uniroot</code> (for
<code>method="default"</code>, <code>method="simple"</code>, <code>method="sort"</code>, and
<code>method="monoH.FC"</code>) or <code>findInterval</code> (for
<code>method="discrete"</code>), notably <code>tol</code>
(<code>uniroot</code>) for increased accuracy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size for <code>rK</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a completely monotone Archimedean generator <code class="reqn">\psi</code>,
</p>
<p style="text-align: center;"><code class="reqn">K(u)=\sum_{k=0}^{d-1}
    \frac{\psi^{(k)}(\psi^{-1}(u))}{k!} (-\psi^{-1}(u))^k,\ u\in[0,1];</code>
</p>

<p>see Barbe et al. (1996).  The corresponding density is
</p>
<p style="text-align: center;"><code class="reqn">\frac{(-1)^d\psi^{(d)}(\psi^{-1}(u))}{(d-1)!}
    (-(\psi^{-1})'(u))(\psi^{-1}(u))^{d-1}</code>
</p>



<h3>Value</h3>

<p>The empirical Kendall distribution function, density, distribution
function, quantile function and random number generator.
</p>


<h3>Note</h3>

<p>Currently, the <code>"default"</code> method of <code>qK()</code> is fast but
not very accurate, see the ‘Examples’ for more accuracy (with
more CPU effort).
</p>


<h3>References</h3>

<p>Barbe, P., Genest, C., Ghoudi, K., and Rémillard, B. (1996),
On Kendall's Process,
<em>Journal of Multivariate Analysis</em> <b>58</b>, 197–229.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133–150. <a href="https://doi.org/10.1016/j.jmva.2012.02.019">doi:10.1016/j.jmva.2012.02.019</a>
</p>
<p>Genest, C. and Rivest, L.-P. (1993). Statistical inference procedures
for bivariate Archimedean copulas.
<em>Journal of the American Statistical Association</em> <b>88</b>, 1034–1043.
</p>
<p>Genest, C., G. Nešlehová, J., and Ziegel, J. (2011).
Inference in multivariate Archimedean copula models. <em>TEST</em>
<b>20</b>, 223–256.
</p>


<h3>See Also</h3>

<p><code>htrafo</code> or <code>emde</code> (where <code>K</code> is used);
<code>splinefun(*, "monoHC")</code> for that method.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tau &lt;- 0.5
(theta &lt;- copGumbel@iTau(tau)) # 2
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

## Basic check of the empirical Kendall distribution function
set.seed(271)
n &lt;- 1000
U &lt;- rCopula(n, copula = cop)
X &lt;- qnorm(U)
K.sample &lt;- pCopula(U, copula = cop)
u &lt;- seq(0, 1, length.out = 256)
edfK &lt;- ecdf(K.sample)
plot(u, edfK(u), type = "l", ylim = 0:1,
     xlab = quote(italic(u)), ylab = quote(K[n](italic(u)))) # simulated
K.n &lt;- Kn(u, x = X)
lines(u, K.n, col = "royalblue3") # Kn
## Difference at 0
edfK(0) # edf of K at 0
K.n[1] # K_n(0); this is &gt; 0 since K.n is the edf of a discrete distribution
## =&gt; therefore, Kn(K.sample, x = X) is not uniform
plot(Kn(K.sample, x = X), ylim = 0:1)
## Note: Kn(0) -&gt; 0 for n -&gt; Inf

## Compute Kendall distribution function
u &lt;- seq(0,1, length.out = 255)
Ku    &lt;- pK(u, copula = cop@copula, d = d) # exact
Ku.MC &lt;- pK(u, copula = cop@copula, d = d, n.MC = 1000) # via Monte Carlo
stopifnot(all.equal(log(Ku),
		    pK(u, copula = cop@copula, d = d, log.p=TRUE)))# rel.err 3.2e-16

## Build sample from K
set.seed(1)
n &lt;- 200
W &lt;- rK(n, copula = cop)

## Plot empirical distribution function based on W
## and the corresponding theoretical Kendall distribution function
## (exact and via Monte Carlo)
plot(ecdf(W), col = "blue", xlim = 0:1, verticals=TRUE,
     main = quote("Empirical"~ F[n](C(U)) ~
                     "and its Kendall distribution" ~ K(u)),
     do.points = FALSE, asp = 1)
abline(0,1, lty = 2); abline(h = 0:1, v = 0:1, lty = 3, col = "gray")
lines(u, Ku.MC, col = "red") # not quite monotone
lines(u, Ku, col = "black")  # strictly  monotone:
stopifnot(diff(Ku) &gt;= 0)
legend(.25, .75, expression(F[n], K[MC](u), K(u)),
       col=c("blue" , "red", "black"), lty = 1, lwd = 1.5, bty = "n")

if(require("Rmpfr")) { # pK() now also works with high precision numbers:
 uM &lt;- mpfr(0:255, 99)/256
 if(FALSE) {
   # not yet, now fails in  polyG() :
   KuM &lt;- pK(uM, copula = cop@copula, d = d)
  ##  debug(copula:::.pK)
  debug(copula:::polyG)
 }
}# if( Rmpfr )


## Testing qK
pexpr &lt;- quote( 0:63/63 );  p &lt;- eval(pexpr)
d &lt;- 10
cop &lt;- onacopulaL("Gumbel", list(theta = 2, 1:d))
system.time(qK0 &lt;- qK(p, copula = cop@copula, d = d)) # "default" - fast


system.time(qK1  &lt;- qK(p, copula= cop@copula, d=d, method = "simple"))
system.time(qK1. &lt;- qK(p, copula= cop@copula, d=d, method = "simple", tol = 1e-12))
system.time(qK2  &lt;- qK(p, copula= cop@copula, d=d, method = "sort"))
system.time(qK2. &lt;- qK(p, copula= cop@copula, d=d, method = "sort",   tol = 1e-12))
system.time(qK3  &lt;- qK(p, copula= cop@copula, d=d, method = "discrete", u.grid = 0:1e4/1e4))
system.time(qK4  &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e2/5e2))
system.time(qK4. &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e2/5e2, tol = 1e-12))
system.time(qK5  &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e3/5e3))
system.time(qK5. &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e3/5e3, tol = 1e-12))
system.time(qK6  &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = (0:5e3/5e3)^2))
system.time(qK6. &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = (0:5e3/5e3)^2, tol = 1e-12))

## Visually they all coincide :
cols &lt;- adjustcolor(c("gray50", "gray80", "light blue",
                      "royal blue", "purple3", "purple4", "purple"), 0.6)
matplot(p, cbind(qK0, qK1, qK2, qK3, qK4, qK5, qK6), type = "l", lwd = 2*7:1, lty = 1:7, col = cols,
        xlab = bquote(p == .(pexpr)), ylab = quote({K^{-1}}(u)),
        main = "qK(p, method = *)")
legend("topleft", col = cols, lwd = 2*7:1, lty = 1:7, bty = "n", inset = .03,
       legend= paste0("method= ",
             sQuote(c("default", "simple", "sort",
                      "discrete(1e4)", "monoH.FC(500)", "monoH.FC(5e3)", "monoH.FC(*^2)"))))

## See they *are* inverses  (but only approximately!):
eqInv &lt;- function(qK) all.equal(p, pK(qK, cop@copula, d=d), tol=0)

eqInv(qK0 ) # "default"	       0.03  worst
eqInv(qK1 ) # "simple"	       0.0011 - best
eqInv(qK1.) # "simple", e-12   0.00000 (8.73 e-13) !
eqInv(qK2 ) # "sort"	       0.0013 (close)
eqInv(qK2.) # "sort", e-12     0.00000 (7.32 e-12)
eqInv(qK3 ) # "discrete"       0.0026
eqInv(qK4 ) # "monoH.FC(500)"  0.0095
eqInv(qK4.) # "m.H.FC(5c)e-12" 0.00963
eqInv(qK5 ) # "monoH.FC(5e3)"  0.001148
eqInv(qK5.) # "m.H.FC(5k)e-12" 0.000989
eqInv(qK6 ) # "monoH.FC(*^2)"  0.001111
eqInv(qK6.) # "m.H.FC(*^2)e-12"0.00000 (1.190 e-09)

## and ensure the differences are not too large
stopifnot(
 all.equal(qK0, qK1, tol = 1e-2) # !
 ,
 all.equal(qK1, qK2, tol = 1e-4)
 ,
 all.equal(qK2, qK3, tol = 1e-3)
 ,
 all.equal(qK3, qK4, tol = 1e-3)
 ,
 all.equal(qK4, qK0, tol = 1e-2) # !
)


stopifnot(all.equal(p, pK(qK0, cop@copula, d=d), tol = 0.04))
</code></pre>


</div>