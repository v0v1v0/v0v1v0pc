<div class="container">

<table style="width: 100%;"><tr>
<td>stress</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conciseness of Presentation Measures</h2>

<h3>Description</h3>

<p>Compute different types of conciseness of presentation measures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stress(x, rows = NULL, cols = NULL, type = "moore")

stress.dist(x, rows = NULL, cols = NULL, bycol = FALSE,
            type = "moore")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>a subscript vector indexing the rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>a subscript vector indexing the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bycol</code></td>
<td>
<p>logical for computation over the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the type of neighborhood to use.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>stress</code> computes the sum of squared distances of each
matrix entry from its adjacent entries. The following types of neighborhoods
are available:
</p>

<dl>
<dt>
<code>moore</code>:</dt>
<dd>
<p>comprises the eight adjacent entries (five at the
margins and three at the corners).</p>
</dd>
<dt>
<code>neumann</code>:</dt>
<dd>
<p>comprises the four adjacent entries (three at the
margins and two at the corners).</p>
</dd>
</dl>
<p>Function <code>stress.dist</code> computes the auto-distance matrix for each pair
of rows (or columns) given one of the above stress measures. Note that the
result depends on the ordering of the unused dimension.
</p>
<p>As the computation can be reduced to summing the edge distances between any
two neighboring points, only half of the value of the proposed measures is
reported.
</p>
<p>Row and/or column indexes (or labels) can be supplied to test specific
orderings, as well as subsets of indexes (labels).
</p>
<p>Note that the matrix should be normalized so that the distance computation
is meaningful.
</p>


<h3>Value</h3>

<p><code>stress</code> returns a scalar real, i.e. half of the global stress measure.
</p>
<p><code>stress.dist</code> returns an object of class <code>dist</code>, i.e. a
lower triangular matrix in column format.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code>dist</code> for general distance computation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
x1 &lt;- matrix(sample(c(FALSE,TRUE),25,rep=TRUE),ncol=5)
stress(x1)
stress(x1, type="neumann")
##
x2 &lt;- cbind(rbind(matrix(1,4,4),matrix(0,4,4)), 
	    rbind(matrix(0,4,4),matrix(1,4,4)))
stress.dist(x2)
stress.dist(x2, bycol=TRUE)
stress.dist(x2, type="neumann")
## Not run: 
##
(res &lt;- stress(x2, rows=c(1,8)))
rownames(x2) &lt;- c(letters[1:7], "ä")
stopifnot(identical(res, stress(x2, rows=c("a","ä"))))
stopifnot(identical(res, stress(x2, rows=c("a",iconv("ä", to="latin1")))))

## End(Not run)
</code></pre>


</div>