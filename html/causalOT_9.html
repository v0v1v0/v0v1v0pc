<div class="container">

<table style="width: 100%;"><tr>
<td>cotOptions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Options available for the COT method</h2>

<h3>Description</h3>

<p>Options available for the COT method
</p>


<h3>Usage</h3>

<pre><code class="language-R">cotOptions(
  lambda = NULL,
  delta = NULL,
  opt.direction = c("dual", "primal"),
  debias = TRUE,
  p = 2,
  cost.function = NULL,
  cost.online = "auto",
  diameter = NULL,
  balance.formula = NULL,
  quick.balance.function = TRUE,
  grid.length = 7L,
  torch.optimizer = torch::optim_rmsprop,
  torch.scheduler = torch::lr_multiplicative,
  niter = 2000,
  nboot = 100L,
  lambda.bootstrap = 0.05,
  tol = 1e-04,
  device = NULL,
  dtype = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The penalty parameter for the entropy penalized optimal transport. Default is NULL. Can be a single number or a set of numbers to try.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The bound for balancing functions if they are being used. Only available for biased entropy penalized optimal transport. Can be a single number or a set of numbers to try.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.direction</code></td>
<td>
<p>Should the optimizer solve the primal or dual problems. Should be one of "dual" or "primal" with a default of "dual" since it is typically faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debias</code></td>
<td>
<p>Should debiased optimal transport be used? TRUE or FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The power of the cost function to use for the cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost.function</code></td>
<td>
<p>A function to calculate the pairwise costs. Should take arguments <code>x1</code>, <code>x2</code>, and <code>p</code>. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost.online</code></td>
<td>
<p>Should an online cost algorithm be used? One of "auto", "online", or "tensorized". "tensorized" is the offline option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diameter</code></td>
<td>
<p>The diameter of the covariate space, if known. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance.formula</code></td>
<td>
<p>Formula for the balancing functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quick.balance.function</code></td>
<td>
<p>TRUE or FALSE denoting whether balance function constraints should be selected via a linear program (TRUE) or just checked for feasibility (FALSE). Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid.length</code></td>
<td>
<p>The number of penalty parameters to explore in a grid search if none are provided in arguments <code>lambda</code> or <code>delta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>torch.optimizer</code></td>
<td>
<p>The torch optimizer to use for methods using debiased entropy penalized optimal transport. If <code>debiased</code> is FALSE or <code>opt.direction</code> is "primal", will default to <code>torch::optim_lbfgs()</code>. Otherwise <code>torch::optim_rmsprop()</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>torch.scheduler</code></td>
<td>
<p>The scheduler for the optimizer. Defaults to <code>torch::lr_multiplicative()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>The number of iterations to run the solver</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>The number of iterations for the bootstrap to select the final penalty parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.bootstrap</code></td>
<td>
<p>The penalty parameter to use for the bootstrap hyperparameter selection of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance for convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>device</code></td>
<td>
<p>An object of class <code>torch_device</code> denoting which device the data will be located on. Default is NULL which will try to use a gpu if available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p>An object of class <code>torch_dtype</code> that determines data type of the data, i.e. double, float, integer. Default is NULL which will try to select for you.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to the solvers. See details</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class <code>cotOptions</code> with the following slots
</p>

<ul>
<li> <p><code>lambda</code>The penalty parameter for the optimal transport distance
</p>
</li>
<li> <p><code>delta</code>The constraint for the balancing functions
</p>
</li>
<li> <p><code>opt.direction</code> Whether to solve the primal or dual optimization problems
</p>
</li>
<li> <p><code>debias</code>TRUE or FALSE if debiased optimal transport distances are used
</p>
</li>
<li> <p><code>balance.formula</code> The formula giving how to generate the balancing functions.
</p>
</li>
<li> <p><code>quick.balance.function</code> TRUE or FALSE whether quick balance functions will be run.
</p>
</li>
<li> <p><code>grid.length</code> The number of parameters to check in a grid search of best parameters
</p>
</li>
<li> <p><code>p</code> The power of the cost function
</p>
</li>
<li> <p><code>cost.online</code> Whether online costs are used
</p>
</li>
<li> <p><code>cost.function</code> The user supplied cost function if supplied.
</p>
</li>
<li> <p><code>diameter</code> The diameter of the covariate space.
</p>
</li>
<li> <p><code>torch.optimizer</code> The <code>torch</code> optimizer used for Sinkhorn Divergences
</p>
</li>
<li> <p><code>torch.scheduler</code> The scheduler for the <code>torch</code> optimizer
</p>
</li>
<li> <p><code>solver.options</code> The arguments to be passeed to the <code>torch.optimizer</code>
</p>
</li>
<li> <p><code>scheduler.options</code> The arguments to be passeed to the <code>torch.scheduler</code>
</p>
</li>
<li> <p><code>osqp.options</code> Arguments passed to the <code>osqp</code> function if quick balance functions are used.
</p>
</li>
<li> <p><code>niter</code> The number of iterations to run the solver
</p>
</li>
<li> <p><code>nboot</code> The number of bootstrap samples
</p>
</li>
<li> <p><code>lambda.bootstrap</code> The penalty parameter to use for the bootstrap hyperparameter selection.
</p>
</li>
<li> <p><code>tol</code> The tolerance for convergence.
</p>
</li>
<li> <p><code>device</code> An object of class <code>torch_device</code>.
</p>
</li>
<li> <p><code>dtype</code> An object of class <code>torch_dtype</code>.
</p>
</li>
</ul>
<h3>Solvers and distances</h3>

<p>The function is setup to direct the COT optimizer to run two basic methods: debiased entropy penalized optimal transport (Sinkhorn Divergences) or entropy penalized optimal transport (Sinkhorn Distances).
</p>


<h4>Sinkhorn Distances</h4>

<p>The optimal transport problem solved is <code class="reqn">min_w OT_\lambda(w,b) </code> where </p>
<p style="text-align: center;"><code class="reqn">OT_\lambda(w,b) = \sum_{ij} C(x_i, x_j) P_{ij} + \lambda \sum_{ij} P_{ij}\log(P_{ij}),</code>
</p>
<p> such that the rows of the matrix <code class="reqn">P_{ij}</code> sum to <code class="reqn">w</code> and the columns sum to <code class="reqn">b</code>. In this case <code class="reqn">C(,)</code> is the cost between units i and j.
</p>



<h4>Sinkhorn Divergences</h4>

<p>The Sinkhorn Divergence solves </p>
<p style="text-align: center;"><code class="reqn">min_w OT_\lambda(w,b) - 0.5 OT_\lambda(w,w) - 0.5 * OT_\lambda(b,b).</code>
</p>
<p> The solver for this function uses the <code>torch</code> package in <code>R</code> and by default will use the <code>optim_rmsprop</code> solver. Your desired <code>torch</code> optimizer can be passed via <code>torch.optimizer</code> with a scheduler passed via <code>torch.scheduler</code>. GPU support is available as detailed in the <code>torch</code> package. Additional arguments in <code>...</code> are passed as extra arguments to the <code>torch</code> optimizer and schedulers as appropriate.
</p>



<h3>Function balancing</h3>

<p>There may be certain functions of the covariates that we wish to balance within some tolerance, <code class="reqn">\delta</code>. For these functions <code class="reqn">B</code>, we will desire
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sum_{i: Z_i = 0} w_i B(x_i) - \sum_{j: Z_j = 1} B(x_j)/n_1}{\sigma} \leq \delta</code>
</p>
<p>, where in this case we are targeting balance with the treatment group for the ATT. <code class="reqn">\sigma</code> is the pooled standard deviation prior to balancing.
</p>


<h3>Cost functions</h3>

<p>The cost function specifies pairwise distances. If argument <code>cost.function</code> is NULL, the function will default to using <code class="reqn">L_p^p</code> distances with a default <code class="reqn">p = 2</code> supplied by the argument <code>p</code>. So for <code>p = 2</code>, the cost between units <code class="reqn">x_i</code> and <code class="reqn">x_j</code> will be </p>
<p style="text-align: center;"><code class="reqn">C(x_i, x_j) = \frac{1}{2} \| x_i - x_j \|_2^2.</code>
</p>

<p>If <code>cost.function</code> is provided, it should be a function that takes arguments <code>x1</code>, <code>x2</code>, and <code>p</code>: <code>function(x1, x2, p){...}</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if ( torch::torch_is_installed()) {
opts1 &lt;- cotOptions(lambda = 1e3, torch.optimizer = torch::optim_rmsprop)
opts2 &lt;- cotOptions(lambda = NULL)
opts3 &lt;- cotOptions(lambda = seq(0.1, 100, length.out = 7))
}
</code></pre>


</div>