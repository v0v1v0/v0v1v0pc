<div class="container">

<table style="width: 100%;"><tr>
<td>predict</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict indicator scores</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt="[Maturing]"></a>
</p>


<h3>Usage</h3>

<pre><code class="language-R">predict(
 .object                   = NULL,
 .benchmark                = c("lm", "unit", "PLS-PM", "GSCA", "PCA", "MAXVAR", "NA"),
 .approach_predict         = c("earliest", "direct"),
 .cv_folds                 = 10,
 .handle_inadmissibles     = c("stop", "ignore", "set_NA"),
 .r                        = 1,
 .test_data                = NULL,
 .approach_score_target    = c("mean", "median", "mode"),
 .sim_points               = 100,
 .disattenuate             = TRUE,
 .treat_as_continuous      = TRUE,
 .approach_score_benchmark = c("mean", "median", "mode", "round"),
 .seed                     = NULL
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.object</code></td>
<td>
<p>An R object of class cSEMResults resulting from a call to <code>csem()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.benchmark</code></td>
<td>
<p>Character string. The procedure to obtain benchmark predictions.
One of "<em>lm</em>", "<em>unit</em>", "<em>PLS-PM</em>", "<em>GSCA</em>", "<em>PCA</em>", "<em>MAXVAR</em>", or "<em>NA</em>".
Default to "<em>lm</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.approach_predict</code></td>
<td>
<p>Character string. Which approach should be used to perform
predictions? One of "<em>earliest</em>" and "<em>direct</em>". If "<em>earliest</em>" predictions
for indicators associated to endogenous constructs are performed using only
indicators associated to exogenous constructs. If "<em>direct</em>", predictions for
indicators associated to endogenous constructs are based on indicators associated
to their direct antecedents. Defaults to "<em>earliest</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.cv_folds</code></td>
<td>
<p>Integer. The number of cross-validation folds to use. Setting
<code>.cv_folds</code> to <code>N</code> (the number of observations) produces
leave-one-out cross-validation samples. Defaults to <code>10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of "<em>stop</em>", "<em>ignore</em>", or "<em>set_NA</em>". If "<em>stop</em>", <code>predict()</code>
will stop immediately if estimation yields an inadmissible result.
For "<em>ignore</em>" all results are returned even if all or some of the estimates
yielded inadmissible results.
For "<em>set_NA</em>" predictions based on inadmissible parameter estimates are
set to <code>NA</code>. Defaults to "<em>stop</em>"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.r</code></td>
<td>
<p>Integer. The number of repetitions to use. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.test_data</code></td>
<td>
<p>A matrix of test data with the same column names as the
training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.approach_score_target</code></td>
<td>
<p>Character string. How should the aggregation of the estimates of
the truncated normal distribution for the predictions using OrdPLS/OrdPLSc be done?
One of "<em>mean</em>", "<em>median</em>" or "<em>mode</em>".
If "<em>mean</em>", the mean of the estimated endogenous indicators is calculated.
If "<em>median</em>", the mean of the estimated endogenous indicators is calculated.
If "<em>mode</em>", the maximum empirical density on the intervals defined by the thresholds
is used. Defaults to "<em>mean</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.sim_points</code></td>
<td>
<p>Integer. How many samples from the truncated normal distribution should
be simulated to estimate the exogenous construct scores? Defaults to "<em>100</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.disattenuate</code></td>
<td>
<p>Logical. Should the benchmark predictions be based on
disattenuated parameter estimates? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.treat_as_continuous</code></td>
<td>
<p>Logical. Should the indicators for the benchmark predictions
be treated as continuous? If <code>TRUE</code> all indicators are treated as continuous and PLS-PM/PLSc is applied.
If <code>FALSE</code> OrdPLS/OrdPLSc is applied. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.approach_score_benchmark</code></td>
<td>
<p>Character string. How should the aggregation
of the estimates of the truncated normal distribution be done for the
benchmark predictions? Ignored if not OrdPLS or OrdPLSc is used to obtain benchmark predictions.
One of "<em>mean</em>", "<em>median</em>", "<em>mode</em>" or "<em>round</em>".
If "<em>round</em>", the benchmark predictions are obtained using the traditional prediction
algorithm for PLS-PM which are rounded for categorical indicators.
If "<em>mean</em>", the mean of the estimated endogenous indicators is calculated.
If "<em>median</em>", the mean of the estimated endogenous indicators is calculated.
If "<em>mode</em>", the maximum empirical density on the intervals defined by the thresholds
is used.
If <code>.treat_as_continuous = TRUE</code> or if all indicators are on a continuous scale,
<code>.approach_score_benchmark</code> is ignored. Defaults to "<em>round</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The predict function implements the procedure introduced by Shmueli et al. (2016) in the PLS context
known as "PLSPredict" (Shmueli et al. 2019) including its variants PLScPredcit, OrdPLSpredict and OrdPLScpredict.
It is used to predict the indicator scores of endogenous constructs and to evaluate the out-of-sample predictive power
of a model.
For that purpose, the predict function uses k-fold cross-validation to randomly
split the data into training and test datasets, and subsequently predicts the
values of the test data based on the model parameter estimates obtained
from the training data. The number of cross-validation folds is 10 by default but
may be changed using the <code>.cv_folds</code> argument.
By default, the procedure is not repeated (<code>.r = 1</code>). You may choose to repeat
cross-validation by setting a higher <code>.r</code> to be sure not to have a particular
(unfortunate) split. See Shmueli et al. (2019) for
details. Typically <code>.r = 1</code> should be sufficient though.
</p>
<p>Alternatively, users may supply a test dataset as matrix or a data frame of <code>.test_data</code> with
the same column names as those in the data used to obtain <code>.object</code> (the training data).
In this case, arguments <code>.cv_folds</code> and <code>.r</code> are
ignored and predict uses the estimated coefficients from <code>.object</code> to
predict the values in the columns of <code>.test_data</code>.
</p>
<p>In Shmueli et al. (2016) PLS-based predictions for indicator <code>i</code>
are compared to the predictions based on a multiple regression of indicator <code>i</code>
on all available exogenous indicators (<code>.benchmark = "lm"</code>) and
a simple mean-based prediction summarized in the Q2_predict metric.
<code>predict()</code> is more general in that is allows users to compare the predictions
based on a so-called target model/specification to predictions based on an
alternative benchmark. Available benchmarks include predictions
based on a linear model, PLS-PM weights, unit weights (i.e. sum scores),
GSCA weights, PCA weights, and MAXVAR weights.
</p>
<p>Each estimation run is checked for admissibility using <code>verify()</code>. If the
estimation yields inadmissible results, <code>predict()</code> stops with an error (<code>"stop"</code>).
Users may choose to <code>"ignore"</code> inadmissible results or to simply set predictions
to <code>NA</code> (<code>"set_NA"</code>) for the particular run that failed.
</p>


<h3>Value</h3>

<p>An object of class <code>cSEMPredict</code> with print and plot methods.
Technically, <code>cSEMPredict</code> is a
named list containing the following list elements:
</p>

<dl>
<dt><code style="white-space: pre;">⁠$Actual⁠</code></dt>
<dd>
<p>A matrix of the actual values/indicator scores of the endogenous constructs.</p>
</dd>
<dt><code style="white-space: pre;">⁠$Prediction_target⁠</code></dt>
<dd>
<p>A list containing matrices of the predicted indicator
scores of the endogenous constructs based on the target model for each repetition
.r. Target refers to procedure used to estimate the parameters in <code>.object</code>.</p>
</dd>
<dt><code style="white-space: pre;">⁠$Residuals_target⁠</code></dt>
<dd>
<p>A list of matrices of the residual indicator scores
of the endogenous constructs based on the target model in each repetition .r.</p>
</dd>
<dt><code style="white-space: pre;">⁠$Residuals_benchmark⁠</code></dt>
<dd>
<p>A list of matrices of the residual indicator scores
of the endogenous constructs based on a model estimated by the procedure
given to <code>.benchmark</code> for each repetition .r.</p>
</dd>
<dt><code style="white-space: pre;">⁠$Prediction_metrics⁠</code></dt>
<dd>
<p>A data frame containing the predictions metrics
MAE, RMSE, Q2_predict, the misclassification error rate (MER), the MAPE, the MSE2,
Theil's forecast accuracy (U1), Theil's forecast quality (U2), Bias proportion
of MSE (UM), Regression proportion of MSE (UR), and disturbance proportion
of MSE (UD) (Hora and Campos 2015; Watson and Teelucksingh 2002).</p>
</dd>
<dt><code style="white-space: pre;">⁠$Information⁠</code></dt>
<dd>
<p>A list with elements
<code>Target</code>, <code>Benchmark</code>,
<code>Number_of_observations_training</code>, <code>Number_of_observations_test</code>, <code>Number_of_folds</code>,
<code>Number_of_repetitions</code>, and <code>Handle_inadmissibles</code>.</p>
</dd>
</dl>
<h3>References</h3>

<p>Hora J, Campos P (2015).
“A review of performance criteria to validate simulation models.”
<em>Expert Systems</em>, <b>32</b>(5), 578–595.
<a href="https://doi.org/10.1111/exsy.12111">doi:10.1111/exsy.12111</a>.<br><br> Shmueli G, Ray S, Estrada JMV, Chatla SB (2016).
“The Elephant in the Room: Predictive Performance of PLS Models.”
<em>Journal of Business Research</em>, <b>69</b>(10), 4552–4564.
<a href="https://doi.org/10.1016/j.jbusres.2016.03.049">doi:10.1016/j.jbusres.2016.03.049</a>.<br><br> Shmueli G, Sarstedt M, Hair JF, Cheah J, Ting H, Vaithilingam S, Ringle CM (2019).
“Predictive Model Assessment in PLS-SEM: Guidelines for Using PLSpredict.”
<em>European Journal of Marketing</em>, <b>53</b>(11), 2322–2347.
<a href="https://doi.org/10.1108/ejm-02-2019-0189">doi:10.1108/ejm-02-2019-0189</a>.<br><br> Watson PK, Teelucksingh SS (2002).
<em>A practical introduction to econometric methods: Classical and modern</em>.
University of West Indies Press, Mona, Jamaica.
</p>


<h3>See Also</h3>

<p>csem, cSEMResults, <code>exportToExcel()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Anime example taken from https://github.com/ISS-Analytics/pls-predict/

# Load data
data(Anime) # data is similar to the Anime.csv found on 
            # https://github.com/ISS-Analytics/pls-predict/ but with irrelevant
            # columns removed

# Split into training and data the same way as it is done on 
# https://github.com/ISS-Analytics/pls-predict/
set.seed(123)

index     &lt;- sample.int(dim(Anime)[1], 83, replace = FALSE)
dat_train &lt;- Anime[-index, ]
dat_test  &lt;- Anime[index, ]

# Specify model
model &lt;- "
# Structural model

ApproachAvoidance ~ PerceivedVisualComplexity + Arousal

# Measurement/composite model

ApproachAvoidance         =~ AA0 + AA1 + AA2 + AA3
PerceivedVisualComplexity &lt;~ VX0 + VX1 + VX2 + VX3 + VX4
Arousal                   &lt;~ Aro1 + Aro2 + Aro3 + Aro4
"

# Estimate (replicating the results of the `simplePLS()` function)
res &lt;- csem(dat_train, 
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using a user-supplied training data set
pp &lt;- predict(res, .test_data = dat_test)
pp

### Compute prediction metrics  ------------------------------------------------
res2 &lt;- csem(Anime, # whole data set
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using 10-fold cross-validation
## Not run: 
pp2 &lt;- predict(res, .benchmark = "lm")
pp2
## There is a plot method available
plot(pp2)
## End(Not run)

### Example using OrdPLScPredict -----------------------------------------------
# Transform the numerical indicators into factors
## Not run: 
data("BergamiBagozzi2000")
data_new &lt;- data.frame(cei1    = as.ordered(BergamiBagozzi2000$cei1),
                       cei2    = as.ordered(BergamiBagozzi2000$cei2),
                       cei3    = as.ordered(BergamiBagozzi2000$cei3),
                       cei4    = as.ordered(BergamiBagozzi2000$cei4),
                       cei5    = as.ordered(BergamiBagozzi2000$cei5),
                       cei6    = as.ordered(BergamiBagozzi2000$cei6),
                       cei7    = as.ordered(BergamiBagozzi2000$cei7),
                       cei8    = as.ordered(BergamiBagozzi2000$cei8),
                       ma1     = as.ordered(BergamiBagozzi2000$ma1),
                       ma2     = as.ordered(BergamiBagozzi2000$ma2),
                       ma3     = as.ordered(BergamiBagozzi2000$ma3),
                       ma4     = as.ordered(BergamiBagozzi2000$ma4),
                       ma5     = as.ordered(BergamiBagozzi2000$ma5),
                       ma6     = as.ordered(BergamiBagozzi2000$ma6),
                       orgcmt1 = as.ordered(BergamiBagozzi2000$orgcmt1),
                       orgcmt2 = as.ordered(BergamiBagozzi2000$orgcmt2),
                       orgcmt3 = as.ordered(BergamiBagozzi2000$orgcmt3),
                       orgcmt5 = as.ordered(BergamiBagozzi2000$orgcmt5),
                       orgcmt6 = as.ordered(BergamiBagozzi2000$orgcmt6),
                       orgcmt7 = as.ordered(BergamiBagozzi2000$orgcmt7),
                       orgcmt8 = as.ordered(BergamiBagozzi2000$orgcmt8))

model &lt;- "
# Measurement models
OrgPres =~ cei1 + cei2 + cei3 + cei4 + cei5 + cei6 + cei7 + cei8
OrgIden =~ ma1 + ma2 + ma3 + ma4 + ma5 + ma6
AffJoy  =~ orgcmt1 + orgcmt2 + orgcmt3 + orgcmt7
AffLove =~ orgcmt5 + orgcmt 6 + orgcmt8

# Structural model
OrgIden ~ OrgPres
AffLove ~ OrgIden
AffJoy  ~ OrgIden 
"
# Estimate using cSEM; note: the fact that indicators are factors triggers OrdPLSc
res &lt;- csem(.model = model, .data = data_new[1:250,])
summarize(res)

# Predict using OrdPLSPredict
set.seed(123)
pred &lt;- predict(
  .object = res, 
  .benchmark = "PLS-PM",
  .test_data = data_new[(251):305,],
   .treat_as_continuous = TRUE, .approach_score_target = "median"
  )

pred 
round(pred$Prediction_metrics[, -1], 4)
## End(Not run)
</code></pre>


</div>