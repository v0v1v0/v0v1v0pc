<div class="container">

<table style="width: 100%;"><tr>
<td>support</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Support of LR fuzzy number
</h2>

<h3>Description</h3>

<p>To determining the support of a LR fuzzy number one can use from this function.
In other words, the <code>support</code> function is able to compute the smallest and biggest values <code class="reqn">x</code> for which <code class="reqn">\mu(x)&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">support(M, Left.fun = NULL, Right.fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>

<p>A LR, RL or L fuzzy number
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Left.fun</code></td>
<td>

<p>The left-shape function which usually defined before using LRFN.plot (see examples in bellow)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Right.fun</code></td>
<td>

<p>The right-shape function which usually defined before using LRFN.plot (see examples in bellow)
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The "support" function return a interval-valued vector in which the membership function value of LR fuzzy number is bigger than zero.
</p>


<h3>Author(s)</h3>

<p>Abbas Parchami </p>


<h3>Examples</h3>

<pre><code class="language-R">Left.fun  = function(x)  { (1-x)*(x&gt;=0)}
Right.fun = function(x)  { (exp(-x))*(x&gt;=0)}
T = LR(1, 0.6, 0.2)
support(T)
LRFN.plot( T, xlim=c(-5,20), lwd=2, lty=3, col=4)

N = RL(3, 0.5, 2)
support(N)

Left.fun  = function(x)  { (1-x)*(x&gt;=0)}
M = L(2,4,3)
support(M)

Left.fun  = function(x)  { (1-x^2)*(x&gt;=0)}
Right.fun = function(x)  { (exp(-x))*(x&gt;=0)}
support( LR(17,5,3))


## The function is currently defined as
function (M, Left.fun = NULL, Right.fun = NULL) 
{
    range1 = M[1] - M[2] - M[3] - 100
    range2 = M[1] + M[2] + M[3] + 100
    x = seq(range1, range2, len = 2e+05)
    if (M[4] == 0) {
        y = Left.fun((M[1] - x)/M[2]) * (x &lt;= M[1]) + Right.fun((x - 
            M[1])/M[3]) * (M[1] &lt; x)
    }
    else if (M[4] == 1) {
        y = Right.fun((M[1] - x)/M[2]) * (x &lt;= M[1]) + Left.fun((x - 
            M[1])/M[3]) * (M[1] &lt; x)
    }
    else if (M[4] == 0.5) {
        y = Left.fun((M[1] - x)/M[2]) * (x &lt;= M[1]) + Left.fun((x - 
            M[1])/M[3]) * (M[1] &lt; x)
    }
    supp = c()
    supp[1] = min(x[0 &lt; y &amp; y &lt; 1])
    supp[2] = max(x[0 &lt; y &amp; y &lt; 1])
    if (supp[1] == min(x)) {
        supp[1] = -Inf
    }
    if (supp[2] == max(x)) {
        supp[2] = +Inf
    }
    return(supp)

  }
</code></pre>


</div>