<div class="container">

<table style="width: 100%;"><tr>
<td>assign_traffic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Algorithms for solving the Traffic Assignment Problem (TAP).</h2>

<h3>Description</h3>

<p>Estimation of the User Equilibrium (UE)
</p>


<h3>Usage</h3>

<pre><code class="language-R">assign_traffic(
  Graph,
  from,
  to,
  demand,
  algorithm = "bfw",
  max_gap = 0.001,
  max_it = .Machine$integer.max,
  aon_method = "bi",
  constant = 1,
  dial_params = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Graph</code></td>
<td>
<p>An object generated by makegraph function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>A vector of origins</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>A vector of destinations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demand</code></td>
<td>
<p>A vector describing the flow between each origin-destination pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character. <code>msa</code>, <code>fw</code>, <code>cfw</code>, <code>bfw</code> or <code>dial</code>. Default to <code>bfw</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_gap</code></td>
<td>
<p>Numeric. Relative gap to achieve. Default to 0.001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_it</code></td>
<td>
<p>Numeric. Maximum number of iterations. Default to <code>.Machine$integer.max</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aon_method</code></td>
<td>
<p>Character.<code>d</code>, <code>bi</code>, <code>nba</code>, <code>cphast</code> or <code>cbi</code>. Default to <code>bi</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in NBA* algorithm. Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dial_params</code></td>
<td>
<p>List. Named list of hyperparameters for <code>dial</code> algorithm. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), progression is displayed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The most well-known assumptions in traffic assignment models are the ones following Wardrop's first principle.
Traffic assignment models are used to estimate the traffic flows on a network. These models take as input a matrix of flows that indicate the volume of traffic between origin and destination (O-D) pairs.
Unlike All-or-Nothing assignment (see get_aon), edge congestion is modeled through the <strong>Volume Decay Function (VDF)</strong>.
The Volume Decay Function used is the most popular in literature, from the Bureau of Public Roads :
</p>
<p><strong>t = t0 * (1 + a * (V/C)^b) </strong>
with t = actual travel time (minutes),
t0 = free-flow travel time (minutes),
a = alpha parameter (unitless),
b = beta parameter (unitless),
V = volume or flow (veh/hour)
C = edge capacity (veh/hour)
</p>
<p>Traffic Assignment Problem is a convex problem and solving algorithms can be divided into two categories : </p>

<ul>
<li>
<p> link-based : <strong>Method of Successive Average</strong> (<code>msa</code>) and <strong>Frank-Wolfe variants</strong> (normal : <code>fw</code>, conjugate : <code>cfw</code> and bi-conjugate : <code>bfw</code>).
These algorithms uses the descent direction given by AON assignment at each iteration, all links are updated at the same time.
</p>
</li>
<li>
<p> bush-based : <strong>Algorithm-B</strong> (<code>dial</code>)
The problem is decomposed into sub-problems, corresponding to each origin of the OD matrix, that operate on acyclic sub-networks of the original transportation network, called bushes.
Link flows are shifted from the longest path to the shortest path recursively within each bush using Newton method.
</p>
</li>
</ul>
<p>Link-based algorithms are historically the first algorithms developed for solving the traffic assignment problem. It require low memory and are known to tail in the vicinity of the optimum and usually cannot be used to achieve highly precise solutions.
Algorithm B is more recent, and is better suited for achieve the highest precise solution. However, it require more memory and can be time-consuming according the network size and OD matrix size.
In <code>cppRouting</code>, the implementation of algorithm-B allow "batching", i.e. bushes are temporarily stored on disk if memory limit, defined by the user, is exceeded.
Please see the package website for practical example and deeper explanations about algorithms. (<a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>)
</p>
<p>Convergence criterion can be set by the user using max_gap argument, it is the relative gap which can be written as :
<strong>abs(TSTT/SPTT - 1)</strong>
with TSTT (Total System Travel Time) = sum(flow * cost),
SPTT (Shortest Path Travel Time) = sum(aon * cost)
</p>
<p>Especially for link-based algorithms (msa, *fw), the larger part of computation time rely on AON assignment. So, choosing the right AON algorithm is crucial for fast execution time.
Contracting the network on-the-fly before AON computing can be faster for large network and/or large OD matrix.
</p>
<p>AON algorithms are : </p>

<ul>
<li> <p><code>bi</code> : bidirectional Dijkstra algorithm
</p>
</li>
<li> <p><code>nba</code> : bidirectional A* algorithm, nodes coordinates and constant parameter are needed
</p>
</li>
<li> <p><code>d</code> : Dijkstra algorithm
</p>
</li>
<li> <p><code>cbi</code> : contraction hierarchies + bidirectional search
</p>
</li>
<li> <p><code>cphast</code> : contraction hierarchies + phast algorithm
</p>
</li>
</ul>
<p>These AON algorithm can be decomposed into two families, depending the sparsity of origin-destination matrix : </p>

<ul>
<li>
<p> recursive pairwise : <code>bi</code>, <code>nba</code> and <code>cbi</code>. Optimal for high sparsity. One-to-one algorithm is called N times, with N being the length of from.
</p>
</li>
<li>
<p> recursive one-to-many : <code>d</code> and <code>cphast</code>. Optimal for dense matrix. One-to-many algorithm is called N times, with N being the number of unique from (or to) nodes
</p>
</li>
</ul>
<p>For large instance, it may be appropriate to test different <code>aon_method</code> for few iterations and choose the fastest one for the final estimation.
</p>
<p>Hyperparameters for algorithm-b are : </p>

<ul>
<li> <p><code>inneriter</code> : number of time bushes are equilibrated within each iteration. Default to 20
</p>
</li>
<li> <p><code>max_tol</code> : numerical tolerance. Flow is set to 0 if less than max_tol. Since flow shifting consist of iteratively adding or substracting double types, numerical error can occur and stop convergence.
Default to 1e-11.
</p>
</li>
<li> <p><code>tmp_path</code> : Path for storing bushes during algorithm-B execution. Default using <code>tempdir()</code>
</p>
</li>
<li> <p><code>max_mem</code> : Maximum amount of RAM used by algorithm-B in gigabytes. Default to 8.
</p>
</li>
</ul>
<p>In New Bidirectional A star algorithm, euclidean distance is used as heuristic function.
To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
All algorithms are partly multithreaded (AON assignment).
</p>


<h3>Value</h3>

<p>A <code>list</code> containing : </p>

<ul>
<li>
<p> The relative gap achieved
</p>
</li>
<li>
<p> Number of iteration
</p>
</li>
<li>
<p> A data.frame containing edges attributes, including equilibrated flows, new costs and free-flow travel times.
</p>
</li>
</ul>
<h3>Note</h3>

<p><code>from</code>, <code>to</code> and <code>demand</code> must be the same length.
<code>alpha</code>, <code>beta</code> and <code>capacity</code> must be filled in during network construction. See makegraph.
</p>


<h3>References</h3>

<p>Wardrop, J. G. (1952). "Some Theoretical Aspects of Road Traffic Research".
</p>
<p>M. Fukushima (1984). "A modified Frank-Wolfe algorithm for solving the traffic assignment problem".
</p>
<p>R. B. Dial (2006). "A path-based user-equilibrium traffic assignment algorithm that obviates path storage and enumeration".
</p>
<p>M. Mitradjieva, P. O. Lindberg (2012).  "The Stiff Is Moving â€” Conjugate Direction Frank-Wolfe Methods with Applications to Traffic Assignment".
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

# Origin-destination trips
trips &lt;- data.frame(from = c(0,0,0,0,1,1,1,1,2,2,2,3,3,4,5,5,5,5,5),
                    to = c(1,2,5,3,2,5,2,4,2,5,2,3,5,2,0,0,3,5,1),
                    flow = c(10,30,15,5,5,2,3,6,4,15,20,2,3,6,2,1,4,5,3))

#Construct graph
graph &lt;- makegraph(edges,directed=TRUE, alpha = 0.15, beta = 4, capacity = 5)


# Solve traffic assignment problem
## using Bi-conjugate Frank-Wolfe algorithm
traffic &lt;- assign_traffic(Graph=graph,
                          from=trips$from, to=trips$to, demand = trips$flow,
                          algorithm = "bfw")
print(traffic$data)

## using algorithm-B
traffic2 &lt;- assign_traffic(Graph=graph,
                           from=trips$from, to=trips$to, demand = trips$flow,
                           algorithm = "dial")
print(traffic2$data)
</code></pre>


</div>