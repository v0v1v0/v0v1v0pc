<div class="container">

<table style="width: 100%;"><tr>
<td>cutpointr_</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The standard evaluation version of cutpointr (deprecated)</h2>

<h3>Description</h3>

<p>This function is equivalent to <code>cutpointr</code> but takes only quoted arguments
for <code>x</code>, <code>class</code> and <code>subgroup</code>. This was useful before
<code>cutpointr</code> supported tidyeval.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cutpointr_(
  data,
  x,
  class,
  subgroup = NULL,
  method = maximize_metric,
  metric = sum_sens_spec,
  pos_class = NULL,
  neg_class = NULL,
  direction = NULL,
  boot_runs = 0,
  boot_stratify = FALSE,
  use_midpoints = FALSE,
  break_ties = median,
  na.rm = FALSE,
  allowParallel = FALSE,
  silent = FALSE,
  tol_metric = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame with the data needed for x, class and optionally
subgroup.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(character) The variable name to be used for
classification, e.g. predictions or test values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgroup</code></td>
<td>
<p>(character) The variable name
of an additional covariate that identifies subgroups. Separate
optimal cutpoints will be determined per group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(function) A function for determining cutpoints. Can
be user supplied or use some of the built in methods. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>(function) The function for computing a metric when using
maximize_metric or minimize_metric as method and and for the
out-of-bag values during bootstrapping. A way of internally validating the performance.
User defined functions can be supplied, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos_class</code></td>
<td>
<p>(optional) The value of class that indicates the positive class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neg_class</code></td>
<td>
<p>(optional) The value of class that indicates the negative class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>(character, optional) Use "&gt;=" or "&lt;=" to indicate whether x
is supposed to be larger or smaller for the positive class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_runs</code></td>
<td>
<p>(numerical) If positive, this number of bootstrap samples
will be used to assess the variability and the out-of-sample performance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_stratify</code></td>
<td>
<p>(logical) If the bootstrap is stratified, bootstrap
samples are drawn separately in both classes and then combined, keeping the
proportion of positives and negatives constant in every resample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = "&gt;=") or the next lowest observation
(for direction = "&lt;=") which avoids biasing the optimal cutpoint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>break_ties</code></td>
<td>
<p>If multiple cutpoints are found, they can be summarized using
this function, e.g. mean or median. To return all cutpoints use c as the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>(logical) Set to TRUE (default FALSE) to keep only complete
cases of x, class and subgroup (if specified). Missing values with
na.rm = FALSE will raise an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allowParallel</code></td>
<td>
<p>(logical) If TRUE, the bootstrapping will be parallelized
using foreach. A local cluster, for example, should be started manually
beforehand.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>(logical) If TRUE suppresses all messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems. Not supported
by all <code>method</code> functions, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further optional arguments that will be passed to method.
minimize_metric and maximize_metric pass ... to metric.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">library(cutpointr)

## Optimal cutpoint for dsi
data(suicide)
opt_cut &lt;- cutpointr_(suicide, "dsi", "suicide")
opt_cut
summary(opt_cut)
plot(opt_cut)
predict(opt_cut, newdata = data.frame(dsi = 0:5))
</code></pre>


</div>