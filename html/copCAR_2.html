<div class="container">

<table style="width: 100%;"><tr>
<td>copCAR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit copCAR model to discrete areal data.</h2>

<h3>Description</h3>

<p>Fit the copCAR model to Bernoulli, negative binomial, or Poisson observations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">copCAR(formula, family, data, offset, A, method = c("CML", "DT", "CE"),
  confint = c("none", "bootstrap", "asymptotic"), model = TRUE, x = FALSE,
  y = TRUE, verbose = FALSE, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class “<code>formula</code>” (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of the model specification are given under "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the marginal distribution of the observations at the areal units and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code>family</code> for details of family functions.) Supported families are <code>binomial</code>, <code>negbinomial</code>, and <code>poisson</code>. When the negative binomial family is used, an initial value for <code class="reqn">\theta</code> must be passed to the <code>negbinomial</code> family function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>copCAR</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component to be included in the linear predictor during fitting. This should be <code>NULL</code> or a numeric vector of length equal to the number of observations. One or more <code>offset</code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code>model.offset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>the symmetric binary adjacency matrix for the underlying graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method for inference. <code>copCAR</code> supports the continous extension (“<code>CE</code>”), distributional transform (“<code>DT</code>”), and composite marginal likelihood (“<code>CML</code>”).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confint</code></td>
<td>
<p>the method for computing confidence intervals. This defaults to “<code>none</code>”. The other options are “<code>bootstrap</code>” (for parametric bootstrap intervals using the quantile method) and “<code>asymptotic</code>” (for intervals computed using an estimate of the asymptotic covariance matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical value indicating whether the model frame should be included as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a logical value indicating whether the model matrix used in the fitting process should be returned as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a logical value indicating whether the response vector used in the fitting process should be returned as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a logical value indicating whether to print various messages to the screen, including progress updates. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of parameters for controlling the fitting process.
</p>

<dl>
<dt><code>bootit</code></dt>
<dd>
<p>the size of the (parametric) bootstrap sample. This applies when <code>confint = "bootstrap"</code>, or when <code>confint = "asymptotic"</code> and <code>method = "CML"</code> or <code>method = "DT"</code>. Defaults to <code>500</code>.</p>
</dd>
<dt><code>m</code></dt>
<dd>
<p>the number of vectors of standard uniforms used to approximate the expected likelhood when <code>method = "CE"</code>. Defaults to <code>1000</code>.</p>
</dd>
<dt><code>rho.max</code></dt>
<dd>
<p>the value <code class="reqn">\rho^{\max}</code>, which is the maximum value of <code class="reqn">\rho</code> used to approximate the CAR variances when <code>method = "CE"</code> or <code>method = "DT"</code>. If missing, assumed to be <code>0.999</code>.</p>
</dd>
<dt><code>epsilon</code></dt>
<dd>
<p>the tolerance <code class="reqn">\epsilon &gt; 0</code> used to approximate the CAR variances when <code>method = "CE"</code> or <code>method = "DT"</code>. If missing, assumed to be <code>0.01</code>.</p>
</dd>
</dl>
<p>item<code>maxit</code>the maximum number of iterations to be used by <code>optim</code> when optimizing the objective function. Defaults to <code>1000</code>.
</p>
<dl>
<dt><code>parallel</code></dt>
<dd>
<p>a logical value indicating whether to parallelize the bootstrap. This defaults to <code>TRUE</code> if the <span class="pkg">parallel</span> package can be loaded.</p>
</dd>
<dt><code>type</code></dt>
<dd>
<p>the cluster type, one of “<code>SOCK</code>” (default), “<code>PVM</code>”, “<code>MPI</code>”, or “<code>NWS</code>”.</p>
</dd>
<dt><code>nodes</code></dt>
<dd>
<p>the number of slave nodes to create.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs frequentist inference for the copCAR model proposed by Hughes (2015). copCAR is a copula-based areal regression model that employs the proper conditional autoregression (CAR) introduced by Besag, York, and Mollié (1991). Specifically, copCAR uses the CAR copula, a Caussian copula based on the proper CAR.
</p>
<p>The spatial dependence parameter <code class="reqn">\rho \in [0, 1)</code>, regression coefficients <code class="reqn">\beta = (\beta_1, \dots, \beta_p)' \in R^p</code>, and, for negative binomial margins, dispersion parameter <code class="reqn">\theta&gt;0</code> can be estimated using the continous extension (CE) (Madsen, 2009), distributional transform (DT) (Kazianka and Pilz, 2010), or composite marginal likelihood (CML) (Varin, 2008) approaches.
</p>
<p>The CE approach transforms the discrete observations to continous outcomes by convolving them with independent standard uniforms (Denuit and Lambert, 2005). The true likelihood for the discrete outcomes is the expected likelihood for the transformed outcomes. An estimate (sample mean) of the expected likelihood is optimized to estimate the copCAR parameters. The number of standard uniform vectors, <code class="reqn">m</code>, can be chosen by the user. The default value is 1,000. The CE approach is exact up to Monte Carlo standard error but is computationally intensive (the computational burden grows rapidly with increasing <code class="reqn">m</code>). The CE approach tends to perform poorly when applied to Bernoulli outcomes, and so that option is not permitted. 
</p>
<p>The distributional transform stochastically "smoothes" the jumps of a discrete distribution function (Ferguson, 1967). The DT-based approximation (Kazianka and Pilz, 2010) for copCAR performs well for Poisson and negative binomial marginals but, like the CE approach, tends to perform poorly for Bernoulli outcomes.
</p>
<p>The CML approach optimizes a composite marginal likelihood formed as the product of pairwise likelihoods of adjacent observations. This approach performs well for Bernoulli, negative binomial, and Poisson outcomes.
</p>
<p>In the CE and DT approaches, the CAR variances are approximated. The quality of the approximation is determined by the values of control parameters <code class="reqn">\epsilon &gt; 0</code> and <code class="reqn">\rho^{\max} \in [0, 1)</code>. The default values are 0.01 and 0.999, respectively.
</p>
<p>When <code>confint = "bootstrap"</code>, a parametric bootstrap is carried out, and confidence intervals are computed using the quantile method. Monte Carlo standard errors (Flegal et al., 2008) of the quantile estimators are also provided.
</p>
<p>When <code>confint = "asymptotic"</code>, confidence intervals are computed using an estimate of the asymptotic covariance matrix of the estimator. For the CE method, the inverse of the observed Fisher information matrix is used. For the CML and DT methods, the objective function is misspecified, and so the asymptotic covariance matrix is the inverse of the Godambe information matrix (Godambe, 1960), which has a sandwich form. The "bread" is the inverse of the Fisher information matrix, and the "meat" is the covariance matrix of the score function. The former is estimated using the inverse of the observed Fisher information matrix. The latter is estimated using a parametric bootstrap.
</p>


<h3>Value</h3>

<p><code>copCAR</code> returns an object of class <code>"copCAR"</code>, which is a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>boot.sample</code></td>
<td>
<p>(if <code>confint = "bootstrap"</code>) the bootstrap sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a named vector of parameter estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confint</code></td>
<td>
<p>the value of <code>confint</code> supplied in the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list containing the names and values of the control parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>the integer code returned by <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.hat</code></td>
<td>
<p>(if <code>confint = "asymptotic"</code>) the estimate of the asymptotic covariance matrix of the parameter estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the <code>data</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the <code>family</code> object used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A character string giving any additional information returned by the optimizer, or <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method (CE, CML, or DT) used for inference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>if requested (the default), the model frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npar</code></td>
<td>
<p>the number of model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the response residuals, i.e., the outcomes minus the fitted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>the value of the objective function at its minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>if requested, the model matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors used in fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>if requested (the default), the response vector used.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Besag, J., York, J., and Mollié, A. (1991) Bayesian image restoration, with two applications in spatial statistics. <em>Annals of the Institute of Statistical Mathematics</em>, <b>43</b>(1), 1–20.
</p>
<p>Denuit, M. and Lambert, P. (2005) Constraints on concordance measures in bivariate discrete data. <em>Journal of Multivariate Analysis</em>, <b>93</b>, 40–57.
</p>
<p>Ferguson, T. (1967) <em>Mathematical statistics: a decision theoretic approach</em>, New York: Academic Press.
</p>
<p>Flegal, J., Haran, M., and Jones, G. (2008) Markov Chain Monte Carlo: can we trust the third significant figure? <em>Statistical Science</em>, 23(2), 250–260.
</p>
<p>Godambe, V. (1960) An optimum property of regular maximum likelihood estimation. <em>The Annals of Mathmatical Statistics</em>, <b>31</b>(4), 1208–1211.
</p>
<p>Hughes, J. (2015) copCAR: A flexible regression model for areal data.  <em>Journal of Computational and Graphical Statistics</em>, <b>24</b>(3), 733–755.
</p>
<p>Kazianka, H. and Pilz, J. (2010) Copula-based geostatistical modeling of continuous and discrete data including covariates. <em>Stochastic Environmental Research and Risk Assessment</em>, <b>24</b>(5), 661–673.
</p>
<p>Madsen, L. (2009) Maximum likelihood estimation of regression parameters with spatially dependent discrete data. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>14</b>(4), 375–391.
</p>
<p>Varin, C. (2008) On composite marginal likelihoods. <em>Advances in Statistical Analysis</em>, <b>92</b>(1), 1–28.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Simulate data and fit copCAR to them.

# Use the 20 x 20 square lattice as the underlying graph.

m = 20
A = adjacency.matrix(m)

# Create a design matrix by assigning coordinates to each vertex
# such that the coordinates are restricted to the unit square.

x = rep(0:(m - 1) / (m - 1), times = m)
y = rep(0:(m - 1) / (m - 1), each = m)
X = cbind(x, y)

# Set the dependence parameter, regression coefficients, and dispersion parameter.

rho = 0.995      # strong dependence
beta = c(1, 1)   # the mean surface increases in the direction of (1, 1)
theta = 2        # dispersion parameter

# Simulate negative binomial data from the model.

z = rcopCAR(rho, beta, X, A, family = negbinomial(theta))

# Fit the copCAR model using the continous extension, and compute 95% (default)
# asymptotic confidence intervals. Give theta the initial value of 1. Use m equal to 100.

fit.ce = copCAR(z ~ X - 1, A = A, family = negbinomial(1), method = "CE", confint = "asymptotic",
                control = list(m = 100))
summary(fit.ce)

# Fit the copCAR model using the DT approximation, and compute 90% confidence
# intervals. Bootstrap the intervals, based on a bootstrap sample of size 100.
# Do the bootstrap in parallel, using ten nodes.

fit.dt = copCAR(z ~ X - 1, A = A, family = negbinomial(1), method = "DT", confint = "bootstrap",
                control = list(bootit = 100, nodes = 10))
summary(fit.dt, alpha = 0.9)

# Fit the copCAR model using the composite marginal likelihood approach.
# Do not compute confidence intervals.

fit.cml = copCAR(z ~ X - 1, A = A, family = negbinomial(1), method = "CML", confint = "none")
summary(fit.cml)

## End(Not run)
</code></pre>


</div>