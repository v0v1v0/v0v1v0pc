<div class="container">

<table style="width: 100%;"><tr>
<td>GLcop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Galambos Extreme Value Copula (with Gamma Power Mixture [Joe/BB4] and Lower Extreme Value Limit)</h2>

<h3>Description</h3>

<p>The <em>Galambos copula</em> (Joe, 2014, p. 174) is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\Theta}(u,v) = \mathbf{GL}(u,v) = uv\,\mathrm{exp}\bigl[\bigl(x^{-\Theta} + y^{-\Theta}\bigr)^{-1/\Theta}\bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">\Theta \in [0, \infty)</code>, <code class="reqn">x = -\log u</code>, and <code class="reqn">y = -\log v</code>. As <code class="reqn">\Theta \rightarrow 0^{+}</code>, the copula limits to <em>independence</em> (<code class="reqn">\mathbf{\Pi}</code>; <code>P</code>) and as  <code class="reqn">\Theta \rightarrow \infty</code>, the copula limits to perfect association (<code class="reqn">\mathbf{M}</code>; <code>M</code>). The copula here is a <em>bivariate extreme value copula</em> (<code class="reqn">BEV</code>), and parameter estimation for <code class="reqn">\Theta</code> requires numerical methods.
</p>
<p>There are two other genetically related forms. Joe (2014, p. 197) describes an extension of the Galambos copula as a <em>Galambos gamma power mixture</em> (GLPM), which is Joe's <em>BB4 copula</em>, with the following form
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\Theta,\delta}(u,v) = \mathbf{GLPM}(u,v) =
\biggl(x + y - 1 - \bigl[(x - 1)^{-\delta} + (y - 1)^{-\delta} \bigr]^{-1/\delta} \biggr)^{-1/\Theta}\mbox{,}</code>
</p>

<p>where <code class="reqn">x = u^{-\Theta}</code>, <code class="reqn">y = v^{-\Theta}</code>, and <code class="reqn">\Theta \ge 0, \delta \ge 0</code>. (Joe shows <code class="reqn">\delta &gt; 0</code>, but zero itself seems to work without numerical problems in practical application.) As <code class="reqn">\delta \rightarrow 0^{+}</code>, the “MTCJ family” (Mardia–Takahasi–Cook–Johnson) results (implemented internally with <code class="reqn">\Theta</code> as the incoming parameter). As <code class="reqn">\Theta \rightarrow 0^{+}</code> the Galambos above results with <code class="reqn">\delta</code> as the incoming parameter.
</p>
<p>This second copula in turn has a <em>lower extreme value limit form</em> that leads to a <em>min-stable bivariate exponential</em> having <em>Pickand dependence function</em> of
</p>
<p style="text-align: center;"><code class="reqn">A(x,y; \Theta, \delta) = x + y - \bigl[x^{-\Theta} + y^{-\Theta} - (x^{\Theta\delta} + y^{\Theta\delta})^{-1/\delta} \bigr]^{-1/\Theta}\mbox{,}</code>
</p>

<p>where this third copula is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}^{LEV}_{\Theta,\delta}(u,v) = \mathbf{GLEV}(u,v) =
\mathrm{exp}[-A(-\log u, -\log v; \Theta, \delta)]\mbox{,}</code>
</p>

<p>for <code class="reqn">\Theta \ge 0, \delta \ge 0</code> and is known as the <em>two-parameter Galambos</em>. (Joe shows <code class="reqn">\delta &gt; 0</code>, but <code class="reqn">\delta = 0</code> itself seems to work without numerical problems in practical application.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">GLcop(   u, v, para=NULL, ...)
GLEVcop( u, v, para=NULL, ...)
GLPMcop( u, v, para=NULL, ...) # inserts third parameter automatically
JOcopBB4(u, v, para=NULL, ...) # inserts third parameter automatically
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>To trigger <code class="reqn">\mathbf{GL}(u,v)</code>, a vector (single element) of <code class="reqn">\Theta</code>, to trigger <code class="reqn">\mathbf{GLEV}(u,v)</code>, a two element vector of <code class="reqn">\Theta</code> and <code class="reqn">\delta</code> and alias is <code>GLEVcop</code>, and to trigger <code class="reqn">\mathbf{GLPM}(u,v)</code>, a three element vector of <code class="reqn">\Theta</code>, <code class="reqn">\delta</code>, and any number (the presence of the third entry alone is the triggering mechanism) though aliases <code>GLPM</code> or <code>JOcopBB4</code> will insert the third parameter automatically for convenience; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Note</h3>

<p>Joe (2014, p. 198) shows <code class="reqn">\mathbf{GLEV}(u,v; \Theta, \delta)</code> as a two-parameter Galambos, but its use within the text seemingly is not otherwise obvious. However, testing of the implementation here seems to show that this copula is really not broader in form than <code class="reqn">\mathbf{GL}(u,v; \alpha)</code>. The <code class="reqn">\alpha</code> can always(?) be chosen to mimic the <code class="reqn">\{\Theta, \delta\}</code>. This assertion can be tested from a semi-independent direction. First, define an alternative style of one-parameter Galambos:
</p>
<pre>
  GL1cop &lt;- function(u,v, para=NULL, ...) {
     GL1pA &lt;- function(x,y,t) { # Pickend dependence func form 1p Galambos
        x + y - (x^-t + y^-t)^(-1/t)
     }
     if(length(u) == 1) { u &lt;- rep(u, length(v)) } else
     if(length(v) == 1) { v &lt;- rep(v, length(u)) }
     exp(-GL1pA(-log(u), -log(v), para[1]))
  }
</pre>
<p>Second, redefine the two-parameter Galambos:
</p>
<pre>
  GL2cop &lt;- function(u,v, para=NULL, ...) {
     GL2pA &lt;- function(x,y,t,d) { # Pickend dependence func form 2p Galambos
        x + y - (x^-t + y^-t - (x^(t*d) + y^(t*d))^(-1/d))^(-1/t)
     }
     if(length(u) == 1) { u &lt;- rep(u, length(v)) } else
     if(length(v) == 1) { v &lt;- rep(v, length(u)) }
     exp(-GL2pA(-log(u), -log(v), para[1], para[2]))
  }
</pre>
<p>Next, we can combine the Pickend dependence functions into an objective function. This objective function will permit the computation of the <code class="reqn">\alpha</code> given a pair <code class="reqn">\{\Theta, \delta\}</code>.
</p>
<pre>
  objfunc &lt;- function(a,t=NA,d=NA, x=0.7, y=0.7) {
     lhs &lt;- (x^-t + y^-t - (x^(t*d) + y^(t*d))^(-1/d))^(-1/t)
     rhs &lt;- (x^-a + y^-a)^(-1/a); return(rhs - lhs) # to be uniroot'ed
  }
</pre>
<p>A demonstration can now be made:
</p>
<pre>
  t &lt;- 0.6; d &lt;- 4; lohi &lt;- c(0,100)
  set.seed(3); UV &lt;- simCOP(3000, cop=GL2cop, para=c(t,d), pch=16,col=3,cex=0.5)
  a &lt;- uniroot(objfunc, interval=lohi, t=t, d=d)$root
  set.seed(3); UV &lt;- simCOP(3000, cop=GL1cop, para=a, lwd=0.5, ploton=FALSE)
</pre>
<p>The graphic so produced shows almost perfect overlap in the simulated values. To date, the author has not really found that the two parameters can be chosen such that the one-parameter version can not attain. Extensive numerical experiments using simulated parameter combinations through the use of various copula metrics (tail dependencies, L-comoments, etc) have not found material differences. <b>Has the author of this package missed something?</b>
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>


<h3>See Also</h3>

<p><code>M</code>, <code>P</code>, <code>GHcop</code>, <code>HRcop</code>, <code>tEVcop</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Theta = pi for GLcop and recovery through Blomqvist Beta     (Joe, 2014, p. 175)
log(2)/(log(log(2)/log(1+blomCOP(cop=GLcop, para=pi))))

# Theta = 2 and delta = 3 for the GLPM form and Blomqvist Beta (Joe, 2014, p. 197)
t &lt;- 2; Btheo &lt;- blomCOP(GLPMcop, para=c(t,3))
Bform &lt;- (2^(t+1) - 1 - taildepCOP(GLPMcop, para=c(t,3))$lambdaU*(2^t -1))^(-1/t)
print(c(Btheo, 4*Bform-1)) # [1] 0.8611903 0.8611900

## Not run: 
  # See the Note section but check Blomqvist Beta here:
  blomCOP(cop=GLcop, para=c(6.043619))  # 0.8552863 (2p version)
  blomCOP(cop=GLcop, para=c(5.6, 0.3))  # 0.8552863 (1p version) 
## End(Not run)
</code></pre>


</div>