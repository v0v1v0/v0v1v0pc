<div class="container">

<table style="width: 100%;"><tr>
<td>ci_ogwa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Ordered Geographically Weighted Average (OWA)</h2>

<h3>Description</h3>

<p>The Ordered Geographically Weighted Averaging (OWA) operator is an extension of the multi-criteria decision aggregation method called OWA (Yager, 1988) that accounts for spatial heterogeneity.</p>


<h3>Usage</h3>

<pre><code class="language-R">ci_ogwa(x, id, indic_col, atleastjp, coords,
                    kernel = "bisquare", adaptive = F, bw, 
                    p = 2, theta = 0, longlat = F, dMat)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Units' unique identifier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>A two-column matrix of latitude and longitude coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atleastjp</code></td>
<td>
<p>Fuzzy linguistic quantifier "At least j".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>function chosen as follows:
gaussian: wgt = exp(-.5*(vdist/bw)^2);
exponential: wgt = exp(-vdist/bw);
bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise;
boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to                      the number of nearest neighbours (i.e. adaptive distance); default is FALSE,                      where a fixed kernel is found (bandwidth is a fixed distance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth used in the weighting function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code>gw.dist</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class "CI". This is a list containing the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>CI_OGWA_n</code></td>
<td>
<p>Composite indicator estimated values for OGWA-.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI_OGWA_p</code></td>
<td>
<p>Composite indicator estimated values for OGWA+.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wp</code></td>
<td>
<p>OGWA weights' vector "More than j".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wn</code></td>
<td>
<p>OGWA weights' vector "At least j".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method="ogwa".</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Fusco E., Liborio M.P.</p>


<h3>References</h3>

<p>Fusco, E., Liborio, M.P., Rabiei-Dastjerdi, H., Vidoli, F., Brunsdon, C. and Ekel, P.I. (2023), Harnessing Spatial Heterogeneity in Composite Indicators through the Ordered Geographically Weighted Averaging (OGWA) Operator. Geographical Analysis. https://doi.org/10.1111/gean.12384
</p>


<h3>See Also</h3>

 <p><code>ci_owa</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(data_HPI)

data_HPI_2019 = data_HPI[data_HPI$year==2019,]
Indic_name = c("Life_Expectancy","Ladder_of_life","Ecological_Footprint")

Indic_norm = normalise_ci(data_HPI_2019, Indic_name, c("POS","POS","NEG"),method=2)$ci_norm
Indic_norm = Indic_norm[Indic_norm$Life_Expectancy&gt;0 &amp; 
              Indic_norm$Ladder_of_life&gt;0 &amp; 
              Indic_norm$Ecological_Footprint &gt;0,]

Indic_CI = data.frame(Indic_norm, 
                       data_HPI_2019[rownames(Indic_norm),
                       c("lat","long","HPI","ISO","Country")])

atleast = 2

coord = Indic_CI[,c("lat","long")]

CI_ogwa_n = ci_ogwa(Indic_CI, id="ISO", 
                      indic_col=c(1:3), 
                      atleastjp=atleast,
                      coords=as.matrix(coord),
                      kernel = "gaussian",
                      adaptive=FALSE, 
                      longlat=FALSE)$CI_OGWA_n


#CI_ogwa_p = ci_ogwa(Indic_CI, id="ISO", 
#                      indic_col=c(1:3), 
#                     atleastjp=atleast,
#                      coords=as.matrix(coord),
#                      kernel = "gaussian",
#                      adaptive=FALSE, 
#                      longlat=FALSE)$CI_OGWA_p

</code></pre>


</div>