<div class="container">

<table style="width: 100%;"><tr>
<td>coop-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cooperation: A Package of Co-Operations</h2>

<h3>Description</h3>

<p>Fast implementations of the co-operations: covariance,
correlation, and cosine similarity.  The implementations are
fast and memory-efficient and their use is resolved
automatically based on the input data, handled by R's S3
methods.  Full descriptions of the algorithms and benchmarks
are available in the package vignettes.
</p>
<p>Covariance and correlation should largely need no introduction.
Cosine similarity is commonly needed in, for example, natural
language processing, where the cosine similarity coefficients
of all columns of a term-document or document-term matrix is
needed.
</p>


<h3>The <code>inplace</code> argument</h3>

<p>When computing covariance and correlation with dense matrices, 
we must operate on the centered and/or scaled input data.  When
<code>inplace=FALSE</code>, a copy of the matrix is made.  This
allows for very wall-clock efficient processing at the cost of 
m*n additional double precision numbers allocated.  On the
other hand, if <code>inplace=TRUE</code>, then the wall-clock 
performance will drop considerably, but at the memory expense
of only m+n additional doubles.  For perspective, given a 
30,000x30,000 matrix, a copy of the data requires an
additional 6.7 GiB of data, while the inplace method requires
only 469 KiB, a 15,000-fold difference.
</p>
<p>Note that cosine is always computed in place.
</p>


<h3>The <code>t</code> functions</h3>

<p>The package also includes "t" functions, like <code>tcosine()</code>. These
behave analogously to <code>tcrossprod()</code> as <code>crossprod()</code> in base R.
So of <code>cosine()</code> operates on the columns of the input matrix, then
<code>tcosine()</code> operates on the rows.  Another way to think of it is,
<code>tcosine(x) = cosine(t(x))</code>.
</p>


<h3>Implementation Details</h3>

<p>Multiple storage schemes for the input data are accepted.  
For dense matrices, an ordinary R matrix input is accepted.  
For sparse matrices, a matrix in COO format, namely 
<code>simple_triplet_matrix</code> from the slam package, is accepted.
</p>
<p>The implementation for dense matrix inputs is dominated
by a symmetric rank-k update via the BLAS subroutine <code>dsyrk</code>;
see the package vignette for a discussion of the algorithm
implementation and complexity.
</p>
<p>The implementation for two dense vector inputs is dominated by the
product <code>t(x) %*% y</code> performed by the BLAS subroutine 
<code>dgemm</code> and the normalizing products <code>t(y) %*% y</code>,
each computed via the BLAS function <code>dsyrk</code>.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt
</p>


</div>