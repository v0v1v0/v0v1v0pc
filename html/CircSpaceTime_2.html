<div class="container">

<table style="width: 100%;"><tr>
<td>APEcirc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Average Prediction Error for circular Variables.</h2>

<h3>Description</h3>

<p><code>APEcirc</code>  computes the average prediction error (APE),
defined as the average circular distance across pairs
</p>


<h3>Usage</h3>

<pre><code class="language-R">APEcirc(real, sim, bycol = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>real</code></td>
<td>
<p>a vector of the  values of the process at the test locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>a matrix with <code>nrow =</code> the test locations and <code>ncol =</code> the number
of posterior samples from the posterior distributions  by
<code>WrapKrigSp</code> <code>WrapKrigSpTi</code>, <code>ProjKrigSp</code>,
<code>ProjKrigSpTi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bycol</code></td>
<td>
<p>logical. It is TRUE if the columns of sim represent the observations and
the rows the posterior samples, the default value is FALSE.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of two elements
</p>

<dl>
<dt><code>ApePoints</code></dt>
<dd>
<p> a vector of APE, one element for each test point</p>
</dd>
<dt><code>Ape</code></dt>
<dd>
<p> the  overall mean</p>
</dd>
</dl>
<h3>References</h3>

<p>G. Jona Lasinio, A. Gelfand, M. Jona-Lasinio,
"Spatial analysis of wave direction data using wrapped Gaussian processes",
The Annals of Applied Statistics 6 (2013), 1478-1498
</p>


<h3>See Also</h3>

<p><code>ProjKrigSp</code> and <code>WrapKrigSp</code> for posterior spatial
estimations,
<code>ProjKrigSpTi</code> and <code>WrapKrigSpTi</code> for posterior spatio-temporal
estimations
</p>
<p>Other model performance indices: <code>CRPScirc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(CircSpaceTime)
## functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

######################################
## Simulation                       ##
######################################
set.seed(1)
n &lt;- 20
### simulate coordinates from a unifrom distribution
coords  &lt;- cbind(runif(n,0,100), runif(n,0,100)) #spatial coordinates
coordsT &lt;- sort(runif(n,0,100)) #time coordinates (ordered)
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho     &lt;- 0.05 #spatial decay
rhoT    &lt;- 0.01 #temporal decay
sep_par &lt;- 0.5 #separability parameter
sigma2  &lt;- 0.3 # variance of the process
alpha   &lt;- c(0.5)
#Gneiting covariance
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist/(rhoT * DistT^2 + 1)^(sep_par/2))

Y &lt;- rmnorm(1,rep(alpha, times = n), SIGMA) #generate the linear variable
theta &lt;- c()
## wrapping step
for(i in 1:n) {
  theta[i] &lt;- Y[i] %% (2*pi)
}
### Add plots of the simulated data

rose_diag(theta)
## use this values as references for the definition of initial values and priors
rho_sp.min &lt;- 3/max(Dist)
rho_sp.max &lt;- rho_sp.min+0.5
rho_t.min  &lt;- 3/max(DistT)
rho_t.max  &lt;- rho_t.min+0.5
val &lt;- sample(1:n,round(n*0.2)) #validation set
set.seed(100)
mod &lt;- WrapSpTi(
  x       = theta[-val],
  coords    = coords[-val,],
  times    = coordsT[-val],
  start   = list("alpha"      = c(.79, .74),
                 "rho_sp"     = c(.33,.52),
                 "rho_t"     = c(.19, .43),
                 "sigma2"    = c(.49, .37),
                 "sep_par"  = c(.47, .56),
                 "k"       = sample(0,length(theta[-val]), replace = TRUE)),
  priors   = list("rho_sp"      = c(0.01,3/4), ### uniform prior on this interval
                  "rho_t"      = c(0.01,3/4), ### uniform prior on this interval
                  "sep_par"  = c(1,1), ### beta prior
                  "sigma2"    = c(5,5),## inverse gamma prior with mode=5/6
                  "alpha" =  c(0,20) ## wrapped gaussian with large variance
  )  ,
  sd_prop   = list( "sigma2" = 0.1,  "rho_sp" = 0.1,  "rho_t" = 0.1,"sep_par"= 0.1),
  iter    = 7000,
  BurninThin    = c(burnin = 3000, thin = 10),
  accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1000, exp = 0.5),
  n_chains = 2 ,
  parallel = FALSE,
  n_cores = 1
)
check &lt;- ConvCheck(mod,startit = 1 ,thin = 1)
check$Rhat ## convergence has been reached
## when plotting chains remember that alpha is a circular variable
par(mfrow = c(3,2))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))


############## Prediction on the validation set
Krig &lt;- WrapKrigSpTi(
  WrapSpTi_out = mod,
  coords_obs =  coords[-val,],
  coords_nobs =  coords[val,],
  times_obs =  coordsT[-val],
  times_nobs =  coordsT[val],
  x_obs = theta[-val]
)
### checking the prediction
Wrap_Ape &lt;- APEcirc(theta[val], Krig$Prev_out)
</code></pre>


</div>