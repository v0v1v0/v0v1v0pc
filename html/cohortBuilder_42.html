<div class="container">

<table style="width: 100%;"><tr>
<td>binding-keys</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Describe data relations with binding keys</h2>

<h3>Description</h3>

<p>When source consists of multiple datasets, binding keys allow to define what
relations occur between them.
When binding keys are defined, applying filtering on one dataset may result with
updating (filtering) the other ones.
</p>
<p>For example having two tables in Source:
'book(book_id, author_id, title)'
'authors(author_id, name, surname)'
if we filter 'authors' table, we way want to return only books for the selected authors.
</p>
<p>With binding keys you could achieve it by providing 'binding_keys' parameter for Source
as below:
</p>
<pre>
  binding_keys = bind_keys(
    bind_key(
      update = data_key('books', 'author_id'),
      data_key('authors', 'author_id')
    )
  )
</pre>
<p>Or if we want to have two-way relation, just define another binding key:
</p>
<pre>
  binding_keys = bind_keys(
    bind_key(
      update = data_key('books', 'author_id'),
      data_key('authors', 'author_id')
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )
</pre>
<p>As a result, whenever 'books' or 'authors' is filtered, the other table will be updated as well.
</p>
<p>In order to understand binding keys concept we need to describe the following functions:
</p>

<ul>
<li>
<p>data_key - Defines which table column should be used to describe relation.
</p>
</li>
<li>
<p><code>bind_key</code> - Defines what relation occur between datasets.
</p>
</li>
<li>
<p><code>bind_keys</code> - If needed, allows to define more than one relation.
</p>
</li>
</ul>
<p>- 'data_key' - requires to provide two parameters:
</p>

<ul>
<li>
<p><code>dataset</code> - Name of the dataset existing in Source.
</p>
</li>
<li>
<p><code>key</code> - Single character string or vector storing column names that are keys, which should be used to describe relation.
</p>
</li>
</ul>
<p>For example ‘data_key(’books', 'author_id')'.
</p>
<p>- 'bind_key' - requires to provide two obligatory parameters
</p>

<ul>
<li>
<p><code>update</code> - Data key describing which table should be updated.
</p>
</li>
<li>
<p><code>...</code> - <strong>Triggering data keys</strong>. One or more data keys describing on which dataset(s) the one in 'update' is dependent.
</p>
</li>
</ul>
<p>The output of 'bind_key' function is named <strong>binding key</strong>.
'bind_key' offers two extra parameters 'post' and 'activate'.
See below to learn how these parameters affect the final result.
</p>
<p>- 'bind_keys' - takes only binding keys as parameters
The function is used to define 'binding_keys' parameter of Source.
Whenever you define a single or more binding keys wrap them with 'bind_keys'.
</p>
<p>It's worth to mention that binding key describes inner-join like relation.
That means the updated table's key is intersection of its key and keys of
remaining tables defined in binding key.
</p>
<p>Another important note is that binding keys order matters - binding is performed
sequentially, taking into account returned data from the previous bindings.
</p>
<p>You may achieve more flexibility with two parameters:
</p>

<ul>
<li>
<p><code>activate</code>
</p>
</li>
<li>
<p><code>post</code>
</p>
</li>
</ul>
<p><strong>Active tables and 'activate' parameter</strong>
</p>
<p>We name a table 'active' that is attached to at least one active filter (in a step).
</p>
<p>When having defined binding key, e.g.
</p>
<pre>
  bind_key(
    update = data_key('books', 'author_id'),
    data_key('authors', 'author_id')
  )
</pre>
<p>the key is taken into account only when at least one triggering table is active.
So in the above example binding key will update 'books' only when 'authors' was
filtered (more precisely when any filter attached to 'authors' is active).
</p>
<p>The 'activate = TRUE' parameter setup, lets us to decide whether 'update' table
should be marked as active as well when the binding finish.
This allows to build dependency chains between table.
</p>
<p>Let's explain this in the below example. Having defined another table in Source
'borrowed(book_id, user_id, date)' and binding key:
</p>
<pre>
  bind_keys(
    bind_key(
      update = data_key('books', 'book_id'),
      data_key('borrowed', 'book_id')
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )
</pre>
<p>Let's consider the case when table 'borrowed' is active, 'books' is not.
What happens during the binding process:
1. Based on the first binding key, active 'borrowed' triggers this one.
2. As a result 'books' is modified.
</p>
<p>What should happen with the second binding key.
We have two options:
1. 'books' could be marked as active as well so it triggers the second key.
2. 'books' could remain inactive so the second key is not triggered.
It will be triggered only when 'books' is directly filtered (activated).
</p>
<p>You may choose between 1 and 2 with 'activate = TRUE' (the default)  and 'activate = FALSE'
respectively.
</p>
<p>So in the above example (because 'activate = TRUE' by default) the authors table
will also be modified by the second binding key.
</p>
<p>To turn off this behavior we just need to:
</p>
<pre>
  bind_keys(
    bind_key(
      update = data_key('books', 'book_id'),
      data_key('borrowed', 'book_id'),
      activate = TRUE
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )
</pre>
<p><strong>Bind filtered on unfiltered data - 'post' parameter</strong>
</p>
<p>Let's tart with the below binding key example:
</p>
<pre>
  bind_keys(
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )
</pre>
<p>Let's assume 'authors' table is filtered and we apply filtering for 'books' table.
We may want to achieve one of the two results:
1. 'authors' filters should be taken into account while binding.
2. we should take unfiltered 'authors' an apply binding based on 'books' choices.
</p>
<p>We can achieve 1 and 2 with defining 'post = TRUE' (the default) and 'post = FALSE' respectively.
</p>
<p>So the following setup:
</p>
<pre>
  bind_keys(
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id'),
      post = FALSE
    )
  )
</pre>
<p>Whenever 'books' is changed will result with filtering only the authors that written selected books -
no extra 'authors' filters will be applied.
</p>
<p>There might be the situation when table was already bound but there is another
one binding key to be executed on the same table.
</p>
<p>In this case 'post = FALSE' case will remain the same - unfiltered table will be taken.
More to that filtering and previous binding related to this table will be ignored.
In case of 'post = TRUE' the previously bound table will be updated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bind_keys(...)

bind_key(update, ..., post = TRUE, activate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In case of 'bind_keys', binding keys created with 'bind_key'.
In case of 'bind_key', data keys describing triggering tables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>
<p>Data key describing table to update.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post</code></td>
<td>
<p>Update filtered or unfiltered table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activate</code></td>
<td>
<p>Mark bound table as active.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List of class 'bind_keys' storing 'bind_key' class objects ('bind_keys') or
'bind_key' class list ('bind_key').
</p>


</div>