<div class="container">

<table style="width: 100%;"><tr>
<td>taildepCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Lower- and Upper-Tail Dependency Parameters of a Copula</h2>

<h3>Description</h3>

<p>Compute the <em>lower-</em> and <em>upper-tail dependency parameters</em> (if they exist), respectively, of a copula according to Nelsen (2006, pp. 214–215). Graphical confirmation of the computations is important, and therefore, the function can also generate a plot. The dependency parameters are expressions of conditional probability that <code class="reqn">Y</code> is greater than the <code class="reqn">100{\times}</code>th percentile of its distribution <code class="reqn">G</code> given that <code class="reqn">X</code> is greater than the <code class="reqn">100{\times}t</code>-th percentile of its distribution <code class="reqn">F</code> as <code class="reqn">t</code> approaches unity. Specifics in terms of quantile functions <code class="reqn">G^{(-1)}(t) = y(t)</code> and <code class="reqn">F^{(-1)}(t) = x(t)</code> follow.
</p>
<p>The <em>lower-tail dependence parameter</em> <code class="reqn">\lambda^L_\mathbf{C}</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\lambda^L_\mathbf{C} = \lim_{t{\rightarrow 0^{+}}} \mathrm{Pr}[Y \le y(t)\mid X \le x(t)]\mbox{, and}</code>
</p>

<p>the <em>upper-tail dependence parameter</em> <code class="reqn">\lambda^U_\mathbf{C}</code> with reversed inequalities is defined as
</p>
<p style="text-align: center;"><code class="reqn">\lambda^U_\mathbf{C} = \lim_{t{\rightarrow 1^{-}}} \mathrm{Pr}[Y &gt; y(t)\mid X &gt; x(t)]\mbox{.}</code>
</p>

<p>Nelsen (2006, p. 214) also notes that both <code class="reqn">\lambda^L_\mathbf{C}</code> and <code class="reqn">\lambda^U_\mathbf{C}</code> are nonparametric and depend only on the copula of <code class="reqn">X</code> and <code class="reqn">Y</code>, and Nelsen shows that each can be computed if the above limits exist as follows:
</p>
<p style="text-align: center;"><code class="reqn">\lambda^L_\mathbf{C} = \lim_{t{\rightarrow 0^{+}}} \frac{\mathbf{C}(t,t)}{t} = \delta_\mathbf{C}'(0^{+})\mbox{\ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda^U_\mathbf{C} = \lim_{t{\rightarrow 1^{-}}} \frac{1 - 2t - \mathbf{C}(t,t)}{1 - t} = 2 - \lim_{t{\rightarrow 1^{-}}} \frac{1 - \mathbf{C}(t,t)}{1-t} = 2 - \delta_\mathbf{C}'(1^{-})\mbox{,}</code>
</p>

<p>where <code class="reqn">\delta_\mathbf{C}'(t)</code> is the derivative of the diagonal of the copula. Multiple presentations are shown because algebraic variants are shown across the literature.
</p>
<p>If <code class="reqn">\lambda^L_\mathbf{C} \in (0,1]</code>, then <code class="reqn">\mathbf{C}</code> has lower-tail dependence but if <code class="reqn">\lambda^L_\mathbf{C} = 0</code>, then <code class="reqn">\mathbf{C}</code> has <em>no</em> lower-tail dependence. Likewise, if <code class="reqn">\lambda^U_\mathbf{C} \in (0,1]</code>, then <code class="reqn">\mathbf{C}</code> has upper-tail dependence but if <code class="reqn">\lambda^U_\mathbf{C} = 0</code>, then <code class="reqn">\mathbf{C}</code> has <em>no</em> upper-tail dependence.
</p>


<h3>Usage</h3>

<pre><code class="language-R">taildepCOP(cop=NULL, para=NULL, tol=1e-6, divisor=2, plot=FALSE, ylim=NULL,
                                verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A tolerance on convergence;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>divisor</code></td>
<td>
<p>The divisor on the incremental reductions towards <code class="reqn">0^+</code> and <code class="reqn">0^-</code> by the algorithm;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>A logical plotting a diagnostic plot of the diagonal derivatives and label the limits;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Optional vertical limits if the plot is turned on. Although the dependence parameters are bounded as described above, numerical stability can be a problem. Stability is especially a problem if an empirical copula is being used; theefore, the bounds of the plot are left open unless the user locks them down with this argument;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Show incremental progress; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copula function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> list is returned.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambdaL</code></td>
<td>
<p>The rounded value of <code class="reqn">\lambda^L_\mathbf{C}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaU</code></td>
<td>
<p>The rounded value of <code class="reqn">\lambda^U_\mathbf{C}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>An attribute identifying the computational source: “taildepCOP”.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p><em>IMPLEMENTED ALGORITHM</em>—The algorithm implemented for <code>taildepCOP</code> is based on halves (or alternatives by the setting of <code>divisor</code> argument) and uses the copula function (not an analytical or even numeric derivative of the diagonal, <code class="reqn">\delta_\mathbf{C}'(t)</code>). Starting from the median or <code class="reqn">t = 0.5</code>, each limit is respectively computed by successive halving (or the setting of argument <code>divisor</code>) of the distance towards <code class="reqn">0^{+}</code> and <code class="reqn">1^{-}</code> and checking the change in computed value against the tolerance <code>tol</code> argument. After the change becomes less than the tolerance, convergence is assumed. Other tests are made for <code>NaN</code> to aid in breaking the successive halvings. The rounding for the numerical results for <code class="reqn">\lambda^U_\mathbf{C}</code> and <code class="reqn">\lambda^L_\mathbf{C}</code> is an order of magnitude larger than the tolerance.
</p>
<p>Users are encouraged to plot the results and further verify whether the convergence makes sense. The plot produced when <code>plot=TRUE</code> shows the probability <code class="reqn">t</code> transformed into standard normal variates by the <code>qnorm()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> so that the distal reaches of each tail and thus limit are readily seen. The terminal points of each limit computation are shown by a small dot and the letter “L” and “U” also are plotted at the terminal points.
</p>
<p>Joe (2014, p. 63) reports that “the empirical measure of tail dependence [<code class="reqn">\hat\lambda_\mathbf{C}^L</code> or <code class="reqn">\hat\lambda_\mathbf{C}^U</code>] for data does not really exist because of the limit.”  Joe (2014) suggests that other sources in the literature are the “best that can be done” (Dobrić and Schmid, 2005; Frahm <em>et al.</em>, 2005). Another source of discussion is by Schmidt and Stadtmüller (2006). The results therein are not yet followed up for the <span class="pkg">copBasic</span> package. Picking up the simulation dealt with extensively in the <b>Note</b> section of <code>vuongCOP</code>, a user might try this:
</p>
<pre>
  set.seed(385); n &lt;- 390
  UV &lt;- simCOP(cop=PSP, n=n, col=8, pch=16, graphics=FALSE)
  taildepCOP(cop=EMPIRcop, para=UV, plot=TRUE, divisor=8, ylim=c(0,1))
  taildepCOP(cop=PSP) # lower=0.5, upper=0
</pre>
<p>The returned tail dependency parameters are numerically of little importance and in strict terms likely misleading. What should be of interest are the plotted trajectories of the lower and upper lines. Note: the lower tail wobbles but seems to show stability towards near <code class="reqn">\hat\lambda_\mathbf{C}^L = 0.5</code> and upper-tail line wobbles downward towards <code class="reqn">\hat\lambda_\mathbf{C}^U = 0</code>. These values are, respectively, the tail dependencies of the <code class="reqn">\mathbf{PSP}</code> copula (<code>PSP</code>). A user might try increasing the sample size by an order of magnitude and rerunning the above code. Lastly, Salvadori <em>et al.</em> (2006, pp. 173–175) caution on the difficulties of nonparametric tail dependency estimation. Given objectives of the <span class="pkg">copBasic</span> package, estimation of <code class="reqn">\hat\lambda_\mathbf{C}^L</code> and <code class="reqn">\hat\lambda_\mathbf{C}^U</code>, therefore, is an open development opportunity.
</p>
<p><em>DEMONSTRATION (Tail Dependence)</em>—The following example shows a comparison between early code examples by Charpentier (2012) concerning copulas and tail dependence using real-world data. Consider the <code>lossalae</code> data set and the following code requiring the <span class="pkg">evd</span> package:
</p>
<pre>
  library(evd); X &lt;- lossalae # Charpentier (2012)
  library(copBasic)
  fakeU &lt;- lmomco::pp(X[,1],sort=FALSE,a=0) # Weibull plotting position i/(n+1)
  fakeV &lt;- lmomco::pp(X[,2],sort=FALSE,a=0) # Weibull plotting position i/(n+1)
  uv &lt;- data.frame(U=fakeU, V=fakeV)  # parameter "object" for Empirical copula
  plot(uv)
  TD &lt;- taildepCOP(cop=EMPIRcop, para=uv, divisor=25,
                   plot=TRUE, ylim=c(0, 7/10))
  U &lt;- rank(X[,1])/(nrow(X)+1); V &lt;- rank(X[,2])/(nrow(X)+1)# Charpentier(2012)
  Lemp &lt;- function(z) sum((U&lt;=z)   &amp; (V&lt;=z))   / sum(U&lt;=z  )# Charpentier(2012)
  Remp &lt;- function(z) sum((U&gt;=1-z) &amp; (V&gt;=1-z)) / sum(U&gt;=1-z)# Charpentier(2012)
  u &lt;- seq(0.001, 0.5, by=.001)                             # Charpentier(2012)
  L &lt;- Vectorize(Lemp)(u); R &lt;- Vectorize(Remp)(rev(u))     # Charpentier(2012)
  lines(qnorm(c(u, u + 0.5 - u[1])), c(L,R)) # modified after Charpentier(2012)
  legend("bottomright", c("Lower-tail dependency by taildepCOP()",
                          "Upper-tail dependency by taildepCOP()",
                          "Charpentier (2012)"), bty="n", cex=0.9,
                          lwd=1, lty=1, col=c("red", "blue", "black"))
</pre>
<p>The figure that will have been generated shows considerably similarity to that from the algorithms of Charpentier. Now, let us extend the discussion by using the <em>Blomqvist (Schmid–Schmidt) Betas</em> (<code>blomCOPss</code>) that have a formulation permitting lower- and upper-tail dependency parameters in a different manner than the definitions of this documentation for <code>taildepCOP</code>.
</p>
<pre>
  edge &lt;- 30 * 1 / (1+nrow(X)) # as few as 30 samples into the tails
  psl &lt;- pnorm(seq(0, qnorm(  edge), by=-0.005))
  psu &lt;- pnorm(seq(0, qnorm(1-edge), by= 0.005))
  lines(qnorm(psl),
        sapply(psl, function(p) { blomCOPss(as.sample=TRUE, para=uv,
                    ctype="checkerboard", uu=rep(p, 2), vv=c(1,1)) }),
                    col="darkgreen", lty=1, lwd=2)
  lines(qnorm(psu),
        sapply(psu, function(p) { blomCOPss(as.sample=TRUE, para=uv,
                    ctype="checkerboard", uu=c(0,0), vv=rep(p, 2)) }),
                    col="darkgreen", lty=1, lwd=2)
  points(0, blomCOP(as.sample=TRUE, para=uv), pch=16, col="magenta", cex=2)
  legend("topleft", c("Tail dependency by Blomqvist (Schmid-Schmidt) Betas",
                      "Blomqvist Beta C(1/2, 1/2)"),
                    bty="n", cex=0.9, lwd=2, lty=c(1,NA), pch=c(NA,16),
                    pt.cex=c(NA,2), col=c("darkgreen", "magenta"))
</pre>
<p>The thick green lines show that the dependency parameters to the left and right are approached along a different trajectory using the definitions in <code>blomCOPss</code>. It seems at some stage in analysis that the practioner will need to decide how deep into the tail the sample will permit for a reliable estimate of the dependency parameters. <em>Blomqvist Beta</em> (<code class="reqn">\hat\beta_\mathbf{C}</code>) (<code>blomCOP</code> is shown as the magenta dot at the median and henceforth from do the trajectories of <code class="reqn">\hat\lambda^L_{\beta^\diamond_\mathbf{C}}</code> and <code class="reqn">\hat\lambda^U_{\beta^\diamond_\mathbf{C}}</code> extend as their <code class="reqn">\mathrm{lim} p \rightarrow 0^+</code>. Ultimately, for the data shown in the figure, perhaps the <code class="reqn">\hat\lambda_\mathbf{C}^L = 0.1</code> and the <code class="reqn">\hat\lambda_\mathbf{C}^U = 0.3</code> and a parametric copula fitted in part to such values.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Charpentier, A., 2012, Copulas and tail dependence, part 1: R-bloggers, dated Sept. 17, 2012, accessed on February 2, 2019 at <br><a href="https://www.r-bloggers.com/2012/09/copulas-and-tail-dependence-part-1/">https://www.r-bloggers.com/2012/09/copulas-and-tail-dependence-part-1/</a>
</p>
<p>Dobrić, J. and Schmid, F., 2005, Nonparametric estimation of the lower tail dependence <code class="reqn">\lambda^L</code> in bivariate copulas: Journal of Applied Statistics, v. 32, no. 4, pp. 387–407.
</p>
<p>Frahm, G., Junker, M., and Schmidt, R., 2005, Estimating the tail-dependence coefficient—<br> Properties and pitfalls: Insurance—Mathematics and Economics, v. 37, no. 1, pp. 80–100.
</p>
<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>
<p>Salvadori, G., De Michele, C., Kottegoda, N.T., and Rosso, R., 2007, Extremes in Nature—An approach using copulas: Springer, 289 p.
</p>
<p>Schmidt, R., and Stadtmüller, U., 2006, Nonparametric estimation of tail dependence: The Scandinavian Journal of Statistics, v. 33, pp. 307–335.
</p>


<h3>See Also</h3>

<p><code>COP</code>, <code>tailconCOP</code>, <code>tailordCOP</code>, <code>blomCOPss</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Plot the tail dependencies by nonexceedance probability for a
# for a positive association Plackett copula and see that both are zero.
taildepCOP(cop=PLACKETTcop, para=3, plot=TRUE)
# So, Plackett has no tail dependency, as Nelsen (2006, p. 215) shows.

## Not run: 
"MOcop" &lt;- function(u,v, para=NULL) { # Marshall-Olkin copula
   alpha &lt;- para[1]; beta &lt;- para[2]; return(min(v*u^(1-alpha), u*v^(1-beta)))
} # The results that follow match those reported by Nelsen (2006, p. 215).
taildepCOP(cop=MOcop, para=c(0.4, 0.9)) # LambL = 0, LambU = 0.4 [min(alpha,beta)]
## End(Not run)

## Not run: 
# Analytical solution to Gumbel-Hougaard copula from the copula package:
copula::lambda(copula::gumbelCopula(3))
#   lower    upper
# 0.000000 0.740079
# Numerical approximation (see copBasic::GHcop for analytical formula):
as.data.frame(taildepCOP(GHcop, para=3))
#  lambdaL lambdaU     source
#1 0.00012 0.74008 taildepCOP
## End(Not run)

## Not run: 
# Plot the tail dependencies by nonexceedance probability
# for the PSP copula, which has lower but no upper-tail dependence.
taildepCOP(cop=PSP, para=NULL, plot=TRUE) # LambL=0.5, LambU=0
# which is readily confirmed by simCOP(1000, cop=PSP)
# Nelsen (2006, p. 216) reports that this copula has LambL=1/2 and LambU=0,
# and we get the same results here.

# How about some composited Plackett-Plackett copulas?
# Each has upper- and lower-tail dependence parameters equal to zero.
para &lt;- list( cop1=PLACKETTcop,  cop2=PLACKETTcop, alpha=0.9392,
             para1=0.00395,     para2=4.67,         beta=0.5699)
taildepCOP(cop=composite2COP, para=para, plot=TRUE, verbose=TRUE) #
## End(Not run)

## Not run: 
# This next Plackett-Plackett is interesting because at its core it looks
# like it should be both tail dependent like M() but the shapes of the curves
# are quite different from those of M(). This example shows numerical
# instability for the upper tail but not the lower tail. So, we extend the
# example to shown the tail dependency trajectories by blomCOPss(). And again
# it is seen that the lower tail as a stable solution but the upper tail
# has instability at 6 standard deviations into the upper tail.
para &lt;- list(  cop1=PLACKETTcop,  cop2=PLACKETTcop, alpha=0.0063,
             para1=0.101,        para2=4493,         beta=0.0167)
taildepCOP(cop=composite2COP, para=para, plot=TRUE)
lsu &lt;- pnorm(seq(-7, 0, by=.01))
psu &lt;- pnorm(seq( 0, 7, by=.01))
lines(qnorm(lsu), sapply(lsu, function(p) {
        blomCOPss(cop=composite2COP, para=para, vv=c(1,1), uu=rep(p, 2)) }),
                    col="darkgreen", lty=2, lwd=1)
lines(qnorm(psu), sapply(psu, function(p) {
        blomCOPss(cop=composite2COP, para=para, uu=c(0,0), vv=rep(p, 2)) }),
                    col="darkgreen", lty=2, lwd=1) #
## End(Not run)
</code></pre>


</div>