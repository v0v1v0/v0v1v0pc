<div class="container">

<table style="width: 100%;"><tr>
<td>testCVPAT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform a Cross-Validated Predictive Ability Test (CVPAT)</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt="[Maturing]"></a>
</p>


<h3>Usage</h3>

<pre><code class="language-R">testCVPAT(
.object1              = NULL,
.object2              = NULL,
.approach_predict     = c("earliest", "direct"),
.seed                 = NULL,
.cv_folds             = 10,
.handle_inadmissibles = c("stop", "ignore"),
.testtype             = c("twosided", "onesided"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.object1</code></td>
<td>
<p>An R object of class cSEMResults resulting from a call to <code>csem()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.object2</code></td>
<td>
<p>An R object of class cSEMResults resulting from a call to <code>csem()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.approach_predict</code></td>
<td>
<p>Character string. Which approach should be used to
predictions? One of "<em>earliest</em>" and "<em>direct</em>". If "<em>earliest</em>" predictions
for indicators associated to endogenous constructs are performed using only
indicators associated to exogenous constructs. If "<em>direct</em>", predictions for
indicators associated to endogenous constructs are based on indicators associated
to their direct antecedents. Defaults to "<em>earliest</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.cv_folds</code></td>
<td>
<p>Integer. The number of cross-validation folds to use. Setting
<code>.cv_folds</code> to <code>N</code> (the number of observations) produces
leave-one-out cross-validation samples. Defaults to <code>10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of "<em>drop</em>", "<em>ignore</em>", or "<em>replace</em>". If "<em>drop</em>", all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For "<em>ignore</em>" all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For "<em>replace</em>" resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to "<em>drop</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.testtype</code></td>
<td>
<p>Character string. One of "<em>twosided</em>" (H1: The models do not
perform equally in predicting indicators belonging to endogenous constructs)"
and <em>onesided</em>" (H1: Model 1 performs better in predicting indicators belonging
to endogenous constructs than model2). Defaults to "<em>twosided</em>".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Perform a Cross-Validated Predictive Ability Test (CVPAT) as described in
(Liengaard et al. 2020). The predictive performance of two models
based on the same dataset is compared. In doing so, the average difference in
losses in predictions is compared for both models.
</p>


<h3>Value</h3>

<p>An object of class <code>cSEMCVPAT</code> with print and plot methods.
Technically, <code>cSEMCVPAT</code> is a
named list containing the following list elements:
</p>

<dl>
<dt>'$Information'</dt>
<dd>
<p>Additional information.</p>
</dd>
</dl>
<h3>References</h3>

<p>Liengaard BD, Sharma PN, Hult GTM, Jensen MB, Sarstedt M, Hair JF, Ringle CM (2020).
“Prediction: Coveted, Yet Forsaken? Introducing a Cross-Validated Predictive Ability Test in Partial Least Squares Path Modeling.”
<em>Decision Sciences</em>, <b>52</b>(2), 362–392.
<a href="https://doi.org/10.1111/deci.12445">doi:10.1111/deci.12445</a>.
</p>


<h3>See Also</h3>

<p>csem, cSEMResults, <code>exportToExcel()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Anime example taken from https://github.com/ISS-Analytics/pls-predict/

# Load data
data(Anime) # data is similar to the Anime.csv found on 
            # https://github.com/ISS-Analytics/pls-predict/ but with irrelevant
            # columns removed

# Split into training and data the same way as it is done on 
# https://github.com/ISS-Analytics/pls-predict/
set.seed(123)

index     &lt;- sample.int(dim(Anime)[1], 83, replace = FALSE)
dat_train &lt;- Anime[-index, ]
dat_test  &lt;- Anime[index, ]

# Specify model
model &lt;- "
# Structural model

ApproachAvoidance ~ PerceivedVisualComplexity + Arousal

# Measurement/composite model

ApproachAvoidance         =~ AA0 + AA1 + AA2 + AA3
PerceivedVisualComplexity &lt;~ VX0 + VX1 + VX2 + VX3 + VX4
Arousal                   &lt;~ Aro1 + Aro2 + Aro3 + Aro4
"

# Estimate (replicating the results of the `simplePLS()` function)
res &lt;- csem(dat_train, 
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using a user-supplied training data set
pp &lt;- predict(res, .test_data = dat_test)
pp

### Compute prediction metrics  ------------------------------------------------
res2 &lt;- csem(Anime, # whole data set
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using 10-fold cross-validation
## Not run: 
pp2 &lt;- predict(res, .benchmark = "lm")
pp2
## There is a plot method available
plot(pp2)
## End(Not run)

### Example using OrdPLScPredict -----------------------------------------------
# Transform the numerical indicators into factors
## Not run: 
data("BergamiBagozzi2000")
data_new &lt;- data.frame(cei1    = as.ordered(BergamiBagozzi2000$cei1),
                       cei2    = as.ordered(BergamiBagozzi2000$cei2),
                       cei3    = as.ordered(BergamiBagozzi2000$cei3),
                       cei4    = as.ordered(BergamiBagozzi2000$cei4),
                       cei5    = as.ordered(BergamiBagozzi2000$cei5),
                       cei6    = as.ordered(BergamiBagozzi2000$cei6),
                       cei7    = as.ordered(BergamiBagozzi2000$cei7),
                       cei8    = as.ordered(BergamiBagozzi2000$cei8),
                       ma1     = as.ordered(BergamiBagozzi2000$ma1),
                       ma2     = as.ordered(BergamiBagozzi2000$ma2),
                       ma3     = as.ordered(BergamiBagozzi2000$ma3),
                       ma4     = as.ordered(BergamiBagozzi2000$ma4),
                       ma5     = as.ordered(BergamiBagozzi2000$ma5),
                       ma6     = as.ordered(BergamiBagozzi2000$ma6),
                       orgcmt1 = as.ordered(BergamiBagozzi2000$orgcmt1),
                       orgcmt2 = as.ordered(BergamiBagozzi2000$orgcmt2),
                       orgcmt3 = as.ordered(BergamiBagozzi2000$orgcmt3),
                       orgcmt5 = as.ordered(BergamiBagozzi2000$orgcmt5),
                       orgcmt6 = as.ordered(BergamiBagozzi2000$orgcmt6),
                       orgcmt7 = as.ordered(BergamiBagozzi2000$orgcmt7),
                       orgcmt8 = as.ordered(BergamiBagozzi2000$orgcmt8))

model &lt;- "
# Measurement models
OrgPres =~ cei1 + cei2 + cei3 + cei4 + cei5 + cei6 + cei7 + cei8
OrgIden =~ ma1 + ma2 + ma3 + ma4 + ma5 + ma6
AffJoy  =~ orgcmt1 + orgcmt2 + orgcmt3 + orgcmt7
AffLove =~ orgcmt5 + orgcmt 6 + orgcmt8

# Structural model
OrgIden ~ OrgPres
AffLove ~ OrgIden
AffJoy  ~ OrgIden 
"
# Estimate using cSEM; note: the fact that indicators are factors triggers OrdPLSc
res &lt;- csem(.model = model, .data = data_new[1:250,])
summarize(res)

# Predict using OrdPLSPredict
set.seed(123)
pred &lt;- predict(
  .object = res, 
  .benchmark = "PLS-PM",
  .test_data = data_new[(251):305,],
   .treat_as_continuous = TRUE, .approach_score_target = "median"
  )

pred 
round(pred$Prediction_metrics[, -1], 4)
## End(Not run)
</code></pre>


</div>