<div class="container">

<table style="width: 100%;"><tr>
<td>graph.diffuseP1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Diffuse Probability P1 from a starting node</h2>

<h3>Description</h3>

<p>Recursively diffuse probability from a starting node based on the
connectivity of the network, representing the likelihood that a 
variable is most influenced by a perturbation in the starting node.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graph.diffuseP1(p1,sn,G,vNodes,thresholdDiff,adj_mat,verbose=FALSE,
                        out_dir="",r_level=1,coords=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>- The probability being dispersed from the starting node, 
sn, which is preferentially distributed between 
network nodes by the probability diffusion algorithm 
based solely on network connectivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sn</code></td>
<td>
<p>- "Start node", or the node most recently visited by the
network walker, from which p1 gets dispersed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>- A list of probabilities, with names of the list being the 
node names in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vNodes</code></td>
<td>
<p>- "Visited nodes", or the history of previous draws
in the node ranking sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholdDiff</code></td>
<td>
<p>- When the probability diffusion algorithm exchanges
this amount (thresholdDiff) or less between nodes, 
the algorithm returns up the call stack.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj_mat</code></td>
<td>
<p>- The adjacency matrix that encodes the edge weights for
the network, G.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>- If debugging or tracking a diffusion event, verbose=TRUE
will activate print statements. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out_dir</code></td>
<td>
<p>- If specified, a image sequence will generate in the
output directory specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_level</code></td>
<td>
<p>- "Recursion level", or the current depth in the call stack 
caused by a recursive algorithm. Only relevant if out_dir
is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>- The x and y coordinates for each node in the network, to
remain static between images. Only relevant if out_dir
is specified.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>G - A list of returned probabilities after the diffusion of
probability has truncated, with names of the list being the node names
in the network.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Read in any network via its adjacency matrix
adj_mat=rbind(c(0,1,2,0,0,0,0,0,0), #A's neighbors
                c(1,0,3,0,0,0,0,0,0), #B's neighbors
                c(2,3,0,0,1,0,0,0,0), #C's neighbors
                c(0,0,0,0,0,0,1,1,0), #D's neighbors
                c(0,0,1,0,0,1,0,0,0), #E's neighbors
                c(0,0,0,0,1,0,0,0,0), #F's neighbors
                c(0,0,0,1,0,0,0,1,0), #G's neighbors
                c(0,0,0,1,0,0,1,0,0), #H's neighbors
                c(0,0,0,0,0,0,0,0,0) #I's neighbors
                )
rownames(adj_mat)=c("A","B","C","D","E","F","G","H","I")
colnames(adj_mat)=c("A","B","C","D","E","F","G","H","I")
G=vector(mode="list", length=ncol(adj_mat))
names(G)=colnames(adj_mat)
G=lapply(G, function(i) i[[1]]=0)
probs_afterCurrDraw=graph.diffuseP1(p1=1.0, sn=names(G)[1], G=G,
                                    vNodes=names(G)[1], 
                                    thresholdDiff=0.01, adj_mat, TRUE)
</code></pre>


</div>