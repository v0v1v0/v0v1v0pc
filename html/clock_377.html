<div class="container">

<table style="width: 100%;"><tr>
<td>clock-setters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calendar setters</h2>

<h3>Description</h3>

<p>This family of functions sets fields in a calendar vector. Each
calendar has its own set of supported setters, which are documented on
their own help page:
</p>

<ul>
<li> <p>year-month-day
</p>
</li>
<li> <p>year-month-weekday
</p>
</li>
<li> <p>year-week-day
</p>
</li>
<li> <p>iso-year-week-day
</p>
</li>
<li> <p>year-quarter-day
</p>
</li>
<li> <p>year-day
</p>
</li>
</ul>
<p>There are also convenience methods for setting certain components
directly on R's native date and date-time types.
</p>

<ul>
<li> <p>dates (Date)
</p>
</li>
<li> <p>date-times (POSIXct / POSIXlt)
</p>
</li>
</ul>
<p>Some general rules about setting components on calendar types:
</p>

<ul>
<li>
<p> You can only set components that are relevant to the calendar type that
you are working with. For example, you can't set the quarter of a
year-month-day type. You'd have to convert to year-quarter-day first.
</p>
</li>
<li>
<p> You can set a component that is at the current precision, or one level
of precision more precise than the current precision. For example,
you can set the day field of a month precision year-month-day type,
but not the hour field.
</p>
</li>
<li>
<p> Setting a component can result in an <em>invalid date</em>, such as
<code>set_day(year_month_day(2019, 02), 31)</code>, as long as it is eventually
resolved either manually or with a strategy from <code>invalid_resolve()</code>.
</p>
</li>
<li>
<p> With sub-second precisions, you can only set the component corresponding
to the precision that you are at. For example, you can set the nanoseconds
of the second while at nanosecond precision, but not milliseconds.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">set_year(x, value, ...)

set_quarter(x, value, ...)

set_month(x, value, ...)

set_week(x, value, ...)

set_day(x, value, ...)

set_hour(x, value, ...)

set_minute(x, value, ...)

set_second(x, value, ...)

set_millisecond(x, value, ...)

set_microsecond(x, value, ...)

set_nanosecond(x, value, ...)

set_index(x, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code style="white-space: pre;">⁠[object]⁠</code>
</p>
<p>An object to set the component for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p><code style="white-space: pre;">⁠[integer]⁠</code>
</p>
<p>The value to set the component to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You cannot set components directly on a time point type, such as
sys-time or naive-time. Convert it to a calendar type first. Similarly,
a zoned-time must be converted to either a sys-time or naive-time, and
then to a calendar type, to be able to set components on it.
</p>


<h3>Value</h3>

<p><code>x</code> with the component set.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- year_month_day(2019, 1:3)

# Set the day
set_day(x, 12:14)

# Set to the "last" day of the month
set_day(x, "last")
</code></pre>


</div>