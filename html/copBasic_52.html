<div class="container">

<table style="width: 100%;"><tr>
<td>FGMcop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Generalized Farlie–Gumbel–Morgenstern Copula</h2>

<h3>Description</h3>

<p>The <em>generalized Farlie–Gumbel–Morgenstern copula</em> (Bekrizade <em>et al.</em>, 2012) is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\Theta, \alpha, n}(u,v) = \mathbf{FGM}(u,v) = uv[1 + \Theta(1-u^\alpha)(1-v^\alpha)]^n\mbox{,}</code>
</p>

<p>where <code class="reqn">\Theta \in [-\mathrm{min}\{1, 1/(n\alpha^2)\}, +1/(n\alpha)]</code>, <code class="reqn">\alpha &gt; 0</code>, and <code class="reqn">n \in 0,1,2,\cdots</code>. The copula <code class="reqn">\Theta = 0</code> or <code class="reqn">\alpha = 0</code> or <code class="reqn">n = 0</code> becomes the <em>independence copula</em> (<code class="reqn">\mathbf{\Pi}(u,v)</code>; <code>P</code>). When <code class="reqn">\alpha = n = 1</code>, then the well-known, single-parameter Farlie–Gumbel–Morgenstern copula results, and <em>Spearman Rho</em> (<code>rhoCOP</code>) is <code class="reqn">\rho_\mathbf{C} = \Theta/3</code> but in general
</p>
<p style="text-align: center;"><code class="reqn">\rho_\mathbf{C} = 12\sum_{r=1}^n {n \choose r} \Theta^r \biggl[\frac{\phantom{\alpha}\Gamma(r+1)\Gamma(2/\alpha)}{\alpha\Gamma(r+1+2/\alpha)} \biggr]^2
\mbox{.}</code>
</p>

<p>The support of <code class="reqn">\rho_\mathbf{C}(\cdots;\Theta, 1, 1)</code> is <code class="reqn">[-1/3, +1/3]</code> but extends via <code class="reqn">\alpha</code> and <code class="reqn">n</code> to <code class="reqn">\approx [-0.50, +0.43]</code>, which shows that the generalization of the copula increases the range of dependency. The generalized version is implemented by <code>FGMcop</code>.
</p>
<p>The <em>iterated Farlie–Gumbel–Morgenstern copula</em> (Chine and Benatia, 2017) for the <code class="reqn">r</code>th iteration is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\beta}(u,v) = \mathbf{FGMi}(u,v) = uv + \sum_{j=1}^{r} \beta_j\cdot(uv)^{[j/2]}\cdot(u'v')^{[(j+1)/2]}\mbox{,}</code>
</p>

<p>where <code class="reqn">u' = 1-u</code> and <code class="reqn">v' = 1-v</code> for <code class="reqn">|\beta_j| \le 1</code> that has <code class="reqn">r</code> dimensions <code class="reqn">\beta = (\beta_1, \cdots, \beta_j, \cdots, \beta_r)</code> and <code class="reqn">[t]</code> is the integer part of <code class="reqn">t</code>. The copula <code class="reqn">\beta = 0</code> becomes the <em>independence copula</em> (<code class="reqn">\mathbf{\Pi}(u,v)</code>; <code>P</code>). The support of <code class="reqn">\rho_\mathbf{C}(\cdots;\beta)</code> is approximately <code class="reqn">[-0.43, +0.43]</code>. The iterated version is implemented by <code>FGMicop</code>. Internally, the <code class="reqn">r</code> is determined from the length of the <code class="reqn">\beta</code> in the <code>para</code> argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FGMcop( u, v, para=c(NA, 1,1), ...)
FGMicop(u, v, para=NULL,       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>A vector of parameters. For the generalized version, the <code class="reqn">\Theta</code>, <code class="reqn">\alpha</code>, and <code class="reqn">n</code> of the copula where the default argument shows the need to include the <code class="reqn">\Theta</code>. However, if a fourth parameter is present, it is treated as a logical to reverse the copula (<code class="reqn">u + v - 1 + \mathbf{FGM}(1-u,1-v; \Theta, \alpha, n)</code>). Also if a single parameter is given, then the <code class="reqn">\alpha = n = 1</code> are automatically set to produce the single-parameter Farlie–Gumbel–Morgenstern copula. For the iterated version, the <code class="reqn">\beta</code> vector of <code class="reqn">r</code> iterations;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Bekrizade, Hakim, Parham, G.A., Zadkarmi, M.R., 2012, The new generalization of Farlie–Gumbel–Morgenstern copulas: Applied Mathematical Sciences, v. 6, no. 71, pp. 3527–3533.
</p>
<p>Chine, Amel, and Benatia, Fatah, 2017, Bivariate copulas parameters estimation using the trimmed L-moments methods: Afrika Statistika, v. 12, no. 1, pp. 1185–1197.
</p>


<h3>See Also</h3>

<p><code>P</code>, <code>mleCOP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Bekrizade et al. (2012, table 1) report for a=2 and n=3 that range in
# theta = [-0.1667, 0.1667] and range in rho = [-0.1806641, 0.4036458]. However,
# we see that they have seemingly made an error in listing the lower bounds of theta:
rhoCOP(FGMcop, para=c(  1/6, 2, 3))  #  0.4036458
rhoCOP(FGMcop, para=c( -1/6, 2, 3))  # Following error results
# In cop(u, v, para = para, ...) : parameter Theta &lt; -0.0833333333333333
rhoCOP(FGMcop, para=c(-1/12, 2, 3))  # -0.1806641 
## End(Not run)

## Not run: 
# Support of FGMrcop(): first for r=1 iterations and then for large r.
sapply(c(-1, 1), function(t) rhoCOP(cop=FGMrcop, para=rep(t, 1)) )
# [1] -0.3333333  0.3333333
sapply(c(-1, 1), function(t) rhoCOP(cop=FGMrcop, para=rep(t,50)) )
# [1] -0.4341385  0.4341385
## End(Not run)

## Not run: 
# Maximum likelihood estimation near theta upper bounds for a=3 and n=2.
set.seed(832)
UV &lt;- simCOP(300, cop=FGMcop, para=c(+0.16, 3, 2))
# Define a transform function for parameter domain, though mleCOP does
# provide some robustness anyway---not forcing n into the positive
# domain via as.integer(exp(p[3])) seems to not always be needed.
FGMpfunc &lt;- function(p) {
  d &lt;- p[1]; a &lt;- exp(p[2]); n &lt;- as.integer(exp(p[3]))
  lwr &lt;- -min(c(1,1/(n*a^2))); upr &lt;- 1/(n*a)
  d &lt;- ifelse(d &lt;= lwr, lwr, ifelse(d &gt;= upr, upr, d))
  return( c(d, a, n) )
}
para &lt;- c(0.16, 3, 2); init &lt;- c(0, 1, 1)
ML &lt;- mleCOP(UV$U, UV$V, cop=FGMcop, init.para=init, parafn=FGMpfunc)
print(ML$para) # [1] 0.1596361 3.1321228 2.0000000
# So, we have recovered reasonable estimates of the three parameters
# given through MLE estimation.
densityCOPplot(cop=FGMcop, para=   para, contour.col=2)
densityCOPplot(cop=FGMcop, para=ML$para, ploton=FALSE) #
## End(Not run)
</code></pre>


</div>