<div class="container">

<table style="width: 100%;"><tr>
<td>item_factors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine latent factors for a new item</h2>

<h3>Description</h3>

<p>Calculate latent factors for a new item, based on either
new 'X' data, new 'I' data, or both.
</p>
<p>Be aware that the package is user/row centric, and this function is provided for
quick experimentation purposes only. Calculating item factors will be slower
than calculating user factors
(except for the 'ContentBased' model for which both types of predictions
are equally fast and equally supported).
as it will not make usage of the precomputed
matrices. If item-based  predictions are required, it's recommended to use
instead the function swap.users.and.items and then use the resulting
object with factors_single or factors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">item_factors(
  model,
  X = NULL,
  X_col = NULL,
  X_val = NULL,
  I = NULL,
  I_col = NULL,
  I_val = NULL,
  I_bin = NULL,
  weight = NULL,
  output_bias = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A collective matrix factorization model from this package - see
fit_models for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>New 'X' data, either as a numeric vector (class 'numeric'), or as
a sparse vector from package 'Matrix' (class 'dsparseVector'). If the 'X' to
which the model was fit was a 'data.frame', the user/row indices will have
been reindexed internally, and the numeration can be found under
'model$info$user_mapping'. Alternatively, can instead pass the column indices
and values and let the model reindex them (see 'X_col' and 'X_val').
Should pass at most one of 'X' or 'X_col'+'X_val'.
</p>
<p>Be aware that, unlikely in pretty much every other function in this package,
here the values are for one <b>column</b> of 'X', not one <b>row</b> like
in e.g. factors_single.
</p>
<p>Dense 'X' data is not supported for 'CMF_implicit' or 'OMF_implicit'.
</p>
<p>Not supported for the 'ContentBased' model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_col</code></td>
<td>
<p>New 'X' data in sparse vector format, with 'X_col' denoting the
users/rows which are not missing. If the 'X' to which the model was fit was
a 'data.frame', here should pass IDs matching to the first column of that 'X',
which will be reindexed internally. Otherwise, should have <b>row</b> indices with
numeration starting at 1 (passed as an integer vector).
Should pass at most one of 'X' or 'X_col'+'X_val'.
</p>
<p>Not supported for the 'ContentBased' model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_val</code></td>
<td>
<p>New 'X' data in sparse vector format, with 'X_val' denoting the
associated values to each entry in 'X_col'
(should be a numeric vector of the same length as 'X_col').
Should pass at most one of 'X' or 'X_col'+'X_val'.
</p>
<p>Not supported for the 'ContentBased' model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>New 'I' data, either as a numeric vector (class 'numeric'), or as a
sparse vector from package 'Matrix' (class 'dsparseVector'). Alternatively,
if 'I' is sparse, can instead pass the indices of the non-missing columns
and their values separately (see 'I_col').
Should pass at most one of 'I' or 'I_col'+'I_val'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I_col</code></td>
<td>
<p>New 'I' data in sparse vector format, with 'I_col' denoting the
attributes/columns which are not missing. Should have numeration starting at 1
(should be an integer vector).
Should pass at most one of 'I' or 'I_col'+'I_val'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I_val</code></td>
<td>
<p>New 'I' data in sparse vector format, with 'I_val' denoting the
associated values to each entry in 'I_col'
(should be a numeric vector of the same length as 'I_col').
Should pass at most one of 'I' or 'I_col'+'I_val'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I_bin</code></td>
<td>
<p>Binary columns of 'I' on which a sigmoid transformation will be
applied. Should be passed as a numeric vector. Note that 'I' and 'I_bin' are
not mutually exclusive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>(Only for the explicit-feedback models)
Associated weight to each non-missing observation in 'X'. Must have the same
number of entries as 'X' - that is, if passing a dense vector of length 'm',
'weight' should be a numeric vector of length 'm' too, if passing a sparse
vector, should have a length corresponding to the number of non-missing elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_bias</code></td>
<td>
<p>Whether to also return the item bias determined by the model
given the data in 'X' (for explicit-feedback models fit with item biases).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If passing 'output_bias=FALSE', will return a vector with
the obtained latent factors for this item. If passing 'output_bias=TRUE', the
result will be a list with entry 'factors' having the above vector, and entry
'bias' having the estimated bias.
</p>


<h3>See Also</h3>

<p>factors_single predict_new_items
</p>


</div>