<div class="container">

<table style="width: 100%;"><tr>
<td>cv.cmls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cross-Validation for cmls
</h2>

<h3>Description</h3>

<p>Does k-fold or generalized cross-validation to tune the constraint options for <code>cmls</code>. Tunes the model with respect to any combination of the arguments <code>const</code>, <code>df</code>, <code>degree</code>, and/or <code>intercept</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.cmls(X, Y, nfolds = 2, foldid = NULL, parameters = NULL,
        const = "uncons", df = 10, degree = 3, intercept = TRUE,
        mse = TRUE, parallel = FALSE, cl = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of dimension <code class="reqn">n</code> x <code class="reqn">p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Matrix of dimension <code class="reqn">n</code> x <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Number of folds for k-fold cross-validation. Ignored if <code>foldid</code> argument is provided. Set <code>nfolds=1</code> for generalized cross-validation (GCV).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>Factor or integer vector of length <code class="reqn">n</code> giving the fold identification for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>Parameters for tuning. Data frame with columns <code>const</code>, <code>df</code>, <code>degree</code>, and <code>intercept</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>Parameters for tuning. Character vector specifying constraints for tuning. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Parameters for tuning. Integer vector specifying degrees of freedom for tuning. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>Parameters for tuning. Integer vector specifying polynomial degrees for tuning. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Parameters for tuning. Logical vector specifying intercepts for tuning. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mse</code></td>
<td>
<p>If <code>TRUE</code> (default), the mean squared error is used as the CV loss function. Otherwise the mean absolute error is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical indicating if <code>parSapply</code> should be used. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>Cluster created by <code>makeCluster</code>. Only used when <code>parallel = TRUE</code>. Recommended usage: <code>cl = makeCluster(detectCores())</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, tuning progress is printed via <code>txtProgressBar</code>. Ignored if <code>parallel = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to the <code>cmls</code> function, e.g., <code>z</code>, <code>struc</code>, <code>backfit</code>, etc.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameters for tuning can be supplied via one of two options: 
</p>
<p>(A) Using the <code>parameters</code> argument. In this case, the argument <code>parameters</code> must be a data frame with columns <code>const</code>, <code>df</code>, <code>degree</code>, and <code>intercept</code>, where each row gives a combination of parameters for the CV tuning.
</p>
<p>(B) Using the <code>const</code>, <code>df</code>, <code>degree</code>, and <code>intercept</code> arguments. In this case, the <code>expand.grid</code> function is used to create the <code>parameters</code> data frame, which contains all combinations of the arguments <code>const</code>, <code>df</code>, <code>degree</code>, and <code>intercept</code>. Duplicates are removed before the CV tuning.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>best.parameters</code></td>
<td>
<p>Best combination of parameters, i.e., the combination that minimizes the <code>cvloss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>top5.parameters</code></td>
<td>
<p>Top five combinations of parameters, i.e., the combinations that give the five smallest values of the <code>cvloss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.parameters</code></td>
<td>
<p>Full set of parameters. Data frame with <code>cvloss</code> (GCV, MSE, or MAE) for each combination of <code>parameters</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (in prep). Constrained multivariate least squares in R.
</p>


<h3>See Also</h3>

<p>See the <code>cmls</code> and <code>const</code> functions for further details on the available constraint options.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># make X
set.seed(1)
n &lt;- 50
m &lt;- 20
p &lt;- 2
Xmat &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)


# make B (which satisfies all constraints except monotonicity)
x &lt;- seq(0, 1, length.out = m)
Bmat &lt;- rbind(sin(2*pi*x), sin(2*pi*x+pi)) / sqrt(4.75)
struc &lt;- rbind(rep(c(TRUE, FALSE), each = m / 2),
               rep(c(FALSE, TRUE), each = m / 2))
Bmat &lt;- Bmat * struc


# make noisy data
Ymat &lt;- Xmat %*% Bmat + rnorm(n*m, sd = 0.5)


# 5-fold CV:  tune df (5,...,15) for const = "smooth"
kcv &lt;- cv.cmls(X = Xmat, Y = Ymat, nfolds = 5,
               const = "smooth", df = 5:15)
kcv$best.parameters
kcv$top5.parameters
plot(kcv$full.parameters$df, kcv$full.parameters$cvloss, t = "b")


## Not run: 

# sample foldid for 5-fold CV
set.seed(2)
foldid &lt;- sample(rep(1:5, length.out = n))


# 5-fold CV:  tune df (5,...,15) w/ all 20 relevant constraints (no struc)
#             using sequential computation (default)
myconst &lt;- as.character(const(print = FALSE)$label[-c(13:16)])
system.time({
  kcv &lt;- cv.cmls(X = Xmat, Y = Ymat, foldid = foldid,
                 const = myconst, df = 5:15)
})
kcv$best.parameters
kcv$top5.parameters


# 5-fold CV:  tune df (5,...,15) w/ all 20 relevant constraints (no struc)
#             using parallel package for parallel computations
myconst &lt;- as.character(const(print = FALSE)$label[-c(13:16)])
system.time({
   cl &lt;- makeCluster(2L)  # using 2 cores
   kcv &lt;- cv.cmls(X = Xmat, Y = Ymat, foldid = foldid,
                  const = myconst, df = 5:15,
                  parallel = TRUE, cl = cl)
   stopCluster(cl)                  
})
kcv$best.parameters
kcv$top5.parameters


# 5-fold CV:  tune df (5,...,15) w/ all 20 relevant constraints (w/ struc)
#             using sequential computation (default)
myconst &lt;- as.character(const(print = FALSE)$label[-c(13:16)])
system.time({
  kcv &lt;- cv.cmls(X = Xmat, Y = Ymat, foldid = foldid,
                 const = myconst, df = 5:15, struc = struc)
})
kcv$best.parameters
kcv$top5.parameters


# 5-fold CV:  tune df (5,...,15) w/ all 20 relevant constraints (w/ struc)
#             using parallel package for parallel computations
myconst &lt;- as.character(const(print = FALSE)$label[-c(13:16)])
system.time({
  cl &lt;- makeCluster(2L)  # using 2 cores
  kcv &lt;- cv.cmls(X = Xmat, Y = Ymat, foldid = foldid,
                 const = myconst, df = 5:15, struc = struc,
                 parallel = TRUE, cl = cl)
  stopCluster(cl)
})
kcv$best.parameters
kcv$top5.parameters


## End(Not run) 

</code></pre>


</div>