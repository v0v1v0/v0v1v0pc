<div class="container">

<table style="width: 100%;"><tr>
<td>tt.fun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Integrals needed in KOH2001</h2>

<h3>Description</h3>

<p>Calculates the three integrals needed for <code>V</code>, under the
restrictions specified in the KOH2001 supplement
</p>


<h3>Usage</h3>

<pre><code class="language-R">tt.fun(D1, extractor, x.i, x.j,  test.for.symmetry=FALSE, method=1, phi)
ht.fun(x.i, x.j, D1, extractor,  Edash.theta,  H1, fast.but.opaque=TRUE,
x.star=NULL, t.vec=NULL, phi) 
hh.fun(x.i, x.j,  H1, E.theta,  phi)
t.fun(x, D1, extractor,  phi) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D1</code></td>
<td>
<p>Matrix of code run points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H1</code></td>
<td>
<p>regression basis functions for <code>D1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extractor</code></td>
<td>
<p>Function to extract <code>x.star</code> and <code>t.vec</code>
from <code>D1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Lat and long of a point in <code>t.fun()</code> (eg <code>D2[1,]</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.i</code></td>
<td>
<p>Lat and long of first point (eg <code>D2[1,]</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.j</code></td>
<td>
<p>Lat and long of second point (eg <code>D2[2,]</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Edash.theta</code></td>
<td>
<p>Function to return expectation of <code>H</code> with respect
to the alternative distribution of <code class="reqn">\theta</code>;
<code>Edash.theta.toy</code> is the example for the toy dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.theta</code></td>
<td>
<p>Function to return expectation of <code>H</code> with respect
to <code class="reqn">\theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.for.symmetry</code></td>
<td>
<p>In <code>tt.fun()</code>, Boolean with <code>TRUE</code>
meaning to calculate each element of <code class="reqn">C</code> explicitly.  If
<code>FALSE</code>, then calculate only the elements of <code class="reqn">C</code> that
lie on or over the diagonal and use the fact that <code class="reqn">C</code> is
symmetric to calculate the other matrix elements.  For <code class="reqn">n</code>
observations, this means <code class="reqn">n(n+1)/2</code> evaluations,
compared with <code class="reqn">n^2</code> for the full case.
</p>
<p>Set this argument to <code>TRUE</code> only when debugging, or testing
accuracy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast.but.opaque</code></td>
<td>
<p>In <code>ht.fun()</code>, Boolean with default
<code>TRUE</code> meaning to pass some precalculated results as
arguments, to save time.  Set this argument to <code>FALSE</code> only
when debugging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.star</code></td>
<td>
<p>In <code>ht.fun()</code>, value of <code class="reqn">x^*</code> (required
only if <code>fast.but.opaque</code> is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.vec</code></td>
<td>
<p>In <code>ht.fun()</code>, value of <code class="reqn">t</code> (required
only if <code>fast.but.opaque</code> is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>In <code>tt.fun()</code>, zero means use the old method and
nonzero means use the new method.  The new method is faster, but
the code is harder to understand.  The two methods should give
identical results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>Hyperparameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The four functions return integrals representing means taken over
<code>theta</code>.  To wit:
</p>

<ul>
<li>
<p> Function <code>tt.fun()</code> evaluates </p>
<p style="text-align: center;"><code class="reqn">\int
  t(x_j,\theta)t(x_i,\theta)^Tp(\theta)d\theta</code>
</p>
<p>  and is used in
<code>V.fun()</code>.  Note that this function is symmetric in <code class="reqn">x_i</code>
and <code class="reqn">x_j</code>.
</p>
</li>
<li>
<p> Function <code>ht.fun()</code> evaluates </p>
<p style="text-align: center;"><code class="reqn">\int
  h_1(x_j,\theta)t(x_i,\theta)^Tp(\theta)d\theta</code>
</p>
<p> and is used in
<code>V.fun()</code>.  Note that this function is <strong>not</strong> symmetric in
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>.
</p>
</li>
<li>
<p> Function
<code>hh.fun()</code> evaluates </p>
<p style="text-align: center;"><code class="reqn">\int
  h_1(x_j,\theta)h_1(x_i,\theta)^Tp(\theta)d\theta</code>
</p>
<p> and is used in
<code>V.fun()</code>.  Note that this function is symmetric in <code class="reqn">x_i</code>
and <code class="reqn">x_j</code>.
</p>
</li>
<li>
<p> Function <code>t.fun()</code> evaluates
</p>
<p style="text-align: center;"><code class="reqn">\int
  t(x_i,\theta)^Tp(\theta)d\theta=
  \int c_1\left( (x_i,\theta),(x_j^*,t_j)\right)p(\theta)\,d\theta
</code>
</p>

<p>using the formula </p>
<p style="text-align: center;"><code class="reqn">
  \sigma_1^2\left|I+2V_\theta\Omega_x\right|^{-1/2}
  \exp\left\{
  -\left(x_i-x_j^*\right)^T\Omega_x\left(x_i-x_j^*\right)
  \right\}\times
  \exp\left\{
  -\left(m_\theta-t_j\right)^T
  \left(2V_\theta+\Omega_t^{-1}\right)^{-1}
  \left(m_\theta-t_j\right)\right\}.
</code>
</p>

<p>It is used in <code>Ez_eq7.supp()</code>.  NB: do not confuse
this function with <code>tee()</code>, which is different.
</p>
</li>
</ul>
<p>These functions are not generally of much interest to the end user; they
are called by <code>V.fun()</code>.  They are defined separately as a
debugging aid, and to simplify the structure of <code>V.fun()</code>.
</p>


<h3>Value</h3>

<p>Each function returns a matrix as described in KOH2001
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001. <em>Bayesian
calibration of computer models</em>.  Journal of the Royal Statistical
Society B, 63(3) pp425-464
</p>
</li>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001.  <em>Supplementary details on
Bayesian calibration of computer models</em>, Internal report, University
of Sheffield.  Available at
<a href="http://www.tonyohagan.co.uk/academic/ps/calsup.ps">http://www.tonyohagan.co.uk/academic/ps/calsup.ps</a>
</p>
</li>
<li>
<p>R. K. S. Hankin 2005. <em>Introducing BACCO, an R bundle for
Bayesian analysis of computer code output</em>, Journal of Statistical
Software, 14(16)
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>V.fun</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(toys)

tt.fun(D1=D1.toy, extractor=extractor.toy, x.i=D2.toy[1,],
    x.j=D2.toy[2,],  phi=phi.toy)

ht.fun(x.i=D2.toy[1,], x.j=D2.toy[2,], D1=D1.toy,
    extractor=extractor.toy, 
    Edash.theta=Edash.theta.toy, H1=H1.toy, fast.but.opaque=FALSE, phi=phi.toy)

ht.fun(x.i=D2.toy[1,], x.j=D2.toy[2,], D1=D1.toy,
    extractor=extractor.toy, 
    Edash.theta=Edash.theta.toy, H1=H1.toy, fast.but.opaque=TRUE,
    x.star=extractor.toy(D1.toy)$x.star, t.vec=extractor.toy(D1.toy)$t.vec,
    phi=phi.toy)



hh.fun(x.i=D2.toy[1,], x.j=D2.toy[2,],
    H1=H1.toy, E.theta=E.theta.toy,  phi=phi.toy)

t.fun(x=x.toy, D1=D1.toy, extractor=extractor.toy, phi=phi.toy)
</code></pre>


</div>