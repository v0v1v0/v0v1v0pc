<div class="container">

<table style="width: 100%;"><tr>
<td>backtracking.sc.dp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Backtracking Clustering for a Specific Cluster Number
</h2>

<h3>Description</h3>

<p>Creates clustering for <code>k</code> number of clusters by using the backtrack data produced by <code>findwithinss.sc.dp()</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">backtracking.sc.dp(x, k, backtrack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a multi-dimensional array containing input data to be clustered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p> the number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backtrack</code></td>
<td>
<p>the backtrack data</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the number of clusters is unknown <code>findwithinss.sc.dp()</code> followed by <code>backtracking.sc.dp()</code> can be used for performing clustering. If only subsequent elements of the input data may form a cluster method <code>findwithinss.sc.dp()</code> calculates the exact minimum of the sum of squares of within-cluster distances (<var>withinss</var>) from each element to its corresponding cluster centre (mean) for different cluster numbers. The user may analyse the <var>withinss</var> in order to select the proper number of clusters. In this case, it is enough to run method <code>backtracking.sc.dp()</code> only once. Another option is to run <code>findwithinss.sc.dp()</code> once, repeat the <code>backtracking.sc.dp()</code> step for a range of potential cluster numbers and then the user may evaluate the optimal solutions created for different number of clusters. This requires much less time than repeating the whole clustering algorithm for the different cluster numbers. 
</p>


<h3>Value</h3>

<p>An object of class '<code>clustering.sc.dp</code>' which has a print method and is a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> A vector of integers (<code>1:k</code>) indicating the cluster to which each point is allocated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p> A matrix whose rows represent cluster centres.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinss</code></td>
<td>
<p> The within-cluster sum of squares for each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p> The number of points in each cluster.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Tibor Szkaliczki <a href="mailto:szkaliczki.tibor@sztaki.hu">szkaliczki.tibor@sztaki.hu</a>
</p>


<h3>See Also</h3>

<p><code>findwithinss.sc.dp</code>, <code>clustering.sc.dp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example: clustering data generated from a random walk with small withinss
x&lt;-matrix(, nrow = 100, ncol = 2)
x[1,]&lt;-c(0,0)
for(i in 2:100) {
  x[i,1]&lt;-x[i-1,1] + rnorm(1,0,0.1)
  x[i,2]&lt;-x[i-1,2] + rnorm(1,0,0.1)
}
k&lt;-10
r&lt;-findwithinss.sc.dp(x,k)

# select the first cluster number where withinss drops below a threshold
thres &lt;- 5.0
k_th &lt;- 1;
while(r$twithinss[k_th] &gt; thres &amp; k_th &lt; k) {
    k_th &lt;- k_th + 1
}

# backtrack
result&lt;-backtracking.sc.dp(x,k_th, r$backtrack)
plot(x, type = 'b', col = result$cluster)
points(result$centers, pch = 24, bg = (1:k_th))
</code></pre>


</div>