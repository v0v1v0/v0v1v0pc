<div class="container">

<table style="width: 100%;"><tr>
<td>cartogramR_options</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set the options of cartogramR in the correct format</h2>

<h3>Description</h3>

<p>Set the options of cartogramR in the correct format
</p>


<h3>Usage</h3>

<pre><code class="language-R">cartogramR_options(
  options,
  method = c("gsm", "gn", "dcn", "GastnerSeguyMore", "GastnerNewman",
    "DougenikChrismanNiemeyer")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>a named list with some (or all) the following components:
</p>

<ul>
<li>
<p> maxit:  (all method) the maximum number of iterations,
default to 50.
</p>
</li>
<li>
<p> maxit_internal:  (<code style="white-space: pre;">⁠"gsm" or "gn"⁠</code>) the maximum number of internal
iterations, default to 10000.
</p>
</li>
<li>
<p> absrel:  (all method)  boolean, if <code>TRUE</code> relative convergence
if <code>FALSE</code> absolute convergence (default to <code>TRUE</code>)
</p>
</li>
<li>
<p> abserror: (all method) Areas on cartogram differ at most by an
(absolute value of) error of abserror. That is,
<code class="reqn">max_{polygons} |area_on_cartogram - target_area| &lt;= abserror</code>
(default to 10000)
</p>
</li>
<li>
<p> abstol:  (<code>"dcn"</code>) the absolute convergence error tolerance:
<code class="reqn">max_\{polygons\} |area(i) - area(i-1)|</code>
default to 1000
</p>
</li>
<li>
<p> relerror: (all method) Areas on cartogram differ at most by an
(absolute value of) relative error of relerror. That is,
<code class="reqn">max_\{polygons\} |area_on_cartogram / target_area - 1| &lt;= relerror</code>
(default to 0.01)
</p>
</li>
<li>
<p> reltol:  (<code>"dcn"</code>) the absolute convergence tolerance:
<code class="reqn">max_\{polygons\} abs((area(i) - area(i-1))/area(i-1)</code>
default to 1e-3
</p>
</li>
<li>
<p> L: (<code style="white-space: pre;">⁠"gsm" or "gn"⁠</code>) integer, gives the value of <code>L</code> (default
is 512), must be a power of two (for fftw)
</p>
</li>
<li>
<p> mp: (all method) if a region contains exactly zero population, it will be
replaced by mp times the smallest (strictly) positive population in any
region (default to 0.2)
</p>
</li>
<li>
<p> pf: (<code style="white-space: pre;">⁠"gsm" or "gn"⁠</code>) Determines space between map and boundary (default to 1.5)
</p>
</li>
<li>
<p> sigma: (<code style="white-space: pre;">⁠"gsm" or "gn"⁠</code>) Width of Gaussian blur to smoothen the density (default to 5)
</p>
</li>
<li>
<p> center: (<code style="white-space: pre;">⁠"gsm" or "gn"⁠</code>) either a character string
(only possible choices are <code>"centroid"</code>
or <code>"point_on_surface"</code>) or a function. If the
object is a function, it  will be used to
calculate the "center" of polygons; <code>"point_on_surface"</code>
will use the function sf::st_point_on_surface
while <code>"centroid"</code> (the default) will use sf::st_centroid.
</p>
</li>
<li>
<p> verbose: (all method) integer giving the verbosity level
(default to <code>0</code>, not verbose)
</p>
</li>
<li>
<p> grid: (<code style="white-space: pre;">⁠"gsm" or "gn"⁠</code>) boolean, if <code>TRUE</code> export the final
grid from flow algorithm (default to <code>TRUE</code>). Setting to <code>FALSE</code>
</p>
</li>
<li>
<p> check.ring.dir: (all method) boolean, if <code>TRUE</code> controls polygons orientation
(default to <code>TRUE</code>)
</p>
</li>
<li>
<p> check.only: (all method) boolean, if <code>TRUE</code> control only polygons orientation
and no replacement is done (default to <code>FALSE</code>)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method to be used, can be one of the following:
<code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code>, <code>dcn</code> or <code>DougenikChrismanNiemeyer</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list to be processed by cartogramR
</p>


<h3>References</h3>


<ul>
<li>
<p> Dougenik, J., Chrisman, R. &amp;  Niemeyer, D. (1985).
An algorithm to construct continuous area cartograms.
Professional Geographer <strong>37</strong>: 75-81.
</p>
</li>
<li>
<p> Gastner, M. &amp; Newman, M. E. J. (2004). Diffusion-based
method for producing density equalizing
maps. <em>Proc. Natl. Acad. Sci. USA</em>, <strong>101</strong>:7499-7504
</p>
</li>
<li>
<p> Gastner, M., Seguy, V. &amp; More, P. (2018). Fast flow-based
algorithm for creating density-equalizing map
projections. <em>Proceedings of the National Academy of Sciences
USA</em>, <strong>115</strong>:E2156-E2164
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
  data(usa)
  carto1 &lt;- cartogramR(usa, "electors64", options=list(verbose=1, L=256))
  plot(carto1)


</code></pre>


</div>