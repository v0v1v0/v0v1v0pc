<div class="container">

<table style="width: 100%;"><tr>
<td>cluster.intern</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply clustering method after multiple imputation</h2>

<h3>Description</h3>

<p>From a list of imputed datasets <code>clusterMI</code> performs cluster analysis on each imputed data set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cluster.intern(
  res.imp,
  method.clustering = "kmeans",
  scaling = TRUE,
  nb.clust = NULL,
  method.hclust = "average",
  method.dist = "euclidean",
  modelNames = NULL,
  modelName.hc = "VVV",
  nstart.kmeans = 100,
  iter.max.kmeans = 10,
  m.cmeans = 2,
  samples.clara = 500,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>res.imp</code></td>
<td>
<p>a list of imputed data sets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.clustering</code></td>
<td>
<p>a single string specifying the clustering algorithm used ("kmeans", "pam", "clara", "hclust" or "mixture","cmeans")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>boolean. If TRUE, variables are scaled. Default value is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.clust</code></td>
<td>
<p>an integer specifying the number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.hclust</code></td>
<td>
<p>character string defining the clustering method for hierarchical clustering (required only if method.clustering = "hclust")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.dist</code></td>
<td>
<p>character string defining the method use for computing dissimilarity matrices in hierarchical clustering (required only if method.clustering = "hclust")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelNames</code></td>
<td>
<p>character string indicating the models to be fitted in the EM phase of clustering (required only if method.clustering = "mixture"). By default modelNames = NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelName.hc</code></td>
<td>
<p>A character string indicating the model to be used in model-based agglomerative hierarchical clustering.(required only if method.clustering = "mixture"). By default modelNames.hc = "VVV".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart.kmeans</code></td>
<td>
<p>how many random sets should be chosen for kmeans initalization. Default value is 100 (required only if method.clustering = "kmeans")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max.kmeans</code></td>
<td>
<p>how many iterations should be chosen for kmeans. Default value is 10 (required only if method.clustering = "kmeans")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.cmeans</code></td>
<td>
<p>degree of fuzzification in cmeans clustering. By default m.cmeans = 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samples.clara</code></td>
<td>
<p>number of samples to be drawn from the dataset when performing clustering using clara algorithm. Default value is 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs cluster analysis (according to the <code>method.clustering</code> argument). For achieving this goal, the function uses as an input an output from the <code>imputedata</code> function and applies the cluster analysis method on each imputed data set
</p>
<p>Step 1 can be tuned by specifying the cluster analysis method used (<code>method.clustering</code> argument).
If <code>method.clustering = "kmeans"</code> or <code>"pam"</code>, then the number of clusters can be specified by tuning the <code>nb.clust</code> argument. By default, the same number as the one used for imputation is used.
The number of random initializations can also be tuned through the <code>nstart.kmeans</code> argument.
If <code>method.clustering = "hclust"</code> (hierarchical clustering), the method used can be specified (see <code>hclust</code>). By default <code>"average"</code> is used. Furthermore, the number of clusters can be specified, but it can also be automatically chosen if <code>nb.clust</code> &lt; 0.
If <code>method.clustering = "mixture"</code> (model-based clustering using gaussian mixture models), the model to be fitted can be tuned by modifying the <code>modelNames</code> argument (see <code>Mclust</code>).
If <code>method.clustering = "cmeans"</code> (clustering using the fuzzy c-means algorithm), then the fuzziness parameter can be modfied by tuning the<code>m.cmeans</code> argument. By default, <code>m.cmeans = 2</code>.
</p>
<p>Can be performed in parallel by specifying the number of CPU cores (<code>nnodes</code> argument).
</p>


<h3>Value</h3>

<p>A list with clustering results
</p>


<h3>See Also</h3>

<p><code>hclust</code>, <code>Mclust</code>, <code>imputedata</code>, <code>cmeans</code>,<code>dist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(wine)

require(parallel)
set.seed(123456)
ref &lt;- wine$cult
nb.clust &lt;- 3
m &lt;- 5 # number of imputed data sets. Should be larger in practice
wine.na &lt;- wine
wine.na$cult &lt;- NULL
wine.na &lt;- prodna(wine.na)

#imputation
res.imp &lt;- imputedata(data.na = wine.na, nb.clust = nb.clust, m = m)

#analysis by kmeans and pooling
nnodes &lt;- 2 # parallel::detectCores()
res.pool &lt;- clusterMI(res.imp, nnodes = nnodes)

res.pool$instability
table(ref, res.pool$part)

</code></pre>


</div>