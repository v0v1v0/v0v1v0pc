<div class="container">

<table style="width: 100%;"><tr>
<td>efficient-programming</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Small Functions to Make R Programming More Efficient
</h2>

<h3>Description</h3>

<p>A small set of functions to address some common inefficiencies in R, such as the creation of logical vectors to compare quantities, unnecessary copies of objects in elementary mathematical or subsetting operations, obtaining information about objects (esp. data frames), or dealing with missing values. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">anyv(x, value)              # Faster than any(x == value). See also kit::panyv()
allv(x, value)              # Faster than all(x == value). See also kit::pallv()
allNA(x)                    # Faster than all(is.na(x)). See also kit::pallNA()
whichv(x, value,            # Faster than which(x == value)
       invert = FALSE)      # or which(x != value). See also Note (3)
whichNA(x, invert = FALSE)  # Faster than which((!)is.na(x))
x %==% value                # Infix for whichv(v, value, FALSE), use e.g. in fsubset()
x %!=% value                # Infix for whichv(v, value, TRUE). See also Note (3)
alloc(value, n,             # Fast rep_len(value, n) or replicate(n, value).
      simplify = TRUE)      # simplify only works if length(value) == 1. See Details.
copyv(X, v, R, ..., invert  # Fast replace(X, v, R), replace(X, X (!/=)= v, R) or
    = FALSE, vind1 = FALSE, # replace(X, (!)v, R[(!)v]). See Details and Note (4).
    xlist = FALSE)          # For multi-replacement see also kit::vswitch()
setv(X, v, R, ..., invert   # Same for X[v] &lt;- r, X[x (!/=)= v] &lt;- r or
    = FALSE, vind1 = FALSE, # x[(!)v] &lt;- r[(!)v]. Modifies X by reference, fastest.
    xlist = FALSE)          # X/R/V can also be lists/DFs. See Details and Examples.
setop(X, op, V, ...,        # Faster than X &lt;- X +\-\*\/ V (modifies by reference)
      rowwise = FALSE)      # optionally can also add v to rows of a matrix or list
X %+=% V                    # Infix for setop(X, "+", V). See also Note (2)
X %-=% V                    # Infix for setop(X, "-", V). See also Note (2)
X %*=% V                    # Infix for setop(X, "*", V). See also Note (2)
X %/=% V                    # Infix for setop(X, "/", V). See also Note (2)
na_rm(x)                    # Fast: if(anyNA(x)) x[!is.na(x)] else x, last
na_locf(x, set = FALSE)     # obs. carried forward and first obs. carried back.
na_focb(x, set = FALSE)     # (by reference). These also support lists (NULL/empty)
na_omit(X, cols = NULL,     # Faster na.omit for matrices and data frames,
        na.attr = FALSE,    # can use selected columns to check, attach indices,
        prop = 0, ...)      # and remove cases with a proportion of values missing
na_insert(X, prop = 0.1,    # Insert missing values at random
          value = NA)
missing_cases(X, cols=NULL, # The opposite of complete.cases(), faster for DF's.
  prop = 0, count = FALSE)  # See also kit::panyNA(), kit::pallNA(), kit::pcountNA()
vlengths(X, use.names=TRUE) # Faster lengths() and nchar() (in C, no method dispatch)
vtypes(X, use.names = TRUE) # Get data storage types (faster vapply(X, typeof, ...))
vgcd(x)                     # Greatest common divisor of positive integers or doubles
fnlevels(x)                 # Faster version of nlevels(x) (for factors)
fnrow(X)                    # Faster nrow for data frames (not faster for matrices)
fncol(X)                    # Faster ncol for data frames (not faster for matrices)
fdim(X)                     # Faster dim for data frames (not faster for matrices)
seq_row(X)                  # Fast integer sequences along rows of X
seq_col(X)                  # Fast integer sequences along columns of X
vec(X)                      # Vectorization (stacking) of matrix or data frame/list
cinv(x)                     # Choleski (fast) inverse of symmetric PD matrix, e.g. X'X
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X, V, R</code></td>
<td>
<p>a vector, matrix or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, v</code></td>
<td>
<p>a (atomic) vector or matrix (<code>na_rm</code> also supports lists).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>a single value of any (atomic) vector type. For <code>whichv</code> it can also be a <code>length(x)</code> vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>logical. <code>TRUE</code> considers elements <code>x != value</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set</code></td>
<td>
<p>logical. <code>TRUE</code> transforms <code>x</code> by reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>logical. If <code>value</code> is a length-1 atomic vector, <code>alloc()</code> with <code>simplify = TRUE</code> returns a length-n atomic vector. If <code>simplify = FALSE</code>, the result is always a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vind1</code></td>
<td>
<p>logical. If <code>length(v) == 1L</code>, setting <code>vind1 = TRUE</code> will interpret <code>v</code> as an index, rather than a value to search and replace.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlist</code></td>
<td>
<p>logical. If <code>X</code> is a list, the default is to treat it like a data frame and replace rows. Setting <code>xlist = TRUE</code> will treat <code>X</code> and its replacement <code>R</code> like 1-dimensional list vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>op</code></td>
<td>
<p>an integer or character string indicating the operation to perform.
</p>

<table>
<tr>
<td style="text-align: left;">
<em> Int. </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> String </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
<td style="text-align: left;">
                 1 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <code>"+"</code>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> add <code>V</code> </td>
</tr>
<tr>
<td style="text-align: left;">
                 2 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <code>"-"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> subtract <code>V</code> </td>
</tr>
<tr>
<td style="text-align: left;">
                 3 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <code>"*"</code>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> multiply by <code>V</code> </td>
</tr>
<tr>
<td style="text-align: left;">
                 4 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <code>"/"</code>  </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> divide by <code>V</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowwise</code></td>
<td>
<p>logical. <code>TRUE</code> performs the operation between <code>V</code> and each row of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>select columns to check for missing values using column names, indices, a logical vector or a function (e.g. <code>is.numeric</code>). The default is to check all columns, which could be inefficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer. The length of the vector to allocate with <code>value</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.attr</code></td>
<td>
<p>logical. <code>TRUE</code> adds an attribute containing the removed cases. For compatibility reasons this is exactly the same format as <code>na.omit</code> i.e. the attribute is called "na.action" and of class "omit".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>double. For <code>na_insert</code>: the proportion of observations to be randomly replaced with <code>NA</code>. For <code>missing_cases</code> and <code>na_omit</code>: the proportion of values missing for the case to be considered missing (within <code>cols</code> if specified). For matrices this is implemented in R as <code>rowSums(is.na(X)) &gt;= max(as.integer(prop * ncol(X)), 1L)</code>. The C code for data frames works equivalently, and skips list- and raw-columns (<code>ncol(X)</code> is adjusted downwards).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>logical. <code>TRUE</code> returns the row-wise missing value count (within <code>cols</code>). This ignores <code>prop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.names</code></td>
<td>
<p>logical. Preserve names if <code>X</code> is a list. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for <code>na_omit</code>: further arguments passed to <code>[</code> for vectors and matrices. With indexed data it is also possible to specify the <code>drop.index.levels</code> argument, see indexing. For <code>copyv</code>, <code>setv</code> and <code>setop</code>, the argument is unused, and serves as a placeholder for possible future arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>alloc</code> is a fusion of <code>rep_len</code> and <code>replicate</code> that is faster in both cases. If <code>value</code> is a length one atomic vector (logical, integer, double, string, complex or raw) and <code>simplify = TRUE</code>, the functionality is as <code>rep_len(value, n)</code> i.e. the output is a length <code>n</code> atomic vector with the same attributes as <code>value</code> (apart from <code>"names"</code>, <code>"dim"</code> and <code>"dimnames"</code>). For all other cases the functionality is as <code>replicate(n, value, simplify = FALSE)</code> i.e. the output is a length-<code>n</code> list of the objects. For efficiency reasons the object is not copied i.e. only the pointer to the object is replicated.
</p>
<p><code>copyv</code> and <code>setv</code> are designed to optimize operations that require replacing data in objects in the broadest sense. The only difference between them is that <code>copyv</code> first deep-copies <code>X</code> before doing replacements whereas <code>setv</code> modifies <code>X</code> in place and returns the result invisibly. There are 3 ways these functions can be used:
</p>

<ol>
<li>
<p> To replace a single value, <code>setv(X, v, R)</code> is an efficient alternative to <code>X[X == v] &lt;- R</code>, and  <code>copyv(X, v, R)</code> is more efficient than <code>replace(X, X == v, R)</code>. This can be inverted using <code>setv(X, v, R, invert = TRUE)</code>, equivalent to <code>X[X != v] &lt;- R</code>.
</p>
</li>
<li>
<p> To do standard replacement with integer or logical indices i.e. <code>X[v] &lt;- R</code> is more efficient using <code>setv(X, v, R)</code>, and, if <code>v</code> is logical, <code>setv(X, v, R, invert = TRUE)</code> is efficient for <code>X[!v] &lt;- R</code>. To distinguish this from use case (1) when <code>length(v) == 1</code>, the argument <code>vind1 = TRUE</code> can be set to ensure that <code>v</code> is always interpreted as an index.
</p>
</li>
<li>
<p> To copy values from objects of equal size i.e. <code>setv(X, v, R)</code> is faster than <code>X[v] &lt;- R[v]</code>, and <code>setv(X, v, R, invert = TRUE)</code> is faster than <code>X[!v] &lt;- R[!v]</code>.
</p>
</li>
</ol>
<p>Both <code>X</code> and <code>R</code> can be atomic or data frames / lists. If <code>X</code> is a list, the default behavior is to interpret it like a data frame, and apply <code>setv/copyv</code> to each element/column of <code>X</code>. If <code>R</code> is also a list, this is done using <code>mapply</code>. Thus <code>setv/copyv</code> can also be used to replace elements or rows in data frames, or copy rows from equally sized frames. Note that for replacing subsets in data frames <code>set</code> from <code>data.table</code> provides a more convenient interface (and there is also <code>copy</code> if you just want to deep-copy an object without any modifications to it).
</p>
<p>If <code>X</code> should not be interpreted like a data frame, setting <code>xlist = TRUE</code> will interpret it like a 1D list-vector analogous to atomic vectors, except that use case (1) is not permitted i.e. no value comparisons on list elements.

</p>



<h3>Note</h3>


<ol>
<li>
<p> None of these functions (apart from <code>alloc</code>) currently support complex vectors.
</p>
</li>
<li> <p><code>setop</code> and the operators <code>%+=%</code>, <code>%-=%</code>, <code>%*=%</code> and <code>%/=%</code> also work with integer data, but do not perform any integer related checks. R's integers are bounded between +-2,147,483,647 and <code>NA_integer_</code> is stored as the value -2,147,483,648. Thus computations resulting in values exceeding +-2,147,483,647 will result in integer overflows, and <code>NA_integer_</code> should not occur on either side of a <code>setop</code> call. These are programmers functions and meant to provide the most efficient math possible to responsible users.
</p>
</li>
<li>
<p> It is possible to compare factors by the levels (e.g. <code>iris$Species %==% "setosa")</code>) or using integers (<code>iris$Species %==% 1L</code>). The latter is slightly more efficient. Nothing special is implemented for other objects apart from basic types, e.g. for dates (which are stored as doubles) you need to generate a date object i.e. <code>wlddev$date %==% as.Date("2019-01-01")</code>. Using <code>wlddev$date %==% "2019-01-01"</code> will give <code>integer(0)</code>.
</p>
</li>
<li> <p><code>setv/copyv</code> only allow positive integer indices being passed to <code>v</code>, and, for efficiency reasons, they only check the first and the last index. Thus if there are indices in the middle that fall outside of the data range it will terminate R.
</p>
</li>
</ol>
<h3>See Also</h3>

<p>Data Transformations, Small (Helper) Functions, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">oldopts &lt;- options(max.print = 70)
## Which value
whichNA(wlddev$PCGDP)                # Same as which(is.na(wlddev$PCGDP))
whichNA(wlddev$PCGDP, invert = TRUE) # Same as which(!is.na(wlddev$PCGDP))
whichv(wlddev$country, "Chad")       # Same as which(wlddev$county == "Chad")
wlddev$country %==% "Chad"           # Same thing
whichv(wlddev$country, "Chad", TRUE) # Same as which(wlddev$county != "Chad")
wlddev$country %!=% "Chad"           # Same thing
lvec &lt;- wlddev$country == "Chad"     # If we already have a logical vector...
whichv(lvec, FALSE)                  # is fastver than which(!lvec)
rm(lvec)

# Using the %==% operator can yield tangible performance gains
fsubset(wlddev, iso3c %==% "DEU") # 3x faster than:
fsubset(wlddev, iso3c == "DEU")

# With multiple categories we can use %iin%
fsubset(wlddev, iso3c %iin% c("DEU", "ITA", "FRA"))

## Math by reference: permissible types of operations
x &lt;- alloc(1.0, 1e5) # Vector
x %+=% 1
x %+=% 1:1e5
xm &lt;- matrix(alloc(1.0, 1e5), ncol = 100) # Matrix
xm %+=% 1
xm %+=% 1:1e3
setop(xm, "+", 1:100, rowwise = TRUE)
xm %+=% xm
xm %+=% 1:1e5
xd &lt;- qDF(replicate(100, alloc(1.0, 1e3), simplify = FALSE)) # Data Frame
xd %+=% 1
xd %+=% 1:1e3
setop(xd, "+", 1:100, rowwise = TRUE)
xd %+=% xd
rm(x, xm, xd)

## setv() and copyv()
x &lt;- rnorm(100)
y &lt;- sample.int(10, 100, replace = TRUE)
setv(y, 5, 0)            # Faster than y[y == 5] &lt;- 0
setv(y, 4, x)            # Faster than y[y == 4] &lt;- x[y == 4]
setv(y, 20:30, y[40:50]) # Faster than y[20:30] &lt;- y[40:50]
setv(y, 20:30, x)        # Faster than y[20:30] &lt;- x[20:30]
rm(x, y)

# Working with data frames, here returning copies of the frame
copyv(mtcars, 20:30, ss(mtcars, 10:20))
copyv(mtcars, 20:30, fscale(mtcars))
ftransform(mtcars, new = copyv(cyl, 4, vs))
# Column-wise:
copyv(mtcars, 2:3, fscale(mtcars), xlist = TRUE)
copyv(mtcars, 2:3, mtcars[4:5], xlist = TRUE)

## Missing values
mtc_na &lt;- na_insert(mtcars, 0.15)    # Set 15% of values missing at random
fnobs(mtc_na)                        # See observation count
missing_cases(mtc_na)                # Fast equivalent to !complete.cases(mtc_na)
missing_cases(mtc_na, cols = 3:4)    # Missing cases on certain columns?
missing_cases(mtc_na, count = TRUE)  # Missing case count
missing_cases(mtc_na, prop = 0.8)    # Cases with 80% or more missing
missing_cases(mtc_na, cols = 3:4, prop = 1)     # Cases mssing columns 3 and 4
missing_cases(mtc_na, cols = 3:4, count = TRUE) # Missing case count on columns 3 and 4

na_omit(mtc_na)                      # 12x faster than na.omit(mtc_na)
na_omit(mtc_na, prop = 0.8)          # Only remove cases missing 80% or more
na_omit(mtc_na, na.attr = TRUE)      # Adds attribute with removed cases, like na.omit
na_omit(mtc_na, cols = .c(vs, am))   # Removes only cases missing vs or am
na_omit(qM(mtc_na))                  # Also works for matrices
na_omit(mtc_na$vs, na.attr = TRUE)   # Also works with vectors
na_rm(mtc_na$vs)                     # For vectors na_rm is faster ...
rm(mtc_na)

## Efficient vectorization
head(vec(EuStockMarkets)) # Atomic objects: no copy at all
head(vec(mtcars))         # Lists: directly in C

options(oldopts)
</code></pre>


</div>