<div class="container">

<table style="width: 100%;"><tr>
<td>monitorCointegration</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Procedure for Monitoring Level and Trend Cointegration</h2>

<h3>Description</h3>

<p>This procedure is able to monitor a cointegration model for level or
trend cointegration and returns the corresponding break point, if available.
It is based on parameter estimation on a pre-break "calibration" period
at the beginning of the sample that is known or assumed to be free of
structural change and can be specified exactly via the <code>m</code> argument
(see Details for further information).
</p>


<h3>Usage</h3>

<pre><code class="language-R">monitorCointegration(x, y, m = 0.25, model = c("FM", "D", "IM"),
  trend = FALSE, kernel = c("ba", "pa", "qs", "tr"), bandwidth = c("and",
  "nw"), D.options = NULL, signif.level = 0.05, return.stats = TRUE,
  return.input = TRUE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br>
Data on which to apply the monitoring procedure (RHS).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br>
Data on which to apply the monitoring procedure (LHS).
Has to be one-dimensional. If <code>matrix</code>, it may
have only one row or column, if <code>data.frame</code> just one column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>[<code>numeric(1)</code>]<br>
Length of calibration period as fraction of the data's length
(between 0.1 and 0.9) or as number of observations (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>[<code>character(1)</code>]<br>
The model to be used for modified OLS calculations. Should be one of
FM-OLS (<code>"FM"</code>), D-OLS (<code>"D"</code>) or IM-OLS (<code>"IM"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p>[<code>logical</code>]<br>
Should an intercept and a linear trend be included?
If <code>FALSE</code> (default), only an intercept is included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br>
The kernel function to use for calculating the long-run variance.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>[<code>character(1)</code> | <code>numeric(1)</code>]<br>
The bandwidth to use for calculating the long-run variance.
Default is Andrews (1991) (<code>"and"</code>), an alternative is Newey West
(1994) (<code>"nw"</code>). You can also set the bandwidth manually.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.options</code></td>
<td>
<p>[<code>list</code> | <code>NULL</code>]<br>
Options for the D-OLS calculations. A list with elements <code>n.lead</code>,
<code>n.lag</code>, <code>kmax</code> and <code>info.crit</code> â€“ or <code>NULL</code> (then
default arguments are the same as in <code>cointRegD</code>.
See that help page for further information.)
Missing list elements will be replaced automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signif.level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br>
Level of significance (between 0.01 and 0.1).
Detection time will be calculated only if the estimated
p-value is smaller than <code>signif.level</code>. Default is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.stats</code></td>
<td>
<p>[<code>logical</code>]<br>
Whether to return all test statistics. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.input</code></td>
<td>
<p>[<code>logical</code>]<br>
Whether to return the input data, default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>[<code>logical</code>]<br>
Wheather to check (and if necessary convert) the arguments.
See <code>checkVars</code> for further information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>getBandwidthNW</code> (<code>inter</code>,
<code>weights</code>), if <code>bandwidth = "nw"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The calibration period can be set by setting the argument <code>m</code> to the
number of the last observation, that should be inside this period.
The corresponding fraction of the data's length will be calculated
automatically. Alternatively you can set <code>m</code> directly to the fitting
fraction value, but you should pay attention to the fact, that the
calibration period may become smaller than intended: The last observation
is calculated as <code>floor(m * N)</code> (with <code>N</code> the length of x).
</p>
<p>The kernel that is used for calculating the long-run variance can be
one of the following:
</p>

<ul>
<li> <p><code>"ba"</code>: Bartlett kernel
</p>
</li>
<li> <p><code>"pa"</code>: Parzen kernel
</p>
</li>
<li> <p><code>"qs"</code>: Quadratic Spectral kernel
</p>
</li>
<li> <p><code>"tr"</code>: Truncated kernel
</p>
</li>
</ul>
<h3>Value</h3>

<p>[<code>cointmonitoR</code>] object with components:
</p>

<dl>
<dt>
<code>Hsm</code> [<code>numeric(1)</code>]</dt>
<dd>
<p>value of the test statistic</p>
</dd>
<dt>
<code>time</code> [<code>numeric(1)</code>]</dt>
<dd>
<p>detected time of structural break</p>
</dd>
<dt>
<code>p.value</code> [<code>numeric(1)</code>]</dt>
<dd>
<p>estimated p-value of the test (between 0.01 and 0.1)</p>
</dd>
<dt>
<code>cv</code> [<code>numeric(1)</code>]</dt>
<dd>
<p>critical value of the test</p>
</dd>
<dt>
<code>sig</code> [<code>numeric(1)</code>]</dt>
<dd>
<p>significance level used for the test</p>
</dd>
<dt>
<code>residuals</code> [<code>numeric</code>]</dt>
<dd>
<p>residuals of the modified OLS model to be used for calculating the
test statistics</p>
</dd>
<dt>
<code>model</code> [<code>character(1)</code>]</dt>
<dd>
<p><code>cointOLS</code> model ("FM", "D", or "IM")</p>
</dd>
<dt>
<code>trend</code> [<code>character(1)</code>]</dt>
<dd>
<p>trend model ("level" or "trend")</p>
</dd>
<dt>
<code>name</code> [<code>character(1)</code>]</dt>
<dd>
<p>name(s) of data</p>
</dd>
<dt>
<code>m</code> [<code>list(2)</code>]</dt>
<dd>
<p>list with components:<br><code>$m.frac</code> [<code>numeric(1)</code>]: calibration period (fraction)<br><code>$m.index</code> [<code>numeric(1)</code>]: calibration period (length)</p>
</dd>
<dt>
<code>kernel</code> [<code>character(1)</code>]</dt>
<dd>
<p>kernel function</p>
</dd>
<dt>
<code>bandwidth</code> [<code>list(2)</code>]</dt>
<dd>
<p><code>$name</code> [<code>character(1)</code>]: bandwidth function (name)<br><code>$number</code> [<code>numeric(1)</code>]: bandwidth</p>
</dd>
<dt>
<code>statistics</code> [<code>numeric</code>]</dt>
<dd>
<p>values of test statistics with the same length as data, but <code>NA</code>
during calibration period (available if <code>return.stats = TRUE</code>)</p>
</dd>
<dt>
<code>input</code> [<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]</dt>
<dd>
<p>copy of input data (available if <code>return.stats = TRUE</code>)</p>
</dd>
<dt>
<code>D.options</code> [<code>list</code>]</dt>
<dd>
<p>information about further parameters (available if <code>model = "D"</code>)</p>
</dd>
</dl>
<h3>References</h3>


<ul><li>
<p> Wagner, M. and D. Wied (2015): "Monitoring Stationarity and
Cointegration," <em>Discussion Paper</em>,
<a href="http://dx.doi.org/10.2139/ssrn.2624657">DOI:10.2139/ssrn.2624657</a>.
</p>
</li></ul>
<h3>See Also</h3>

<p>Other cointmonitoR: <code>monitorStationarity</code>,
<code>plot.cointmonitoR</code>,
<code>print.cointmonitoR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(42)
x = data.frame(x1 = cumsum(rnorm(200)), x2 = cumsum(rnorm(200)))
eps1 = rnorm(200, sd = 2)
eps2 = c(eps1[1:100], cumsum(eps1[101:200]))

y = x$x1 - x$x2 + 10 + eps1
monitorCointegration(x = x, y = y, m = 0.5, model = "FM")

y2 = y + seq(1, 30, length = 200)
monitorCointegration(x = x, y = y2, m = 0.5, model = "FM")
monitorCointegration(x = x, y = y2, m = 0.5, trend = TRUE, model = "FM")

y3 = x$x1 - x$x2 + 10 + eps2
monitorCointegration(x = x, y = y3, m = 0.5, model = "FM")
monitorCointegration(x = x, y = y3, m = 0.5, model = "D")
monitorCointegration(x = x, y = y3, m = 0.5, model = "IM")

</code></pre>


</div>