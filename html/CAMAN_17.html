<div class="container">

<table style="width: 100%;"><tr>
<td>mixalg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Finite Mixture Models</h2>

<h3>Description</h3>

<p>This hybrid mixture algorithm  combines the VEM algorithm  for flexible
support size and the EM algorithm for a fixed number of components.
The solution of the VEM algorithm provides starting values for the EM
algorithm. By the NPMLE theorem the EM algorithm
thus starts very close to the global maximum and proper convergence of the
EM algorithm to a global maximum is ensured.
</p>
<p>The algorithm proceeds as follows
</p>
<p>Step 1: Define an approximating grid <code>lambda[1], ..., lambda[L]</code>
</p>
<p>Step 2: Use the VEM algorithm to maximize L(P) in the simplex
<code class="reqn">\Omega</code> and identify grid points with positive support. 
Here positive support is defined as <code>p[j] &gt;= epsilon</code> (often <code>epsilon = 10^-2</code>).<br>
This gives an initial estimate of <code>k</code>.<br></p>
<p>Step 3: Use these <code>k</code> points and corresponding mixing weights
p[j] as starting values for the EM algorithm
</p>
<p>Step 4: Collapse identical components if <code>| lambda[j]- lambda[i] | &lt; delta </code> (often delta=0.05) for i != j
</p>
<p>Step 5: Obtain the final number of components <code>k</code>
</p>
<p>This sequential algorithm leads to an initial estimate of the  NPMLE
and a proper solution for the subsequent EM algorithm. Crucial points are
the definitions of <code class="reqn">\delta</code> and <code class="reqn">\epsilon</code>. Depending on these settings
different solutions could result from this algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mixalg(obs, weights=NULL, family="gaussian", data=NULL, pop.at.risk=NULL, 
       var.lnOR=NULL, limit=0.01, acc=10^(-7), numiter=5000, startk=50)
</code></pre>


<h3>Arguments</h3>

   
<table>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>

<p>observed / dependent variable. Vector or colname of <code>data</code>. Must be specified!
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>weights of the data. Vector or colname of <code>data</code>. Default is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>the underlying type density function as a character ("gaussian", "poisson" or "binomial")!
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame. <code>obs</code>, <code>weights</code>, <code>pop.at.risk</code> and <code>var.lnOR</code> can be specified as column name of the data frame. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop.at.risk</code></td>
<td>

<p>population at risk: These data could be used to determine a mixture model for Poisson data. Vector or colname of <code>data</code>. Default is<code>NULL</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.lnOR</code></td>
<td>

<p>variances of the data: These variances might be given when working with meta analyses! Vector or colname of <code>data</code>. Default is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit</code></td>
<td>

<p>parameter to control the limit of union several components. Default is 0.01.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc</code></td>
<td>

<p>convergence criterion. VEM and EM loops stop when deltaLL&lt;acc. Default is 10^(-7). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numiter</code></td>
<td>

<p>parameter to control the maximal number of iterations in the VEM and EM loops. Default is 5000. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startk</code></td>
<td>

<p>starting/maximal number of components. This number will be used to compute the grid in the VEM. Default is 50.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The documentation of <code>leukDat</code> contains a disease mapping example using <code>mixalg</code> and the documentation of <code>golubMerge</code> contains a microarray analysis example.
</p>


<h3>Value</h3>

<p>The function returns a CAMAN.object, describing a finite mixture model.
The main information about the mixture model is printed by just typing the &lt;object&gt;. Additional information is given in <code>summary(object)</code> (summary.CAMAN.object). 
Single attributes can be accessed using the <code>@</code>, e.g. mix@LL.
<br></p>
<table><tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>(input) data </p>
</td>
</tr></table>
<p><br></p>
<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>underlying type density function  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LL</code></td>
<td>
<p>Likelihood of the final (best) iteration </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC</code></td>
<td>
<p>Likelihood of the final (best) iteration </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.k</code></td>
<td>
<p>number of components obtained </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>probability of each component</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>parameter of distribution (normal distr. -&gt; mean, poisson distr. -&gt; lambda, binomial distr. -&gt; prob) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>component.var</code></td>
<td>
<p>variance of each component (ONLY if <code>family</code> == "gaussian") </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>probabilies, belonging to each component </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classification</code></td>
<td>
<p>classification labels for each observation (<code>which.max</code> of <code>@prob</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>number of steps performed (EM, VEM). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VEM_result</code></td>
<td>
<p>result of VEM algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>the matched call. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_metaAnalysis</code></td>
<td>
<p>parameter specifying, whether a meta analysis was performed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VEM_result</code></td>
<td>
<p>Outcome of the VEM-algorithm, which was run before the EM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finalacc</code></td>
<td>
<p>deltaLL of the final iteration (for VEM and EM)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Peter Schlattmann and Johannes Hoehne  
</p>


<h3>References</h3>

<p>D. B\"ohning, P. Schlattmann, B.G. Lindsay: C.A.MAN - Computer Assisted
Analysis of Mixtures: Statistical Algorithms.<em>Biometrics</em>, 1992, 48, 283-303
</p>
<p>P. Schlattmann: On bootstrapping the unknown number of components in
finite mixtures of Poisson distributions. <em>Statistics and Computing</em>, 2005, 15, 179-188
</p>
<p>Schlattmann, P. (2009). <em>Medical Applications of Finite Mixture Models.</em> Berlin: Springer.
</p>


<h3>See Also</h3>

<p><code>mixalg.EM</code>, <code>mixalg.VEM</code>, <code>anova.CAMAN.object</code>, <code>mixcov</code>, <code>mixalg.boot</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">### POISSON data with weights: thai_cohort
data(thai_cohort)
mix &lt;- mixalg(obs="counts", weights="frequency", family="poisson", 
              data=thai_cohort, numiter=18000, acc=0.00001, startk=25)


# meta analysis
data(aspirin)
mix &lt;- mixalg(obs="logrr", var.lnOR="var", data=aspirin)


## See the documentation of golub.Merge for a
## microarray analysis example using mixalg

## See the documentation of leukDat for a disease
## mapping example using mixalg

</code></pre>


</div>