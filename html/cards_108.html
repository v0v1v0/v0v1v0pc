<div class="container">

<table style="width: 100%;"><tr>
<td>process_selectors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Process tidyselectors</h2>

<h3>Description</h3>

<p>Functions process tidyselect arguments passed to functions in the cards package.
The processed values are saved to the calling environment, by default.
</p>

<ul>
<li> <p><code>process_selectors()</code>: the arguments will be processed with tidyselect and
converted to a vector of character column names.
</p>
</li>
<li> <p><code>process_formula_selectors()</code>: for arguments that expect named lists or
lists of formulas (where the LHS of the formula is a tidyselector). This
function processes these inputs and returns a named list. If a name is
repeated, the last entry is kept.
</p>
</li>
<li> <p><code>fill_formula_selectors()</code>: when users override the default argument values,
it can be important to ensure that each column from a data frame is assigned
a value. This function checks that each column in <code>data</code> has an assigned
value, and if not, fills the value in with the default value passed here.
</p>
</li>
<li> <p><code>compute_formula_selector()</code>: used in <code>process_formula_selectors()</code> to
evaluate a single argument.
</p>
</li>
<li> <p><code>check_list_elements()</code>: used to check the class/type/values of the list
elements, primarily those processed with <code>process_formula_selectors()</code>.
</p>
</li>
<li> <p><code>cards_select()</code>: wraps <code>tidyselect::eval_select() |&gt; names()</code>, and returns
better contextual messaging when errors occur.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">process_selectors(data, ...)

process_formula_selectors(data, ...)

fill_formula_selectors(data, ...)

## S3 method for class 'data.frame'
process_selectors(data, ..., env = caller_env())

## S3 method for class 'data.frame'
process_formula_selectors(
  data,
  ...,
  env = caller_env(),
  include_env = FALSE,
  allow_empty = TRUE
)

## S3 method for class 'data.frame'
fill_formula_selectors(data, ..., env = caller_env())

compute_formula_selector(
  data,
  x,
  arg_name = caller_arg(x),
  env = caller_env(),
  strict = TRUE,
  include_env = FALSE,
  allow_empty = TRUE
)

check_list_elements(
  x,
  predicate,
  error_msg = NULL,
  arg_name = rlang::caller_arg(x)
)

cards_select(expr, data, ..., arg_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>(<code>data.frame</code>)<br>
a data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(<code>dynamic-dots</code>)<br>
named arguments where the value of the argument is processed with tidyselect.
</p>

<ul>
<li> <p><code>process_selectors()</code>: the values are tidyselect-compatible selectors
</p>
</li>
<li> <p><code>process_formula_selectors()</code>: the values are named lists, list of formulas
a combination of both, or a single formula. Users may pass <code>~value</code> as a
shortcut for <code>everything() ~ value</code>.
</p>
</li>
<li> <p><code>check_list_elements()</code>: named arguments where the name matches an existing
list in the <code>env</code> environment, and the value is a predicate function
to test each element of the list, e.g. each element must be a string or
a function.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>(<code>environment</code>)<br>
env to save the results to. Default is the calling environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_env</code></td>
<td>
<p>(<code>logical</code>)<br>
whether to include the environment from the formula object in the returned
named list. Default is <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_empty</code></td>
<td>
<p>(<code>logical</code>)<br>
Logical indicating whether empty result is acceptable while process
formula-list selectors. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<ul>
<li> <p><code>compute_formula_selector()</code>: (<code>formula-list-selector</code>)<br>
a named list, list of formulas, or a single formula that will be
converted to a named list.
</p>
</li>
<li> <p><code>check_list_elements()</code>: (named <code>list</code>)<br>
a named list
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arg_name</code></td>
<td>
<p>(<code>string</code>)<br>
the name of the argument being processed. Used
in error messaging. Default is <code>caller_arg(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>(<code>logical</code>)<br>
whether to throw an error if a variable doesn't exist in the reference data
(passed to <code>tidyselect::eval_select()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicate</code></td>
<td>
<p>(<code>function</code>)<br>
a predicate function that returns <code>TRUE</code> or <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error_msg</code></td>
<td>
<p>(<code>character</code>)<br>
a character vector that will
be used in error messaging when mis-specified arguments are passed. Elements
<code>"{arg_name}"</code> and <code>"{variable}"</code> are available using glue syntax for messaging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>(<code>expression</code>)<br>
Defused R code describing a selection according to the tidyselect syntax.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>process_selectors()</code>, <code>fill_formula_selectors()</code>, <code>process_formula_selectors()</code>
and <code>check_list_elements()</code> return NULL. <code>compute_formula_selector()</code> returns a
named list.
</p>


<h3>Examples</h3>

<pre><code class="language-R">example_env &lt;- rlang::new_environment()

process_selectors(ADSL, variables = starts_with("TRT"), env = example_env)
get(x = "variables", envir = example_env)

fill_formula_selectors(ADSL, env = example_env)

process_formula_selectors(
  ADSL,
  statistic = list(starts_with("TRT") ~ mean, TRTSDT = min),
  env = example_env
)
get(x = "statistic", envir = example_env)

check_list_elements(
  get(x = "statistic", envir = example_env),
  predicate = function(x) !is.null(x),
  error_msg = c(
    "Error in the argument {.arg {arg_name}} for variable {.val {variable}}.",
    "i" = "Value must be a named list of functions."
  )
)

# process one list
compute_formula_selector(ADSL, x = starts_with("U") ~ 1L)
</code></pre>


</div>