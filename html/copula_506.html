<div class="container">

<table style="width: 100%;"><tr>
<td>rnchild</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sampling Child 'nacopula's</h2>

<h3>Description</h3>

<p>Method for generating vectors of random numbers of nested Archimedean
copulas which are child copulas.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rnchild(x, theta0, V0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <code>"nacopula"</code> object, typically emerging from an
<code>"outer_nacopula"</code> object constructed with
<code>onacopula()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>the parameter (vector) of the parent Archimedean copula
which contains <code>x</code> as a child.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V0</code></td>
<td>
<p>a <code>numeric</code> vector of realizations of
<code class="reqn">V_{0}</code> following <code class="reqn">F_{0}</code> whose length determines the
number of generated vectors, that is, for each realization
<code class="reqn">V_{0}</code>, a vector of variates from <code>x</code> is generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>possibly further arguments for the given copula family.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The generation is done recursively, descending the tree implied by the
nested Archimedean structure.  The algorithm is based on a mixture
representation and requires sampling <code class="reqn">V_{01}\sim F_{01}</code>
given random variates <code class="reqn">V_0\sim F_{0}</code>.  Calling
<code>"rnchild"</code> is only intended for experts.  The typical call of
this function takes place through <code>rnacopula()</code>.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>a <code>numeric</code> matrix containing the vector of random
variates from the child copula.  The number of rows of this matrix
therefore equals the length of <code class="reqn">V_{0}</code> and the number of
columns corresponds to the dimension of the child copula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indcol</code></td>
<td>
<p>an <code>integer</code> vector of indices of <code>U</code>
(the vector following a nested Archimedean copula of which <code>x</code> is
a child) whose corresponding components of <code>U</code> are arguments of
the nested Archimedean copula <code>x</code>.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>rnacopula</code>, also for the references.
Further, classes <code>"nacopula"</code> and
<code>"outer_nacopula"</code>; see also <code>onacopula()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Construct a three-dimensional nested Clayton copula with parameters
## chosen such that the Kendall's tau of the respective bivariate margins
## are 0.2 and 0.5.
theta0 &lt;- copClayton@iTau(.2)
theta1 &lt;- copClayton@iTau(.5)
C3 &lt;- onacopula("C", C(theta0, 1, C(theta1, c(2,3))))
## Sample n random variates V0 ~ F0 (a Gamma(1/theta0,1) distribution)
n &lt;- 1000
V0 &lt;- copClayton@V0(n, theta0)

## Given these variates V0, sample the child copula, that is, the bivariate
## nested Clayton copula with parameter theta1
U23 &lt;- rnchild(C3@childCops[[1]], theta0, V0)

## Now build the three-dimensional vectors of random variates by hand
U1 &lt;- copClayton@psi(rexp(n)/V0, theta0)
U &lt;- cbind(U1, U23$U)

## Plot the vectors of random variates from the three-dimensional nested
## Clayton copula
splom2(U)
</code></pre>


</div>