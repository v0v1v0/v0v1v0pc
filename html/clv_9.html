<div class="container">

<table style="width: 100%;"><tr>
<td>cls.stab.sim.ind</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster Stability - Similarity Index and Pattern-wise Stability Approaches</h2>

<h3>Description</h3>

<p><code>cls.stab.sim.ind</code> and <code>cls.stab.opt.assign</code> reports validation measures for clustering results. Both functions return lists of  
cluster stability results computed according to similarity index and pattern-wise stability approaches.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cls.stab.sim.ind( data, cl.num, rep.num, subset.ratio, clust.method,
                   method.type, sim.ind.type, fast, ... )
cls.stab.opt.assign( data, cl.num, rep.num, subset.ratio, clust.method,
                      method.type, fast, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>numeric matrix</code> or <code>data.frame</code> where columns correspond to variables and rows to 
observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl.num</code></td>
<td>

<p>integer <code>vector</code> with information about numbers of cluster to which <code>data</code> will be partitioned.
If vector is not an integer type, it will be coerced with warning.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep.num</code></td>
<td>

<p>integer number which tells how many pairs of data subsets will be partitioned for particular number of clusters.
The results of partitioning for given pair of subsets is used to compute similarity indices (in case of <code>cls.stab.sim.ind</code>) 
or <em>pattern-wise stability</em> (in case of <code>cls.stab.opt.assign</code>, for more details see references). 
By default <code>rep.num</code> value is 10. If wrong argument is applied it will be repaced with default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset.ratio</code></td>
<td>

<p>a number comming from (0,1) section which tells how big data subsets should be. 0 means empty subset, 1 means all data. 
By default <code>subset.ratio</code> is set to 0.75. If wrong argument is applied it will be repaced with default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust.method</code></td>
<td>

<p>string vector with names of cluster algorithms to be used. Available are:
"agnes", "diana", "hclust", "kmeans", "pam", "clara". Combinations are also possible.
By default <code>c("agnes","pam")</code> vector is applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.type</code></td>
<td>

<p>string vector with information useful only in context of "agnes" and "hclust" algorithms . Available are:
"single", "average", "complete", "ward" and "weighted" (for more details see <code>agnes</code>,
<code>hclust</code> ). The last type is applicable only for "agnes". Combinations are also possible.
By default <code>c("single","average")</code> vector is applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.ind.type</code></td>
<td>

<p>string vector with information useful only for <code>cls.stab.sim.ind</code> function. User is able to choose which 
similarity indices (external measures) to use to compare two partitionings. Available are:
"dot.pr", "sim.ind", "rand", "jaccard" (for more details see <code>similarity.index</code>,
<code>dot.product</code>, <code>std.ext</code>). Combinations are also possible.
By default <code>c("dot.pr","sim.ind")</code> vector is applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast</code></td>
<td>

<p>logical argument which sets the way of computing cluster stability for hierarchical algorithms. By default it is set to
TRUE, which means that each result produced by hierarchical algorithm is partitioned for the number of clusters chosen in 
<code>cl.num</code> argument and given clustering results are put for further computation. In this way computation of cluster 
stability is faster. If wrong argument is applied it will be repaced with default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional parameters for clustering algorithms. Note: use with caution! Different clustering methods chosen in <code>clust.method</code> have 
different set of parameter names - mixing them often disallow any cluster algorithm to run.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both functions realize cluster stability approaches described in <em>Detecting stable clusters using principal component analysis</em> (see references).
</p>
<p>The <code>cls.stab.sim.ind</code> function realizes algorithm given in <em>chapter 3.1</em> where only cosine similarity index (see <code>dot.product</code>) 
is introduced as a similarity index between two different partitionings. This function realize this cluster stability approach also for other 
similarity indices such us <code>similarity.index</code>, <code>clv.Rand</code> and <code>clv.Jaccard</code>.
The important thing is that <code>similarity index</code> (if chosen) produced by this function is not exactly the same as index produced by
<code>similarity.index</code> function. The value of the <code>similarity.index</code> is a number which depends on number of clusters.
Eg. if two "n-clusters" partitionings are compared the value always will be a number which belong to the <code>[1/n, 1]</code> section. That means the 
results produced by this similarity index are not comparable for different number of clusters. That's why each result is scaled thanks to 
the linear function <code>f:[1/n, 1] -&gt; [0, 1]</code> where "n" is a number of clusters.
The results' layout is described in <em>Value</em> section.
</p>
<p>The <code>cls.stab.opt.assign</code> function realizes algorithm given in <em>chapter 3.2</em> where <em>pattern-wise agreement</em> and 
<em>pattern-wise stability</em> was introduced. Function returns the lowest <em>pattern-wise stability</em> value for given number of
clusters. The results' layout is described in <em>Value</em> section.
</p>
<p>It often happens that clustering algorithms can't produce amount of clusters that user wants. In this situation only the warning is 
produced and cluster stability is computed for partitionings with unequal number of clusters.
</p>
<p>The cluster stability will not be calculated for all cluster numbers that are bigger than the subset size.
For example if <code>data</code> contains about 20 objects and the <code>subset.ratio</code> equals 0.5 then the highest cluster number to 
calculate is 10. In that case all elements above 10 will be removed from <code>cl.num</code> vector.
</p>


<h3>Value</h3>

<p><code>cls.stab.sim.ind</code> returns a list of lists of matrices. Each matrix consists of the set of external similarity indices (which one similarity 
index see below) where number of columns is equal to <code>cl.num</code> vector length and row number is equal to <code>rep.num</code> value what means
that each column contain a set of similarity indices computed for fixed number of clusters.
The order of the matricides depends on three input arguments: <code>clust.method</code>, <code>method.type</code>, and <code>sim.ind.type</code>.
Combination of <code>clust.method</code> and <code>method.type</code> give a names for elements listed in the first list. Each element of this list is also a 
list type where each element name correspond to one of similarity index type chosen thanks to <code>sim.ind.type</code> argument. 
The order of the names exactly match to the order given in those arguments description. It is easy to understand after considering the 
following example. <br>
Let say we are running <code>cls.stab.sim.ind</code> with default arguments then the results will be given in the following order:
<code>$agnes.single$dot.pr</code>, <code>$agnes.single$sim.ind</code>, <code>$agnes.average$dot.pr</code>, <code>$agnes.average$sim.ind</code>, <code>$pam$dot.pr</code>, 
<code>$pam$sim.ind</code>. <br><br></p>
<p><code>cls.stab.opt.assign</code> returns a list of vectors. Each vector consists of the set of cluster stability indices described in 
<em>Detecting stable clusters using principal component analysis</em> (see references). Vector length is equal to <code>cl.num</code> vector length what 
means that each position in vector is assigned to proper clusters' number given in <code>cl.num</code> argument.
The order of the vectors depends on two input arguments: <code>clust.method</code>, <code>method.type</code>. The order of the names exactly match to the order 
given in arguments description. It is easy to understand after considering the following example. <br>
Let say we are running <code>cls.stab.opt.assign</code> with <code>c("pam", "kmeans", "hclust", "agnes")</code> as <code>clust.method</code> and <code>c("ward","average")</code> 
as <code>method.type</code> then the results will be given in the following order:
<code>$hclust.average</code>, <code>$hclust.ward</code>, <code>$agnes.average</code>, <code>$agnes.ward</code>, <code>$kmeans</code>, <code>$pam</code>.<br></p>


<h3>Author(s)</h3>

<p>Lukasz Nieweglowski</p>


<h3>References</h3>

<p>A. Ben-Hur and I. Guyon <em>Detecting stable clusters using principal component analysis</em>,
<a href="http://citeseerx.ist.psu.edu/">http://citeseerx.ist.psu.edu/</a>
</p>
<p>C. D. Giurcaneanu, I. Tabus, I. Shmulevich, W. Zhang <em>Stability-Based Cluster Analysis Applied To Microarray Data</em>, 
<a href="http://citeseerx.ist.psu.edu/">http://citeseerx.ist.psu.edu/</a>.
</p>
<p>T. Lange, V. Roth, M. L. Braun and J. M. Buhmann <em>Stability-Based Validation of Clustering Solutions</em>,
<a href="ml-pub.inf.ethz.ch/publications/papers/2004/lange.neco_stab.03.pdf">ml-pub.inf.ethz.ch/publications/papers/2004/lange.neco_stab.03.pdf</a>
</p>


<h3>See Also</h3>

<p>Advanced cluster stability functions:
<code>cls.stab.sim.ind.usr</code>, <code>cls.stab.opt.assign.usr</code>. 
</p>
<p>Functions that compare two different partitionings:
<code>clv.Rand</code>, <code>dot.product</code>, <code>similarity.index</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# load and prepare data
library(clv)
data(iris)
iris.data &lt;- iris[,1:4]

# fix arguments for cls.stab.* function
iter = c(2,3,4,5,6,7,9,12,15)
smp.num = 5
ratio = 0.8

res1 = cls.stab.sim.ind( iris.data, iter, rep.num=smp.num, subset.ratio=0.7,
                         sim.ind.type=c("rand","dot.pr","sim.ind") )
res2 = cls.stab.opt.assign( iris.data, iter, clust.method=c("hclust","kmeans"),
                             method.type=c("single","average") )

print(res1)
boxplot(res1$agnes.average$sim.ind)
plot(res2$hclust.single)

</code></pre>


</div>