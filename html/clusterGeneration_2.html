<div class="container">

<table style="width: 100%;"><tr>
<td>genPositiveDefMat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GENERATE A POSITIVE DEFINITE MATRIX/COVARIANCE MATRIX</h2>

<h3>Description</h3>

<p>Generate a positive definite matrix/covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">genPositiveDefMat(
  dim, 
  covMethod = c("eigen", "onion", "c-vine", "unifcorrmat"), 
  eigenvalue = NULL,
  alphad = 1, 
  eta = 1, 
  rangeVar = c(1, 10), 
  lambdaLow = 1, 
  ratioLambda = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>

<p>Dimension of the matrix to be generated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covMethod</code></td>
<td>

<p>Method to generate positive definite matrices/covariance matrices.
Choices are “eigen”, “onion”, “c-vine”, or “unifcorrmat”; see details below. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigenvalue</code></td>
<td>

<p>numeric. user-specified eigenvalues when <code>covMethod = "eigen"</code>. If <code>eigenvalue = NULL</code> and <code>covMethod = "eigen"</code>, then eigenvalues will be automatically generated.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphad</code></td>
<td>
<p>parameter for unifcorrmat method to generate random correlation matrix
<code>alphad=1</code> for uniform. <code>alphad</code> should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>parameter for “c-vine” and “onion” methods to generate random correlation matrix
<code>eta=1</code> for uniform. <code>eta</code> should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rangeVar</code></td>
<td>

<p>Range for variances of a covariance matrix (see details).
The default range is <code class="reqn">[1, 10]</code> which can generate reasonable
variability of variances.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaLow</code></td>
<td>

<p>Lower bound on the eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, eigenvalues are generated for cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>lambdaLow</code> should be positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratioLambda</code></td>
<td>

<p>The ratio of the upper bound of the eigenvalues to the lower bound of the 
eigenvalues of cluster covariance matrices.  See <code>lambdaLow</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current version of the function <code>genPositiveDefMat</code> implements four 
methods to generate random covariance matrices. The first method, denoted by 
“eigen”, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots,\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then
uses columns of a randomly generated orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code> is then 
contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\ldots,\lambda_p)*\boldsymbol{Q}^T</code>.
</p>
<p>The remaining methods, denoted as “onion”, “c-vine”, and “unifcorrmat”
respectively, first generates a random 
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method mentioned and proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots,\sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>egvalues</code></td>
<td>

<p>eigenvalues of Sigma
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>

<p>positive definite matrix/covariance matrix
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br>
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177–2189.
</p>
<p>Ghosh, S., Henderson, S. G. (2003). 
Behavior of the NORTA method for correlated random vector generation 
as the dimension increases.
<em>ACM Transactions on Modeling and Computer Simulation (TOMACS)</em>,
<b>13(3)</b>, 276–294.
</p>
<p>Kurowicka and Cooke, 2006.
<em>Uncertainty Analysis with High Dimensional Dependence Modelling</em>,
Wiley, 2006.
</p>


<h3>Examples</h3>

<pre><code class="language-R">genPositiveDefMat(
		  dim = 4, 
		  covMethod = "unifcorrmat")

aa &lt;- genPositiveDefMat(
			dim = 3,
			covMethod = "eigen", 
			eigenvalue = c(3, 2, 1))
print(aa)
print(eigen(aa$Sigma))

</code></pre>


</div>