<div class="container">

<table style="width: 100%;"><tr>
<td>clock-invalid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Invalid calendar dates</h2>

<h3>Description</h3>

<p>This family of functions is for working with <em>invalid</em> calendar dates.
</p>
<p>Invalid dates represent dates made up of valid individual components, which
taken as a whole don't represent valid calendar dates. For example, for
<code>year_month_day()</code> the following component ranges are valid:
<code style="white-space: pre;">⁠year: [-32767, 32767]⁠</code>, <code style="white-space: pre;">⁠month: [1, 12]⁠</code>, <code style="white-space: pre;">⁠day: [1, 31]⁠</code>.
However, the date <code>2019-02-31</code> doesn't exist even though it is made up
of valid components. This is an example of an invalid date.
</p>
<p>Invalid dates are allowed in clock, provided that they are eventually
resolved by using <code>invalid_resolve()</code> or by manually resolving them through
arithmetic or setter functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">invalid_detect(x)

invalid_any(x)

invalid_count(x)

invalid_remove(x)

invalid_resolve(x, ..., invalid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code style="white-space: pre;">⁠[calendar]⁠</code>
</p>
<p>A calendar vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invalid</code></td>
<td>
<p><code style="white-space: pre;">⁠[character(1) / NULL]⁠</code>
</p>
<p>One of the following invalid date resolution strategies:
</p>

<ul>
<li> <p><code>"previous"</code>: The previous valid instant in time.
</p>
</li>
<li> <p><code>"previous-day"</code>: The previous valid day in time, keeping the time of
day.
</p>
</li>
<li> <p><code>"next"</code>: The next valid instant in time.
</p>
</li>
<li> <p><code>"next-day"</code>: The next valid day in time, keeping the time of day.
</p>
</li>
<li> <p><code>"overflow"</code>: Overflow by the number of days that the input is invalid
by. Time of day is dropped.
</p>
</li>
<li> <p><code>"overflow-day"</code>: Overflow by the number of days that the input is
invalid by. Time of day is kept.
</p>
</li>
<li> <p><code>"NA"</code>: Replace invalid dates with <code>NA</code>.
</p>
</li>
<li> <p><code>"error"</code>: Error on invalid dates.
</p>
</li>
</ul>
<p>Using either <code>"previous"</code> or <code>"next"</code> is generally recommended, as these
two strategies maintain the <em>relative ordering</em> between elements of the
input.
</p>
<p>If <code>NULL</code>, defaults to <code>"error"</code>.
</p>
<p>If <code>getOption("clock.strict")</code> is <code>TRUE</code>, <code>invalid</code> must be supplied and
cannot be <code>NULL</code>. This is a convenient way to make production code robust
to invalid dates.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Invalid dates must be resolved before converting them to a time point.
</p>
<p>It is recommended to use <code>"previous"</code> or <code>"next"</code> for resolving invalid
dates, as these ensure that <em>relative ordering</em> among <code>x</code> is maintained.
This is a often a very important property to maintain when doing time series
data analysis. See the examples for more information.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>invalid_detect()</code>: Returns a logical vector detecting invalid dates.
</p>
</li>
<li> <p><code>invalid_any()</code>: Returns <code>TRUE</code> if any invalid dates are detected.
</p>
</li>
<li> <p><code>invalid_count()</code>: Returns a single integer containing the number of
invalid dates.
</p>
</li>
<li> <p><code>invalid_remove()</code>: Returns <code>x</code> with invalid dates removed.
</p>
</li>
<li> <p><code>invalid_resolve()</code>: Returns <code>x</code> with invalid dates resolved using the
<code>invalid</code> strategy.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Invalid date
x &lt;- year_month_day(2019, 04, 30:31, c(3, 2), 30, 00)
x

invalid_detect(x)

# Previous valid moment in time
x_previous &lt;- invalid_resolve(x, invalid = "previous")
x_previous

# Previous valid day, retaining time of day
x_previous_day &lt;- invalid_resolve(x, invalid = "previous-day")
x_previous_day

# Note that `"previous"` retains the relative ordering in `x`
x[1] &lt; x[2]
x_previous[1] &lt; x_previous[2]

# But `"previous-day"` here does not!
x_previous_day[1] &lt; x_previous_day[2]

# Remove invalid dates entirely
invalid_remove(x)

y &lt;- year_quarter_day(2019, 1, 90:92)
y

# Overflow rolls forward by the number of days between `y` and the previous
# valid date
invalid_resolve(y, invalid = "overflow")
</code></pre>


</div>