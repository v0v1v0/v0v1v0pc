<div class="container">

<table style="width: 100%;"><tr>
<td>eval_Coxmos_models</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>eval_Coxmos_models</h2>

<h3>Description</h3>

<p>The <code>eval_Coxmos_models</code> function facilitates the comprehensive evaluation of multiple Coxmos
models in a concurrent manner. It is designed to provide a detailed assessment of the models'
performance by calculating the Area Under the Curve (AUC) for each model at specified time points.
The results generated by this function are primed for visualization using the <code>plot_evaluation()</code>
function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval_Coxmos_models(
  lst_models,
  X_test,
  Y_test,
  pred.method = "cenROC",
  pred.attr = "mean",
  times = NULL,
  PARALLEL = FALSE,
  max_time_points = 15,
  verbose = FALSE,
  progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lst_models</code></td>
<td>
<p>List of Coxmos models. Each object of the list must be named.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_test</code></td>
<td>
<p>Numeric matrix or data.frame. Explanatory variables for test data (raw format).
Qualitative variables must be transform into binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y_test</code></td>
<td>
<p>Numeric matrix or data.frame. Response variables for test data. Object must have
two columns named as "time" and "event". For event column, accepted values are: 0/1 or FALSE/TRUE
for censored and event observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.method</code></td>
<td>
<p>Character. AUC evaluation algorithm method for evaluate the model performance.
Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C",
"smoothROCtime_I" (default: "cenROC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.attr</code></td>
<td>
<p>Character. Way to evaluate the metric selected. Must be one of the following:
"mean" or "median" (default: "mean").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of
'max_time_points' points will be selected equally distributed (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PARALLEL</code></td>
<td>
<p>Logical. Run the cross validation with multicore option. As many cores as your
total cores - 1 will be used. It could lead to higher RAM consumption (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time_points</code></td>
<td>
<p>Numeric. Maximum number of time points to use for evaluating the model
(default: 15).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress_bar</code></td>
<td>
<p>Logical. If progress_bar = TRUE, progress bar is shown (default = TRUE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function begins by validating the names of the models provided in the <code>lst_models</code> list and
ensures that there are at least two events present in the dataset. It then checks for the
availability of the specified evaluation method and ensures that the test times are consistent
with the training times of the models.
</p>
<p>The core of the function revolves around the evaluation of each model. Depending on the user's
preference, the evaluations can be executed in parallel, which can significantly expedite the
process, especially when dealing with a large number of models. The function employs various
evaluation methods, as specified by the <code>pred.method</code> parameter, to compute the AUC values. These
methods include but are not limited to "risksetROC", "survivalROC", and "cenROC".
</p>
<p>Post-evaluation, the function collates the results, including training times, AIC values, c-index,
Brier scores, and AUC values for each time point. The results are then transformed into a
structured data frame, making it conducive for further analysis and visualization. It's worth
noting that potential issues in AUC computation, often arising from sparse samples, are flagged
to the user for further inspection.
</p>


<h3>Value</h3>

<p>A list of four objects.
<code>df</code>: A data.frame which the global predictions for all models. This data.frame is used to
plot the information by the function <code>plot_evaluation()</code>.
<code>lst_AUC</code>: A list of models where the user can check the linear predictors computed, the
global AUC, the AUC per time point and the predicted time points selected.
<code>lst_BRIER</code>: A list of models where the user can check the predicted time points selected,
the Brier Score per time point and the Integrative Brier score (computed by <code>survcomp::sbrier.score2proba</code>).
<code>time</code>: Time used for evaluation process.
</p>


<h3>Author(s)</h3>

<p>Pedro Salguero Garcia. Maintainer: pedsalga@upv.edu.es
</p>


<h3>References</h3>

<p>Harrell FE, Califf RM, Pryor DB, Lee KL, Rosati RA (1982).
“Evaluating the Yield of Medical Tests.”
<em>JAMA</em>, <b>247</b>.
<a href="https://doi.org/10.1001/jama.1982.03320430047030">doi:10.1001/jama.1982.03320430047030</a>, <a href="https://jamanetwork.com/journals/jama">https://jamanetwork.com/journals/jama</a>.
MS S, AC C, J Q, B H (2011).
“survcomp: an R/Bioconductor package for performance assessment and comparison of survival models.”
<em>Bioinformatics</em>, <b>27(22)</b>, 3206-3208.
Heagerty PJ, Lumley T, Pepe MS (2000).
“Time-Dependent ROC Curves for Censored Survival Data and a Diagnostic Marker.”
<em>Biometrics</em>.
Heagerty PJ, Zheng Y (2005).
“Survival Model Predictive Accuracy and ROC Curves.”
<em>Biometrics</em>, <b>61</b>, 92-105.
<a href="https://doi.org/10.1111/j.0006-341x.2005.030814.x">doi:10.1111/j.0006-341x.2005.030814.x</a>.
Beyene KM, Ghouch AE (2020).
“Smoothed time-dependent receiver operating characteristic curve for right censored survival data.”
<em>Statistics in Medicine</em>, <b>39</b>(24), 3373-3396.
ISSN 10970258, <a href="https://pubmed.ncbi.nlm.nih.gov/32687225/">https://pubmed.ncbi.nlm.nih.gov/32687225/</a>.
Pérez-Fernández S, Martínez-Camblor P, Filzmoser P, Corral N (2018).
“nsROC: An R package for Non-Standard ROC Curve Analysis.”
<em>The R Journal</em>.
<a href="https://doi.org/10.1007/s00180-020-00955-7">doi:10.1007/s00180-020-00955-7</a>.
Díaz-Coto S, Martínez-Camblor P, Pérez-Fernández S (2020).
“smoothROCtime: an R package for time-dependent ROC curve estimation.”
<em>Computational Statistics</em>, <b>35</b>(3), 1231-1251.
ISSN 16139658, <a href="https://doi.org/10.1007/s00180-020-00955-7">doi:10.1007/s00180-020-00955-7</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("X_proteomic")
data("Y_proteomic")
set.seed(123)
index_train &lt;- caret::createDataPartition(Y_proteomic$event, p = .5, list = FALSE, times = 1)
X_train &lt;- X_proteomic[index_train,1:50]
Y_train &lt;- Y_proteomic[index_train,]

X_test &lt;- X_proteomic[-index_train,1:50]
Y_test &lt;- Y_proteomic[-index_train,]

model_icox &lt;- splsicox(X_train, Y_train, n.comp = 2)
model_drcox &lt;- splsdrcox(X_train, Y_train, n.comp = 2)
lst_models &lt;- list("splsicox" = model_icox, "splsdrcox" = model_drcox)
eval_Coxmos_models(lst_models, X_test, Y_test, pred.method = "cenROC")
</code></pre>


</div>