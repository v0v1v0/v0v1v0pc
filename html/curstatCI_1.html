<div class="container">

<table style="width: 100%;"><tr>
<td>ComputeBW</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data-driven bandwidth vector</h2>

<h3>Description</h3>

<p>The function ComputeBW computes the bandwidth that minimizes the pointwise Mean Squared Error using the subsampling principle in combination with undersmoothing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ComputeBW(data, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Dataframe with three variables:
</p>

<dl>
<dt>t</dt>
<dd>
<p>Observation points t sorted in ascending order. All observations need to be positive. The total number of unique observation points equals <code>length(t)</code>.</p>
</dd>
<dt>freq1</dt>
<dd>
<p>Frequency of observation t satisfying <code class="reqn">x \le t</code>.
The total number of observations with censoring indicator <code class="reqn">\delta =1</code> equals <code>sum(freq1)</code>. </p>
</dd>
<dt>freq2</dt>
<dd>
<p>Frequency of observation t. The sample size equals <code>sum(freq2)</code>. If no tied observations are present in the data <code>length(t)</code> equals <code>sum(freq2)</code>. </p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector containing the points where the confidence intervals are computed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>bw data-driven bandwidth vector of size <code>length(x)</code> containing the bandwidth value for each point in x.
</p>


<h3>References</h3>

<p>Groeneboom, P. and Hendrickx, K. (2017). The nonparametric bootstrap for the current status model. Electronic Journal of Statistics 11(2):3446-3848.
</p>


<h3>See Also</h3>

<p><code>vignette("curstatCI")</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(Rcpp)
library(curstatCI)

# sample size
n &lt;- 1000

# truncated exponential distribution on (0,2)
set.seed(100)
t &lt;- rep(NA, n)
delta &lt;- rep(NA, n)
for(i in (1:n) ){
  x&lt;-runif(1)
  y&lt;--log(1-(1-exp(-2))*x)
  t[i]&lt;-2*runif(1);
  if(y&lt;=t[i]){ delta[i]&lt;-1}
  else{delta[i]&lt;-0}}

A&lt;-cbind(t[order(t)], delta[order(t)], rep(1,n))

# x vector
grid&lt;-seq(0.1,1.9 ,by = 0.1)

# data-driven bandwidth vector
bw &lt;- ComputeBW(data =A, x = grid)
plot(grid, bw)

</code></pre>


</div>