<div class="container">

<table style="width: 100%;"><tr>
<td>CorpusData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Manage Corpus Data and Encode CWB Corpus.</h2>

<h3>Description</h3>

<p>Manage Corpus Data and Encode CWB Corpus.
</p>
<p>Manage Corpus Data and Encode CWB Corpus.
</p>


<h3>Details</h3>

<p>See the <a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">CWB Encoding Tutorial</a> on
characters allowed for encoding attributes: "By convention, all attribute
names must be lowercase (more precisely, they may only contain the characters
a-z, 0-9, -, and _, and may not start with a digit). Therefore, the names of
XML elements to be included in the CWB corpus must not contain any non-ASCII
or uppercase letters." (section 2)
</p>
<p>Import XML files.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>chunktable</code></dt>
<dd>
<p>A <code>data.table</code> with column "id" (unique values),
columns with metadata, and a column with text chunks.</p>
</dd>
<dt><code>tokenstream</code></dt>
<dd>
<p>A <code>data.table</code> with a column "cpos" (corpus position), and
columns with positional attributes, such as "word", "lemma", "pos", "stem".</p>
</dd>
<dt><code>metadata</code></dt>
<dd>
<p>A <code>data.table</code> with a column "id", to link data with
chunks/tokenstream, columns with document-level metadata, and a column
"cpos_left" and "cpos_right", which can be generated using method
<code style="white-space: pre;">⁠$add_corpus_positions()⁠</code>.</p>
</dd>
<dt><code>sentences</code></dt>
<dd>
<p>A <code>data.table</code>.</p>
</dd>
<dt><code>named_entities</code></dt>
<dd>
<p>A <code>data.table</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CorpusData-new"><code>CorpusData$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-print"><code>CorpusData$print()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-tokenize"><code>CorpusData$tokenize()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-import_xml"><code>CorpusData$import_xml()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-add_corpus_positions"><code>CorpusData$add_corpus_positions()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-purge"><code>CorpusData$purge()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-encode"><code>CorpusData$encode()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-clone"><code>CorpusData$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-CorpusData-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize a new instance of class <code>CorpusData</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$new()</pre></div>



<h5>Returns</h5>

<p>A class <code>CorpusData</code> object.
</p>


<hr>
<a id="method-CorpusData-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print summary of <code>CorpusData</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$print()</pre></div>


<hr>
<a id="method-CorpusData-tokenize"></a>



<h4>Method <code>tokenize()</code>
</h4>

<p>Simple tokenization of text in chunktable.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$tokenize(..., verbose = TRUE, progress = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Arguments that are passed into <code>tokenizers::tokenize_words()</code>.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>A logical value, whether to be verbose.</p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>A logical value, whether to show progress bar.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-CorpusData-import_xml"></a>



<h4>Method <code>import_xml()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>CorpusData$import_xml(
  filenames,
  body = "//body",
  meta = NULL,
  mc = NULL,
  progress = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filenames</code></dt>
<dd>
<p>A vector of files to process.</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>An xpath expression defining the body of the XML document.</p>
</dd>
<dt><code>meta</code></dt>
<dd>
<p>A named character vector with XPath expressions.</p>
</dd>
<dt><code>mc</code></dt>
<dd>
<p>A numeric/integer value, number of cores to use.</p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>A logical value, whether to show progress bar.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The <code>CorpusData</code> object is returned invisibly.
</p>


<hr>
<a id="method-CorpusData-add_corpus_positions"></a>



<h4>Method <code>add_corpus_positions()</code>
</h4>

<p>Add column 'cpos' to tokenstream and columns 'cpos_left' and
'cpos_right' to metadata.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$add_corpus_positions(verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt>
<dd>
<p>A logical value, whether to be verbose.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-CorpusData-purge"></a>



<h4>Method <code>purge()</code>
</h4>

<p>Remove patterns from chunkdata that are known to cause problems. This is
done most efficiently at the chunkdata level of data preparation as the
length of the character vector to handle is much smaller than when
tokenization/annotation has been performed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$purge(
  replacements = list(c("^\\s*&lt;.*?&gt;\\s*$", ""), c("’", "'"))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>replacements</code></dt>
<dd>
<p>A list of length-two character vectors with regular
expressions and replacements.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-CorpusData-encode"></a>



<h4>Method <code>encode()</code>
</h4>

<p>Encode corpus. If the corpus already exists, it will be removed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$encode(
  corpus,
  p_attributes = "word",
  s_attributes = NULL,
  encoding,
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  data_dir = NULL,
  method = c("R", "CWB"),
  verbose = TRUE,
  compress = FALSE,
  reload = TRUE,
  quietly = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>corpus</code></dt>
<dd>
<p>The name of the CWB corpus.</p>
</dd>
<dt><code>p_attributes</code></dt>
<dd>
<p>Positional attributes.</p>
</dd>
<dt><code>s_attributes</code></dt>
<dd>
<p>Columns that will be encoded as structural attributes.</p>
</dd>
<dt><code>encoding</code></dt>
<dd>
<p>Encoding/charset of the CWB corpus.</p>
</dd>
<dt><code>registry_dir</code></dt>
<dd>
<p>Corpus registry, the directory where registry files are
stored.</p>
</dd>
<dt><code>data_dir</code></dt>
<dd>
<p>Directory where to create directory for indexed corpus files.</p>
</dd>
<dt><code>method</code></dt>
<dd>
<p>Either "R" or "CWB".</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>A logical value, whether to be verbose.</p>
</dd>
<dt><code>compress</code></dt>
<dd>
<p>A logical value, whether to compress corpus.</p>
</dd>
<dt><code>reload</code></dt>
<dd>
<p>A <code>logical</code> value, whether to reload corpus.</p>
</dd>
<dt><code>quietly</code></dt>
<dd>
<p>A <code>logical</code> value passed into <code>RcppCWB::cwb_makeall()</code>,
<code>RcppCWB::cwb_huffcode()</code> and <code>RcppCWB::cwb_compress_rdx</code> to control
verbosity of these functions.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-CorpusData-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">library(RcppCWB)
library(data.table)

# this example relies on the R method to write data to disk, there is also a method "CWB"
# that relies on CWB tools to generate the indexed corpus. The CWB can downloaded
# and installed within the package by calling cwb_install()

# create temporary registry file so that data in RcppCWB package can be used

registry_rcppcwb &lt;- system.file(package = "RcppCWB", "extdata", "cwb", "registry")
registry_tmp &lt;- fs::path(tempdir(), "registry")
if (!dir.exists(registry_tmp)) dir.create(registry_tmp)
r &lt;- registry_file_parse("REUTERS", registry_dir = registry_rcppcwb)
r[["home"]] &lt;- system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters")
registry_file_write(r, corpus = "REUTERS", registry_dir = registry_tmp)

# decode structural attribute 'places'

s_attrs_places &lt;- RcppCWB::s_attribute_decode(
  corpus = "REUTERS",
  data_dir = system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters"),
  s_attribute = "places", method = "R"
)
s_attrs_places[["id"]] &lt;- 1L:nrow(s_attrs_places)
setnames(s_attrs_places, old = "value", new = "places")

# decode positional attribute 'word'

tokens &lt;- apply(s_attrs_places, 1, function(row){
  ids &lt;- cl_cpos2id(
    corpus = "REUTERS", cpos = row[1]:row[2],
    p_attribute = "word", registry = registry_tmp
  )
  cl_id2str(corpus = "REUTERS", id = ids, p_attribute = "word", registry = registry_tmp)
})
tokenstream &lt;- rbindlist(
lapply(
  1L:length(tokens),
  function(i) data.table(id = i, word = tokens[[i]]))
  )
tokenstream[["cpos"]] &lt;- 0L:(nrow(tokenstream) - 1L)

# create CorpusData object (see vignette for further explanation)

CD &lt;- CorpusData$new()
CD$tokenstream &lt;- as.data.table(tokenstream)
CD$metadata &lt;- as.data.table(s_attrs_places)

# Remove temporary registry with home dir still pointing to RcppCWB data dir
# to prevent data from being deleted
file.remove(fs::path(registry_tmp, "reuters"))
file.remove(registry_tmp)

# create temporary directories (registry directory and one for indexed corpora)

registry_tmp &lt;- fs::path(tempdir(), "registry")
data_dir_tmp &lt;- fs::path(tempdir(), "data_dir")
if (!dir.exists(registry_tmp)) dir.create(registry_tmp)
if (!dir.exists(data_dir_tmp)) dir.create(data_dir_tmp)

CD$encode(
  corpus = "REUTERS", encoding = "utf8",
  p_attributes = "word", s_attributes = "places",
  registry_dir = registry_tmp, data_dir = data_dir_tmp,
  method = "R"
)
reg &lt;- registry_data(name = "REUTERS", id = "REUTERS", home = data_dir_tmp, p_attributes = "word")
registry_file_write(data = reg, corpus = "REUTERS", registry_dir = registry_tmp)

# see whether it works

cl_cpos2id(corpus = "REUTERS", p_attribute = "word", cpos = 0L:4049L, registry = registry_tmp)
</code></pre>


</div>