<div class="container">

<table style="width: 100%;"><tr>
<td>generator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a generator function</h2>

<h3>Description</h3>

<p><code>generator()</code> creates an generator factory. A generator is an
iterator function that can pause its execution with
<code>yield()</code> and resume from where it left off. Because they manage
state for you, generators are the easiest way to create
iterators. See <code>vignette("generator")</code>.
</p>
<p>The following rules apply:
</p>

<ul>
<li>
<p> Yielded values do not terminate the generator. If you call the
generator again, the execution resumes right after the yielding
point. All local variables are preserved.
</p>
</li>
<li>
<p> Returned values terminate the generator. If called again after a
<code>return()</code>, the generator keeps returning the <code>exhausted()</code>
sentinel.
</p>
</li>
</ul>
<p>Generators are compatible with all features based on the iterator
protocol such as <code>loop()</code> and <code>collect()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generator(fn)

gen(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>A function template for generators. The function can
<code>yield()</code> values. Within a generator, <code>for</code> loops have
iterator support.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>A yielding expression.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>yield()</code>, <code>coro_debug()</code> for step-debugging.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A generator statement creates a generator factory. The
# following generator yields two times and then returns `"c"`:
generate_abc &lt;- generator(function() {
  yield("a")
  yield("b")
  "c"
})

# Or equivalently:
generate_abc &lt;- generator(function() {
  for (x in letters[1:3]) {
    yield(x)
  }
})

# The factory creates generator instances. They are iterators
# that you can call successively to obtain new values:
abc &lt;- generate_abc()
abc()
abc()

# Once a generator has returned it keeps returning `exhausted()`.
# This signals to its caller that new values can no longer be
# produced. The generator is exhausted:
abc()
abc()

# You can only exhaust a generator once but you can always create
# new ones from a factory:
abc &lt;- generate_abc()
abc()


# As generators implement the coro iteration protocol, you can use
# coro tools like `loop()`. It makes it possible to loop over
# iterators with `for` expressions:
loop(for (x in abc) print(x))

# To gather values of an iterator in a list, use `collect()`. Pass
# the `n` argument to collect that number of elements from a
# generator:
abc &lt;- generate_abc()
collect(abc, 1)

# Or drain all remaining elements:
collect(abc)


# coro provides a short syntax `gen()` for creating one-off
# generator _instances_. It is handy to adapt existing iterators:
numbers &lt;- 1:10
odds &lt;- gen(for (x in numbers) if (x %% 2 != 0) yield(x))
squares &lt;- gen(for (x in odds) yield(x^2))
greetings &lt;- gen(for (x in squares) yield(paste("Hey", x)))

collect(greetings)


# Arguments passed to generator instances are returned from the
# `yield()` statement on reentry:
new_tally &lt;- generator(function() {
  count &lt;- 0
  while (TRUE) {
    i &lt;- yield(count)
    count &lt;- count + i
  }
})
tally &lt;- new_tally()
tally(1)
tally(2)
tally(10)
</code></pre>


</div>