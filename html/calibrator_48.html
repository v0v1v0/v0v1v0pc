<div class="container">

<table style="width: 100%;"><tr>
<td>reality</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reality</h2>

<h3>Description</h3>

  
<p>Function to compute reality, gratis <em>deus ex machina</em>.  Includes a
simple computer model that substitutes for a complex climate model,
and a simple function that substitutes for the base system, in this
case the climate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">model.inadequacy(X, set.seed.to.zero=TRUE, draw.from.prior=FALSE,
     export.true.hyperparameters=FALSE,phi=NULL)
computer.model(X, params=NULL, set.seed.to.zero=TRUE,
draw.from.prior=FALSE, export.true.hyperparameters=FALSE,phi=NULL)
phi.true.toy(phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Observation point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>Parameters needed by <code>computer.model()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set.seed.to.zero</code></td>
<td>
<p>Boolean, with the default value of <code>TRUE</code>
meaning to set the RNG seed to zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draw.from.prior</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
generate obsevations from the “true” values of the
parameters, and <code>TRUE</code> meaning to draw from the relevant
apriori distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export.true.hyperparameters</code></td>
<td>
<p>Boolean, with default value
of <code>FALSE</code> meaning to return the observed scalar.  Set to
<code>TRUE</code> to exercise omniscience and access the <em>true</em>
values of the parameters and hyperparameters.  Only the omnipotent
should set this variable, and only the omniscient may see its true
value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>In function <code>phi.true.toy()</code> the hyperparameters
<code class="reqn">\phi</code>.  Note that apriori distributions are unchanged
(they are irrelevant to omniscient beings).
</p>
<p>In functions <code>reality()</code> and <code>computer.model()</code>, the prior
distributions of the hyperparameters is passed via <code>phi</code> (so it
only elements <code>psi1.apriori</code> and <code>psi2.apriori</code> need to be set).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>reality()</code> provides <em>the</em> scalar value observed at
a point <code>x</code>.  Evaluation expense is zero; there is no overhead.
</p>
<p>(However, it does not compute “reality”: the function returns a
value subject to observational error <code class="reqn">N(0,\lambda)</code>
as per equation 5.  It might be better to call this function
<code>observation()</code>)
</p>
<p>Function <code>computer.model()</code> returns the output of a simple,
nonlinear computer model.
</p>
<p>Both functions documented here return a random variable drawn from an
appropriate (correlated) multivariate Gaussian distribution, and are
thus Gaussian processes.
</p>
<p>The approach is more explicit in the help pages of the emulator
package.  There, Gaussian processes are generated by directly invoking
<code>rmvnorm()</code> with a suitable correlation matrix
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001. <em>Bayesian
calibration of computer models</em>.  Journal of the Royal Statistical
Society B, 63(3) pp425-464
</p>
</li>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001.  <em>Supplementary details on
Bayesian calibration of computer models</em>, Internal report, University
of Sheffield.  Available at
<a href="http://www.tonyohagan.co.uk/academic/ps/calsup.ps">http://www.tonyohagan.co.uk/academic/ps/calsup.ps</a>
</p>
</li>
<li>
<p>R. K. S. Hankin 2005. <em>Introducing BACCO, an R bundle for
Bayesian analysis of computer code output</em>, Journal of Statistical
Software, 14(16)
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>computer.model</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
  data(toys)


  computer.model(X=D2.toy,params=theta.toy)
  computer.model(D1.toy)
  computer.model(X=x.toy, params=extractor.toy(D1.toy)$t.vec)


  phi.fix &lt;- phi.change(old.phi=phi.toy,
           psi1=c(1, 0.5, 1, 1, 0.5,  0.4),phi.fun=phi.fun.toy)
      #The values come from c(REAL.SCALES,REAL.SIGMA1SQUARED) as
      #seen in the sourcecode for computer.model().

  computer.model(D1.toy)   # use debug(computer.model) and examine
                           # var.matrix directly.  It should match the
                           #  output from V1():


          # first fix phi so that it has the correct values for psi1 (see the
          # section on psi1 in ?phi.fun.toy for how to get this):

   phi.fix &lt;- phi.change(old.phi=phi.toy,psi1=c(1, 0.5, 1.0, 1.0, 0.5,
   0.4), phi.fun=phi.fun.toy)
   V1(D1.toy,phi=phi.fix)





# What are the hyperparameters that were used to create reality?
phi.true.toy(phi=phi.toy)

# 
 computer.model(X=D2.toy,params=theta.toy,draw.from.prior=TRUE,phi=phi.toy)


</code></pre>


</div>