<div class="container">

<table style="width: 100%;"><tr>
<td>connectivity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Connectivity Index - Internal Measure</h2>

<h3>Description</h3>

<p>Function evaluates <em>connectivity</em> index.
</p>


<h3>Usage</h3>

<pre><code class="language-R">connectivity(data,clust,neighbour.num, dist="euclidean")
connectivity.diss.mx(diss.mx,clust,neighbour.num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>numeric matrix</code> or <code>data.frame</code> where columns correspond to variables and rows to 
observations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diss.mx</code></td>
<td>

<p>square, symetric <code>numeric matrix</code> or <code>data.frame</code>, representation of 
dissimilarity matrix where infomartion about distances between objects is stored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust</code></td>
<td>

<p>integer <code>vector</code> with information about cluster id the object is assigned to.
If vector is not integer type, it will be coerced with warning. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbour.num</code></td>
<td>
<p>value which tells how many nearest neighbors for every object should be checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>chosen metric: "euclidean" (default value), "manhattan", "correlation" 
(variable enable only in <code>connectivity</code> function).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For given data and its partitioning <em>connectivity</em> index is computed.
For choosen pattern <code>neighbour.num</code> nearest neighbours are found and sorted from closest 
to most further. Alghorithm checks if those neighbours are 
assigned to the same cluster. At the beggining <em>connectivity</em> value is equal 0 and increase 
with value:
</p>

<table>
<tr>
<td style="text-align: left;">
	1/i </td>
<td style="text-align: left;"> when i-th nearest neighbour is not assigned to the same cluster, </td>
</tr>
<tr>
<td style="text-align: left;">
	0   </td>
<td style="text-align: left;"> otherwise.
	</td>
</tr>
</table>
<p>Procedure is repeated for all patterns which comming from our data set. All values received 
for particular pattern are added and creates main <em>connectivity</em> index.
</p>


<h3>Value</h3>

<p><code>connectivity</code> returns a <em>connectivity</em> value.
</p>


<h3>Author(s)</h3>

<p>Lukasz Nieweglowski</p>


<h3>References</h3>

<p>J. Handl, J. Knowles and D. B. Kell <em>Sumplementary material to computational cluster validation in post-genomic data analysis</em>, 
<a href="http://dbkgroup.org/handl/clustervalidation/supplementary.pdf">http://dbkgroup.org/handl/clustervalidation/supplementary.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load and prepare data
library(clv)
data(iris)
iris.data &lt;- iris[,1:4]

# cluster data
pam.mod &lt;- pam(iris.data,5) # create five clusters
v.pred &lt;- as.integer(pam.mod$clustering) # get cluster ids associated to gived data objects

# compute connectivity index using data and its clusterization
conn1 &lt;- connectivity(iris.data, v.pred, 10)
conn2 &lt;- connectivity(iris.data, v.pred, 10, dist="manhattan")
conn3 &lt;- connectivity(iris.data, v.pred, 10, dist="correlation")

# the same using dissimilarity matrix
iris.diss.mx &lt;- as.matrix(daisy(iris.data))
conn4 &lt;- connectivity.diss.mx(iris.diss.mx, v.pred, 10)
</code></pre>


</div>