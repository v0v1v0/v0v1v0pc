<div class="container">

<table style="width: 100%;"><tr>
<td>pobs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pseudo-Observations</h2>

<h3>Description</h3>

<p>Compute the pseudo-observations for the given data matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pobs(x, na.last = "keep",
     ties.method = eval(formals(rank)$ties.method), lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix (or <code class="reqn">d</code>-vector) of random
variates to be converted to pseudo-observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.last</code></td>
<td>
<p>string passed to <code>rank</code>; see there.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties.method</code></td>
<td>
<p><code>character</code> string specifying how ranks
should be computed if there are ties in any of the coordinate
samples of <code>x</code>; passed to <code>rank</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p><code>logical</code> which, if <code>FALSE</code>,
returns the pseudo-observations when applying the
empirical marginal survival functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">n</code> realizations
<code class="reqn">\bm{x}_i=(x_{i1},\dots,x_{id})^T</code>,
<code class="reqn">i\in\{1,\dots,n\}</code> of a random vector <code class="reqn">\bm{X}</code>,
the pseudo-observations are defined via <code class="reqn">u_{ij}=r_{ij}/(n+1)</code> for
<code class="reqn">i\in\{1,\dots,n\}</code> and <code class="reqn">j\in\{1,\dots,d\}</code>, where <code class="reqn">r_{ij}</code> denotes the rank of <code class="reqn">x_{ij}</code> among all
<code class="reqn">x_{kj}</code>, <code class="reqn">k\in\{1,\dots,n\}</code>.  When there are
no ties in any of the coordinate samples of <code>x</code>, the
pseudo-observations can thus also be computed by component-wise applying the
marginal empirical distribution functions to the data and scaling the result by
<code class="reqn">n/(n+1)</code>. This asymptotically negligible scaling factor is used to
force the variates to fall inside the open unit hypercube, for example, to
avoid problems with density evaluation at the boundaries. Note that
<code>pobs(, lower.tail=FALSE)</code> simply returns <code>1-pobs()</code>.
</p>


<h3>Value</h3>

<p><code>matrix</code> (or <code>vector</code>) of the same
dimensions as <code>x</code> containing the pseudo-observations.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simple definition of the function:
pobs

## Draw from a multivariate normal distribution
d &lt;- 10
set.seed(1)
P &lt;- Matrix::nearPD(matrix(pmin(pmax(runif(d*d), 0.3), 0.99), ncol=d))$mat
diag(P) &lt;- rep(1, d)
n &lt;- 500
x &lt;- MASS::mvrnorm(n, mu = rep(0, d), Sigma = P)

## Compute pseudo-observations (should roughly follow a Gauss
## copula with correlation matrix P)
u &lt;- pobs(x)
plot(u[,5],u[,10], xlab=quote(italic(U)[1]), ylab=quote(italic(U)[2]))

## All components: pairwise plot
pairs(u, gap=0, pch=".", labels =
      as.expression( lapply(1:d, function(j) bquote(italic(U[.(j)]))) ))
</code></pre>


</div>