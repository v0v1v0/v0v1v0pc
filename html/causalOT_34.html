<div class="container">

<table style="width: 100%;"><tr>
<td>Measure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An R6 Class for setting up measures</h2>

<h3>Description</h3>

<p>An R6 Class for setting up measures
</p>


<h3>Usage</h3>

<pre><code class="language-R">Measure(
  x,
  weights = NULL,
  probability.measure = TRUE,
  adapt = c("none", "weights", "x"),
  balance.functions = NA_real_,
  target.values = NA_real_,
  dtype = NULL,
  device = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The data points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The empirical measure. If NULL, assigns equal weight to each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probability.measure</code></td>
<td>
<p>Is the empirical measure a probability measure? Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>Should we try to adapt the data ("x"), the weights ("weights"), or neither ("none"). Default is "none".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance.functions</code></td>
<td>
<p>A matrix of functions of the covariates to target for mean balance. If NULL and <code>target.values</code> are provided, will use the data in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.values</code></td>
<td>
<p>The targets for the balance functions. Should be the same length as columns in <code>balance.functions.</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p>The torch_tensor dtype or NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>device</code></td>
<td>
<p>The device to have the data on. Should be result of <code>torch::torch_device()</code> or NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a Measure object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>balance_functions</code></dt>
<dd>
<p>the functions of the data that
we want to adjust towards the targets</p>
</dd>
<dt><code>balance_target</code></dt>
<dd>
<p>the values the balance_functions are targeting</p>
</dd>
<dt><code>adapt</code></dt>
<dd>
<p>What aspect of the data will be adapted. One of "none","weights", or "x".</p>
</dd>
<dt><code>device</code></dt>
<dd>
<p>the <code>torch::torch_device</code> of the data.</p>
</dd>
<dt><code>dtype</code></dt>
<dd>
<p>the torch::torch_dtype of the data.</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>the rows of the covariates, x.</p>
</dd>
<dt><code>d</code></dt>
<dd>
<p>the columns of the covariates, x.</p>
</dd>
<dt><code>probability_measure</code></dt>
<dd>
<p>is the measure a probability measure?</p>
</dd>
</dl>
</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>grad</code></dt>
<dd>
<p>gets or sets gradient</p>
</dd>
<dt><code>init_weights</code></dt>
<dd>
<p>returns the initial value of the weights</p>
</dd>
<dt><code>init_data</code></dt>
<dd>
<p>returns the initial value of the data</p>
</dd>
<dt><code>requires_grad</code></dt>
<dd>
<p>checks or turns on/off gradient</p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>gets or sets weights</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>Gets or sets the data</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Measure-detach"><code>Measure$detach()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-get_weight_parameters"><code>Measure$get_weight_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-clone"><code>Measure$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Measure-detach"></a>



<h4>Method <code>detach()</code>
</h4>

<p>generates a deep clone of the object without gradients.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure$detach()</pre></div>


<hr>
<a id="method-Measure-get_weight_parameters"></a>



<h4>Method <code>get_weight_parameters()</code>
</h4>

<p>Makes a copy of the weights parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure$get_weight_parameters()</pre></div>


<hr>
<a id="method-Measure-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">if(torch::torch_is_installed()) {
m &lt;- Measure(x = matrix(0, 10, 2), adapt = "none")
print(m)
m$x
m$x &lt;- matrix(1,10,2) # must have same dimensions
m$x
m$weights
m$weights &lt;- 1:10/sum(1:10)
m$weights

# with gradients
m &lt;- Measure(x = matrix(0, 10, 2), adapt = "weights")
m$requires_grad # TRUE
m$requires_grad &lt;- "none" # turns off
m$requires_grad # FALSE
m$requires_grad &lt;- "x"
m$requires_grad # TRUE
m &lt;- Measure(matrix(0, 10, 2), adapt = "none")
m$grad # NULL
m &lt;- Measure(matrix(0, 10, 2), adapt = "weights")
loss &lt;- sum(m$weights * 1:10)
loss$backward()
m$grad
# note the weights gradient is on the log softmax scale
#and the first parameter is fixed for identifiability
m$grad &lt;- rep(1,9)  
m$grad
}
</code></pre>


</div>