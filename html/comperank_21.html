<div class="container">

<table style="width: 100%;"><tr>
<td>offense-defense</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Offense-Defense method</h2>

<h3>Description</h3>

<p>Functions to compute rating and ranking
using Offense-Defense method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rate_od(cr_data, ..., force_nonneg_h2h = TRUE, eps = 0.001, tol = 1e-04,
  max_iterations = 100)

rank_od(cr_data, ..., force_nonneg_h2h = TRUE, eps = 0.001, tol = 1e-04,
  max_iterations = 100, keep_rating = FALSE, ties = c("average", "first",
  "last", "random", "max", "min"), round_digits = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cr_data</code></td>
<td>
<p>Competition results in format ready for
as_longcr().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Head-to-Head expression (see h2h_mat()).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_nonneg_h2h</code></td>
<td>
<p>Whether to force nonnegative values in Head-to-Head
matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Coefficient for total support.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance value for iterative algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iterations</code></td>
<td>
<p>Maximum number of iterations for iterative algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_rating</code></td>
<td>
<p>Whether to keep rating columns in ranking output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties</code></td>
<td>
<p>Value for <code>ties</code> in <code>round_rank()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code>round_rank()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Offense-Defense (OD) rating is designed for games in which player's
goal is to make higher score than opponent(s). To describe competition
results Head-to-Head matrix is computed using <code>...</code> (see
h2h_mat() for technical details and section <strong>Design
of Head-to-Head values</strong> for design details). For pairs of players without
common games Head-to-Head value is computed to 0 (not <code>NA</code>). <strong>Note</strong> that
values should be non-negative and non-NA. This can be ensured with setting
<code>force_nonneg_h2h</code> to <code>TRUE</code>.
</p>
<p>For player which can achieve <em>high</em> Head-to-Head value (even against the
player with strong defense) it is said that he/she has <strong>strong offense</strong>
which results into <em>high</em> offensive rating. For player which can force their
opponents into achieving <em>low</em> Head-to-Head value (even if they have strong
offense) it is said that he/she has <strong>strong defense</strong> which results into
<em>low</em> defensive rating.
</p>
<p>Offensive and defensive ratings describe different skills of players. In
order to fully rate players, OD ratings are computed: offensive ratings
divided by defensive. The more OD rating the better player performance.
</p>
<p>Algorithm for OD ratings is as follows:
</p>

<ol>
<li>
<p> Compute Head-to-Head matrix using <code>...</code>.
</p>
</li>
<li>
<p> Add small value to Head-to-Head matrix to ensure convergence of the
iterative algorithm in the next step. If all values are strictly positive
then this step is omitted. In other case small value is computed as the
smallest non-zero Head-to-Head value multiplied by <code>eps</code>.
</p>
</li>
<li>
<p> Perform iterative fixed point search with the following recurrent formula:
<code>def_{k+1} = t(A) %*% inv(A %*% inv(def_{k}))</code> where <code style="white-space: pre;">⁠def_{k}⁠</code>
is a vector of defensive ratings at iteration <code>k</code>, <code>A</code> is a perturbed
Head-to-Head matrix, <code>inv(x) = 1 / x</code>. Iterative search stops if at least one
of two conditions is met:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠sum(abs(def_{k+1} / def_{k} - 1)) &lt; tol⁠</code>.
</p>
</li>
<li>
<p> Number of iterations exceeds maximum number of iterations
<code>max_iterations</code>.
</p>
</li>
</ul>
</li>
<li>
<p> Compute offensive ratings: <code>off = A %*% inv(def)</code>.
</p>
</li>
<li>
<p> Compute OD ratings: <code>od = off / def</code>.
</p>
</li>
</ol>
<p>Ratings are computed based only on games between players of interest (see
Players). However, be careful with OD ratings for players with no games:
they will have weak offense (because they "scored" 0 in all games) but
strong defense (because all their opponents also "scored" 0 in all common
games). Therefore accounting for missing players might be not a very good
idea.
</p>


<h3>Value</h3>

<p><code>rate_od()</code> returns a tibble with the following
columns:
</p>

<ul>
<li> <p><strong>player</strong> - player identifier.
</p>
</li>
<li> <p><strong>rating_off</strong> - offensive rating of player. <strong>Bigger
value indicates better player performance</strong>.
</p>
</li>
<li> <p><strong>rating_def</strong> - defensive rating of player. <strong>Smaller value indicates
better player performance</strong>.
</p>
</li>
<li> <p><strong>rating_od</strong> - Offense-Defense rating of player. <strong>Bigger value indicates
better player performance</strong>.
</p>
</li>
</ul>
<p><code>rank_od()</code> returns a <code>tibble</code> of the similar structure as <code>rate_od()</code>:
</p>

<ul>
<li> <p><strong>player</strong> - player identifier.
</p>
</li>
<li> <p><strong>rating_off</strong>, <strong>rating_def</strong>, <strong>rating_od</strong> - ratings (if
<code>keep_rating = TRUE</code>).
</p>
</li>
<li> <p><strong>ranking_off</strong>, <strong>ranking_def</strong>, <strong>ranking_od</strong> -
rankings computed with <code>round_rank()</code>.
</p>
</li>
</ul>
<h3>Design of Head-to-Head values</h3>

<p>Head-to-Head values in these functions are assumed to follow the property
which can be <em>equivalently</em> described in two ways:
</p>

<ul>
<li>
<p> In terms of matrix format: <strong>the more Head-to-Head
value in row <em>i</em> and column <em>j</em> the better player from row <em>i</em> performed than
player from column <em>j</em></strong>.
</p>
</li>
<li>
<p> In terms of long format: <strong>the more Head-to-Head
value the better player1 performed than player2</strong>.
</p>
</li>
</ul>
<p>This design is chosen because in most competitions the goal is to score
<strong>more points</strong> and not less. Also it allows for more smooth use of
h2h_funs from <code>comperes</code> package.
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in longcr format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p>Amy N. Langville, Carl D. Meyer (2012) <em>Who’s #1?: The
science of rating and ranking</em>.
</p>
<p>Philip A. Knight (2008) <em>The Sinkhorn-Knopp algorithm:
Convergence and applications.</em>. SIAM Journal of Matrix Analysis,
30(1):261–275, 2008 (For stopping rule of iterative algorithm).
</p>


<h3>Examples</h3>

<pre><code class="language-R">rate_od(ncaa2005, mean(score1))

rank_od(ncaa2005, mean(score1))

rank_od(ncaa2005, mean(score1), keep_rating = TRUE)

# Account for self play
rate_od(ncaa2005, if(player1[1] == player2[1]) 0 else mean(score1))

</code></pre>


</div>