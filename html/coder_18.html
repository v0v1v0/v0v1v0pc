<div class="container">

<table style="width: 100%;"><tr>
<td>classcodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Classcodes methods</h2>

<h3>Description</h3>

<p><code>classcodes</code> are classification schemes based on regular expression stored in
data frames. These are essential to the package and constitute the third
part of the triad of case data, code data and a classification scheme.
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.classcodes(x, ...)

## S3 method for class 'classcodes'
as.classcodes(
  x,
  ...,
  regex = attr(x, "regexpr"),
  indices = attr(x, "indices"),
  hierarchy = attr(x, "hierarchy")
)

## S3 method for class 'data.frame'
as.classcodes(
  x,
  ...,
  regex = NULL,
  indices = NULL,
  hierarchy = attr(x, "hierarchy"),
  .name = NULL
)

is.classcodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data frame with columns described in the details section.
Alternatively a <code>classcodes</code> object to be modified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed between methods#'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex, indices</code></td>
<td>
<p>character vector with names of columns in <code>x</code> containing
regular expressions/indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchy</code></td>
<td>
<p>named list of pairwise group names to appear as superior and
subordinate for indices.
To be used for indexing when the subordinate class is redundant
(see the details section of <code>elixhauser</code> for an example).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name</code></td>
<td>
<p>used internally for name dispatch</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A classcodes object is a data frame with mandatory columns:
</p>

<ul>
<li> <p><code>group</code>: unique and non missing class names
</p>
</li>
<li>
<p> At least one column with regular expressions
(regex without Perl-like versions) defining class
membership. Those columns can have arbitrary names
(as specified by the <code>regex</code> argument).
Occurrences of non unique regular expressions will lead to the same class
having multiple names. This is accepted but will raise a warning.
Classes do not have to be disjunct.
</p>
</li>
</ul>
<p>The object can have additional optional columns:
</p>

<ul>
<li> <p><code>description</code>: description of each category
</p>
</li>
<li> <p><code>condition</code>: a class might have conditions additional to what
is expressed by the regular expressions.
If so, these should be specified as quoted
expressions that can be evaluated within the data frame used by
<code>classify()</code>
</p>
</li>
<li>
<p> weights for each class used by
<code>index()</code>. Could be more than one and could have arbitrary names
(as specified by the <code>indices</code>argument).
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object of class <code>classcodes</code> (inheriting from data frame)
with additional attributes:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠code:⁠</code> the coding used (for example "icd10", or "ATC").
<code>NULL</code> for unknown/arbitrary coding.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠regexprs:⁠</code> name of columns with regular expressions
(as specified by the <code>regex</code>argument)
</p>
</li>
<li> <p><code style="white-space: pre;">⁠indices:⁠</code> name of columns with (optional) index weights
(as specified by the <code>indices</code>argument)
</p>
</li>
<li> <p><code style="white-space: pre;">⁠hierarchy:⁠</code> list as specified by the <code>hierarchy</code> argument.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠name:⁠</code> name as specified by the <code>.name</code> argument.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>vignette("classcodes")</code>
<code>vignette("Interpret_regular_expressions")</code>
The package have several default classcodes included, see <code>all_classcodes()</code>.
</p>
<p>Other classcodes: 
<code>all_classcodes()</code>,
<code>as.data.frame.classified()</code>,
<code>codebook()</code>,
<code>print.classcodes()</code>,
<code>print.classified()</code>,
<code>set_classcodes()</code>,
<code>summary.classcodes()</code>,
<code>visualize.classcodes()</code>
</p>
<p>Other classcodes: 
<code>all_classcodes()</code>,
<code>as.data.frame.classified()</code>,
<code>codebook()</code>,
<code>print.classcodes()</code>,
<code>print.classified()</code>,
<code>set_classcodes()</code>,
<code>summary.classcodes()</code>,
<code>visualize.classcodes()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The Elixhauser comorbidity classification is already a classcodes object
is.classcodes(coder::elixhauser)

# Strip its class attributes to use in examples
df &lt;- as.data.frame(coder::elixhauser)

# Specify which columns store regular expressions and indices
# (assume no hierarchy)
elix &lt;-
  as.classcodes(
    df,
    regex     = c("icd10", "icd10_short", "icd9cm", "icd9cm_ahrqweb", "icd9cm_enhanced"),
    indices   = c("sum_all", "sum_all_ahrq", "walraven",
                "sid29", "sid30", "ahrq_mort", "ahrq_readm"),
    hierarchy = NULL
  )
elix

# Specify hierarchy for patients with different types of cancer and diabetes
# See `?elixhauser` for details
as.classcodes(
  elix,
  hierarchy = list(
    cancer   = c("metastatic cancer", "solid tumor"),
    diabetes = c("diabetes complicated", "diabetes uncomplicated")
  )
)

# Several checks are performed to not allow any erroneous classcodes object
## Not run: 
  as.classcodes(iris)
  as.classcodes(iris, regex = "Species")

## End(Not run)
</code></pre>


</div>