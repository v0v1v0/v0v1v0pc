<div class="container">

<table style="width: 100%;"><tr>
<td>curve_cont</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimate Counterfactual Survival or Failure Probabilities for Levels of a Continuous Variable
</h2>

<h3>Description</h3>

<p>This function can be utilized to estimate counterfactual survival curves or cumulative incidence functions (CIF) for specific values of a continuous covariate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">curve_cont(data, variable, model, horizon,
           times, group=NULL, cause=1, cif=FALSE,
           contrast="none", reference="km", ref_value=NULL,
           event_time=NULL, event_status=NULL,
           conf_int=FALSE, conf_level=0.95,
           n_boot=300, n_cores=1,
           na.action=options()$na.action,
           return_boot=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A <code>data.frame</code> containing all required variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable</code></td>
<td>

<p>A single character string specifying the continuous variable of interest, for which the survival curves should be estimated. This variable has to be contained in the <code>data.frame</code> that is supplied to the <code>data</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>A model describing the time-to-event process (such as an <code>coxph</code> model). Needs to include <code>variable</code> as an independent variable. It also has to have an associated <code>predictRisk</code> method. See <code>?predictRisk</code> for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>horizon</code></td>
<td>

<p>A numeric vector containing a range of values of <code>variable</code> for which the survival curves should be calculated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>

<p>A numeric vector containing points in time at which the survival probabilities should be calculated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>

<p>An optional single character string specifying a factor variable in <code>data</code>. When used, the regression standardization is performed conditional on this factor variable, meaning that one estimate is returned for each level of the factor variable. See details for a better description. Set to <code>NULL</code> (default) to use no grouping variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cause</code></td>
<td>

<p>The cause of interest. In standard survival data with only one event type, this should be kept at 1. For data with multiple failure types, this argument should be specified. In addition, the <code>cif</code> argument should be set to <code>TRUE</code> in those cases.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cif</code></td>
<td>

<p>Whether to calculate the cumulative incidence (CIF) instead of the survival probability. If multiple failure types are present, the survival probability cannot be estimated in an unbiased way. In those cases, this argument should always be set to <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>

<p>Defines what kind of estimate should be returned. Can be either <code>"none"</code> (default), <code>"diff"</code> or <code>"ratio"</code>. When <code>"none"</code> is used, it simply returns the counterfactual survival probabilities (or CIF if <code>cif=TRUE</code>) without any further calculations. If <code>"diff"</code> or <code>"ratio"</code> is used instead, the difference or ratio to some reference value will be returned. See argument below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>

<p>Defines what kind of reference value to use when estimating causal contrasts. Only used if <code>contrast!="none"</code>, ignored otherwise. Can be either <code>"km"</code> (using standard Kaplan-Meier estimates as reference) or <code>"value"</code> (using the g-computation estimates of a specific value of the <code>variable</code> as reference). To specify which value to use when using <code>reference="value"</code>, the <code>ref_value</code> argument should be used. See details for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref_value</code></td>
<td>

<p>A single number corresponding to the reference value used when estimating causal contrasts using <code>reference="value"</code>. See details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event_time</code></td>
<td>

<p>A single character string specifying the time until the occurrence of the event of interest or <code>NULL</code> (default). Only used when estimating causal contrasts with <code>reference="km"</code>, ignored otherwise. If specified, this variable has to be contained in the <code>data.frame</code> that is supplied to the <code>data</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event_status</code></td>
<td>

<p>A single character string specifying the status of the event of interest or <code>NULL</code> (default). Only used when estimating causal contrasts with <code>reference="km"</code>, ignored otherwise. If specified, this variable has to be contained in the <code>data.frame</code> that is supplied to the <code>data</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_int</code></td>
<td>

<p>Whether to calculate point-wise confidence intervals or not. If <code>TRUE</code>, <code>n_boot</code> bootstrap samples are drawn, the g-computation step is performed on each bootstrap sample and the confidence intervals are calculated using the percentile method from these results. Can get very slow if the dataset is large or there are many values in <code>horizon</code> or <code>times</code>. Using <code>n_cores</code> can speed up the process a lot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_level</code></td>
<td>

<p>A number specifying the confidence level of the bootstrap confidence intervals. Ignored if <code>conf_int=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_boot</code></td>
<td>

<p>A single integer specifying how many bootstrap repetitions should be performed. Ignored if  <code>conf_int=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>

<p>The number of processor cores to use when performing the calculations. If <code>n_cores=1</code> (default), single threaded processing is used. If <code>n_cores &gt; 1</code> the <span class="pkg">foreach</span> package and the <span class="pkg">doParallel</span> package are used to run the calculations on <code>n_cores</code> in parallel. This might speed up the runtime considerably when it is initially slow.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>How missing values should be handled. Can be one of: <code>na.fail</code>, <code>na.omit</code>, <code>na.pass</code>, <code>na.exclude</code> or a user-defined custom function. Also accepts strings of the function names. See <code>?na.action</code> for more details. By default it uses the na.action which is set in the global options by the respective user.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_boot</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default). If <code>TRUE</code> (and <code>conf_int=TRUE</code>) this function will return the individual bootstrap estimates instead of the usual estimates. This may be useful to perform tests or calculate other type of bootstrap confidence intervals manually.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed to <code>predictRisk</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is used internally in all plot functions included in this R-package and generally does not need to be called directly by the user. It can however be used to get specific values or as a basis to create custom plots not included in this package. Below we give a small introduction to what this function does. A more detailed description of the underlying methodology can be found in our article on this subject (Denz &amp; Timmesfeld 2022).
</p>
<p><strong><em>Target Estimand (default)</em></strong>
</p>
<p>By default (<code>contrast="none"</code>) this function tries to estimate the survival probability at <code>times</code> that would have been observed if every individual in the sample had received a value of <code>horizon</code> in the <code>variable</code>. Let <code class="reqn">Z</code> be the continuous variable we are interested in. Let <code class="reqn">T</code> be the time until the occurrence of the event of interest. Under the potential outcome framework, there is an uncountably infinite amount of potential survival times <code class="reqn">T^{(Z=z)}</code>, one for each possible value of <code class="reqn">Z</code>. The target estimand is then defined as:
</p>
<p style="text-align: center;"><code class="reqn">S_{z}(t) = E(I(T^{(Z=z)} &gt; t))</code>
</p>

<p>If we additionally consider a categorical <code>group</code> variable <code class="reqn">D</code>, the target estimand is similarly defined as:
</p>
<p style="text-align: center;"><code class="reqn">S_{zd}(t) = E(I(T^{(Z=z, D=d)} &gt; t))</code>
</p>

<p>where <code class="reqn">T^{(Z=z, D=d)}</code> is the survival time that would have been observed if the individual had received both <code class="reqn">Z = z</code> and <code class="reqn">D = d</code>.
</p>
<p><strong><em>Target Estimand (using contrasts)</em></strong>
</p>
<p>If contrasts are used (<code>contrast!="none"</code>), target estimands based on <code class="reqn">S_{z}(t)</code> or <code class="reqn">S_{zd}(t)</code> are used instead. When using <code>contrast="diff"</code> and <code>reference="km"</code>, the target estimand is simply the difference between the observed survival probability in the entire sample (denoted by <code class="reqn">S(t)</code>, estimated using a Kaplan-Meier estimator) and the counterfactual survival probability:
</p>
<p style="text-align: center;"><code class="reqn">\Delta_{KM}(t, z) = S(t) - S_z(t)</code>
</p>

<p>If <code>contrast="ratio"</code> is used instead, the substraction sign is simply replace by a division. If <code>group</code> was specified, <code class="reqn">S(t)</code> is replaced by <code class="reqn">S_d(t)</code> (a stratified Kaplan-Meier estimator) and <code class="reqn">S_z(t)</code> is replaced by <code class="reqn">S_{zd}(t)</code>. Instead of using a Kaplan-Meier estimator as <code>reference</code>, one may also use a specific <code class="reqn">S_z(t)</code> as reference using <code>reference="value"</code> and setting <code>ref_value</code> to the <code class="reqn">Z</code> that should be used. All of these causal contrasts and their implications are described in detail in the appendix of our article on this topic (Denz &amp; Timmesfeld 2022).
</p>
<p><strong><em>Estimation Methodology</em></strong>
</p>
<p><em>G-Computation</em>, also known as the <em>Corrected Group Prognosis</em> method, <em>Direct-Standardization</em> or <em>G-Formula</em>, is used internally to estimate the counterfactual survival probability or CIF for values of a continuous variable. This is done by setting the <code>variable</code> to a specific value for all rows in <code>data</code> first. Afterwards, the <code>model</code> is used to predict the survival probability of each individual at all <code>times</code>, given the value of <code>variable</code> and their other observed covariates (which are included in the model as independent variables). These estimates are then averaged for each time point. This procedure is repeated for every value in <code>horizon</code>. If a <code>group</code> is supplied, these calculations are repeated for every possible value in <code>group</code>, with the estimated individual survival probabilities also being conditional on that value.
</p>
<p>To obtain valid estimates of the target estimand using this function, the fundamental causal identifiability assumptions have to be met. Those are described in detail in our article on this topic (Denz &amp; Timmesfeld 2022). If those assumptions are not met, the estimates may only be used to showcase simple associations. They cannot be endowed with a counterfactual interpretation in this case.
</p>
<p><strong><em>Supported Models</em></strong>
</p>
<p>This function relies on the <code>predictRisk</code> function from the <span class="pkg">riskRegression</span> package to create the covariate and time specific estimates of the probabilities. All models with an associated <code>predictRisk</code> method may be used in this function. This includes a variety of models, such as the Cox proportional hazards regression model and the aalen additive hazards model. If the model that should be used has no <code>predictRisk</code> method, the user either needs to write their own <code>predictRisk</code> method or contact the maintainers of the <span class="pkg">riskRegression</span> package.
</p>
<p><strong><em>Bootstrap Confidence Intervals</em></strong>
</p>
<p>By using <code>conf_int=TRUE</code>, bootstrap confidence intervals may be estimated. This will draw <code>n_boot</code> samples of size <code>nrow(data)</code> with replacement from <code>data</code> in the first step. Afterwards, the <code>model</code> is fit to each of those bootstrap samples and the <code>curve_cont</code> function is recursively called to obtain the estimates of interests for each sample. Using the percentile approach, the bootstrap confidence intervals are calculated. This requires that the <code>model</code> object contains a <code>call</code> parameter, because the <code>update()</code> function is used internally.
</p>
<p><strong><em>Computational Complexity</em></strong>
</p>
<p>If many values are included in <code>times</code>, <code>horizon</code> or both and/or <code>data</code> has a lot of rows, this function may become very slow. Since bootstrapping relies on sampling with replacement from the original <code>data</code> and repeating the entire procedure <code>n_boot</code> times, this also dramatically increases the runtime. Parallel processing may be used to speed up the computations. This can be done by simply setting <code>n_cores</code> to values higher than 1.
</p>
<p><strong><em>Missing Data</em></strong>
</p>
<p>Currently, this function does not support advanced handling of missing data. The <code>data.frame</code> supplied to <code>data</code> should contain no missing data in the relevant columns. To achieve this, the <code>na.action</code> argument can be set to <code>"na.omit"</code>, which will remove all rows that do contain missing data.
</p>
<p><strong><em>Competing Events</em></strong>
</p>
<p>By supplying a <code>model</code> that directly takes into account competing events and using the <code>cause</code> argument, the user may also use the functionality offered in this package to create plots in this setting. Internally, the <code>predictRisk</code> method will then be used to estimate the conditional cause-specific cumulative incidence function, which will then be used to carry out the g-computation step explained above. <strong>However</strong> the underlying target estimand of this procedure is dependent on which kind of model was supplied. It is therefore not possible to define it here concisely. Future research is necessary to clarify this point. This feature should only be used with great caution.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> containing the columns <code>time</code> (the point in time), <code>est</code> (the estimated survival probability or CIF) and <code>cont</code> (the specific value of <code>variable</code> used). If <code>group</code> was used, it includes the additional <code>group</code> column, specifying the level of the grouping variable. If <code>conf_int=TRUE</code> was used, it additionally includes the columns <code>se</code> (bootstrap standard error of the estimate), <code>ci_lower</code> (lower limit of the bootstrap confidence interval) and <code>ci_upper</code> (upper limit of the bootstrap confidence interval).
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>References</h3>

<p>Robin Denz, Nina Timmesfeld (2023). "Visualizing the (Causal) Effect of a Continuous Variable on a Time-To-Event Outcome". In: Epidemiology 34.5
</p>
<p>Brice Ozenne, Anne Lyngholm Sorensen, Thomas Scheike, Christian Torp-Pedersen and Thomas Alexander Gerds. riskRegression: Predicting the Risk of an Event using Cox Regression Models. The R Journal (2017) 9:2, pages 440-460.
</p>
<p>I-Ming Chang, Rebecca Gelman, and Marcello Pagano. Corrected Group Prognostic Curves and Summary Statistics. Journal of Chronic Diseases (1982) 35, pages 669-674
</p>
<p>James Robins. A New Approach to Causal Inference in Mortality Studies with a Sustained Exposure Period: Application to Control of the Healthy Worker Survivor Effect. Mathematical Modelling (1986) 7, pages 1393-1512.
</p>


<h3>See Also</h3>

<p><code>predictRisk</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(contsurvplot)
library(riskRegression)
library(survival)

# using data from the survival package
data(nafld, package="survival")

# take a random sample to keep example fast
set.seed(42)
nafld1 &lt;- nafld1[sample(nrow(nafld1), 150), ]

# fit cox-model with age
model &lt;- coxph(Surv(futime, status) ~ age, data=nafld1, x=TRUE)

# estimate survival probability at some points in time, for
# a range of age values
plotdata &lt;- curve_cont(data=nafld1,
                       variable="age",
                       model=model,
                       horizon=c(50, 60, 70, 80),
                       times=c(1000, 2000, 3000, 4000))

# estimate cumulative incidences instead
plotdata &lt;- curve_cont(data=nafld1,
                       variable="age",
                       model=model,
                       horizon=c(50, 60, 70, 80),
                       times=c(1000, 2000, 3000, 4000),
                       cif=TRUE)
</code></pre>


</div>