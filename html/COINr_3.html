<div class="container">

<table style="width: 100%;"><tr>
<td>Aggregate.data.frame</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate data frame</h2>

<h3>Description</h3>

<p>Aggregates a data frame into a single column using a specified function. Note that COINr has a number of aggregation functions built in,
all of which are of the form <code style="white-space: pre;">⁠a_*()⁠</code>, e.g. <code>a_amean()</code>, <code>a_gmean()</code> and friends.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'data.frame'
Aggregate(
  x,
  f_ag = NULL,
  f_ag_para = NULL,
  dat_thresh = NULL,
  by_df = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Data frame to be aggregated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_ag</code></td>
<td>
<p>The name of an aggregation function, as a string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_ag_para</code></td>
<td>
<p>Any additional parameters to pass to <code>f_ag</code>, as a named list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat_thresh</code></td>
<td>
<p>An optional data availability threshold, specified as a number between 0 and 1. If a row
of <code>x</code> has data availability lower than this threshold, the aggregated value for that row will be
<code>NA</code>. Data availability, for a row <code>x_row</code> is defined as <code>sum(!is.na(x_row))/length(x_row)</code>, i.e. the
fraction of non-<code>NA</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_df</code></td>
<td>
<p>Controls whether to send a numeric vector to <code>f_ag</code> (if <code>FALSE</code>, default) or a data frame (if <code>TRUE</code>) - see
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Aggregation is performed row-wise using the function <code>f_ag</code>, such that for each row <code>x_row</code>, the output is
<code>f_ag(x_row, f_ag_para)</code>, and for the whole data frame, it outputs a numeric vector. The data frame <code>x</code> must
only contain numeric columns.
</p>
<p>The function <code>f_ag</code> must be supplied as a string, e.g. <code>"a_amean"</code>, and it must take as a minimum an input
<code>x</code> which is either a numeric vector (if <code>by_df = FALSE</code>), or a data frame (if <code>by_df = TRUE</code>). In the former
case <code>f_ag</code> should return a single numeric value (i.e. the result of aggregating <code>x</code>), or in the latter case
a numeric vector (the result of aggregating the whole data frame in one go).
</p>
<p><code>f_ag</code> can optionally have other parameters, e.g. weights, specified as a list in <code>f_ag_para</code>.
</p>
<p>Note that COINr has a number of aggregation functions built in,
all of which are of the form <code style="white-space: pre;">⁠a_*()⁠</code>, e.g. <code>a_amean()</code>, <code>a_gmean()</code> and friends. To see a list browse COINr functions alphabetically or
type <code>a_</code> in the R Studio console and press the tab key (after loading COINr), or see the <a href="https://bluefoxr.github.io/COINr/articles/aggregate.html#coinr-aggregation-functions">online documentation</a>.
</p>
<p>Optionally, a data availability threshold can be assigned below which the aggregated value will return
<code>NA</code> (see <code>dat_thresh</code> argument). If <code>by_df = TRUE</code>, this will however be ignored because aggregation is not
done on individual rows. Note that more complex constraints could be built into <code>f_ag</code> if needed.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class="language-R"># get some indicator data - take a few columns from built in data set
X &lt;- ASEM_iData[12:15]

# normalise to avoid zeros - min max between 1 and 100
X &lt;- Normalise(X,
               global_specs = list(f_n = "n_minmax",
                                    f_n_para = list(l_u = c(1,100))))

# aggregate using harmonic mean, with some weights
y &lt;- Aggregate(X, f_ag = "a_hmean", f_ag_para = list(w = c(1, 1, 2, 1)))

</code></pre>


</div>