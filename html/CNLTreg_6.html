<div class="container">

<table style="width: 100%;"><tr>
<td>fwtnppermC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Forward complex wavelet lifting transform
</h2>

<h3>Description</h3>

<p>Performs the complex-valued lifting transform on a signal with grid <span class="env">x</span> and corresponding function 
values <span class="env">f</span>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fwtnppermC(x, f, LocalPred = LinearPred, neighbours = 1, 
intercept = TRUE, closest = FALSE, nkeep = 2, 
mod = sample(1:length(x), (length(x) - nkeep), FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LocalPred</code></td>
<td>
<p>The type of regression to be performed in the prediction lifting step. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and
<code>AdaptNeigh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbours</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step.
If <span class="env">closest</span> is <code>FALSE</code>, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Indicates whether or not the regression prediction includes an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closest</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">closest</span> is <code>FALSE</code>,
the neighbours will be chosen symmetrically around the removed point.
Otherwise, the closest neighbours (in distance) will be chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nkeep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal.
This must be at least two. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>Vector of length (length(<code>x</code>)-<code>nkeep</code>). This gives
the trajectory for the lifting algorithm to follow, i.e. it gives
the order of point removal.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">n</code> points on a line, <span class="env">x</span>, each with a corresponding envf value this function computes
the complex-valued lifting transform of the (<span class="env">x</span>,<span class="env">f</span>) data. This is similar in spirit to the 
real-valued lifting transform in <code>fwtnpperm</code>, except that the algorithm constructs *two* 
orthogonally linked prediction filters, as in Section 2.2 of Hamilton et al. (2018).  A summary of the 
procedure is as follows:
</p>
<p>Step One. Compute "integrals" associated to each point, representing the intervals that each gridpoint 
<code>x_i</code> spans. 
</p>
<p>Then for each point index in the lifting trajectory <span class="env">mod</span>, 
</p>
<p>Step Two(a). The neighbours of the removed point are identified using the specified neighbour configuration.
The value of <span class="env">f</span> at the removed point is predicted using the specified regression over the
neighbours, unless an adaptive procedure is chosen. In this case, the algorithm chooses the regression which
produces the minimal detail coefficient (in magnitude) from a range of regression types (see <code>AdaptPred</code> or <code>AdaptNeigh</code> for more information).  In either case, the regression
specifies a local filter of the function values over the neighbourhood, <code>L</code>.
</p>
<p>Step Two(b). A second filter, <code>M</code>, is then constructed orthogonal to <code>L</code>, such that it has unit norm, see Hamilton et al. (2018) for more details. 
</p>
<p>The differences between the removed point's <span class="env">f</span> value and the predictions using the two filters are computed, which constitute the real and imaginary parts of the complex-valued wavelet coefficient.  This coefficient is then stored
</p>
<p>Step Three. The integrals and the scaling function values (neighbouring <span class="env">coeffv</span> values) are updated according to the filter <code>L</code>. 
</p>
<p>The algorithm continues until all points in <span class="env">mod</span> are removed.  
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coeff</code></td>
<td>
<p>matrix of detail and scaling coefficients in the wavelet decomposition of the signal; first column: real component, second column: imaginary component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points removed during the transform
(in <span class="env">removelist</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition. These are the
indices of the <span class="env">X</span> values which remain after all points in <span class="env">removelist</span> have been predicted and
removed. This has length <span class="env">nkeep</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform
(in the order of removal).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamlist</code></td>
<td>
<p>a list of all the prediction weights used at each step of the transform; each list entry is a matrix of two rows, corresponding to the filters <code>L</code> and <code>M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphalist</code></td>
<td>
<p>a list of the update coefficients used in the update step of the decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>The complex-valued lifting matrix associated to the transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reo</code></td>
<td>
<p>An index into the observations indicating a reordering to give <code>1:n</code>.  This is reported for convenience for other functions, and is not intended for use by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeffv</code></td>
<td>
<p>vector of complex-valued detail and scaling coefficients in the wavelet decomposition of the signal; contains the same information as <span class="env">coeff</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ialpha</code></td>
<td>
<p>Vector of "irregularity degree" measures corresponding to each lifting step of the transform.  Note that this is returned for convenience in other functions, and is not intended for use by the user.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight</p>


<h3>References</h3>

<p>Hamilton, J., Knight, Nunes, M. A. and Fryzlewicz (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>69</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br><br>
For related literature on the lifting methodology adopted in the technique, see<br><br>
Nunes, M. A., Knight, M. I and Nason, G. P. (2006) Adaptive lifting for nonparametric regression.
<em>Stat. Comput.</em> <b>16</b> (2), 143–159.<br><br>
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1–16.
</p>


<h3>See Also</h3>

<p><code>AdaptNeigh</code>, <code>AdaptPred</code>, <code>CubicPred</code>, 
<code>denoisepermC</code>, 
<code>denoisepermCh</code>, 
<code>LinearPred</code>, 
<code>orthpredfilters</code>, 
<code>QuadPred</code>     
</p>


<h3>Examples</h3>

<pre><code class="language-R">    library(adlift)

    # construct an (irregular) observation grid
     x&lt;-runif(256)

     #construct a signal
     f&lt;-make.signal2("blocks",x=x)

     fwd&lt;-fwtnppermC(x,f,LocalPred=AdaptPred,neigh=1,closest=FALSE)

     # have a look at the complex-valued coefficients and the removal trajectory:

     fwd$coeffv

     fwd$removelist	
</code></pre>


</div>