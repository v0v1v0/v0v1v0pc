<div class="container">

<table style="width: 100%;"><tr>
<td>factorize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
S3 generic function and methods for factorization.
</h2>

<h3>Description</h3>

<p>The <code>default</code> method factorizes positive numeric integer arguments,
returning a vector of prime factors.  The <code>factor</code> method can be used to
generate pseudo-factors.  It accepts a factor, <code>f</code>, as principal
argument and returns a data frame with factors <code>fa</code>, <code>fb</code>,
... each with a prime number of levels such that <code>f</code> is model
equivalent to <code>join(fa, fb, ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
factorize(x, divisors = primes(max(x)), ...)
## S3 method for class 'factor'
factorize(x, name = deparse(substitute(x)), extension =
letters, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Principal argument.
</p>
<p>The <code>default</code> method factorizes (smallish) positive integers;
</p>
<p>The <code>factor</code> method generates prime pseudo-factors from a
factor with a composite number of levels (as required for partial
confounding).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>divisors</code></td>
<td>

<p>Candidate prime divisors for all numers to be factorized.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>

<p>Stem of the name to be given to component pseudo-factors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extension</code></td>
<td>

<p>Distinguishing strings to be added to the stem to nominate the
pseudo-factors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments, if any.  (Presently ignored.)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Primarily intended to split a factor with a non-prime number of levels
into a series of pseudo-factors, each with a prime number of levels
and which jointly define the same classes as the factor itself.
</p>
<p>The main reason to do this would be to confound one or more of the
pseudo-factors, or their interactions, with blocks using constructions
that only apply for prime numbers of levels.  In this way the
experiment can be made smaller, at the cost of some treatment
contrasts being confounded with blocks.
</p>
<p>The default method factorizes integers by a clumsy, though effective
enough way for small integers.  The function is vectorized in the
sense that if a vector of integers to factorize is specified, the
object returned is a list of numeric vectors, giving the prime
divisors (including repeats) of the given integers respectively.
</p>
<p>As with any method of factorizing integers, it may become very slow if
the prime factors are large.
</p>


<h3>Value</h3>

<p>For the <code>default</code> method a vector, or list of vectors, of prime
integer divisors of the components of <code>x</code>, (including repeats).
</p>
<p>For the <code>factor</code> method, a design with factors having prime
numbers of levels for factor arguments.
</p>


<h3>Side Effects</h3>

<p>None.
</p>


<h3>See Also</h3>

<p>conf.design, join
</p>


<h3>Examples</h3>

<pre><code class="language-R">factorize(12321)
### [1]  3  3 37 37

f &lt;- factor(1:6)
data.frame(f, factorize(f))
###   f fa fb
### 1 1  0  0
### 2 2  1  0
### 3 3  0  1
### 4 4  1  1
### 5 5  0  2
### 6 6  1  2

des &lt;- with(list(f = factor(rep(6:1, 1:6))),
            data.frame(f, factorize(f)))
head(des, 7)
##   f fa fb
## 1 6  1  2
## 2 5  0  2
## 3 5  0  2
## 4 4  1  1
## 5 4  1  1
## 6 4  1  1
## 7 3  0  1
</code></pre>


</div>