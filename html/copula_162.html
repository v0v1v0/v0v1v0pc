<div class="container">

<table style="width: 100%;"><tr>
<td>enacopula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation Procedures for (Nested) Archimedean Copulas</h2>

<h3>Description</h3>

<p>A set of ten different estimators, currently for one-parameter
Archimedean copulas, of possibly quite high dimensions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">enacopula(u, cop,
          method = c("mle", "smle", "dmle",
                     "mde.chisq.CvM", "mde.chisq.KS",
                     "mde.gamma.CvM", "mde.gamma.KS",
                     "tau.tau.mean", "tau.theta.mean", "beta"),
          n.MC = if (method == "smle") 10000 else 0,
          interval = initOpt(cop@copula@name),
          xargs = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula to be estimated, where <code class="reqn">n</code>
denotes the sample size and <code class="reqn">d</code> the dimension.  Consider applying the
function <code>pobs</code> first in order to obtain <code>u</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p><code>outer_nacopula</code> to be estimated
(currently only Archimedean copulas are provided).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a <code>character</code> string specifying the
estimation method to be used, which has to be one (or a unique
abbreviation) of
</p>

<dl>
<dt><code>"mle"</code></dt>
<dd>
<p>maximum likelihood estimator (MLE) computed
via <code>.emle</code>.</p>
</dd>
<dt><code>"smle"</code></dt>
<dd>
<p>simulated maximum likelihood estimator (SMLE)
computed with the function <code>.emle</code>, where
<code>n.MC</code> gives the Monte Carlo sample size.</p>
</dd>
<dt><code>"dmle"</code></dt>
<dd>
<p>MLE based on the diagonal (DMLE); see
<code>edmle</code>.</p>
</dd>
<dt><code>"mde.chisq.CvM"</code></dt>
<dd>
<p>minimum distance estimator based
on the chisq distribution and Cramér-von Mises
distance; see <code>emde</code>.</p>
</dd>
<dt><code>"mde.chisq.KS"</code></dt>
<dd>
<p>minimum distance estimation based on
the chisq distribution and Kolmogorov-Smirnov distance; see
<code>emde</code>.</p>
</dd>
<dt><code>"mde.gamma.CvM"</code></dt>
<dd>
<p>minimum distance estimation based on
the Erlang distribution and Cramér-von Mises distance;
see <code>emde</code>.</p>
</dd>
<dt><code>"mde.gamma.KS"</code></dt>
<dd>
<p>minimum distance estimation based on
the Erlang distribution and Kolmogorov-Smirnov distance; see
<code>emde</code>.</p>
</dd>
<dt><code>"tau.tau.mean"</code></dt>
<dd>
<p>averaged pairwise Kendall's tau estimator</p>
</dd>
<dt><code>"tau.theta.mean"</code></dt>
<dd>
<p>average of pairwise Kendall's tau
estimators</p>
</dd>
<dt><code>"beta"</code></dt>
<dd>
<p>multivariate Blomqvist's beta estimator</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.MC</code></td>
<td>
<p>only for <code>method = "smle"</code>: <code>integer</code>,
sample size for simulated maximum likelihood estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in
Hofert et al. (2012).  Used for all methods except
<code>"tau.tau.mean"</code> and <code>"tau.theta.mean"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xargs</code></td>
<td>
<p>list of additional arguments for the chosen estimation method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>optimize</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>enacopula</code> serves as a wrapper for the different
implemented estimators and provides a uniform framework to utilize
them.  For more information, see the single estimators as given in the
section ‘See Also’.
</p>
<p>Note that Hofert, Mächler, and McNeil (2013) compared these
estimators. Their findings include a rather poor performance and numerically
challenging problems of some of these estimators. In particular, the
estimators obtained by <code>method="mde.gamma.CvM"</code>,
<code>method="mde.gamma.KS"</code>, <code>method="tau.theta.mean"</code>, and
<code>method="beta"</code> should be used with care (or not at all). Overall, MLE
performed best (by far).
</p>


<h3>Value</h3>

<p>the estimated parameter, <code class="reqn">\hat{\theta}</code>, that is, currently a
number as only one-parameter Archimedean copulas are considered.
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133–150.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25–63.
</p>


<h3>See Also</h3>

<p><code>emle</code> which returns an object of <code>"mle"</code>
providing useful methods not available for other estimators.
<code>demo(opC-demo)</code> and <code>vignette("GIG", package="copula")</code> for
examples of two-parameter families.
<code>edmle</code> for the diagonal maximum likelihood estimator.
<code>emde</code> for the minimum distance estimators.
<code>etau</code> for the estimators based on Kendall's tau.
<code>ebeta</code> for the estimator based on Blomqvist's beta.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;- 12
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 100
U &lt;- rnacopula(n, cop)

meths &lt;- eval(formals(enacopula)$method)

fun &lt;- function(meth, u, cop, theta) {
	run.time &lt;- system.time(val &lt;- enacopula(u, cop=cop, method=meth))
	list(value=val, error=val-theta, utime.ms=1000*run.time[[1]])
}
t(res &lt;- sapply(meths, fun, u=U, cop=cop, theta=theta))
</code></pre>


</div>