<div class="container">

<table style="width: 100%;"><tr>
<td>cv.sb.splsicox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross validation cv.sb.splsicox</h2>

<h3>Description</h3>

<p>This function performs cross-validated sparse partial least squares single block for splsicox.
The function returns the optimal number of components and the optimal sparsity penalty value based
on cross-validation. The performance could be based on multiple metrics as Area Under the Curve
(AUC), Brier Score or C-Index. Furthermore, the user could establish more than one metric
simultaneously.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.sb.splsicox(
  X,
  Y,
  max.ncomp = 8,
  penalty.list = seq(0.1, 0.9, 0.2),
  n_run = 3,
  k_folds = 10,
  x.center = TRUE,
  x.scale = FALSE,
  remove_near_zero_variance = TRUE,
  remove_zero_variance = TRUE,
  toKeep.zv = NULL,
  remove_variance_at_fold_level = FALSE,
  remove_non_significant_models = FALSE,
  remove_non_significant = FALSE,
  alpha = 0.05,
  w_AIC = 0,
  w_c.index = 0,
  w_AUC = 1,
  w_BRIER = 0,
  times = NULL,
  max_time_points = 15,
  MIN_AUC_INCREASE = 0.01,
  MIN_AUC = 0.8,
  MIN_COMP_TO_CHECK = 3,
  pred.attr = "mean",
  pred.method = "cenROC",
  fast_mode = FALSE,
  MIN_EPV = 5,
  return_models = FALSE,
  returnData = FALSE,
  PARALLEL = FALSE,
  verbose = FALSE,
  seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix or data.frame. Explanatory variables. Qualitative variables must be
transform into binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric matrix or data.frame. Response variables. Object must have two columns named as
"time" and "event". For event column, accepted values are: 0/1 or FALSE/TRUE for censored and
event observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.ncomp</code></td>
<td>
<p>Numeric. Maximum number of PLS components to compute for the cross validation
(default: 8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.list</code></td>
<td>
<p>Numeric vector. Penalty for variable selection for the individual cox
models. Variables with a lower P-Value than 1 - "penalty" in the individual cox analysis will
be keep for the sPLS-ICOX approach (default: seq(0.1,0.9,0.2)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_run</code></td>
<td>
<p>Numeric. Number of runs for cross validation (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_folds</code></td>
<td>
<p>Numeric. Number of folds for cross validation (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.center</code></td>
<td>
<p>Logical. If x.center = TRUE, X matrix is centered to zero means (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.scale</code></td>
<td>
<p>Logical. If x.scale = TRUE, X matrix is scaled to unit variances (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_near_zero_variance</code></td>
<td>
<p>Logical. If remove_near_zero_variance = TRUE, near zero variance
variables will be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_zero_variance</code></td>
<td>
<p>Logical. If remove_zero_variance = TRUE, zero variance variables will
be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toKeep.zv</code></td>
<td>
<p>Character vector. Name of variables in X to not be deleted by (near) zero variance
filtering (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_variance_at_fold_level</code></td>
<td>
<p>Logical. If remove_variance_at_fold_level = TRUE, (near) zero
variance will be removed at fold level (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant_models</code></td>
<td>
<p>Logical. If remove_non_significant_models = TRUE,
non-significant models are removed before computing the evaluation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant</code></td>
<td>
<p>Logical. If remove_non_significant = TRUE, non-significant
variables/components in final cox model will be removed until all variables are significant by
forward selection (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Numerical values are regarded as significant if they fall below the
threshold (default: 0.05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_AIC</code></td>
<td>
<p>Numeric. Weight for AIC evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_c.index</code></td>
<td>
<p>Numeric. Weight for C-Index evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_AUC</code></td>
<td>
<p>Numeric. Weight for AUC evaluator. All weights must sum 1 (default: 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_BRIER</code></td>
<td>
<p>Numeric. Weight for BRIER SCORE evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of
'max_time_points' points will be selected equally distributed (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time_points</code></td>
<td>
<p>Numeric. Maximum number of time points to use for evaluating the model
(default: 15).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC_INCREASE</code></td>
<td>
<p>Numeric. Minimum improvement between different cross validation models to
continue evaluating higher values in the multiple tested parameters. If it is not reached for next
'MIN_COMP_TO_CHECK' models and the minimum 'MIN_AUC' value is reached, the evaluation stops
(default: 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC</code></td>
<td>
<p>Numeric. Minimum AUC desire to reach cross-validation models. If the minimum is
reached, the evaluation could stop if the improvement does not reach an AUC higher than adding
the 'MIN_AUC_INCREASE' value (default: 0.8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_COMP_TO_CHECK</code></td>
<td>
<p>Numeric. Number of penalties/components to evaluate to check if the AUC
improves. If for the next 'MIN_COMP_TO_CHECK' the AUC is not better and the 'MIN_AUC' is meet,
the evaluation could stop (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.attr</code></td>
<td>
<p>Character. Way to evaluate the metric selected. Must be one of the following:
"mean" or "median" (default: "mean").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.method</code></td>
<td>
<p>Character. AUC evaluation algorithm method for evaluate the model performance.
Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C",
"smoothROCtime_I" (default: "cenROC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast_mode</code></td>
<td>
<p>Logical. If fast_mode = TRUE, for each run, only one fold is evaluated
simultaneously. If fast_mode = FALSE, for each run, all linear predictors are computed for test
observations. Once all have their linear predictors, the evaluation is perform across all the
observations together (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_EPV</code></td>
<td>
<p>Numeric. Minimum number of Events Per Variable (EPV) you want reach for the final
cox model. Used to restrict the number of variables/components can be computed in final cox models.
If the minimum is not meet, the model cannot be computed (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_models</code></td>
<td>
<p>Logical. Return all models computed in cross validation (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnData</code></td>
<td>
<p>Logical. Return original and normalized X and Y matrices (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PARALLEL</code></td>
<td>
<p>Logical. Run the cross validation with multicore option. As many cores as your
total cores - 1 will be used. It could lead to higher RAM consumption (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Number. Seed value for performing runs/folds divisions (default: 123).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>cv.sb.splsicox</code> function performs cross-validation for the single-block sparse partial least
squares individual Cox analysis. While the function can handle datasets with multiple blocks, it
processes each block individually, ensuring a detailed examination of each block's contribution to
the survival outcome. This is distinct from multiblock methods where all blocks are analyzed
simultaneously.
</p>
<p>In the context of this function, "single-block" means that each block of data is analyzed
separately, one at a time. This approach is beneficial when different blocks represent distinct
types or sources of data, allowing for a granular understanding of each block's significance
without the interference of other blocks.
</p>
<p>The cross-validation process involves partitioning the dataset into multiple subsets (folds) and
then iteratively training the model on a subset of the data while validating it on the remaining
data. This helps in determining the optimal hyperparameters for the model, such as the number of
latent components and the penalty for variable selection.
</p>
<p>The function offers flexibility in specifying various hyperparameters and options for data
preprocessing. The output provides a comprehensive overview of the cross-validation results,
including metrics like AIC, C-Index, Brier Score, and AUC for each hyper-parameter combination.
Visualization tools are also provided to aid in understanding the model's performance across
different hyperparameters.
</p>
<p>In summary, the <code>cv.sb.splsicox</code> function offers a robust approach for determining the optimal
parameters for the single-block sparse partial least squares individual Cox analysis, ensuring
optimal feature selection, dimensionality reduction, and predictive modeling for each individual
block in the dataset.
</p>


<h3>Value</h3>

<p>Instance of class "Coxmos" and model "cv.SB.sPLS-ICOX".
<code>best_model_info</code>: A data.frame with the information for the best model.
<code>df_results_folds</code>: A data.frame with fold-level information.
<code>df_results_runs</code>: A data.frame with run-level information.
<code>df_results_comps</code>: A data.frame with component-level information (for cv.coxEN, EN.alpha
information).
</p>
<p><code>lst_models</code>: If return_models = TRUE, return a the list of all cross-validated models.
<code>pred.method</code>: AUC evaluation algorithm method for evaluate the model performance.
</p>
<p><code>opt.comp</code>: Optimal component selected by the best_model.
<code>opt.penalty</code>: Optimal penalty value selected by the best_model.
</p>
<p><code>plot_AIC</code>: AIC plot by each hyper-parameter.
<code>plot_c_index</code>: C-Index plot by each hyper-parameter.
<code>plot_BRIER</code>: Brier Score plot by each hyper-parameter.
<code>plot_AUC</code>: AUC plot by each hyper-parameter.
</p>
<p><code>class</code>: Cross-Validated model class.
</p>
<p><code>lst_train_indexes</code>: List (of lists) of indexes for the observations used in each run/fold
for train the models.
<code>lst_test_indexes</code>: List (of lists) of indexes for the observations used in each run/fold
for test the models.
</p>
<p><code>time</code>: time consumed for running the cross-validated function.
</p>


<h3>Author(s)</h3>

<p>Pedro Salguero Garcia. Maintainer: pedsalga@upv.edu.es
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("X_multiomic")
data("Y_multiomic")
set.seed(123)
index_train &lt;- caret::createDataPartition(Y_multiomic$event, p = .5, list = FALSE, times = 1)
X_train &lt;- X_multiomic
X_train$mirna &lt;- X_train$mirna[index_train,1:50]
X_train$proteomic &lt;- X_train$proteomic[index_train,1:50]
Y_train &lt;- Y_multiomic[index_train,]
cv.sb.splsicox_model &lt;- cv.sb.splsicox(X_train, Y_train, max.ncomp = 2, penalty.list = c(0.5),
n_run = 1, k_folds = 2, x.center = TRUE, x.scale = TRUE)
</code></pre>


</div>