<div class="container">

<table style="width: 100%;"><tr>
<td>conCovOpt_utils</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Build disjunctive normal forms realizing con-cov optima
</h2>

<h3>Description</h3>

<p><code>reprodAssign</code> generates the output values of disjunctive normal forms (DNFs) reaching con-cov optima. <code>DNFbuild</code> builds a DNF realizing a targeted con-cov optimum; it only works for crisp-set and multi-value data (cf. Baumgartner and Ambuehl 2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">reprodAssign(x, outcome = names(x), id = xi$id)
DNFbuild(x, outcome = names(x), reduce = c("ereduce", "rreduce", "none"), 
         id = xi$id, maxCombs = 1e7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>An object produced by <code>selectMax</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>

<p>A character string specifying <em>one</em> outcome value in <code>attr(x, "configTable")</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>An integer vector referring to the identifier of the targeted con-cov optimum or optima.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce</code></td>
<td>

<p>A character string: if <code>"ereduce"</code> or <code>"rreduce"</code>, the canonical DNF realizing the con-cov optimum is freed of redundancies using <code>ereduce</code> or <code>rreduce</code>, respectively; if <code>"none"</code>, the unreduced canonical DNF is returned. <code>reduce=TRUE</code> is interpreted as <code>"rreduce"</code>, <code>reduce=FALSE</code> and <code>reduce=NULL</code> as <code>"none"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxCombs</code></td>
<td>

<p>Passed to <code>ereduce</code> if <code>reduce = "ereduce"</code>; ignored otherwise. (See <code>ereduce</code> for details.)  
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An atomic CNA model (asf) accounts for the behavior of the <code>outcome</code> in terms of a redundancy-free DNF. <code>reprodAssign</code> generates the output values such a DNF has to return in order to reach a con-cov optimum stored in an object of class '<code>selectMax</code>'. If the data stored in <code>attr(x, "configTable")</code> are crisp-set or multi-value, <code>DNFbuild</code> builds the DNFs realizing the targeted con-cov optimum. (For fuzzy-set data an error is returned.) If <code>reduce = "ereduce"</code> (default), <em>all</em> redundancy-free DNFs are built using <code>ereduce</code>; if <code>reduce = "rreduce"</code> (more computationally efficient), <em>one</em> (randomly selected) redundancy-free DNF is built using <code>rreduce</code>; if <code>reduce = "none"</code>, the non-reduced canonical DNF is returned.
The argument <code>id</code> allows for selecting a targeted con-cov optimum via its identifier (see examples below).
</p>


<h3>Value</h3>

<p><code>reprodAssign</code>: A matrix of scores.
<code>DNFbuild</code>: A Boolean formula in disjunctive normal form (DNF).
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2021. “Optimizing Consistency and Coverage in Configurational Causal Modeling.” <em>Sociological Methods &amp; Research</em>.<br> doi:10.1177/0049124121995554. 
</p>


<h3>See Also</h3>

<p><code>conCovOpt</code>, <code>selectMax</code>, <code>condTbl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># CS data, d.educate
cco1 &lt;- conCovOpt(d.educate)
best1 &lt;- selectMax(cco1)
reprodAssign(best1, outcome =  "E")
DNFbuild(best1, outcome =  "E")
DNFbuild(best1, outcome =  "E", reduce = FALSE) # canonical DNF
DNFbuild(best1, outcome =  "E", reduce = "ereduce") # all redundancy-free DNFs
DNFbuild(best1, outcome =  "E", reduce = "rreduce") # one redundancy-free DNF
DNFbuild(best1, outcome =  "E", reduce = "none") # canonical DNF

# Simulated mv data
datMV &lt;- data.frame(
  A = c(3,2,1,1,2,3,2,2,2,1,1,2,3,2,2,2,1,2,3,3,3,1,1,1,3,1,2,1,2,3,3,2,2,2,1,2,2,3,2,1,2,1,3,3),
  B = c(1,2,3,2,1,1,2,1,2,2,3,1,1,1,2,3,1,3,3,3,1,1,3,2,2,1,1,3,3,2,3,1,2,1,2,2,1,1,2,2,3,3,3,3),
  C = c(1,3,3,3,1,1,1,2,2,3,3,1,1,2,2,2,3,1,1,2,1,2,2,3,3,1,2,2,2,3,2,1,1,2,2,2,1,1,1,2,2,1,1,2),
  D = c(3,1,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,1,1,1,1,1,2,2,2,2,2,3,1,1,1,1,1,2,2,2,2,2,3,3,3),
  E = c(3,2,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3)
)

# Apply conCovOpt and selectMax.
(cco2 &lt;- conCovOpt(datMV))
(best2 &lt;- selectMax(cco2))

# Apply DNFbuild to build the redundancy-free DNFs reaching best2.
(formula1 &lt;- DNFbuild(best2, outcome = "D=3"))
# Both DNFs in formula1 reache the con-cov score stored in best2 for outcome "D=3".
condTbl(paste0(formula1, "&lt;-&gt; D=3"), datMV)
# Build only one redundancy-free DNF reaching best2.
DNFbuild(best2, outcome = "D=3", reduce = "rreduce")
# Any factor value in datMV can be treated as outcome.
(formula2 &lt;- DNFbuild(best2, outcome =  "E=3", reduce = "rreduce"))
condTbl(paste0(formula2, "&lt;-&gt; E=3"), datMV)
# Any con-cov optimum in cco2 can be targeted via its identifier.
(formula3 &lt;- DNFbuild(best2, outcome =  "E=3", id = 508))
condTbl(paste0(formula3, "&lt;-&gt; E=3"), datMV)

# Simulated fs data
datFS &lt;- data.frame(
  A = c(.73, .85, .94, .36, .73, .79, .39, .82, .15, .12, .67, .27, .3), 
  B = c(.21, .03, .91, .64, .39, .12, .06, .7,  .73, .15, .88, .73, .36), 
  C = c(.61,  0,  .61,  1,  .94, .15, .88, .27, .12, .12, .27, .15, .15), 
  D = c(.64, .67, .3,  .06, .33, .03, .76, .94, .67, .76, .18, .27, .36), 
  E = c(.91, .94, .67, .85, .73, .79, .24, .09, .03, .21, .33, .36, .27)
)

# Apply conCovOpt and selectMax.
(cco3 &lt;- conCovOpt(datFS, outcome = "E"))
(best3 &lt;- selectMax(cco3))

# Apply reprodAssign.
reprodAssign(best3, outcome = "E")
# Select a con-cov optimum in cco3 via its identifier.
reprodAssign(best3, outcome = "E", id = 252)

# DNFbuild does not work for fs data; it generates an error.
try(DNFbuild(best3, outcome = "E"))
</code></pre>


</div>