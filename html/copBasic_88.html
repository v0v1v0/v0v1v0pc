<div class="container">

<table style="width: 100%;"><tr>
<td>lcomoms2.ABKGcop2parameter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert L-comoments to Parameters of Alpha-Beta-Kappa-Gamma Compositions of Two One-Parameter Copulas</h2>

<h3>Description</h3>

<p><em>EXPERIMENTAL</em>—This function converts the <em>L-comoments</em> of a bivariate sample to the four parameters of a composition of two one-parameter copulas. Critical inputs are of course the first three dimensionless L-comoments: <em>L-correlation</em>, <em>L-coskew</em>, and <em>L-cokurtosis</em>. The most complex input is the <code>solutionenvir</code>, which is an <code>environment</code> containing arbitrarily long, but individual tables, of L-comoment and parameter pairings. These pairings could be computed from the examples in <code>simcompositeCOP</code>.
</p>
<p>The individual tables are prescanned for potentially acceptable solutions and the absolute additive error of both L-comoments for a given order is controlled by the <code>tNeps</code> arguments. The default values seem acceptable. The purpose of the prescanning is to reduce the computation space from perhaps millions of solutions to a few orders of magnitude. The computation of the solution error can be further controlled by <code class="reqn">X</code> or <code class="reqn">u</code> with respect to <code class="reqn">Y</code> or <code class="reqn">v</code> using the <code>comptNerrXY</code> arguments, but experiments thus far indicate that the defaults are likely the most desired. A solution “matching” the L-correlation is always sought; thus there is no <code>uset2err</code> argument. The arguments <code>uset3err</code> and <code>uset4err</code> provide some level of granular control on addition error minimization; the defaults seek to “match” L-coskew and ignore L-cokurtosis. The <code>setreturn</code> controls which rank of computed solution is returned; users might want to manually inspect a few of the most favorable solutions, which can be done by the <code>setreturn</code> or inspection of the returned object from the <code>lcomoms2.ABKGcop2parameter</code> function. The examples are detailed and self-contained to the <span class="pkg">copBasic</span> package; curious users are asked to test these.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lcomoms2.ABKGcop2parameter(solutionenvir=NULL,
                           T2.12=NULL, T2.21=NULL,
                           T3.12=NULL, T3.21=NULL,
                           T4.12=NULL, T4.21=NULL,
                           t2eps=0.1, t3eps=0.1, t4eps=0.1,
                           compt2erruv=TRUE, compt2errvu=TRUE,
                           compt3erruv=TRUE, compt3errvu=TRUE,
                           compt4erruv=TRUE, compt4errvu=TRUE,
                           uset3err=TRUE, uset4err=FALSE,
                           setreturn=1, maxtokeep=1e5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>solutionenvir</code></td>
<td>
<p>The environment containing solutions;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T2.12</code></td>
<td>
<p>L-correlation <code class="reqn">\tau_2^{[12]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T2.21</code></td>
<td>
<p>L-correlation <code class="reqn">\tau_2^{[21]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T3.12</code></td>
<td>
<p>L-coskew <code class="reqn">\tau_3^{[12]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T3.21</code></td>
<td>
<p>L-coskew <code class="reqn">\tau_3^{[21]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T4.12</code></td>
<td>
<p>L-cokurtosis <code class="reqn">\tau_4^{[12]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T4.21</code></td>
<td>
<p>L-cokurtosis <code class="reqn">\tau_4^{[21]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t2eps</code></td>
<td>
<p>An error term in which to pick a potential solution as close enough on preliminary processing for <code class="reqn">\tau_2^{[1 \leftrightarrow 2]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t3eps</code></td>
<td>
<p>An error term in which to pick a potential solution as close enough on preliminary processing for <code class="reqn">\tau_3^{[1 \leftrightarrow 2]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t4eps</code></td>
<td>
<p>An error term in which to pick a potential solution as close enough on preliminary processing for <code class="reqn">\tau_4^{[1 \leftrightarrow 2]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt2erruv</code></td>
<td>
<p>Compute an L-correlation error using the 1 with respect to 2 (or <code class="reqn">u</code> wrt <code class="reqn">v</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt2errvu</code></td>
<td>
<p>Compute an L-correlation error using the 2 with respect to 1 (or <code class="reqn">v</code> wrt <code class="reqn">u</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt3erruv</code></td>
<td>
<p>Compute an L-coskew error using the 1 with respect to 2 (or <code class="reqn">u</code> wrt <code class="reqn">v</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt3errvu</code></td>
<td>
<p>Compute an L-coskew error using the 2 with respect to 1 (or <code class="reqn">v</code> wrt <code class="reqn">u</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt4erruv</code></td>
<td>
<p>Compute an L-cokurtosis error using the 1 with respect to 2 (or <code class="reqn">u</code> wrt <code class="reqn">v</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt4errvu</code></td>
<td>
<p>Compute an L-cokurtosis error using the 2 with respect to 1 (or <code class="reqn">v</code> wrt <code class="reqn">u</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uset3err</code></td>
<td>
<p>Use the L-coskew error in the determination of the solution. The L-correlation error is always used;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uset4err</code></td>
<td>
<p>Use the L-cokurtosis error in the determination of the solution. The L-correlation error is always used;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setreturn</code></td>
<td>
<p>Set (index) number of the solution to return. The default of 1 returns the preferred solutions based on the controls for the minimization; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxtokeep</code></td>
<td>
<p>The value presets the number of rows in the solution matrix. This matrix is filled with potential solutions as the various subfiles of the <code>solutionenvir</code> are scanned. The matrix is trimmed of <code>NA</code>s and error trapping is in place for too small values of <code>maxtokeep</code>. The default value appears appropriate for the feeding of massively large simulated parameter spaces.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> is returned.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Asquith, W.H., 2011, Distributional analysis with L-moment statistics using the R environment for statistical computing: Createspace Independent Publishing Platform, ISBN 978–146350841–8.
</p>
<p>Salvadori, G., De Michele, C., Kottegoda, N.T., and Rosso, R., 2007, Extremes in Nature—An approach using copulas: Springer, 289 p.
</p>


<h3>See Also</h3>

<p><code>simCOP</code>, <code>simcompositeCOP</code>, <code>composite3COP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  mainpara &lt;- list(cop1=PLACKETTcop, cop2=PLACKETTcop,
                   para1gen=function() { return(10^runif(1, min=-5, max=5)) },
                   para2gen=function() { return(10^runif(1, min=-5, max=5)) })
  nsim &lt;- 1E4
  sample.size.for.estimation &lt;- 1000
  PlackettPlackettABKGtest &lt;-
      simcomposite3COP(n=sample.size.for.estimation, nsim=nsim, parent=mainpara)
  save(PlackettPlackettABKGtest,file="PlackettPlackettABKG.RData",compress="xz")

# Plackett-Plackett composited copula from the copBasic package
# Then create an environment to house the "table".
PlackettPlackettABKG &lt;- new.env()
assign("NeedToCreateForDemo", PlackettPlackettABKGtest, envir=PlackettPlackettABKG)

# Now that the table is assigned into the environment, the parameter estimation
# function can be used. In reality a much much larger solution set is needed.
# Assume one had the following six L-comoments, extract a possible solution.
PPcop &lt;- lcomoms2.ABKGcop2parameter(solutionenvir=PlackettPlackettABKG,
                                    T2.12=-0.5059, T2.21=-0.5110,
                                    T3.12= 0.1500, T3.21= 0.1700,
                                    T4.12=-0.0500, T4.21= 0.0329,
                                    uset3err=TRUE, uset4err=TRUE)
# Now take that solution and setup a parameter object.
para &lt;- list(cop1=PLACKETTcop, cop2=PLACKETTcop,
             alpha=PPcop$alpha, beta=PPcop$beta, kappa=PPcop$kappa, gamma=PPcop$gamma,
             para1=PPcop$Cop1Thetas, para2=PPcop$Cop2Thetas)

# Example Plot Number 1
D &lt;- simCOP(n=2000, cop=composite3COP,  para=para, col=rgb(0,0,0,0.1), pch=16)
print(lmomco::lcomoms2(D, nmom=4)) # See the six extacted sample values for this seed.
T2.12 &lt;- -0.4877171; T2.21 &lt;- -0.4907403
T3.12 &lt;-  0.1642508; T3.21 &lt;-  0.1715944
T4.12 &lt;- -0.0560310; T4.21 &lt;- -0.0350028
PPcop &lt;- lcomoms2.ABKGcop2parameter(solutionenvir=PlackettPlackettABKG,
                                    T2.12=T2.12, T2.21=T2.21,
                                    T3.12=T3.12, T3.21=T3.21,
                                    T4.12=T4.12, T4.21=T4.21, uset4err=TRUE)
para &lt;- list(cop1=PLACKETTcop, cop2=PLACKETTcop,
             alpha=PPcop$alpha, beta=PPcop$beta, kappa=PPcop$kappa, gamma=PPcop$gamma,
             para1=PPcop$Cop1Thetas, para2=PPcop$Cop2Thetas)

# Example Plot Number 2
D &lt;- simCOP(n=1000, cop=composite3COP, para=para, col=rgb(0,0,0,0.1), pch=16)
level.curvesCOP(cop=composite3COP, para=para, delt=0.1, ploton=FALSE)
qua.regressCOP.draw(cop=composite3COP, para=para,
                    ploton=FALSE, f=c(seq(0.05, 0.95, by=0.05)))
qua.regressCOP.draw(cop=composite3COP, para=para, wrtV=TRUE,
                    ploton=FALSE, f=c(seq(0.05, 0.95, by=0.05)), col=c(3,2))
diag &lt;- diagCOP(cop=composite3COP, para=para, ploton=FALSE, lwd=4)
# Compare plots 1 and 2, some generalized consistency between the two is evident.
# One can inspect alternative solutions like this
# S &lt;- PPcop$solutions$solutions[,1:18]
# B &lt;- S[abs(S$t2.12res) &lt; 0.02 &amp; abs(S$t2.21res) &lt; 0.02 &amp;
#        abs(S$t3.12res) &lt; 0.02 &amp; abs(S$t3.21res) &lt; 0.02, ]
#print(B)
## End(Not run)
</code></pre>


</div>