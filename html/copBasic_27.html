<div class="container">

<table style="width: 100%;"><tr>
<td>densityCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Density of a Copula</h2>

<h3>Description</h3>

<p>Numerically estimate the <em>copula density</em> for a sequence of <code class="reqn">u</code> and <code class="reqn">v</code> probabilities for which each sequence has equal steps that are equal to <code class="reqn">\Delta(uv)</code>. The density <code class="reqn">c(u,v)</code> of a copula <code class="reqn">\mathbf{C}(u,v)</code> is numerically estimated by
</p>
<p style="text-align: center;"><code class="reqn">c(u,v) = \bigl[\mathbf{C}(u_2,v_2) - \mathbf{C}(u_2,v_1) - \mathbf{C}(u_1,v_2) + \mathbf{C}(u_1,v_1)\bigr]\, /\, \bigl[\Delta(uv)\times\Delta(uv)\bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">c(u,v) \ge 0</code> (see Nelsen, 2006, p. 10; <code>densityCOPplot</code>). The <em>joint density</em> can be defined by the coupla density for continuous variables and is the ratio of the joint density funcion <code class="reqn">f(x,y)</code> for random variables <code class="reqn">X</code> and <code class="reqn">Y</code> to the product of the marginal densities (<code class="reqn">f_x(x)</code> and <code class="reqn">f_y(y)</code>):
</p>
<p style="text-align: center;"><code class="reqn">c\bigl(F_x(x), F_y(y)\bigr) = \frac{f(x,y)}{f_x(x)f_y(y)}\mbox{,}</code>
</p>

<p>where <code class="reqn">F_x(x)</code> and  <code class="reqn">F_y(y)</code> are the respective cumulative distribution functions of <code class="reqn">X</code> and <code class="reqn">Y</code>, and lastly <code class="reqn">u = F_x(x)</code> and <code class="reqn">v = F_y(y)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">densityCOP(u,v, cop=NULL, para=NULL, deluv=.Machine$double.eps^0.25,
                truncate.at.zero=TRUE, the.zero=0, sumlogs=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deluv</code></td>
<td>
<p>The change in the sequences <code class="reqn">\{u, v\} \mapsto \delta, \ldots, 1-\delta; \delta = \Delta(uv)</code> probabilities;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truncate.at.zero</code></td>
<td>
<p>A density must be <code class="reqn">c(u,v) \ge 0</code>, but because this computation is based on a rectangular approximation and not analytical, there exists a possibility that very small rectangles could result in numerical values in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> that are less than zero. This usually can be blamed on rounding. This logical if <code>TRUE</code> truncates computed densities to zero, and the default assumes that the user is providing a proper copula. A <code>FALSE</code> value is used by the function <code>isfuncCOP</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>the.zero</code></td>
<td>
<p>The value for “the zero” where a small number might be useful for pseudo-maximum likelihood estimation using <code>sumlogs</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumlogs</code></td>
<td>
<p>Return the <code class="reqn">\sum{\log c(u,v; \Theta)}</code> where <code class="reqn">\Theta</code> are the parameters in <code>para</code> and this feature is provided for <code>mleCOP</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copula function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for <code class="reqn">c(u,v)</code> are returned.
</p>


<h3>Note</h3>

<p>The <span class="pkg">copBasic</span> package does not currently have copula densities as analytical solutions implemented. This is because initial design decisions were entirely on cumulative distribution function (CDF) representations of the copula.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>simCOP</code>, <code>densityCOPplot</code>, <code>kullCOP</code>, <code>mleCOP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Joe (2014, p. 164) shows the closed form copula density for the Plackett.
"dPLACKETTcop" &lt;- function(u,v,para) {
   uv &lt;- u*v; upv &lt;- u + v; eta &lt;- para - 1
   A &lt;- para*(1+eta*(upv - 2*uv)); B &lt;- ((1+eta*upv)^2 - 4*para*eta*uv)^(3/2)
   return(A/B)
}
dPLACKETTcop(0.32, 0.74,            para=1.3) # 0.9557124
densityCOP(  0.32, 0.74, cop=PLcop, para=1.3) # 0.9557153
## End(Not run)

## Not run: 
# Joe (2014, p. 165) shows the corner densities of the Plackett as Theta.
# copBasic uses numerical density estimation and not analytical formula.
eps &lt;- .Machine$double.eps
densityCOP(0,0, cop=PLcop, para=4) # 3.997073  (default eps^0.25)
densityCOP(1,1, cop=PLcop, para=4) # 3.997073  (default eps^0.25)
densityCOP(1,1, cop=PLcop, para=4, deluv=eps)     # 0 (silent failure)
densityCOP(1,1, cop=PLcop, para=4, deluv=eps^0.5) # 4.5
densityCOP(1,1, cop=PLcop, para=4, deluv=eps^0.4) # 4.002069
densityCOP(1,1, cop=PLcop, para=4, deluv=eps^0.3) # 3.999513
# So, we see that the small slicing does have an effect, the default of 0.25 is
# intented for general application by being away enough from machine limits.
## End(Not run)

## Not run: 
# Joe (2014, p. 170) shows the closed form copula density for "Bivariate Joe/B5" copula
"dJOEB5cop" &lt;- function(u, v, para) {
   up &lt;- (1-u)^para; vp &lt;- (1-v)^para; eta &lt;- para - 1
   A &lt;- (up + vp - up*vp); B &lt;- (1-u)^eta * (1-v)^eta; C &lt;- (eta + A)
   return(A^(-2 + 1/para) * B * C)
}
densityCOP(0.32, 0.74, cop=JOcopB5, para=1.3)  # 0.9410653
dJOEB5cop( 0.32, 0.74, para=1.3)               # 0.9410973 
## End(Not run)
</code></pre>


</div>