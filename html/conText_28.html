<div class="container">

<table style="width: 100%;"><tr>
<td>get_context</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get context words (words within a symmetric window around the target word/phrase)
sorrounding a user defined target.</h2>

<h3>Description</h3>

<p>A wrapper function for quanteda's <code>kwic()</code> function that subsets documents to where
target is present before tokenizing to speed up processing, and concatenates
kwic's pre/post variables into a <code>context</code> column.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_context(
  x,
  target,
  window = 6L,
  valuetype = "fixed",
  case_insensitive = TRUE,
  hard_cut = FALSE,
  what = "word",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(character) vector - this is the set of documents (corpus) of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>(character) vector - these are the target words whose contexts we want to evaluate
This vector may include a single token, a phrase or multiple tokens and/or phrases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>(numeric) - defines the size of a context (words around the target).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valuetype</code></td>
<td>
<p>the type of pattern matching: <code>"glob"</code> for "glob"-style
wildcard expressions; <code>"regex"</code> for regular expressions; or <code>"fixed"</code> for
exact matching. See valuetype for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case_insensitive</code></td>
<td>
<p>logical; if <code>TRUE</code>, ignore case when matching a
<code>pattern</code> or dictionary values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hard_cut</code></td>
<td>
<p>(logical) - if TRUE then a context must have <code>window</code> x 2 tokens,
if FALSE it can have <code>window</code> x 2 or fewer (e.g. if a doc begins with a target word,
then context will have <code>window</code> tokens rather than <code>window</code> x 2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>(character) defines which quanteda tokenizer to use. You will rarely want to change this.
For chinese text you may want to set <code>what = 'fastestword'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>(logical) - if TRUE, report the total number of target instances found.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>data.frame</code> with the following columns:
</p>

<dl>
<dt><code>docname</code></dt>
<dd>
<p> (character) document name to which instances belong to.</p>
</dd>
<dt><code>target</code></dt>
<dd>
<p>(character) targets.</p>
</dd>
<dt><code>context</code></dt>
<dd>
<p>(numeric) pre/post variables in <code>kwic()</code> output concatenated.</p>
</dd>
</dl>
<h3>Note</h3>

<p><code>target</code> in the return data.frame is equivalent to <code>kwic()</code>'s <code>keyword</code> output variable,
so it may not match the user-defined target exactly if <code>valuetype</code> is not fixed.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># get context words sorrounding the term immigration
context_immigration &lt;- get_context(x = cr_sample_corpus, target = 'immigration',
                                   window = 6, valuetype = "fixed", case_insensitive = FALSE,
                                   hard_cut = FALSE, verbose = FALSE)
</code></pre>


</div>