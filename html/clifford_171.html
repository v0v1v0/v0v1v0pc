<div class="container">

<table style="width: 100%;"><tr>
<td>involution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clifford involutions</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>An <dfn>involution</dfn> is a function that is its own inverse, or
equivalently \(f(f(x))=x\).  There are several important
involutions on Clifford objects; these commute past the grade operator
with \(f(\left\langle A\right\rangle_r)=\left\langle
  f(A)\right\rangle_r\) and are linear: \(f(\alpha A+\beta
  B)=\alpha f(A)+\beta f(B)\).
</p>
<p>The <dfn>dual</dfn> is documented here for convenience, even though it is
not an involution (applying the dual <em>four</em> times is the
identity).
</p>

<ul>
<li>
<p> The <dfn>reverse</dfn> \(A^\sim\) is given by
<code>rev()</code> (both Perwass and Dorst use a tilde, as in
\(\tilde{A}\) or \(A^\sim\).  However, both
Hestenes and Chisholm use a dagger, as in
\(A^\dagger\).  This page uses Perwass's notation).
The <dfn>reverse</dfn> of a term written as a product of basis vectors is
simply the product of the same basis vectors but written in reverse
order.  This changes the sign of the term if the number of basis
vectors is 2 or 3 (modulo 4).  Thus, for example,
\(\left(e_1e_2e_3\right)^\sim=e_3e_2e_1=-e_1e_2e_3\)
and
\(\left(e_1e_2e_3e_4\right)^\sim=e_4e_3e_2e_1=+e_1e_2e_3e_4\).
Formally, if \(X=e_{i_1}\ldots e_{i_k}\), then
\(\tilde{X}=e_{i_k}\ldots e_{i_1}\).
</p>
\[\left\langle
      A^\sim\right\rangle_r=\widetilde{\left\langle
	A\right\rangle_r}=(-1)^{r(r-1)/2}\left\langle A\right\rangle_r
    \]
<p>Perwass shows that \(\left\langle
      AB\right\rangle_r=(-1)^{r(r-1)/2}\left\langle\tilde{B}\tilde{A}\right\rangle_r
      \).
</p>
</li>
<li>
<p> The <dfn>Conjugate</dfn> \(A^\dagger\) is given by
<code>Conj()</code> (we use Perwass's notation, def 2.9 p59).  This
depends on the signature of the Clifford algebra; see
<code>grade.Rd</code> for notation.  Given a basis blade
\(e_\mathbb{A}\) with \(\mathbb{A}\subseteq\left\lbrace
    1,\ldots,p+q\right\rbrace\), then we have \(e_\mathbb{A}^\dagger = (-1)^m
    {e_\mathbb{A}}^\sim\), where \(m=\mathrm{gr}_{-}(\mathbb{A})\).  Alternatively, we
might say \[\left(\left\langle
    A\right\rangle_r\right)^\dagger=(-1)^m(-1)^{r(r-1)/2}\left\langle
    A\right\rangle_r \] where
\(m=\mathrm{gr}_{-}(\left\langle A\right\rangle_r)\)
[NB I have changed Perwass's notation].
</p>
</li>
<li>
<p> The <dfn>main (grade) involution</dfn> or <dfn>grade involution</dfn>
\(\widehat{A}\) is given by <code>gradeinv()</code>.  This
changes the sign of any term with odd grade: \[
    \widehat{\left\langle A\right\rangle_r} =(-1)^r\left\langle
    A\right\rangle_r\] (I don't see this in Perwass or Hestenes;
notation follows Hitzer and Sangwine).  It is a special case of
grade negation.
</p>
</li>
<li>
<p> The <dfn>grade <i>r</i>-negation</dfn>
\(A_{\overline{r}}\) is given by <code>neg()</code>.  This
changes the sign of the grade <i>r</i> component of <i>A</i>.  It is
formally defined as \(A-2\left\langle
    A\right\rangle_r\) but function <code>neg()</code> uses a more
efficient method.  It is possible to negate all terms with specified
grades, so for example we might have \(\left\langle
    A\right\rangle_{\overline{\left\lbrace 1,2,5\right\rbrace}} =
    A-2\left( \left\langle A\right\rangle_1 +\left\langle
    A\right\rangle_2+\left\langle A\right\rangle_5\right)\) and
the R idiom would be <code>neg(A,c(1,2,5))</code>.  Note that Hestenes
uses “\(A_{\overline{r}}\)” to mean the same as
\(\left\langle A\right\rangle_r\).
</p>
</li>
<li>
<p> The <dfn>Clifford conjugate</dfn> \(\overline{A}\) is
given by <code>cliffconj()</code>.  It is distinct from conjugation
\(A^\dagger\), and is defined in Hitzer and Sangwine as
</p>
\[\overline{\left\langle A\right\rangle_r} =
      (-1)^{r(r+1)/2}\left\langle A\right\rangle_r.\]
</li>
<li>
<p> The <dfn>dual</dfn> \(C^*\) of a clifford object \(C\) is
given by <code>dual(C,n)</code>; argument <code>n</code> is the dimension of the
underlying vector space.  Perwass gives
\[C^*=CI^{-1}\]
</p>
<p>where \(I=e_1e_2\ldots e_n\) is the unit pseudoscalar
[note that Hestenes uses \(I\) to mean something different].
The dual is sensitive to the signature of the Clifford algebra
<em>and</em> the dimension of the underlying vector space.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'clifford'
rev(x)
## S3 method for class 'clifford'
Conj(z)
cliffconj(z)
neg(C,n)
gradeinv(C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>C,x,z</code></td>
<td>
<p>Clifford object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer vector specifying grades to be negated in <code>neg()</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code>grade</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- rcliff()
x
rev(x)


A &lt;- rblade(g=3)
B &lt;- rblade(g=4)
rev(A %^% B) == rev(B) %^% rev(A)  # should be TRUE
rev(A * B) == rev(B) * rev(A)          # should be TRUE

a &lt;- rcliff()
dual(dual(dual(dual(a,8),8),8),8) == a # should be TRUE

</code></pre>


</div>