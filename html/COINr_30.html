<div class="container">

<table style="width: 100%;"><tr>
<td>Custom.purse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Custom operation</h2>

<h3>Description</h3>

<p>Custom operation on a purse. This is an experimental new feature.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'purse'
Custom(
  x,
  dset,
  f_cust,
  f_cust_para = NULL,
  global = FALSE,
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A purse object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dset</code></td>
<td>
<p>The data set to apply the operation to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_cust</code></td>
<td>
<p>Function to apply to the data set. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_cust_para</code></td>
<td>
<p>Optional additional parameters to pass to the function defined
by <code>f_cust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>global</code></td>
<td>
<p>Logical: if <code>TRUE</code>, the entire data set, over all time points, is passed
to the function <code>f_cust</code>. This is useful if the custom operation should be different for
different time points, for example. Otherwise if <code>FALSE</code>, passes the data set within each
coin one at a time to <code>f_cust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to</code></td>
<td>
<p>Name of data set to write to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to pass to/from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In this function, the data set named <code>dset</code> is extracted from the coin using
<code>get_dset(purse, dset)</code>. It is passed to the function <code>f_cust</code>, which is required
to return an equivalent but modified data frame, which is then written as a new
data set with name <code>write_to</code>. This is intended to allow arbitrary operations
on coin data sets while staying within the COINr framework, which means that if
<code>Regen()</code> is used, these operations will be re-run, allowing them to be included
in things like sensitivity analysis.
</p>
<p>The format of <code>f_cust</code> is important. It must be a function whose first argument
is called <code>x</code>: this will be the argument that the data is passed to. The data will
be in the same format as extracted via <code>get_dset(purse, dset)</code>, which means it will
have <code>uCode</code> and <code>Time</code> columns. <code>f_cust</code> can have other arguments which are passed
to it via <code>f_cust_para</code>. The function should return a data frame similar to the data
that was passed to it, it must contain have the same column names (meaning you can't
remove indicators), but otherwise is flexible - this means some caution is necessary
to ensure that subsequent operations don't fail. Be careful, for example, to ensure
that there are no duplicates in <code>uCode</code>, and that indicator columns are numeric.
</p>
<p>The function assigned to <code>f_cust</code> is passed to <code>base::do.call()</code>, therefore it can
be passed either as a string naming the function, or as the function itself. Depending
on the context, the latter option may be preferable because this stores the function
within the coin, which makes it portable. Otherwise, if the function is simply
named as a string, you must make sure it is available to access in the environment.
</p>


<h3>Value</h3>

<p>An updated purse.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># build example purse
purse &lt;- build_example_purse(up_to = "new_coin")

# custom function - set points before 2020 to NA for BEL in FDI due to a
# break in the series
f_cust &lt;- function(x){x[(x$uCode == "BEL") &amp; (x$Time &lt; 2020), "FDI"] &lt;- NA;
                      return(x)}



</code></pre>


</div>