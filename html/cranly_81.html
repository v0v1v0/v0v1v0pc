<div class="container">

<table style="width: 100%;"><tr>
<td>word_cloud.cranly_network</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>wordcloud of author names, package descriptions, and package titles</h2>

<h3>Description</h3>

<p>wordcloud of author names, package descriptions, and package titles
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cranly_network'
word_cloud(
  x,
  package = Inf,
  author = Inf,
  maintainer = Inf,
  base = TRUE,
  recommended = TRUE,
  exact = TRUE,
  perspective = "description",
  random_order = FALSE,
  ignore_words = c("www.jstor.org", "www.arxiv.org", "arxiv.org", "provides", "https"),
  stem = FALSE,
  colors = rev(colorspace::heat_hcl(10)),
  ...
)

## S3 method for class 'numeric'
word_cloud(
  x,
  random_order = FALSE,
  colors = rev(colorspace::heat_hcl(10)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>either a  <code>cranly_network</code> object or a named vector of term frequencies (typically the output of <code>compute_term_frequency()</code> with <code>frequency = "term"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>package</code></td>
<td>
<p>a vector of character strings with the package names to be matched. Default is <code>Inf</code> which returns all available packages in <code>x</code> for further subsetting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>author</code></td>
<td>
<p>a vector of character strings with the author names to be matched. Default is <code>Inf</code> which returns all available author in <code>x</code> for further subsetting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maintainer</code></td>
<td>
<p>a vector of character strings with the maintainer names to be matched. Default is <code>Inf</code> which returns all available maintainers in <code>x</code> for further subsetting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>logical. Should we include base packages in the subset? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recommended</code></td>
<td>
<p>logical. Should we include recommended packages in the subset? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>logical. Should we use exact matching? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perspective</code></td>
<td>
<p>should the wordcloud be that of package descriptions (<code>perspective = "description"</code>; default), of package titles (<code>perspective = "title"</code>) or of author names (<code>perspective = "author"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random_order</code></td>
<td>
<p>should words be plotted in random order? If <code>FALSE</code> (default) words are plotted in decreasing frequency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_words</code></td>
<td>
<p>a vector of words to be ignored when forming the corpus.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stem</code></td>
<td>
<p>should words be stemmed using Porter's stemming algorithm? Default is <code>FALSE</code>. See <code>tm::stemDocument()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colors</code></td>
<td>
<p>color words from least to most frequent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments to be passed to wordcloud::wordcloud (except <code>random.order</code> which is already defined through <code>random_order</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When applied to <code>cranly_network</code> objects, <code>word_cloud()</code> subsets
either according to <code>author</code> (using the intersection of the result
of <code>author_of()</code> and <code>author_with()</code>) or according to package
(using the intersection of the results of <code>package_with()</code> and
<code>package_by()</code>).
</p>
<p>For handling more complex queries, one can manually extract the #'
term frequencies from a supplied vector of character strings (see
<code>compute_term_frequency()</code>), and use <code>word_cloud()</code> on them. See the
examples.
</p>


<h3>Value</h3>

<p>A word cloud.
</p>


<h3>See Also</h3>

<p><code>compute_term_frequency()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Package directives network
cran_db &lt;- clean_CRAN_db()
package_network &lt;- build_network(cran_db)
## Descriptions of all packages in tidyverse
tidyverse &lt;- imported_by(package_network, "tidyverse", exact = TRUE)
set.seed(123)
word_cloud(package_network, package = tidyverse, exact = TRUE, min.freq = 2)

## or by manually creating the term frequencies from descriptions
descriptions &lt;- descriptions_of(package_network, tidyverse, exact = TRUE)
term_freq &lt;- compute_term_frequency(descriptions)
set.seed(123)
word_cloud(term_freq, min.freq = 2)


</code></pre>


</div>