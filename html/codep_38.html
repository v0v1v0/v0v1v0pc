<div class="container">

<table style="width: 100%;"><tr>
<td>MCA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple-descriptors, Multiscale Codependence Analysis</h2>

<h3>Description</h3>

<p>Class, Functions, and methods to perform Multiscale Codependence Analysis
(MCA)
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCA(Y, X, emobj)

test.cdp(object, alpha = 0.05, max.step, response.tests = TRUE)

permute.cdp(object, permute, alpha = 0.05, max.step, response.tests = TRUE)

parPermute.cdp(
  object,
  permute,
  alpha = 0.05,
  max.step,
  response.tests = TRUE,
  nnode,
  seeds,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A numeric matrix or vector containing the response variable(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or vector containing the explanatory variable(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emobj</code></td>
<td>
<p>A eigenmap-class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A cdp-class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The type I (alpha) error threshold used by the
testing procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.step</code></td>
<td>
<p>The maximum number of steps to perform when testing for
statistical significance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response.tests</code></td>
<td>
<p>A boolean specifying whether to test individual
response variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permute</code></td>
<td>
<p>The number of random permutations used for testing. When
omitted, the number of permutations is calculated using function
<code>minpermute</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnode</code></td>
<td>
<p>The number of parallel computation nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>Seeds for computation nodes' random number generators when using
parallel computation during the permutation test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to return user notifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Parameters to be passed to function <code>parallel::makeCluster</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Multiscale Codependence Analysis (MCA) allows to calculate
correlation-like (i.e.codependence) coefficients between two variables with
respect to structuring variables (Moran's eigenvector maps). The purpose of
this function is limited to parameter fitting.
</p>
<p>Test procedures are handled through <code>test.cdp</code> (parametric testing) or
<code>permute.cdp</code> (permutation testing). Moreover, methods are provided for
printing (<code>print.cdp</code>), displaying a summary of the tests
(<code>summary.cdp</code>), plotting results (<code>plot.cdp</code>), calculating
fitted (<code>fitted.cdp</code>) and residuals values (<code>redisuals.cdp</code>), and
making predictions (<code>predict.cdp</code>).
</p>
<p>It is noteworthy that the test procedure used by <code>MCA</code> deviates from the
standard R workflow since intermediate testing functions (<code>test.cdp</code> and
<code>permute.cdp</code>) need first to be called before any testing be performed.
</p>
<p>Function <code>parPermute.cdp</code> allows the user to spread the number of
permutation on many computation nodes. It relies on package parallel.
Omitting argument <code>nnode</code> lets function <code>parallel::detectCores</code>
specify the number of node. Similarly, omitting parameter <code>seeds</code> lets
the function define the seeds as a set of values drawn from a uniform random
distribution between with minimum value <code>-.Machine$integer.max</code> and
maximum value <code>.Machine$integer.max</code>.
</p>


<h3>Value</h3>

<p>A cdp-class object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>MCA()</code>: Main function to compute the multiscale codependence analysis
</p>
</li>
<li> <p><code>test.cdp()</code>: Parametric statistical testing for multiscale codependence analysis
</p>
</li>
<li> <p><code>permute.cdp()</code>: Permutation testing for multiscale codependence analysis.
</p>
</li>
<li> <p><code>parPermute.cdp()</code>: Permutation testing for multiscale codependence analysis using parallel
processing.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to multiscale
codependence analysis: Assessing the drivers of community structure across
spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example 1: St. Marguerite River Salmon Transect
data(salmon)

## Converting the data from data frames to to matrices:
Abundance &lt;- log1p(as.matrix(salmon[,"Abundance",drop = FALSE]))
Environ &lt;- as.matrix(salmon[,3L:5])

## Creating a spatial eigenvector map:
map1 &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.binary,
                 boundaries = c(0,20))

## Case of a single descriptor:
mca1 &lt;- MCA(Y = Abundance, X = Environ[,"Substrate",drop = FALSE],
            emobj = map1)
mca1
mca1_partest &lt;- test.cdp(mca1)
mca1_partest
summary(mca1_partest)
par(mar = c(6,4,2,4))
plot(mca1_partest, las = 3, lwd=2)
mca1_pertest &lt;- permute.cdp(mca1)
## Not run: 
## or:
mca1_pertest &lt;- parPermute.cdp(mca1, permute = 999999)

## End(Not run)
mca1_pertest
summary(mca1_pertest)
plot(mca1_pertest, las = 3)
mca1_pertest$UpYXcb$C # Array containing the codependence coefficients

## With all descriptors at once:
mca2 &lt;- MCA(Y = log1p(as.matrix(salmon[,"Abundance",drop = FALSE])),
            X = as.matrix(salmon[,3L:5]), emobj = map1)
mca2
mca2_partest &lt;- test.cdp(mca2)
mca2_partest
summary(mca2_partest)
par(mar = c(6,4,2,4))
plot(mca2_partest, las = 3, lwd=2)
mca2_pertest &lt;- permute.cdp(mca2)
## Not run: 
## or:
    mca2_pertest &lt;- parPermute.cdp(mca2, permute = 999999)

## End(Not run)
mca2_pertest
summary(mca2_pertest)
plot(mca2_pertest, las = 3, lwd=2)
mca2_pertest$UpYXcb$C # Array containing the codependence coefficients
mca2_pertest$UpYXcb$C[,1L,] # now turned into a matrix.

### Example 2: Doubs Fish Community Transect

data(Doubs)

## Sites with no fish observed are excluded:
excl &lt;- which(rowSums(Doubs.fish) == 0)

## Creating a spatial eigenvector map:
map2 &lt;- eigenmap(x = Doubs.geo[-excl,"DFS"])
## The eigenvalues are in map2$lambda, the MEM eigenvectors in matrix map2$U

## MCA with multivariate response data analyzed on the basis of the Hellinger
## distance:
Y &lt;- LGTransforms(Doubs.fish[-excl,],"Hellinger")

mca3 &lt;- MCA(Y = Y, X=Doubs.env[-excl,], emobj = map2)
mca3_pertest &lt;- permute.cdp(mca3)
## Not run: 
## or:
mca3_pertest &lt;- parPermute.cdp(mca3, permute = 999999)

## End(Not run)

mca3_pertest
summary(mca3_pertest)
par(mar = c(6,4,2,4))
plot(mca3_pertest, las = 2, lwd=2)

## Array containing all the codependence coefficients:
mca3_pertest$UpYXcb$C

## Display the results along the transect
spmeans &lt;- colMeans(Y)
pca1 &lt;- svd(Y - rep(spmeans, each=nrow(Y)))
par(mar = c(5,5,2,5) + 0.1)
plot(y = pca1$u[,1L], x = Doubs.geo[-excl,"DFS"], pch = 21L, bg = "red",
     ylab = "PCA1 loadings", xlab = "Distance from river source (km)")

## A regular transect of sites from 0 to 450 (km) spaced by 1 km intervals
## (451 sites in total). It is used for plotting spatially-explicit
## predictions.

x &lt;- seq(0,450,1)
newdists &lt;- matrix(NA, length(x), nrow(Doubs.geo[-excl,]))
for(i in 1L:nrow(newdists))
  newdists[i,] &lt;- abs(Doubs.geo[-excl,"DFS"] - x[i])

## Calculating predictions for the regular transect under the same set of
## environmental conditions from which the codependence model was built.
prd1 &lt;- predict(mca3_pertest,
                newdata = list(target = eigenmap.score(map2, newdists)))

## Projection of the predicted species abundance on pca1:
Uprd1 &lt;-
  (prd1 - rep(spmeans, each = nrow(prd1))) %*%
  pca1$v %*% diag(pca1$d^-1)
lines(y = Uprd1[,1L], x = x, col=2, lty = 1)

## Projection of the predicted species abundance on pca2:
plot(y = pca1$u[,2L], x = Doubs.geo[-excl,"DFS"], pch = 21L, bg = "red",
     ylab = "PCA2 loadings", xlab = "Distance from river source (km)")
lines(y = Uprd1[,2L], x = x, col = 2, lty = 1)

## Displaying only the observed and predicted abundance for Brown Trout.
par(new = TRUE)
plot(y = Y[,"TRU"], Doubs.geo[-excl,"DFS"], pch = 21L,
     bg = "green", ylab = "", xlab = "", new = FALSE, axes = FALSE)
axis(4)
lines(y = prd1[,"TRU"], x = x, col = 3)
mtext(side = 4, "sqrt(Brown trout rel. abundance)", line = 2.5)

### Example 3: Borcard et al. Oribatid Mite

## Testing the (2-dimensional) spatial codependence between the Oribatid Mite
## community structure and environmental variables, while displaying the
## total effects of the significant variables on the community structure
## (i.e., its first principal component).

data(mite)

map3 &lt;- eigenmap(x = mite.geo)

Y &lt;- LGTransforms(mite.species, "Hellinger")

## Organize the environmental variables
mca4 &lt;- MCA(Y = Y, X = mite.env, emobj = map3)
mca4_partest &lt;- test.cdp(mca4, response.tests = FALSE)
summary(mca4_partest)
plot(mca4_partest, las = 2, lwd = 2)
plot(mca4_partest, col = rainbow(1200)[1L:1000], las = 3, lwd = 4,
     main = "Codependence diagram", col.signif = "white")

## Making a regular point grid for plotting the spatially-explicit
## predictions:
rng &lt;- list(
  x = seq(min(mite.geo[,"x"]) - 0.1, max(mite.geo[,"x"]) + 0.1, 0.05),
  y = seq(min(mite.geo[,"y"]) - 0.1, max(mite.geo[,"y"]) + 0.1, 0.05))
grid &lt;- cbind(x = rep(rng[["x"]], length(rng[["y"]])),
              y = rep(rng[["y"]], each = length(rng[["x"]])))
newdists &lt;- matrix(NA, nrow(grid), nrow(mite.geo))
for(i in 1L:nrow(grid)) {
  newdists[i,] &lt;- ((mite.geo[,"x"] - grid[i,"x"])^2 +
                     (mite.geo[,"y"] - grid[i,"y"])^2)^0.5
}

spmeans &lt;- colMeans(Y)
pca2 &lt;- svd(Y - rep(spmeans, each = nrow(Y)))

prd2 &lt;- predict(mca4_partest,
                newdata = list(target = eigenmap.score(map3, newdists)))
Uprd2 &lt;-
  (prd2 - rep(spmeans, each = nrow(prd2))) %*%
  pca2$v %*% diag(pca2$d^-1)

## Printing the response variable (first principal component of the mite
## community structure).
prmat &lt;- Uprd2[,1L]
dim(prmat) &lt;- c(length(rng$x), length(rng$y))
zlim &lt;- c(min(min(prmat), min(pca2$u[,1L])), max(max(prmat),
                                                 max(pca2$u[,1L])))
image(z = prmat, x = rng$x, y = rng$y, asp = 1, zlim = zlim,
      col = rainbow(1200L)[1L:1000], ylab = "y", xlab = "x")
points(
  x=mite.geo[,"x"], y=mite.geo[,"y"], pch=21L,
  bg = rainbow(1200L)[round(1+(999*(pca2$u[,1L]-zlim[1L])/(zlim[2L]-zlim[1L])),0)])

</code></pre>


</div>