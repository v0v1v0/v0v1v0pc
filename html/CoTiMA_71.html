<div class="container">

<table style="width: 100%;"><tr>
<td>ctmaOptimizeInit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ctmaOptimizeInit</h2>

<h3>Description</h3>

<p>Initial fitting (i.e., applies <code>ctmaInit</code>) to a primary study reFit times to capitalize on chance for obtaining
a hard-to-find optimal fit. This could be very helpful if a primary yields out-of-range estimates, which could happen if the fitting
algorithm unfortunately used random start values that resulted in a locally but not globally optimal fit. Essentially, using
ctmaOptimizeInit is like gambling, hoping that at leas one set of starting values (the number is tries is specified in the reFits argument)
eneables finding the global optimal fit. On unix-like machines (e.g. MacOS), this could be done in parallel mode if coresToUse &gt; 1.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ctmaOptimizeInit(
  primaryStudies = NULL,
  activeDirectory = NULL,
  problemStudy = NULL,
  reFits = NULL,
  finishsamples = NULL,
  n.latent = NULL,
  coresToUse = c(1),
  indVarying = FALSE,
  randomScaleTime = c(1, 1),
  activateRPB = FALSE,
  checkSingleStudyResults = FALSE,
  customPar = FALSE,
  T0means = 0,
  manifestMeans = 0,
  manifestVars = NULL,
  CoTiMAStanctArgs = NULL,
  scaleTime = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>primaryStudies</code></td>
<td>
<p>list of primary study information created with <code>ctmaPrep</code> or <code>ctmaFitToPrep</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activeDirectory</code></td>
<td>
<p>activeDirectory</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>problemStudy</code></td>
<td>
<p>number (position in list) where the problem study in primaryStudies is found</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reFits</code></td>
<td>
<p>how many reFits should be done</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finishsamples</code></td>
<td>
<p>number of samples to draw (either from hessian based covariance or posterior distribution) for final results computation (default = 1000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.latent</code></td>
<td>
<p>number of latent variables of the model (hast to be specified)!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coresToUse</code></td>
<td>
<p>if neg., the value is subtracted from available cores, else value = cores to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indVarying</code></td>
<td>
<p>control for unobserved heterogeneity by having randomly (inter-individually) varying manifest means</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomScaleTime</code></td>
<td>
<p>lower and upper limit of uniform distribution from which timeScale argument for ctmaInit is uniformly shuffled (integer)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activateRPB</code></td>
<td>
<p>set to TRUE to receive push messages with 'CoTiMA' notifications on your phone</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkSingleStudyResults</code></td>
<td>
<p>displays estimates from single study 'ctsem' models and waits for user input to continue.
Useful to check estimates before they are saved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>customPar</code></td>
<td>
<p>logical. If set TRUE (default) leverages the first pass using priors and ensure that the drift diagonal cannot easily go too negative (helps since ctsem &gt; 3.4)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T0means</code></td>
<td>
<p>Default 0 (assuming standardized variables). Can be assigned labels to estimate them freely.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>manifestMeans</code></td>
<td>
<p>Default 0 (assuming standardized variables). Can be assigned labels to estimate them freely.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>manifestVars</code></td>
<td>
<p>define the error variances of the manifests with a single time point using R-type lower triangular matrix with nrow=n.manifest &amp; ncol=n.manifest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CoTiMAStanctArgs</code></td>
<td>
<p>parameters that can be set to improve model fitting of the <code>ctStanFit</code> Function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleTime</code></td>
<td>
<p>scale time (interval) - sometimes desirable to improve fitting</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>returns a list with bestFit (= the best fit achieved), all_minus2ll (= all -2ll values for all fitted models), and summary, which
is printed if the summary function is applied to the returned object, and which shows the summary information of the ctsem model with the
best fit.
</p>


<h3>Note</h3>

<p>All but one of multiple cores are used on unix-type machines for parallel fitting
</p>
<p>During fitting, not output is generated. Be patient.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
optimFit313 &lt;- ctmaOptimizeInit(primaryStudies=CoTiMAstudyList_3,
                                activeDirectory="/Users/tmp/",  # adapt!
                                problemStudy=which(CoTiMAstudyList_3$studyNumbers == 313),
                                reFits=10,
                                n.latent=2)
summary(optimFit313)

## End(Not run)

</code></pre>


</div>