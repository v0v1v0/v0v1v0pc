<div class="container">

<table style="width: 100%;"><tr>
<td>ipf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Iterative Proportional Fitting
</h2>

<h3>Description</h3>

<p>ML estimation for hierarchical loglinear models via conventional
iterative proportional fitting (IPF).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ipf(table, margins, start, eps=0.0001, maxits=50, showits=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>

<p>contingency table (array) to be fit by a log-linear model. All
elements must be non-negative. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margins</code></td>
<td>

<p>vector describing the marginal totals to be fitted. A margin is described
by the factors not summed over, and margins are separated by zeros.
Thus c(1,2,0,2,3,0,1,3) would indicate fitting the (1,2), (2,3), and
(1,3) margins in a three-way table, i.e., the model of no three-way
association.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>starting value for IPF algorithm. The default is a uniform table.
If structural zeros appear in <code>table</code>, <code>start</code> should contain zeros
in those cells and ones elsewhere.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>convergence criterion. This is the largest proportional change in an
expected cell count from one iteration to the next.  Any expected cell
count that drops below 1E-07 times the average cell probability
(1/number of non-structural zero cells) is set to zero during the
iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxits</code></td>
<td>

<p>maximum number of iterations performed. The algorithm will stop if the
parameter still has not converged after this many iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showits</code></td>
<td>

<p>if <code>TRUE</code>, reports the iterations of IPF so the user can monitor the
progress of the algorithm.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>array like <code>table</code>, but containing fitted values (expected
frequencies) under the loglinear model. 
</p>


<h3>DETAILS</h3>

<p>This function is usually used to compute ML estimates for a loglinear
model. For ML estimates, the array <code>table</code> should contain the observed
frequencies from a cross-classified contingency table. Because this is
the "cell-means" version of IPF, the resulting fitted values will add
up to equals <code>sum(table)</code>. To obtain estimated cell probabilities,
rescale the fitted values to sum to one.
</p>
<p>This function may also be used to compute the posterior mode of the
multinomial cell probabilities under a Dirichlet prior.  For a
posterior mode, set the elements of <code>table</code> to (observed frequencies +
Dirichlet hyperparameters - 1). Then, after running IPF, rescale the
fitted values to sum to one.
</p>


<h3>Note</h3>

<p>This function is essentially the same as the old S function <code>loglin</code>, but
results are computed to double precision.  See <code>help(loglin)</code> for more
details.
</p>


<h3>References</h3>

<p>Agresti, A. (1990) Categorical Data Analysis. J. Wiley &amp; Sons, New
York.
</p>
<p>Schafer (1996) <em>Analysis of Incomplete Multivariate Data.</em>
Chapman &amp; Hall, Chapter 8.
</p>


<h3>See Also</h3>

<p><code>ecm.cat</code>, <code>bipf</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(HairEyeColor)                     # load data
m=c(1,2,0,1,3,0,2,3)                   # no three-way interaction
fit1 &lt;- ipf(HairEyeColor,margins=m,
            showits=TRUE)              # fit model
X2 &lt;- sum((HairEyeColor-fit1)^2/fit1)  # Pearson chi square statistic
df &lt;- prod(dim(HairEyeColor)-1)        # Degrees of freedom for this example
1 - pchisq(X2,df)                      # p-value for fit1
</code></pre>


</div>