<div class="container">

<table style="width: 100%;"><tr>
<td>pca.ct</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Continuous-time principal component analysis</h2>

<h3>Description</h3>

<p>A continuous-time version of principal component analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pca.ct(fdobj, cor = FALSE, common_trend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdobj</code></td>
<td>
<p>continuous-time multivariate data set of class <code>"fd"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>logical: use correlation matrix if <code>TRUE</code>,
covariance if <code>FALSE</code> (the default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common_trend</code></td>
<td>
<p>logical: Should the curves be centered with respect to the mean function?
Defaults to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>variances of the principal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>the matrix of loadings (i.e., its columns are the
eigenvectors of the continuous-time covariance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scorefd</code></td>
<td>
<p>score functions.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Biplab Paul &lt;paul.biplab497@gmail.com&gt; and Philip Tzvi Reiss &lt;reiss@stat.haifa.ac.il&gt;
</p>


<h3>See Also</h3>

<p><code>cov.ct</code>; <code>princomp</code>, for the classical version
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

# Data for one session from a classic EEG data set
require(fda)
require(eegkit)
data(eegdata)
data(eegcoord)
longdat &lt;- subset(eegdata, subject=="co2a0000369" &amp; trial==0)
widedat &lt;- reshape(longdat, direction="wide", drop=c("subject","group","condition","trial"),
                 v.names="voltage",idvar="channel")

# Convert time series for 64 channels to a functional data object
bsb &lt;- create.bspline.basis(c(0,255),nbasis=30)
fdo &lt;- Data2fd(argvals=0:255, y=t(as.matrix(widedat[,-1])), basisobj=bsb)
plot(fdo)

# Now do PCA and display first loadings for 3 PC's,
# along with percent variance explained by each
pcc &lt;- pca.ct(fdo)
pve &lt;- 100*pcc$var/sum(pcc$var)
par(mfrow=c(1,3))
cidx &lt;- match(widedat[,1],rownames(eegcoord))
eegspace(eegcoord[cidx,4:5],pcc$loadings[,1], colorlab="PC1 loadings",
         main=paste0(round(pve[1],0), "%"), mar=c(17,3,12,2), cex.main=2)
eegspace(eegcoord[cidx,4:5],pcc$loadings[,2], colorlab="PC2 loadings",
         main=paste0(round(pve[2],0), "%"), mar=c(17,3,12,2), cex.main=2)
eegspace(eegcoord[cidx,4:5],pcc$loadings[,3], colorlab="PC3 loadings",
         main=paste0(round(pve[3],0), "%"), mar=c(17,3,12,2), cex.main=2)

# Linear discriminant analysis: discriminating among the 1st, 2nd and 3rd portions
#  of the time interval
ld &lt;- lda.ct(fdo, c(85,170))
plot(ld)
eegspace(eegcoord[cidx,4:5],ld$scaling[,1], colorlab="LD1 coefficients",
         mar=c(17,3,12,2), cex.main=2)
eegspace(eegcoord[cidx,4:5],ld$scaling[,2], colorlab="LD2 coefficients",
         mar=c(17,3,12,2), cex.main=2)


## End(Not run)

</code></pre>


</div>