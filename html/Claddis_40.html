<div class="container">

<table style="width: 100%;"><tr>
<td>find_shortest_costmatrix_path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Finds the shortest path between two states in a costmatrix</h2>

<h3>Description</h3>

<p>Given a start and end state, returns the shortest path through a costmatrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find_shortest_costmatrix_path(costmatrix, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>costmatrix</code></td>
<td>
<p>An object of class <code>costMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>The start state for the requested path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p>The end state of the requested path.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A common problem in graph theory is identifying the shortest path to take between two vertices of a connected graph. A costmatrix also describes a graph, with transition costs representing edge weights that can be asymmetric (e.g., going from 0 to 1 can have a different weight than going from 1 to 0). Finding the shortest path between states - i.e., the path that minimises total weight (cost) - from a costmatrix has two main applications in Claddis: 1. to check a costmatrix is internally consistent (no cost is misidentified due to a "cheaper" route being available - solving a problem identified in Maddison and Maddison 2003), and 2. to identify the minimum cost a character could have on a tree (an essential aspect of various homoplasy metrics, see Hoyal Cuthill et al. 2010).
</p>
<p>The function returns a vector describing (one) shortest (i.e., lowest cost) path between <code>start</code> and <code>end</code>. If the direct path is shortest this will be simply <code>start</code> and <code>end</code>, but if an indirect route is cheaper then other node(s) will appear between these values.
</p>
<p>In operation the function is inspired by Dijkstra's algorithm (Dijkstra 1959) but differs in some aspects to deal with the special case of a cladistic-style costmatrix. Essentially multiple paths are considered with the algorithm continuing until either the destination node (<code>end</code>) is reached or the accumulated cost (path length) exceeds the direct cost (meaning the path cannot be more optimal, lower cost, than the direct one).
</p>
<p>Note: that because infinite costs are allowed in costmatrices to convey that a particular transition is not allowed these are always likely to be replaced (meanng the path does become possible) unless they apply to entire rows or columns of a costmatrix.
</p>
<p>Note: negative costs are not allowed in costmatrices as they will confound the halting criteria of the algorithm. (They also do not make logical sense in a costmatrix anyway!)
</p>
<p>Note: if multiple equally optimal solutions are possible, the function will only return one of them. I.e., just because a solution is not presented it cannot be assumed it is suboptimal.
</p>


<h3>Value</h3>

<p>A vector of states describing (one) of the optimal path(s) in the order <code>start</code> to <code>end</code>.
</p>


<h3>Author(s)</h3>

<p>Graeme T. Lloyd <a href="mailto:graemetlloyd@gmail.com">graemetlloyd@gmail.com</a>
</p>


<h3>References</h3>

<p>Dijkstra, E. W., 1959. A note on two problems in connexion with graphs. <em>Numerische Mathematik</em>, <b>1</b>, 269â€“271.
</p>
<p>Hoyal Cuthill, J. F., Braddy, S. J. and Donoghue, P. C. J., 2010. A formula for maximum possible steps in multistate characters: isolating matrix parameter effects on measures of evolutionary convergence. <em>Cladistics</em>, <b>26</b>, 98-102.
</p>
<p>Maddison, D. R. and Maddison, W. P., 2003. <em>MacClade 4: Analysis of phylogeny and character evolution</em>. Version 4.06. Sinauer Associates, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>

<p>convert_adjacency_matrix_to_costmatrix, make_costmatrix
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Make a four-state Dollo costmatrix:
costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state = 3,
  character_type = "dollo",
  dollo_penalty = 100
)

# Find the shortest path from state 0 to state 3:
find_shortest_costmatrix_path(
  costmatrix = costmatrix,
  start = "0",
  end = "3"
)

# Show that this is directional by asking for the reverse path:
find_shortest_costmatrix_path(
  costmatrix = costmatrix,
  start = "3",
  end = "0"
)

</code></pre>


</div>