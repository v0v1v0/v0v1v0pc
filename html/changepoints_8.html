<div class="container">

<table style="width: 100%;"><tr>
<td>calibrate.online.network.missing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibrate step for online change point detection for network data with missing values.</h2>

<h3>Description</h3>

<p>Calibrate step for online change point detection for network data by controlling the false alarm rate at level alpha.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calibrate.online.network.missing(
  train_miss_list,
  train_eta_list,
  threshold_len,
  alpha_grid,
  permu_num,
  pi_lb_hat,
  pi_ub_hat,
  rho_hat,
  rank_hat,
  C_lambda = 2/3,
  delta = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>train_miss_list</code></td>
<td>
<p>A <code>list</code> of adjacency matrices (with entries being 0 or 1) with missing values being coercing to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train_eta_list</code></td>
<td>
<p>A <code>list</code> of matrices associated with data_incomplete_list, each matrix indicates the missing entries in corresponding adjacency matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold_len</code></td>
<td>
<p>An <code>integer</code> scalar of the length of tuned thresholds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_grid</code></td>
<td>
<p>A <code>numeric</code> vector in (0,1) representing the desired false alarm rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permu_num</code></td>
<td>
<p>An <code>integer</code> scalar of number of random permutation for calibration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_lb_hat</code></td>
<td>
<p>A <code>numeric</code> scalar of the lower bound of the missing probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_ub_hat</code></td>
<td>
<p>A <code>numeric</code> scalar of the upper bound of the missing probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho_hat</code></td>
<td>
<p>A <code>numeric</code> scalar of the sparsity parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank_hat</code></td>
<td>
<p>An <code>integer</code> scalar of the rank of the underlying graphon matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_lambda</code></td>
<td>
<p>A <code>numeric</code> scalar of an absolute constant, which is set to be 2/3 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>An <code>integer</code> scalar of minimum spacing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>list</code> with the following structure:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>C_lambda</code></td>
<td>
<p>The absolute constant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho_hat</code></td>
<td>
<p>the (estimated) sparsity parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank_hat</code></td>
<td>
<p>the (estimated) rank of underlying graphon matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_lb_hat</code></td>
<td>
<p>the (estimated) lower bound of the missing probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_ub_hat</code></td>
<td>
<p>the (estimated) upper bound of the missing probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds_array</code></td>
<td>
<p>A <code>numeric</code> array of calibrated threshold</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Haotian Xu
</p>


<h3>References</h3>

<p>Dubey, Xu and Yu (2021) &lt;arxiv:2110.06450&gt;
</p>


<h3>See Also</h3>

<p><code>online.network.missing</code> for detecting online change point.
</p>


<h3>Examples</h3>

<pre><code class="language-R">p = 6 # number of nodes
rho = 0.5 # sparsity parameter
block_num = 3 # number of groups for SBM
train_obs_num = 150 # sample size for each segment
conn1_mat = rho * matrix(c(0.6,1,0.6,1,0.6,0.5,0.6,0.5,0.6), nrow = 3) # connectivity matrix 
set.seed(1)
can_vec = sample(1:p, replace = FALSE) # randomly assign nodes into groups
sbm = simu.SBM(conn1_mat, can_vec, train_obs_num, symm = TRUE, self = TRUE)
train_mat = sbm$obs_mat
train_list = lapply(1:ncol(train_mat), function(t) lowertri2mat(train_mat[,t], p, diag = TRUE))
pi_mat = matrix(0.9, p, p)
train_eta_list = lapply(1:length(train_list), function(t) gen.missing(pi_mat, symm = TRUE))
train_miss_list = lapply(1:length(train_list), function(t) train_eta_list[[t]] * train_list[[t]])
pi_lb_hat = quantile(Reduce("+", train_eta_list)/train_obs_num, 0.05) # estimator of pi_lb
pi_ub_hat = quantile(Reduce("+", train_eta_list)/train_obs_num, 0.95) # estimator of pi_ub
C_lambda = 2/3
lambda = lambda.network.missing(1, length(train_miss_list), length(train_miss_list), 0.05, 
                                rho = 0.509, pi_ub = pi_ub_hat, p, C_lambda)
graphon_miss_impute = softImpute.network.missing(train_miss_list, train_eta_list, lambda, 1)
graphon_miss_hat = graphon_miss_impute$u %*% diag(as.numeric(graphon_miss_impute$d)) %*% 
                   t(graphon_miss_impute$v)
rho_hat = quantile(graphon_miss_hat, 0.95)
rank_hat = sum(graphon_miss_impute$d != 0)
alpha_grid = c(0.05)
permu_num = 10
threshold_len = 30
temp = calibrate.online.network.missing(train_miss_list, train_eta_list, threshold_len, alpha_grid, 
                   permu_num, pi_lb_hat, pi_ub_hat, rho_hat, rank_hat, C_lambda, delta = 5)
</code></pre>


</div>