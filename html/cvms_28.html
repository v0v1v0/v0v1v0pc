<div class="container">

<table style="width: 100%;"><tr>
<td>plot_confusion_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot a confusion matrix</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Creates a <code>ggplot2</code> object representing a confusion matrix with counts,
overall percentages, row percentages and column percentages. An extra row and column with sum tiles and the
total count can be added.
</p>
<p>The confusion matrix can be created with <code>evaluate()</code>. See <code>`Examples`</code>.
</p>
<p>While this function is intended to be very flexible (hence the large number of arguments),
the defaults should work in most cases for most users. See the <code>Examples</code>.
</p>
<p><strong>NEW</strong>: Our
<a href="https://huggingface.co/spaces/ludvigolsen/plot_confusion_matrix">
<strong>Plot Confusion Matrix</strong> web application</a>
allows using this function without code. Select from multiple design templates
or make your own.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot_confusion_matrix(
  conf_matrix,
  target_col = "Target",
  prediction_col = "Prediction",
  counts_col = "N",
  sub_col = NULL,
  class_order = NULL,
  add_sums = FALSE,
  add_counts = TRUE,
  add_normalized = TRUE,
  add_row_percentages = TRUE,
  add_col_percentages = TRUE,
  diag_percentages_only = FALSE,
  rm_zero_percentages = TRUE,
  rm_zero_text = TRUE,
  add_zero_shading = TRUE,
  amount_3d_effect = 1,
  add_arrows = TRUE,
  counts_on_top = FALSE,
  palette = "Blues",
  intensity_by = "counts",
  intensity_lims = NULL,
  intensity_beyond_lims = "truncate",
  theme_fn = ggplot2::theme_minimal,
  place_x_axis_above = TRUE,
  rotate_y_text = TRUE,
  digits = 1,
  font_counts = font(),
  font_normalized = font(),
  font_row_percentages = font(),
  font_col_percentages = font(),
  arrow_size = 0.048,
  arrow_nudge_from_text = 0.065,
  tile_border_color = NA,
  tile_border_size = 0.1,
  tile_border_linetype = "solid",
  sums_settings = sum_tile_settings(),
  darkness = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>conf_matrix</code></td>
<td>
<p>Confusion matrix <code>tibble</code> with each combination of
targets and predictions along with their counts.
</p>
<p>E.g. for a binary classification:
</p>

<table>
<tr>
<td style="text-align: right;">
  <strong>Target</strong> </td>
<td style="text-align: right;"> <strong>Prediction</strong> </td>
<td style="text-align: right;"> <strong>N</strong> </td>
</tr>
<tr>
<td style="text-align: right;">
  class_1 </td>
<td style="text-align: right;"> class_1 </td>
<td style="text-align: right;"> 5 </td>
</tr>
<tr>
<td style="text-align: right;">
  class_1 </td>
<td style="text-align: right;"> class_2 </td>
<td style="text-align: right;"> 9 </td>
</tr>
<tr>
<td style="text-align: right;">
  class_2 </td>
<td style="text-align: right;"> class_1 </td>
<td style="text-align: right;"> 3 </td>
</tr>
<tr>
<td style="text-align: right;">
  class_2 </td>
<td style="text-align: right;"> class_2 </td>
<td style="text-align: right;"> 2 </td>
</tr>
<tr>
<td style="text-align: right;">
 </td>
</tr>
</table>
<p>As created with the various evaluation functions in <code>cvms</code>, like
<code>evaluate()</code>.
</p>
<p>An additional <code>`sub_col`</code> column (<code>character</code>) can be specified
as well. Its content will replace the bottom text ('counts' by default or
'normalized' when <code>`counts_on_top`</code> is enabled).
</p>
<p><strong>Note</strong>: If you supply the results from <code>evaluate()</code>
or <code>confusion_matrix()</code> directly,
the confusion matrix <code>tibble</code> is extracted automatically, if possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_col</code></td>
<td>
<p>Name of column with target levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction_col</code></td>
<td>
<p>Name of column with prediction levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts_col</code></td>
<td>
<p>Name of column with a count for each combination
of the target and prediction levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub_col</code></td>
<td>
<p>Name of column with text to replace the bottom text
('counts' by default or 'normalized' when <code>`counts_on_top`</code> is enabled).
</p>
<p>It simply replaces the text, so all settings will still be called
e.g. <code>`font_counts`</code> etc. When other settings make it so, that no
bottom text is displayed (e.g. <code>`add_counts` = FALSE</code>),
this text is not displayed either.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class_order</code></td>
<td>
<p>Names of the classes in <code>`conf_matrix`</code> in the desired order.
When <code>NULL</code>, the classes are ordered alphabetically.
Note that the entire set of unique classes from both <code>`target_col`</code>
and <code>`prediction_col`</code> must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_sums</code></td>
<td>
<p>Add tiles with the row/column sums. Also adds a total count tile. (Logical)
</p>
<p>The appearance of these tiles can be specified in <code>`sums_settings`</code>.
</p>
<p>Note: Adding the sum tiles with a palette requires the <code>ggnewscale</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_counts</code></td>
<td>
<p>Add the counts to the middle of the tiles. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_normalized</code></td>
<td>
<p>Normalize the counts to percentages and
add to the middle of the tiles. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_row_percentages</code></td>
<td>
<p>Add the row percentages,
i.e. how big a part of its row the tile makes up. (Logical)
</p>
<p>By default, the row percentage is placed to the right of the tile, rotated 90 degrees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_col_percentages</code></td>
<td>
<p>Add the column percentages,
i.e. how big a part of its column the tile makes up. (Logical)
</p>
<p>By default, the row percentage is placed at the bottom of the tile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag_percentages_only</code></td>
<td>
<p>Whether to only have row and column percentages in the diagonal tiles. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm_zero_percentages</code></td>
<td>
<p>Whether to remove row and column percentages when the count is <code>0</code>. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm_zero_text</code></td>
<td>
<p>Whether to remove counts and normalized percentages when the count is <code>0</code>. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_zero_shading</code></td>
<td>
<p>Add image of skewed lines to zero-tiles. (Logical)
</p>
<p>Note: Adding the zero-shading requires the <code>rsvg</code> and <code>ggimage</code> packages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amount_3d_effect</code></td>
<td>
<p>Amount of 3D effect (tile overlay) to add.
Passed as whole number from <code>0</code> (no effect) up to <code>6</code> (biggest effect).
This helps separate tiles with the same intensities.
</p>
<p>Note: The overlay may not fit the tiles in many-class cases that haven't been tested.
If the boxes do not overlap properly, simply turn it off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_arrows</code></td>
<td>
<p>Add the arrows to the row and col percentages. (Logical)
</p>
<p>Note: Adding the arrows requires the <code>rsvg</code> and <code>ggimage</code> packages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts_on_top</code></td>
<td>
<p>Switch the counts and normalized counts,
such that the counts are on top. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>palette</code></td>
<td>
<p>Color scheme. Passed directly to <code>`palette`</code> in
<code>ggplot2::scale_fill_distiller</code>.
</p>
<p>Try these palettes: <code>"Greens"</code>, <code>"Oranges"</code>,
<code>"Greys"</code>, <code>"Purples"</code>, <code>"Reds"</code>,
as well as the default <code>"Blues"</code>.
</p>
<p>Alternatively, pass a named list with limits of a custom gradient as e.g.
<code>`list("low"="#B1F9E8", "high"="#239895")`</code>. These are passed to
<code>ggplot2::scale_fill_gradient</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intensity_by</code></td>
<td>
<p>The measure that should control the color intensity of the tiles.
Either <code>`counts`</code>, <code>`normalized`</code> or one of <code>`log counts`,
 `log2 counts`, `log10 counts`, `arcsinh counts`</code>.
</p>
<p>For 'normalized', the color limits become <code>0-100</code> (except when
<code>`intensity_lims`</code> are specified), why the intensities
can better be compared across plots.
</p>
<p>For the 'log*' and 'arcsinh' versions, the log/arcsinh transformed counts are used.
</p>
<p><strong>Note</strong>: In 'log*' transformed counts, 0-counts are set to '0', why they
won't be distinguishable from 1-counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intensity_lims</code></td>
<td>
<p>A specific range of values for the color intensity of
the tiles. Given as a numeric vector with <code>c(min, max)</code>.
</p>
<p>This allows having the same intensity scale across plots for better comparison
of prediction sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intensity_beyond_lims</code></td>
<td>
<p>What to do with values beyond the
<code>`intensity_lims`</code>. One of <code>"truncate", "grey"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theme_fn</code></td>
<td>
<p>The <code>ggplot2</code> theme function to apply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>place_x_axis_above</code></td>
<td>
<p>Move the x-axis text to the top and reverse the levels such that
the "correct" diagonal goes from top left to bottom right. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotate_y_text</code></td>
<td>
<p>Whether to rotate the y-axis text to
be vertical instead of horizontal. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to round to (percentages only).
Set to a negative number for no rounding.
</p>
<p>Can be set for each font individually via the <code>font_*</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font_counts</code></td>
<td>
<p><code>list</code> of font settings for the counts.
Can be provided with <code>font()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font_normalized</code></td>
<td>
<p><code>list</code> of font settings for the normalized counts.
Can be provided with <code>font()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font_row_percentages</code></td>
<td>
<p><code>list</code> of font settings for the row percentages.
Can be provided with <code>font()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font_col_percentages</code></td>
<td>
<p><code>list</code> of font settings for the column percentages.
Can be provided with <code>font()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow_size</code></td>
<td>
<p>Size of arrow icons. (Numeric)
</p>
<p>Is divided by <code>sqrt(nrow(conf_matrix))</code> and passed on
to <code>ggimage::geom_icon()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow_nudge_from_text</code></td>
<td>
<p>Distance from the percentage text to the arrow. (Numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tile_border_color</code></td>
<td>
<p>Color of the tile borders. Passed as <em><code>`colour`</code></em> to
<code>ggplot2::geom_tile</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tile_border_size</code></td>
<td>
<p>Size of the tile borders. Passed as <em><code>`size`</code></em> to
<code>ggplot2::geom_tile</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tile_border_linetype</code></td>
<td>
<p>Linetype for the tile borders. Passed as <em><code>`linetype`</code></em> to
<code>ggplot2::geom_tile</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sums_settings</code></td>
<td>
<p>A list of settings for the appearance of the sum tiles.
Can be provided with <code>sum_tile_settings()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>darkness</code></td>
<td>
<p>How dark the darkest colors should be, between <code>0</code> and <code>1</code>, where <code>1</code> is darkest.
</p>
<p>Technically, a lower value increases the upper limit in
<code>ggplot2::scale_fill_distiller</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Inspired by Antoine Sachet's answer at https://stackoverflow.com/a/53612391/11832955
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object representing a confusion matrix.
Color intensity depends on either the counts (default) or the overall percentages.
</p>
<p>By default, each tile has the normalized count
(overall percentage) and count in the middle, the
column percentage at the bottom, and the
row percentage to the right and rotated 90 degrees.
</p>
<p>In the "correct" diagonal (upper left to bottom right, by default),
the column percentages are the class-level sensitivity scores,
while the row percentages are the class-level positive predictive values.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other plotting functions: 
<code>font()</code>,
<code>plot_metric_density()</code>,
<code>plot_probabilities()</code>,
<code>plot_probabilities_ecdf()</code>,
<code>sum_tile_settings()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Attach cvms
library(cvms)
library(ggplot2)

# Two classes

# Create targets and predictions data frame
data &lt;- data.frame(
  "target" = c("A", "B", "A", "B", "A", "B", "A", "B",
               "A", "B", "A", "B", "A", "B", "A", "A"),
  "prediction" = c("B", "B", "A", "A", "A", "B", "B", "B",
                   "B", "B", "A", "B", "A", "A", "A", "A"),
  stringsAsFactors = FALSE
)

# Evaluate predictions and create confusion matrix
evaluation &lt;- evaluate(
  data = data,
  target_col = "target",
  prediction_cols = "prediction",
  type = "binomial"
)

# Inspect confusion matrix tibble
evaluation[["Confusion Matrix"]][[1]]

# Plot confusion matrix
# Supply confusion matrix tibble directly
plot_confusion_matrix(evaluation[["Confusion Matrix"]][[1]])
# Plot first confusion matrix in evaluate() output
plot_confusion_matrix(evaluation)


## Not run: 
# Add sum tiles
plot_confusion_matrix(evaluation, add_sums = TRUE)

## End(Not run)


# Add labels to diagonal row and column percentages
# This example assumes "B" is the positive class
# but you could write anything as prefix to the percentages
plot_confusion_matrix(
    evaluation,
    font_row_percentages = font(prefix=c("NPV = ", "", "", "PPV = ")),
    font_col_percentages = font(prefix=c("Spec = ", "", "", "Sens = "))
)

# Three (or more) classes

# Create targets and predictions data frame
data &lt;- data.frame(
  "target" = c("A", "B", "C", "B", "A", "B", "C",
               "B", "A", "B", "C", "B", "A"),
  "prediction" = c("C", "B", "A", "C", "A", "B", "B",
                   "C", "A", "B", "C", "A", "C"),
  stringsAsFactors = FALSE
)

# Evaluate predictions and create confusion matrix
evaluation &lt;- evaluate(
  data = data,
  target_col = "target",
  prediction_cols = "prediction",
  type = "multinomial"
)

# Inspect confusion matrix tibble
evaluation[["Confusion Matrix"]][[1]]

# Plot confusion matrix
# Supply confusion matrix tibble directly
plot_confusion_matrix(evaluation[["Confusion Matrix"]][[1]])
# Plot first confusion matrix in evaluate() output
plot_confusion_matrix(evaluation)


## Not run: 
# Add sum tiles
plot_confusion_matrix(evaluation, add_sums = TRUE)

## End(Not run)


# Counts only
plot_confusion_matrix(
  evaluation[["Confusion Matrix"]][[1]],
  add_normalized = FALSE,
  add_row_percentages = FALSE,
  add_col_percentages = FALSE
)

# Change color palette to green
# Change theme to `theme_light`.
plot_confusion_matrix(
  evaluation[["Confusion Matrix"]][[1]],
  palette = "Greens",
  theme_fn = ggplot2::theme_light
)


## Not run: 
# Change colors palette to custom gradient
# with a different gradient for sum tiles
plot_confusion_matrix(
  evaluation[["Confusion Matrix"]][[1]],
  palette = list("low" = "#B1F9E8", "high" = "#239895"),
  sums_settings = sum_tile_settings(
    palette = list("low" = "#e9e1fc", "high" = "#BE94E6")
  ),
  add_sums = TRUE
)

## End(Not run)


# The output is a ggplot2 object
# that you can add layers to
# Here we change the axis labels
plot_confusion_matrix(evaluation[["Confusion Matrix"]][[1]]) +
  ggplot2::labs(x = "True", y = "Guess")

# Replace the bottom tile text
# with some information
# First extract confusion matrix
# Then add new column with text
cm &lt;- evaluation[["Confusion Matrix"]][[1]]
cm[["Trials"]] &lt;- c(
  "(8/9)", "(3/9)", "(1/9)",
  "(3/9)", "(7/9)", "(4/9)",
  "(1/9)", "(2/9)", "(8/9)"
 )

# Now plot with the `sub_col` argument specified
plot_confusion_matrix(cm, sub_col="Trials")


</code></pre>


</div>