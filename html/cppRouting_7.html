<div class="container">

<table style="width: 100%;"><tr>
<td>get_distance_pair</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute shortest distance between origin and destination nodes.</h2>

<h3>Description</h3>

<p>Compute shortest distance between origin and destination nodes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_distance_pair(
  Graph,
  from,
  to,
  aggregate_aux = FALSE,
  algorithm = "bi",
  constant = 1,
  allcores = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Graph</code></td>
<td>
<p>An object generated by makegraph, cpp_simplify or cpp_contract function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>A vector of one or more vertices from which distances are calculated (origin).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate_aux</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the additional weight is summed along shortest paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character. <code>Dijkstra</code> for uni-directional Dijkstra, <code>bi</code> for bi-directional Dijkstra, <code>A*</code> for A star unidirectional search or <code>NBA</code> for New bi-directional A star .Default to <code>bi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in <code>A*</code> and <code>NBA</code> algorithms.
Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allcores</code></td>
<td>
<p>Logical (deprecated). If <code>TRUE</code>, all cores are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If graph is not contracted, the user has the choice between : </p>

<ul>
<li>
<p> unidirectional Dijkstra (<code>Dijkstra</code>)
</p>
</li>
<li>
<p> A star (<code>A*</code>) : projected coordinates should be provided
</p>
</li>
<li>
<p> bidirectional Dijkstra (<code>bi</code>)
</p>
</li>
<li>
<p> New bi-directional A star (<code>NBA</code>) : projected coordinates should be provided
</p>
</li>
</ul>
<p>If the input graph has been contracted by cpp_contract function, the algorithm is a modified bidirectional search.
</p>
<p>Shortest path is always computed according to the main edge weights, corresponding to the 3rd column of <code>df</code> argument in makegraph function.
If <code>aggregate_aux</code> argument is <code>TRUE</code>, the values returned are the sum of auxiliary weights along shortest paths.
</p>
<p>In A* and New Bidirectional A star algorithms, euclidean distance is used as heuristic function.
</p>
<p>All algorithms are <strong>multithreaded.</strong> <code>allcores</code> argument is deprecated, please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>To understand how A star algorithm work, see <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">https://en.wikipedia.org/wiki/A*_search_algorithm</a>.
To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p>Vector of shortest distances.
</p>


<h3>Note</h3>

<p><code>from</code> and <code>to</code> must be the same length.
It is not possible to aggregate auxiliary weights on a Graph object coming from cpp_simplify function.
</p>


<h3>See Also</h3>

<p>get_distance_matrix, get_path_pair, cpp_contract
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6),
                  dist = c(5,3,4,7,5,5,5,8,7))

#Construct directed  graph with travel time as principal weight, and distance as secondary weight
graph &lt;- makegraph(edges[,1:3], directed=TRUE, aux = edges$dist)

#Get all nodes IDs
nodes &lt;- graph$dict$ref

# Get shortest times between all nodes : the result are in time unit
time_mat &lt;- get_distance_pair(graph, from = nodes, to = nodes)

# Get distance according shortest times : the result are in distance unit
dist_mat &lt;- get_distance_pair(graph, from = nodes, to = nodes, aggregate_aux = TRUE)

print(time_mat)
print(dist_mat)
</code></pre>


</div>