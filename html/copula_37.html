<div class="container">

<table style="width: 100%;"><tr>
<td>Bernoulli</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Bernoulli Numbers</h2>

<h3>Description</h3>

<p>Compute the <code class="reqn">n</code>th Bernoulli number, or
generate all Bernoulli numbers up to the <code class="reqn">n</code>th,
using diverse <code>method</code>s, that is, algorithms.
</p>
<p><b>NOTE</b> the current default methods will be changed – to get
better accuracy!

</p>


<h3>Usage</h3>

<pre><code class="language-R">Bernoulli    (n, method = c("sumBin", "sumRamanujan", "asymptotic"),
              verbose = FALSE)
Bernoulli.all(n, method = c("A-T", "sumBin", "sumRamanujan", "asymptotic"),
              precBits = NULL, verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>positive integer, indicating the index of the largest (and
last) of the Bernoulli numbers needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string, specifying which method should be
applied. The default for <code>Bernoulli.all()</code>, <code>"A-T"</code>
stands for the Akiyama-Tanigawa algorithm
which is nice and simple but has bad numerical properties.  It can
however work with high precision "mpfr"-numbers, see <code>precBits</code>.
<code>"sumRamanujan"</code> is somewhat more efficient but not yet implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precBits</code></td>
<td>
<p>currently only for <code>method = "A-T"</code> –
<code>NULL</code> or a positive integer indicating the precision of the
initial numbers in bits, using package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>'s multiprecision
arithmetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>(for <code>"A-T"</code>:) logical indicating if the
intermediate results of the algorithm should be printed.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<dl>
<dt>
<code>Bernoulli()</code>:</dt>
<dd>
<p>a number</p>
</dd>
<dt>
<code>Bernoulli.all()</code>:</dt>
<dd>
<p>a numeric vector of length n,
containing B(n)</p>
</dd>
</dl>
<h3>References</h3>

<p>Kaneko, Masanobu (2000)
The Akiyama-Tanigawa algorithm for Bernoulli numbers;
Journal of Integer Sequences <b>3</b>, article 00.2.9
</p>


<h3>See Also</h3>

<p><code>Eulerian</code>, <code>Stirling1</code>, etc.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## The example for the paper
MASS::fractions(Bernoulli.all(8, verbose=TRUE))

B10 &lt;- Bernoulli.all(10)
MASS::fractions(B10)

system.time(B50  &lt;- Bernoulli.all(50))#  {does not cache} -- still "no time"
system.time(B100 &lt;- Bernoulli.all(100))# still less than a milli second

## Using Bernoulli() is not much slower, but hopefully *more* accurate!
## Check first - TODO
system.time(B.1c &lt;- Bernoulli(100))# caches ..
system.time(B1c. &lt;- Bernoulli(100))# ==&gt; now much faster
stopifnot(identical(B.1c, B1c.))

if(FALSE)## reset the cache:
assign("Bern.tab", list(), envir = copula:::.nacopEnv)

## More experiments in the source of the copula package ../tests/Stirling-etc.R
</code></pre>


</div>