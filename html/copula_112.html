<div class="container">

<table style="width: 100%;"><tr>
<td>polylog</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Polylogarithm <code class="reqn">\mathrm{Li_s(z)}</code> and Debye Functions</h2>

<h3>Description</h3>

<p>Compute the polylogarithm function <code class="reqn">\mathrm{Li_s(z)}</code>,
initially defined as the power series,
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_s(z) = \sum_{k=1}^\infty {z^k \over k^s},</code>
</p>

<p>for <code class="reqn">|z| &lt; 1</code>, and then more generally (by analytic continuation) as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_1(z) = -\log(1-z),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_{s+1}(z) = \int_0^z \frac{\mathrm{Li}_s(t)}{t}\,dt.</code>
</p>

<p>Currently, mainly the case of negative integer <code class="reqn">s</code> is well supported,
as that is used for some of the Archimedean copula densities.
</p>
<p>For <code class="reqn">s = 2</code>, <code class="reqn">\mathrm{Li_2(z)}</code> is also called
‘dilogarithm’ or “Spence's function”.  The
<code>"default"</code> method uses the <code>dilog</code> or
<code>complex_dilog</code> function from package <a href="https://CRAN.R-project.org/package=gsl"><span class="pkg">gsl</span></a>,
respectively when <code class="reqn">s = 2</code>.
</p>
<p>Also compute the Debye_n functions, for <code class="reqn">n=1</code> and <code class="reqn">n=2</code>, in a
slightly more general manner than the <span class="pkg">gsl</span> package functions
<code>debye_1</code> and <code>debye_2</code> (which cannot deal with
non-finite <code>x</code>.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">polylog(z, s,
        method = c("default", "sum", "negI-s-Stirling",
                   "negI-s-Eulerian", "negI-s-asymp-w"),
        logarithm = FALSE, is.log.z = FALSE, is.logmlog = FALSE,
        asymp.w.order = 0, n.sum)

debye1(x)
debye2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>numeric or complex vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>complex number; current implementation is aimed at
<code class="reqn">s \in \{0,-1,\dots\}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string specifying the algorithm to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logarithm</code></td>
<td>
<p>logical specified to return log(Li.(.)) instead of Li.(.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.log.z</code></td>
<td>
<p>logical; if TRUE, the specified <code>z</code> argument is
really <code class="reqn">w = \log(z)</code>;
that is, we compute <code class="reqn">\mathrm{Li}_s(\exp(w))</code>, and
we typically have <code class="reqn">w &lt; 0</code>, or equivalently, <code class="reqn">z &lt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.logmlog</code></td>
<td>
<p>logical; if TRUE, the specified argument <code>z</code> is
<code class="reqn">lw = \log(-w) = \log(-\log(z))</code>
(where as above, <code class="reqn">w = \log(z)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asymp.w.order</code></td>
<td>
<p>currently only default is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sum</code></td>
<td>
<p>for <code>method="sum"</code> only: the number of terms used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector, may contain <code>Inf</code>, <code>NA</code>, and
negative values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Almost entirely taken from
<a href="https://en.wikipedia.org/wiki/Polylogarithm">https://en.wikipedia.org/wiki/Polylogarithm</a>:
</p>
<p>For integer values of the polylogarithm order, the following
explicit expressions are obtained by repeated application of
<code class="reqn">z \frac{\partial}{\partial z}</code> to
<code class="reqn">\mathrm{Li}_1(z)</code>:

</p>
<p style="text-align: center;"><code class="reqn">
  \mathrm{Li}_{1}(z) = -\log(1-z), \ \
  \mathrm{Li}_{0}(z) = {z \over 1-z}, \ \
  \mathrm{Li}_{-1}(z) = {z \over (1-z)^2}, \ \
  \mathrm{Li}_{-2}(z) = {z \,(1+z) \over (1-z)^3},
</code>
</p>

<p><code class="reqn">\mathrm{Li}_{-3}(z) = {z \,(1+4z+z^2) \over (1-z)^4}</code>, etc.
</p>
<p>Accordingly, the polylogarithm reduces to a ratio of polynomials in
z, and is therefore a rational function of z, for all nonpositive
integer orders.  The general case may be expressed as a finite sum:

</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_{-n}(z) =
  \left(z \,{\partial \over \partial z} \right)^n \frac{z}{1-z}
  = \sum_{k=0}^n k! \,S(n+1,k+1) \left({z \over {1-z}} \right)^{k+1}
  \ \ (n=0,1,2,\ldots),</code>
</p>

<p>where <code class="reqn">S(n,k)</code> are the Stirling numbers of the second kind.
</p>
<p>Equivalent formulae applicable to negative integer orders are
(Wood 1992, § 6) ...
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_{-n}(z) = {1 \over (1-z)^{n+1}} \sum_{k=0}^{n-1}
  			\left\langle {n \atop k} \right\rangle z^{n-k} =
			\frac{z \sum_{k=0}^{n-1} \left\langle {n \atop k} \right
			  \rangle z^k}{(1-z)^{n+1}},
      \qquad (n=1,2,3,\ldots) ~, </code>
</p>

<p>where <code class="reqn">\left\langle {n \atop k} \right\rangle</code>  are the
Eulerian numbers; see also <code>Eulerian</code>.
</p>




<h3>Value</h3>

<p>numeric/complex vector as <code>z</code>, or <code>x</code>, respectively.
</p>


<h3>References</h3>

<p>Wikipedia (2011) <em>Polylogarithm</em>,
<a href="https://en.wikipedia.org/wiki/Polylogarithm">https://en.wikipedia.org/wiki/Polylogarithm</a>.
</p>
<p>Wood, D. C. (June 1992).
The Computation of Polylogarithms.  Technical Report 15-92.
Canterbury, UK: University of Kent Computing Laboratory.
<a href="https://www.cs.kent.ac.uk/pubs/1992/110/">https://www.cs.kent.ac.uk/pubs/1992/110/</a>.
</p>
<p>Apostol, T. M. (2010), <em>"Polylogarithm"</em>, in the
NIST Handbook of Mathematical Functions, <a href="https://dlmf.nist.gov/25.12">https://dlmf.nist.gov/25.12</a>
</p>
<p>Lewin, L. (1981).
<em>Polylogarithms and Associated Functions</em>.
New York: North-Holland. ISBN 0-444-00550-1.
</p>
<p>For Debye functions:  Levin (1981) above, and <br>
Wikipedia (2014) <em>Debye function</em>,
<a href="https://en.wikipedia.org/wiki/Debye_function">https://en.wikipedia.org/wiki/Debye_function</a>.
</p>


<h3>See Also</h3>

<p>The polylogarithm is used in MLE for some Archimedean copulas; see
<code>emle</code>;
</p>
<p>The Debye functions are used for <code>tau</code> or
<code>rho</code> computations of the Frank copula.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## The dilogarithm,  polylog(z, s = 2) = Li_2(.) -- mathmatically defined on C \ [1, Inf)
## so x -&gt; 1 is a limit case:
polylog(z = 1, s = 2)
## in the limit, should be equal to
pi^2 / 6

## Default method uses  GSL's dilog():
rLi2 &lt;- curve(polylog(x, 2), -5, 1, n= 1+ 6*64, col=2, lwd=2)
abline(c(0,1), h=0,v=0:1, lty=3, col="gray40")
## "sum" method gives the same for |z| &lt; 1 and large number of terms:
ii &lt;- which(abs(rLi2$x) &lt; 1)
stopifnot(all.equal(rLi2$y[ii],
            polylog(rLi2$x[ii], 2, "sum", n.sum = 1e5),
          tolerance = 1e-15))


z1 &lt;- c(0.95, 0.99, 0.995, 0.999, 0.9999)
L   &lt;- polylog(         z1,  s=-3,method="negI-s-Euler") # close to Inf
LL  &lt;- polylog(     log(z1), s=-3,method="negI-s-Euler",is.log.z=TRUE)
LLL &lt;- polylog(log(-log(z1)),s=-3,method="negI-s-Euler",is.logmlog=TRUE)
all.equal(L, LL)
all.equal(L, LLL)

p.Li &lt;- function(s.set, from = -2.6, to = 1/4, ylim = c(-1, 0.5),
                 colors = c("orange","brown", palette()), n = 201, ...)
{
    s.set &lt;- sort(s.set, decreasing = TRUE)
    s &lt;- s.set[1] # &lt;_ for auto-ylab
    curve(polylog(x, s, method="negI-s-Stirling"), from, to,
          col=colors[1], ylim=ylim, n=n, ...)
    abline(h=0,v=0, col="gray")
    for(is in seq_along(s.set)[-1])
        curve(polylog(x, s=s.set[is], method="negI-s-Stirling"),
              add=TRUE, col = colors[is], n=n)
    s &lt;- rev(s.set)
    legend("bottomright",paste("s =",s), col=colors[2-s], lty=1, bty="n")
}

## yellow is unbearable (on white):
palette(local({p &lt;- palette(); p[p=="yellow"] &lt;- "goldenrod"; p}))

## Wikipedia page plot (+/-):
p.Li(1:-3, ylim= c(-.8, 0.6), colors = c(2:4,6:7))

## and a bit more:
p.Li(1:-5)

## For the range we need it:
ccol &lt;- c(NA,NA, rep(palette(),10))
p.Li(-1:-20, from=0, to=.99, colors=ccol, ylim = c(0, 10))
## log-y scale:
p.Li(-1:-20, from=0, to=.99, colors=ccol, ylim = c(.01, 1e7),
     log = "y", yaxt = "n")
if(require(sfsmisc)) eaxis(2) else axis(2)
</code></pre>


</div>