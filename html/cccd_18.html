<div class="container">

<table style="width: 100%;"><tr>
<td>rng</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Relative Neighborhood Graph.</h2>

<h3>Description</h3>

<p>the relative neighborhood graph defined by a set of points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rng(x=NULL, dx=NULL, r = 1, method = NULL, usedeldir = TRUE, open = TRUE, k = NA,
    algorithm = 'cover_tree')
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a data matrix. Either <code>x</code> or <code>dx</code> must be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx</code></td>
<td>
<p> an interpoint distance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p> a multiplier to grow the balls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> the method used for the distance. 
See <code>dist</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usedeldir</code></td>
<td>
<p>a logical. If true and the data are two dimensional
and the deldir package is installed, the Delaunay triangularization
is first computed, and this is used to compute the relative
neighborhood graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>open</code></td>
<td>
<p>logical. If TRUE, open balls are used in the definition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>If given, <code>get.knn</code> is used from FNN to approximate
the relative neighborhood graph. Only the <code>k</code> nearest neighbors to
the points are used to determine whether an edge should be made or not.
This will be much faster and use less memory for large data sets, but 
is an approximation unless <code>k</code> is sufficiently large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>See <code>get.knn</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>the relative neighborhood graph is defined in terms of balls
centered at observations. For two observations, the balls are
set to have radius equal to the distance between the observations
(or <code>r</code> times this distance if <code>r</code> is not 1). There is
an edge between the vertices associated with the observations if 
and only if there are no vertices in the lune defined by the
intersection of the balls.
</p>
<p>The flag <code>open</code> should make no difference for most applications,
but there are very specific cases (see the example section below)
where setting it to be TRUE will give the wrong answer (thanks to
Luke Mathieson for pointing this out to me).
</p>


<h3>Value</h3>

<p>an object of class igraph, with the additional attributes
</p>
<table>
<tr style="vertical-align: top;">
<td><code>layout</code></td>
<td>
<p>the x matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r,p</code></td>
<td>
<p>arguments given to <code>rng</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> David J. Marchette david.marchette@navy.mil</p>


<h3>References</h3>

 
<p>J.W. Jaromczyk and G.T. Toussaint,
"Relative neighborhood graphs and their relatives",
Proceedings of the IEEE, 
80, 1502-1517, 1992.
</p>
<p>G.T. Toussaint,
"A Graph-Theoretic Primal Sketch",
Computational Morphology, 229-260, 1988.
</p>
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>


<h3>See Also</h3>

<p><code>gg</code>,<code>cccd</code>,<code>ccd</code>,
<code>dist</code>
<code>get.knn</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(runif(100),ncol=2)

g &lt;- rng(x)
## Not run: 
plot(g)

## End(Not run)

## Example using 'open':
g &lt;- graph.full(5,directed=FALSE)

g1 &lt;- rng(x=get.adjacency(g,sparse=FALSE),open=TRUE)
ecount(g1)
g2 &lt;- rng(x=get.adjacency(g,sparse=FALSE),open=FALSE)
graph.isomorphic(g2,g)


</code></pre>


</div>