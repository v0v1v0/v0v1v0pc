<div class="container">

<table style="width: 100%;"><tr>
<td>lmranks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regressions Involving Ranks</h2>

<h3>Description</h3>

<p>Estimation and inference for regressions involving ranks, i.e. regressions in which the dependent and/or the independent
variable has been transformed into ranks before running the regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lmranks(
  formula,
  data,
  subset,
  weights,
  na.action = stats::na.fail,
  method = "qr",
  model = TRUE,
  x = FALSE,
  qr = TRUE,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = offset,
  omega = 1,
  ...
)

## S3 method for class 'lmranks'
plot(x, which = 1, ...)

## S3 method for class 'lmranks'
proj(object, onedf = FALSE, ...)

## S3 method for class 'lmranks'
predict(object, newdata, ...)

## S3 method for class 'lmranks'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)

## S3 method for class 'lmranks'
vcov(object, complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object of class "<code>formula</code>": a symbolic description
of the model to be fitted. Exactly like the formula for linear model except that
variables to be ranked can be indicated by <code>r()</code>. See Details and Examples below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>currently not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>currently not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>currently not supported. User is expected to handle NA values prior to the use of this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method to be used; for fitting, currently only
<code>method = "qr"</code> is supported; <code>method = "model.frame"</code> returns
the model frame (the same as with <code>model = TRUE</code>, see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, y, qr</code></td>
<td>
<p>logicals. If TRUE the corresponding components of the fit (the model frame, the response, the QR decomposition) are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<ul>
<li>
<p> For <code>lmranks</code>: Logical. Should model matrix be returned?
</p>
</li>
<li>
<p> For <code>plot</code> method: An <code>lmranks</code> object.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>singular.ok</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default in S but
not in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>) a singular fit is an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector or matrix of extents
matching those of the response.  One or more <code>offset</code> terms can be
included in the formula instead or as well, and if more than one are
specified their sum is used.  See <code>model.offset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>real number in the interval [0,1] defining how ties are handled (if there are any).
The value of <code>omega</code> is passed to <code>frank</code> for computation of ranks.
The default is 1 so that the rank of a realized value is defined as the
empirical cdf evaluated at that realized value. See Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>lm()</code>: additional arguments to be passed to the low level
regression fitting functions (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>As in <code>plot.lm</code>. Currently only no.1 is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>lmranks</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onedf</code></td>
<td>
<p>A logical flag. If <code>TRUE</code>, a projection is returned for all
the columns of the model matrix. If <code>FALSE</code>, the single-column
projections are collapsed by terms of the model (as represented in
the analysis of variance table).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of
the estimated parameters is returned and printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in
a symbolic form (see <code>symnum</code>) rather than as numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>logical indicating if the full variance-covariance matrix
should be returned also in case of an over-determined system where
some coefficients are undefined and <code>coef(.)</code> contains NAs correspondingly.
When <code>complete = TRUE</code>, <code>vcov()</code> is compatible with <code>coef()</code> also in this singular case.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs estimation and inference for regressions involving ranks. Suppose there is a dependent variable <code class="reqn">Y_i</code> and independent
variables <code class="reqn">X_i</code> and <code class="reqn">W_i</code>, where <code class="reqn">X_i</code> is a scalar and <code class="reqn">W_i</code> a vector (possibly including a constant). Instead of running a linear regression of <code class="reqn">Y_i</code> on <code class="reqn">X_i</code> and <code class="reqn">W_i</code>, we want to first transform
<code class="reqn">Y_i</code> and/or <code class="reqn">X_i</code> into ranks. Denote by <code class="reqn">R_i^Y</code> the rank of <code class="reqn">Y_i</code> and <code class="reqn">R_i^X</code> the rank of <code class="reqn">X_i</code>. Then, a
<strong>rank-rank regression</strong>, </p>
<p style="text-align: center;"><code class="reqn">R_i^Y = \rho R_i^X + W_i'\beta + \varepsilon_i,</code>
</p>
<p> is run using the formula <code>r(Y)~r(X)+W</code>. Similarly, a
<strong>regression of the raw dependent variable on the ranked regressor</strong>,
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \rho R_i^X + W_i'\beta + \varepsilon_i,</code>
</p>
<p> can be implemented by the formula <code>Y~r(X)+W</code>, and a
<strong>regression of the ranked dependent variable on the raw regressors</strong>, </p>
<p style="text-align: center;"><code class="reqn">R^Y_i = W_i'\beta + \varepsilon_i,</code>
</p>
<p> can be implemented by the formula <code>r(Y)~W</code>.
</p>
<p>The function works, in many ways, just like <code>lm</code> for linear regressions. Apart from some smaller details, there are two important differences:
first, in <code>lmranks</code>, the mark <code>r()</code> can be used in formulas to indicate variables to be ranked before running the regression and, second,
subsequent use of <code>summary</code> produces a summary table with the correct standard errors, t-values and p-values (while those of the <code>lm</code> are not correct for
regressions involving ranks). See Chetverikov and Wilhelm (2023) for more details.
</p>
<p>Many other aspects of the function are similar to <code>lm</code>. For instance,
<code>.</code> in a formula means 'all columns not otherwise in the formula' just as in <code>lm</code>. An
intercept is included by default.
In a model specified as <code>r(Y)~r(X)+.</code>, both <code>r(X)</code> and <code>X</code> will be
included in the model - as it would have been in <code>lm</code> and, say,
<code>log()</code> instead of <code>r()</code>.
One can exclude <code>X</code> with a <code>-</code>, i.e. <code>r(Y)~r(X)+.-X</code>. See
<code>formula</code> for more about model specification.
</p>
<p>The <code>r()</code> is a private alias for <code>frank</code>.
The <code>increasing</code> argument, provided at individual regressor level,
specifies whether the ranks should increase or decrease as regressor values increase.
The <code>omega</code> argument of <code>frank</code>, provided at <code>lmranks</code> function level,
specifies how ties in variables are to be handled and
can be supplied as argument in <code>lmranks</code>. For more details, see <code>frank</code>.
By default <code>increasing</code> is set to <code>TRUE</code> and <code>omega</code> is set equal to <code>1</code>,
which means <code>r()</code> computes ranks by transforming a variable through its empirical cdf.
</p>
<p>Many functions defined for <code>lm</code> also work correctly with <code>lmranks</code>.
These include <code>coef</code>, <code>model.frame</code>,
<code>model.matrix</code>, <code>resid</code>,
<code>update</code> and others.
On the other hand, some would return incorrect results if they treated
<code>lmranks</code> output in the same way as <code>lm</code>'s. The central contribution of this package
are <code>vcov</code>, <code>summary</code> and <code>confint</code> implementations using the correct asymptotic theory for regressions involving ranks.
</p>
<p>See the <code>lm</code> documentation for more.
</p>


<h3>Value</h3>

<p>An object of class <code>lmranks</code>, inheriting (as much as possible) from class <code>lm</code>.
</p>
<p>Additionally, it has an <code>omega</code> entry, corresponding to the <code>omega</code> argument,
a <code>ranked_response</code> logical entry, and
a <code>rank_terms_indices</code> - an integer vector with indices of entries of <code>terms.labels</code> attribute
of <code>terms(formula)</code>, which correspond to ranked regressors.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot(lmranks)</code>: Plot diagnostics for an <code>lmranks</code> object
</p>
<p>Displays plots useful for assessing quality of model fit. Currently, only one
plot is available, which plots fitted values against residuals (for homoscedacity check).
</p>
</li>
<li> <p><code>proj(lmranks)</code>: Projections of the data onto terms of rank-rank regression model
</p>
</li>
<li> <p><code>predict(lmranks)</code>: Predict method for Linear Model for Ranks Fits
</p>
</li>
<li> <p><code>summary(lmranks)</code>: Summarizing fits of rank-rank regressions
</p>
</li>
<li> <p><code>vcov(lmranks)</code>: Calculate Variance-Covariance Matrix for a Fitted <code>lmranks</code> object
</p>
<p>Returns the variance-covariance matrix of the regression coefficients
(main parameters) of a fitted <code>lmranks</code> object. Its result is theoretically valid
and asymptotically consistent, in contrast to naively running <code>vcov(lm(...))</code>.
</p>
</li>
</ul>
<h3>Rank-rank regressions with clusters</h3>

<p>Sometimes, the data is divided into clusters (groups) and one is
interested in running rank-rank regressions separately within each cluster, where the ranks are not computed
within each cluster, but using all observations pooled across all clusters. Specifically, let <code class="reqn">G_i=1,\ldots,n_G</code> denote
a variable that indicates the cluster to which the i-th observation belongs. Then, the regression model of interest is
</p>
<p style="text-align: center;"><code class="reqn">R_i^Y = \sum_{g=1}^{n_G} 1\{G_i=g\}(\rho_g R_i^X + W_i'\beta_g) + \varepsilon_i,</code>
</p>

<p>where <code class="reqn">\rho_g</code> and <code class="reqn">\beta_g</code> are now cluster-specific coefficients, but the ranks <code class="reqn">R_i^Y</code> and <code class="reqn">R_i^X</code> are computed as
ranks among all observations <code class="reqn">Y_i</code> and <code class="reqn">X_i</code>, respectively. That means the rank of an observation is not computed among the other observations
in the same cluster, but rather among all available observations across all clusters.
</p>
<p>This type of regression is implemented in the <code>lmranks</code> function using interaction notation: <code>r(Y)~(r(X)+W):G</code>. Here, the variable
G <strong>must</strong> be a <code>factor</code>.
</p>
<p>Since the theory for clustered regression mixing grouped and ungrouped (in)dependent variables is not yet developed, such a model will raise an error.
Also, by default the function includes a cluster-specific intercept, i.e. <code>r(Y)~(r(X)+W):G</code> is internally interpreted as <code>r(Y)~(r(X)+W):G+G-1</code>.
</p>
<p><code>contrasts</code> of <code>G</code> must be of <code>contr.treatment</code> kind,
which is the default.
</p>


<h3>Warning</h3>

<p>As a consequence of the order, in which <code>model.frame</code> applies operations,
<code>subset</code> and <code>na.action</code> would be applied after evaluation of <code>r()</code>.
That would drop some rank values from the final model frame and returned coefficients
and standard errors could no longer be correct.
The user must handle NA values and filter the data on their own prior to usage in <code>lmranks</code>.
</p>
<p>Wrapping <code>r()</code> with other functions (like <code>log(r(x))</code>) will not
recognize correctly the mark (because it will not be caught in <code>terms(formula, specials = "r")</code>).
The ranks will be calculated correctly, but their transformation will be treated later in <code>lm</code> as a regular
regressor. This means that the corresponding regression coefficient will be calculated correctly,
but the standard errors, statistics etc. will not.
</p>
<p><code>r</code>, <code>.r_predict</code> and <code>.r_cache</code> are special expressions, used
internally to interpret <code>r</code> mark correctly. Do not use them in <code>formula</code>.
</p>
<p>A number of methods defined for <code>lm</code> do not yield theoretically correct
results when applied to <code>lmranks</code> objects; errors or warnings are raised in those instances.
Also, the <code>df.residual</code> component is set to NA, since the notion of effects of freedom
for the rank models is not theoretically established (at time of 1.2 release).
</p>


<h3>References</h3>

<p>Chetverikov and Wilhelm (2023), "Inference for Rank-Rank Regressions".
<a href="http://arxiv.org/pdf/2310.15512">arXiv preprint arXiv:2310.15512</a>
</p>


<h3>See Also</h3>

<p><code>lm</code> for details about other arguments; <code>frank</code>.
</p>
<p>Generic functions <code>coef</code>, <code>effects</code>,
<code>residuals</code>,
<code>fitted</code>, <code>model.frame</code>,
<code>model.matrix</code>, <code>update</code> .
</p>


<h3>Examples</h3>

<pre><code class="language-R"># rank-rank regression:
X &lt;- rnorm(500)
Y &lt;- X + rnorm(500)
rrfit &lt;- lmranks(r(Y) ~ r(X))
summary(rrfit)

# naive version of the rank-rank regression:
RY &lt;- frank(Y, increasing=TRUE, omega=1)
RX &lt;- frank(X, increasing=TRUE, omega=1)
fit &lt;- lm(RY ~ RX)
summary(fit)
# the coefficient estimates are the same as in the lmranks function, but
# the standard errors, t-values, p-values are incorrect

# support of `data` argument:
data(mtcars)
lmranks(r(mpg) ~ r(hp) + ., data = mtcars)
# Same as above, but use the `hp` variable only through its rank
lmranks(r(mpg) ~ r(hp) + . - hp, data = mtcars)

# rank-rank regression with clusters:
G &lt;- factor(rep(LETTERS[1:4], each=nrow(mtcars) / 4))
lmr &lt;- lmranks(r(mpg) ~ r(hp):G, data = mtcars)
summary(lmr)
model.matrix(lmr)
# Include all columns of mtcars as usual covariates:
lmranks(r(mpg) ~ (r(hp) + .):G, data = mtcars)

</code></pre>


</div>