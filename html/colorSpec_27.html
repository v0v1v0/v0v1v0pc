<div class="container">

<table style="width: 100%;"><tr>
<td>canonicalOptimalColors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>compute the Canonical Optimal Colors</h2>

<h3>Description</h3>

<p>Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> 
equal to <code>'responsivity.material'</code>.
The set of all possible material reflectance functions (or transmittance functions) 
is convex, closed, and bounded (in any reasonable function space),
and this implies that the set of all possible output responses 
from <code>x</code> is also convex, closed, and bounded.
The latter set is called the <em>object-color solid</em> or <em>Rösch Farbkörper</em> for <code>x</code>.
A color on the boundary of the <em>object-color solid</em> is called an <em>optimal color</em> for <code>x</code>.
The corresponding transmittance spectrum is called an  <em>optimal spectrum</em> for <code>x</code>.
The special points <b>W</b> (the response to the perfect reflecting diffuser)
and <b>0</b> (the response to the perfect absorbing diffuser) are optimal.
</p>
<p>Currently the function only works if the number of spectra in 
<code>x</code> is 3 (e.g. RGB or XYZ).
In this case the <em>object-color solid</em> is a zonohedron whose boundary
is the union of parallelograms, which may be coplanar.
These parallelograms are indexed by distinct pairs of the wavelengths of <code>x</code>;
if <code>x</code> has N wavelengths, then there are N*(N-1) parallelograms.
The center of each parallelogram is called a <em>canonical optimal color</em>.
Interestingly, the special points <b>W</b> and <b>0</b> are not canonical.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'colorSpec'
canonicalOptimalColors( x, lambda, spectral=FALSE )

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code>
equal to <code>'responsivity.material'</code> and 3 spectra</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a numeric Mx2 matrix whose rows contain distinct pairs of wavelengths of <code>x</code>,
or a numeric vector that can be converted to such a matrix, by row.
If any entry in <code>lambda</code> is not a wavelength of <code>x</code>,
it is an error. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spectral</code></td>
<td>
<p>if <code>TRUE</code>, the function returns a <b>colorSpec</b> object
with the optimal spectra, see <b>Value</b>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The 3 responsivities are regarded not as continuous functions, 
but as step functions.
This implies that the color solid is a zonohedron.
In the preprocessing phase the zonohedral representation is calculated.
The faces of the zonohedron are either parallelograms,
or <em>compound faces</em> that can be partitioned into parallelograms.
The centers of all these parallelograms are the canonical optimal colors.
<br>
The optimal spectra take value 1/2 at the 2 given wavelengths, and 0 or 1 elsewhere.
If the 2 wavelengths are <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>,
and <code class="reqn">\lambda_1 &lt; \lambda_2</code> then the spectrum is approximately a bandpass filter.
If the 2 wavelengths are swapped, then the spectrum is "flipped"
and is approximately a bandstop filter.
</p>


<h3>Value</h3>

<p>If argument <code>spectral=FALSE</code>,
<code>canonicalOptimalColors()</code> returns a <code>data.frame</code> with a row for each row in <code>lambda</code>.
The columns in the output are:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the given matrix argument <code>lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimal</code></td>
<td>

<p>the computed optimal colors - an Mx3 matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transitions</code></td>
<td>
<p>the number of transitions in the optimal spectrum, this is a positive even number</p>
</td>
</tr>
</table>
<p>If <code>rownames(lambda)</code> is not <code>NULL</code>, they are copied to the row names of the output.
</p>
<p>If argument <code>spectral=TRUE</code>,
it returns a <b>colorSpec</b> object with quantity 
<code>'transmittance'</code>.
This object contains the optimal spectra,
and the above-mentioned <code>data.frame</code> can then be obtained by applying
<code>extradata()</code> to the returned object.
</p>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Centore, Paul.
<em>A zonohedral approach to optimal colours</em>.
<b>Color Research &amp; Application</b>.
Vol. 38.
No. 2.
pp. 110-119.
April 2013.
</p>
<p>Logvinenko, A. D.
An object-color space. 
<b>Journal of Vision</b>.
9(11):5, 1-23, (2009).<br><code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>
doi:10.1167/9.11.5.
</p>
<p>Schrödinger, E. (1920). 
Theorie der Pigmente von grösster Leuchtkraft. 
<b>Annalen der Physik</b>.
62, 603-622.
</p>
<p>West, G. and M. H. Brill.
Conditions under which Schrödinger object colors are optimal.
<b>Journal of the Optical Society of America</b>.
73. pp. 1223-1225. 1983.
</p>


<h3>See Also</h3>

<p><code>probeOptimalColors()</code>,
<code>bandRepresentation()</code>,
<code>scanner.ACES</code>,
<code>extradata()</code>,
<code>type</code>,
vignette <a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">wave    = seq(400,700,by=5)
D50.eye = product( D50.5nm, 'material', xyz1931.1nm, wavelength=wave )
canonicalOptimalColors( D50.eye, c(500,600, 550,560, 580,585) )
##    lambda.1 lambda.2   optimal.x   optimal.y   optimal.z transitions
##  1      500      600 47.02281830 80.07281030  4.33181530           2
##  2      550      560  5.18490614 10.09045773  0.06121505           2
##  3      580      585 26.91247649 21.49031008  0.03457904           6
</code></pre>


</div>