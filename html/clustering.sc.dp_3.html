<div class="container">

<table style="width: 100%;"><tr>
<td>findwithinss.sc.dp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Finding Optimal Withinss in Clustering Multidimensional Data with Sequential Constraint by Dynamic Programming
</h2>

<h3>Description</h3>

<p>Performs the main step of clustering multidimensional data with sequential constraint by a dynamic programming approach guaranteeing optimality. 
It returns the minimum <var>withinss</var> for each number of clusters less than or equal to <code>k</code> and backtracking data that can be used to find quickly the optimal clustering for a specific cluster number. This function was created in order to support the case when the number of clusters is unknown in advance. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">findwithinss.sc.dp(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>	a multi-dimensional array containing input data to be clustered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>	the maximal number of clusters, the output will be generated for cluster numbers between 1 and <code>k</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Method <code>clustering.sc.dp()</code> is split into two methods (<code>findwithinss.sc.dp()</code> and <code>backtracking.sc.dp()</code>) in order to support the case when the number of clusters is not known in advance. Method <code>findwithinss.sc.dp()</code> returns the minimal sum of squares of within-cluster distances (<var>withinss</var>) for each number of clusters less than or equal to <code>k</code> and the backtrack data which can be used to quickly determine the optimal clustering for a specific cluster number. The returned <var>withinss</var> are guaranteed to be optimal among the solutions where only subsequent items form a cluster. 
</p>
<p>The outputs of the method can be used to select the proper number of clusters. The user may analyse the <var>withinss</var> in order to select the proper number of clusters. Another option is to run <code>findwithinss.sc.dp()</code> once, repeat the <code>backtracking.sc.dp()</code> step for a range of potential cluster numbers and then the user may evaluate the optimal solutions created for different number of clusters. This requires much less time than repeating the whole clustering algorithm. 
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>twithinss</code></td>
<td>
<p> a vector of total within-cluster sums of the optimal clusterings for each number of clusters less than or equal to <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backtrack</code></td>
<td>
<p> backtrack data used by <code>backtracking.sc.dp()</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Tibor Szkaliczki <a href="mailto:szkaliczki.tibor@sztaki.hu">szkaliczki.tibor@sztaki.hu</a>
</p>


<h3>See Also</h3>

<p><code>clustering.sc.dp</code>, <code>backtracking.sc.dp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example: clustering data generated from a random walk with small withinss
x&lt;-matrix(, nrow = 100, ncol = 2)
x[1,]&lt;-c(0,0)
for(i in 2:100) {
  x[i,1]&lt;-x[i-1,1] + rnorm(1,0,0.1)
  x[i,2]&lt;-x[i-1,2] + rnorm(1,0,0.1)
}
k&lt;-10
r&lt;-findwithinss.sc.dp(x,k)

# select the first cluster number where withinss drops below a threshold
thres &lt;- 5.0
k_th &lt;- 1;
while(r$twithinss[k_th] &gt; thres &amp; k_th &lt; k) {
    k_th &lt;- k_th + 1
}

# backtrack
result&lt;-backtracking.sc.dp(x,k_th, r$backtrack)
plot(x, type = 'b', col = result$cluster)
points(result$centers, pch = 24, bg = (1:k_th))
</code></pre>


</div>