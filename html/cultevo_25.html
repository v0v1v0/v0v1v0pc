<div class="container">

<table style="width: 100%;"><tr>
<td>ssm.compositionality</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find a segmentation that maximises the overall string coverage across all signals.</h2>

<h3>Description</h3>

<p>This algorithm builds on Spike's measure of compositionality (see
<code>sm.compositionality</code>), except instead of simply determining
which segment(s) have the highest mutual predictability for each
meaning feature separately, it attempts to find a combination of
non-overlapping segments for each feature that maximises the overall string
coverage over all signals. In other words, it tries to find a segmentation
which can account for (or 'explain') as much of the string material in the
signals as possible.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssm.compositionality(x, y, groups = NULL)

ssm.segmentation(x, y, mergefeatures = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a list or vector of character sequences</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a matrix or data frame with as many rows as there are
strings (see section Meaning data format)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>a list or vector with as many items as strings, used to split
the signals and meanings into data sets for which the compositionality
measures are computed separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mergefeatures</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>ssm.segmentation</code> will
try to improve on the initial solution by incrementally merging pairs of
meaning features as long as doing so improves the overall string coverage
of the segmentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical: if <code>TRUE</code>, messages detailed information about
the number of segment combinations considered for every coverage computed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For large data sets and long strings, this computation can get very slow.
If the attested signals are such that no perfect segmentation is possible,
this algorithm is not guaranteed to find any segmentation (as no such
segmentation might exist).
</p>


<h3>See Also</h3>

<p><code>sm.compositionality</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ssm.segmentation(c("as", "bas", "basf"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))


# signaling system where one meaning distinction is not encoded in the signals
print(threebytwoanimals &lt;- enumerate.meaningcombinations(list(animal=c("dog", "cat", "tiger"),
  colour=c("col1", "col2"))))

ssm.segmentation(c("greendog", "bluedog", "greenfeline", "bluefeline", "greenfeline", "bluefeline"),
  threebytwoanimals)

# the same analysis again, but allow merging of features
ssm.segmentation(c("greendog", "bluedog", "greenfeline", "bluefeline", "greenfeline", "bluefeline"),
  threebytwoanimals, mergefeatures=TRUE)
</code></pre>


</div>