<div class="container">

<table style="width: 100%;"><tr>
<td>plotcpfa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot Optimal Model from Classification with Parallel Factor Analysis
</h2>

<h3>Description</h3>

<p>Plots optimal model based on results from a 'wrapcpfa' object obtained using function <code>cpfa</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotcpfa(object, cmeasure = "acc", meanvalue = TRUE, supNum = FALSE, 
         parallel = FALSE, cl = NULL, scale.remode = NULL, newscales = 1, 
         scale.abmode = NULL, sign.remode = NULL, newsigns = 1, 
         sign.abmode = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>An object of class 'wrapcpfa' from function <code>cpfa</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmeasure</code></td>
<td>

<p>Classification performance measure used to select the optimal number of components. Options include <code>c("err", "acc", "tpr", "fpr", "tnr", "fnr", "ppv", "npv", "fdr", "fom", "fs")</code>. If <code>cmeasure</code> is in <code>c("err", "fpr", "fnr", "fdr", "fom")</code>, the number of components that minimized <code>cmeasure</code> is selected among all classification methods. Otherwise, the number that maximized <code>cmeasure</code> is selected.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanvalue</code></td>
<td>

<p>Logical indicating whether to find the optimal number of components based on the mean performance across replications from the results generated by <code>cpfa</code>. If <code>meanvalue = FALSE</code>, the median is used. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supNum</code></td>
<td>

<p>Logical indicating whether to suppress text displaying component weight values within plot cells. If TRUE, values are not displayed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>

<p>Logical indicating if parallel computing should be implemented. If TRUE, parallel computing is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>Cluster for parallel computing, which is used when <code>parallel = TRUE</code>. Note that if <code>parallel = TRUE</code> and <code>cl = NULL</code>, then the cluster is defined as <code>makeCluster(detectCores())</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.remode</code></td>
<td>

<p>Character that indicates a mode to rescale. Must be one of <code>c("A", "B", "C", "D")</code>. Sent directly to argument <code>mode</code> in function <code>rescale</code> from package <b>multiway</b>. See help file for <code>rescale</code> for additional details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newscales</code></td>
<td>

<p>The root mean-square for columns of the mode indicated by <code>scale.remode</code>. See help file for <code>rescale</code> for additional details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.abmode</code></td>
<td>

<p>Character that indicates the mode that absorbs the inverse of rescalings applied to the mode indicated by <code>scale.remode</code>. Must be one of <code>c("A", "B", "C", "D")</code>. Sent directly to argument <code>absorb</code> in function <code>rescale</code> from package <b>multiway</b>. See help file for <code>rescale</code> for additional details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign.remode</code></td>
<td>

<p>Character that indicates a mode to resign. Must be one of <code>c("A", "B", "C", "D")</code>. Sent directly to argument <code>mode</code> in function <code>resign</code> from package <b>multiway</b>. See help file for <code>resign</code> for additional details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newsigns</code></td>
<td>

<p>Scalar or vector indicating resignings for columns of the mode indicated by <code>sign.remode</code>. See help file for <code>resign</code> for additional details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign.abmode</code></td>
<td>

<p>Character that indicates the mode that absorbs the negation of the resignings applied to the mode indicated by <code>sign.remode</code>. Must be one of <code>c("A", "B", "C", "D")</code>. Sent directly to argument <code>absorb</code> in function <code>resign</code> from package <b>multiway</b>. See help file for <code>resign</code> for additional details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments to be passed to function <code>parafac</code> for fitting a Parafac model or function <code>parafac2</code> for fitting a Parafac2 model. See help file for function <code>parafac</code> or for function <code>parafac2</code> for additional details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Selects the number of components that optimized a performance measure across all classification methods used by <code>cpfa</code>. With this optimal number of components, fits the Parafac or Parafac2 model that was used by <code>cpfa</code> to create the input 'wrapcpfa' object. Uses same constraints used in <code>cpfa</code>. Plots component weights for this optimal model using heatmaps. Darker red indicates component weights that are more negative while darker green indicates component weights that are more positive. For three-way Parafac, plots A and B weights. For four-way Parafac, plots A, B, and C weights. For three-way Parafac2, plots B weights. For four-way Parafac2, plots B and C weights.
</p>


<h3>Value</h3>

<p>Returns one or more heatmap plots of component weights for the optimal Parafac or Parafac2 model. Returns list of estimated component weights used in the plots.
</p>


<h3>Author(s)</h3>

<p>Matthew Snodgress &lt;snodg031@umn.edu&gt;
</p>


<h3>References</h3>

<p>See help file for function <code>cpfa</code> for a list of references.
</p>


<h3>Examples</h3>

<pre><code class="language-R">########## Parafac2 example with 4-way array and multiclass response ##########

# set seed and specify dimensions of a four-way tensor
set.seed(5)
mydim &lt;- c(10, 11, 12, 100)
nf &lt;- 3

# create correlation matrix between response and fourth mode's weights 
rho.dd &lt;- .35 
rho.dy &lt;- .75 
cormat.values &lt;- c(1, rho.dd, rho.dd, rho.dy, rho.dd, 1, rho.dd, rho.dy, 
                   rho.dd, rho.dd, 1, rho.dy, rho.dy, rho.dy, rho.dy, 1)
cormat &lt;- matrix(cormat.values, nrow = (nf + 1), ncol = (nf + 1))

# sample from a multivariate normal with specified correlation structure
ymean &lt;- Dmean &lt;- 2
mu &lt;- as.matrix(c(Dmean, Dmean, Dmean, ymean))
eidecomp &lt;- eigen(cormat, symmetric = TRUE)
L.sqrt &lt;- diag(eidecomp$values^0.5)
cormat.sqrt &lt;- eidecomp$vectors %*% L.sqrt %*% t(eidecomp$vectors)
Z &lt;- matrix(rnorm(mydim[4] * (nf + 1)), nrow = mydim[4], ncol = (nf + 1))
Xw &lt;- rep(1, mydim[4]) %*% t(mu) + Z %*% cormat.sqrt
Dmat &lt;- Xw[, 1:nf]

# create a random four-way data tensor with D weights related to a response
Bmat &lt;- matrix(runif(mydim[2] * nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3] * nf), nrow = mydim[3], ncol = nf)
nDd &lt;- rep(c(10, 12, 14), length.out = mydim[4])
Gmat &lt;- matrix(rnorm(nf * nf), nrow = nf)
Amat &lt;- vector("list", mydim[4])
X &lt;- Xmat &lt;- Emat &lt;- Amat
for (Dd in 1:mydim[4]) {
   Amat[[Dd]] &lt;- matrix(nf * rnorm(nDd[Dd]), nrow = nDd[Dd], ncol = nf)
   Amat[[Dd]] &lt;- svd(Amat[[Dd]], nv = 0)$u %*% Gmat
   leftMat &lt;- Amat[[Dd]] %*% diag(Dmat[Dd,])
   Xmat[[Dd]] &lt;- array(tcrossprod(leftMat, krprod(Cmat, Bmat)), 
                       dim = c(nDd[Dd], mydim[2], mydim[3]))
   Emat[[Dd]] &lt;- array(rnorm(nDd[Dd] * mydim[2] * mydim[3]), 
                       dim = c(nDd[Dd], mydim[2], mydim[3]))
   X[[Dd]] &lt;- Xmat[[Dd]] + Emat[[Dd]]
}

# create a multiclass response
stor &lt;- matrix(rep(1, nrow(Xw)), nrow = nrow(Xw))
stor[which(Xw[, (nf + 1)] &lt; (ymean - 0.4 * sd(Xw[, (nf + 1)])))] &lt;- 2
stor[which(Xw[, (nf + 1)] &gt; (ymean + 0.4 * sd(Xw[, (nf + 1)])))] &lt;- 0
y &lt;- factor(stor)

# initialize
alpha &lt;- seq(0, 1, length = 2)
gamma &lt;- c(0, 1)
cost &lt;- c(0.1, 5)
rda.alpha &lt;- seq(0.1, 0.9, length = 2)
delta &lt;- c(0.1, 2)
method &lt;- c("PLR", "SVM", "RDA")
family &lt;- "multinomial"
parameters &lt;- list(alpha = alpha, gamma = gamma, cost = cost, 
                   rda.alpha = rda.alpha, delta = delta)
model &lt;- "parafac2"
nfolds &lt;- 3
nstart &lt;- 1

# constrain first mode weights to be orthogonal, fourth mode to be nonnegative
const &lt;- c("orthog", "uncons", "uncons", "nonneg")

# fit Parafac2 model and use fourth mode weights to tune classification
# methods, to predict class labels, and to return classificaiton 
# performance measures pooled across multiple train-test splits
output &lt;- cpfa(x = X, y = y, model = model, nfac = nf, nrep = 2, ratio = 0.8, 
               nfolds = nfolds, method = method, family = family, 
               parameters = parameters, type.out = "descriptives", 
               seeds = NULL, plot.out = TRUE, parallel = FALSE, const = const,
               nstart = nstart, ctol = 1e-2)

# plot heatmap of component weights for optimal model
plotcpfa(output, nstart = nstart, ctol = 1e-2)
</code></pre>


</div>