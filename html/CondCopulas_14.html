<div class="container">

<table style="width: 100%;"><tr>
<td>CKT.KendallReg.LambdaCV</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kendall's regression: choice of the penalization parameter by K-folds cross-validation</h2>

<h3>Description</h3>

<p>In this model, three variables <code class="reqn">X_1</code>, <code class="reqn">X_2</code> and <code class="reqn">Z</code> are observed.
We try to model the conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally
to <code class="reqn">Z=z</code>, as follows:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda(\tau_{X_1, X_2 | Z = z})
= \sum_{i=1}^{p'} \beta_i \psi_i(z),</code>
</p>

<p>where <code class="reqn">\tau_{X_1, X_2 | Z = z}</code> is the conditional Kendall's tau
between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally to <code class="reqn">Z=z</code>,
<code class="reqn">\Lambda</code> is a function from <code class="reqn">]-1, 1[]</code> to <code class="reqn">R</code>,
<code class="reqn">(\beta_1, \dots, \beta_p)</code> are unknown coefficients to be estimated
and <code class="reqn">\psi_1, \dots, \psi_{p'})</code> are a dictionary of functions.
To estimate <code class="reqn">beta</code>, we used the penalized estimator which is defined
as the minimizer of the following criteria
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2n'} \sum_{i=1}^{n'} [\Lambda(\hat\tau_{X_1, X_2 | Z = z})
- \sum_{j=1}^{p'} \beta_j \psi_j(z)]^2 + \lambda * |\beta|_1.</code>
</p>

<p>This function chooses the penalization parameter <code class="reqn">lambda</code>
by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CKT.KendallReg.LambdaCV(
  X1 = NULL,
  X2 = NULL,
  Z = NULL,
  ZToEstimate,
  designMatrixZ = cbind(ZToEstimate, ZToEstimate^2, ZToEstimate^3),
  typeEstCKT = 4,
  h_lambda,
  Lambda = identity,
  kernel.name = "Epa",
  Kfolds_lambda = 10,
  l_norm = 1,
  matrixSignsPairs = NULL,
  progressBars = "global",
  observedX1 = NULL,
  observedX2 = NULL,
  observedZ = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p>a vector of n observations of the first variable <code class="reqn">X_1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>a vector of n observations of the second variable <code class="reqn">X_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>a vector of n observations of the conditioning variable,
or a matrix with n rows of observations of the conditioning vector
(if <code class="reqn">Z</code> is multivariate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZToEstimate</code></td>
<td>
<p>the new data of observations of Z at which
the conditional Kendall's tau should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>designMatrixZ</code></td>
<td>
<p>the transformation of the ZToEstimate that
will be used as predictors. By default, no transformation is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h_lambda</code></td>
<td>
<p>the smoothing bandwidth used in the cross-validation
procedure to choose <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>the function to be applied on conditional Kendall's tau.
By default, the identity function is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.name</code></td>
<td>
<p>name of the kernel. Possible choices are
"Gaussian" (Gaussian kernel) and "Epa" (Epanechnikov kernel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kfolds_lambda</code></td>
<td>
<p>the number of folds used in the cross-validation
procedure to choose <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l_norm</code></td>
<td>
<p>type of norm used for selection of the optimal lambda.
l_norm=1 corresponds to the sum of absolute values of differences
between predicted and estimated conditional Kendall's tau
while l_norm=2 corresponds to the sum of squares of differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrixSignsPairs</code></td>
<td>
<p>the results of a call to
<code>computeMatrixSignPairs</code> (if already computed).
If <code>NULL</code> (the default value), the <code>matrixSignsPairs</code>
will be computed again from the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressBars</code></td>
<td>
<p>should progress bars be displayed?
Possible values are
</p>

<ul>
<li> <p><code>"none"</code>: no progress bar at all.
</p>
</li>
<li> <p><code>"global"</code>: only one global progress bar (default behavior)
</p>
</li>
<li> <p><code>"eachStep"</code>: uses a global progress bar + one progress bar
for each kernel smoothing step.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observedX1, observedX2, observedZ</code></td>
<td>
<p>old parameter names for <code>X1</code>,
<code>X2</code>, <code>Z</code>. Support for this will be removed at a later version.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following components
</p>

<ul>
<li> <p><code>lambdaCV</code>: the chosen value of the
penalization parameters <code>lambda</code>.
</p>
</li>
<li> <p><code>vectorLambda</code>: a vector containing the values of
<code>lambda</code> that have been compared.
</p>
</li>
<li> <p><code>vectorMSEMean</code>: the estimated MSE for each value of
<code>lambda</code> in <code>vectorLambda</code>
</p>
</li>
<li> <p><code>vectorMSESD</code>: the estimated standard deviation of the
MSE for each <code>lambda</code>. It can be used to construct confidence
intervals for estimates of the MSE given by <code>vectorMSEMean</code>.
</p>
</li>
</ul>
<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2020).
On Kendallâ€™s regression.
Journal of Multivariate Analysis, 178, 104610.
</p>


<h3>See Also</h3>

<p>the main fitting function <code>CKT.kendallReg.fit</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># We simulate from a conditional copula
set.seed(1)
N = 400
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2, 10, by = 0.1)
result &lt;- CKT.KendallReg.LambdaCV(X1 = X1, X2 = X2, Z = Z,
                                  ZToEstimate = newZ, h_lambda = 2)

plot(x = result$vectorLambda, y = result$vectorMSEMean,
     type = "l", log = "x")

</code></pre>


</div>