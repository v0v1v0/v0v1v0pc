<div class="container">

<table style="width: 100%;"><tr>
<td>enlist_contrasts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>List of contrast matrices</h2>

<h3>Description</h3>

<p>Returns a named list of contrast matrices to use with modeling
functions directly. See <code>set_contrasts()</code> for a function
to set contrasts directly to the dataframe. See details for syntax
information
</p>


<h3>Usage</h3>

<pre><code class="language-R">enlist_contrasts(model_data, ..., verbose = getOption("contrastable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model_data</code></td>
<td>
<p>Data frame you intend on passing to your model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>A series of 2 sided formulas with factor name on the left hand
side and desired contrast scheme on the right hand side. The reference
level can be set with <code>+</code>, the intercept can be overwritten with <code>*</code>,
comparison labels can be set using <code>|</code>, and trends for polynomial coding
can be removed using <code>-</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, defaults to FALSE, whether messages should be printed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>enlist_contrasts()</code>, <code>set_contrasts()</code>,
and <code>glimpse_contrasts()</code> use special syntax to set
contrasts for multiple factors. The syntax consists of two-sided formulas
with the desired factor column on the left hand side and the contrast
specification on the right hand side. For example, <code>varname ~ scaled_sum_code</code>. Many contrasts support additional kinds of contrast
manipulations using overloaded operators:
</p>

<ul>
<li> <p><code>+ X</code>: Set the reference level to the level named X. Only supported for
schemes that have a singular reference level such as
<code>sum_code()</code>, <code>scaled_sum_code()</code>,
<code>treatment_code()</code>, <code>stats::contr.treatment()</code>,
<code>stats::contr.sum()</code>, <code>stats::contr.SAS()</code>. Ignored for schemes like
<code>helmert_code()</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠* X⁠</code>: Overwrite the intercept to the mean of the level named X
</p>
</li>
<li> <p><code>- A:B</code>: For polynomial coding schemes only, drop comparisons A through B.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠| c(...)⁠</code>: Change the comparison labels for the contrast matrix to the
character vector <code>c(...)</code> of length <code>n-1</code>. These labels will appear in the
output/summary of a statistical model. Note that for <code>brms::brm</code>,
instances of <code>-</code> (a minus sign) are replaced with <code>M</code>.
</p>
</li>
</ul>
<p>You can also specify multiple variables on the left hand side of a formula
using tidyselect helpers. See examples for more information.
</p>
<p>Typically model functions like lm will have a contrasts argument where you
can set the contrasts at model run time, rather than having to manually
change the contrasts on the underlying factor columns in your data. This
function will return such a named list of contrast matrices to pass to these
functions. Note that this function should not be used within a modeling
function call, e.g., <code>lm(y~x, data = model_data, contrasts =
enlist_contrasts(model_data, x~sum_code))</code>. Often, this will call
<code>enlist_contrasts</code> twice, rather than just once.
</p>
<p>For some model fitting functions, like <code>brms::brm</code>, there is no
contrasts argument. For such cases, use <code>set_contrasts()</code> to
set contrasts directly to the factors in a dataframe.
</p>
<p>One good way to use <code>enlist_contrasts()</code> is in conjunction
with <code>MASS::fractions()</code> to create a list of matrices that can be printed
to explicitly show the entire contrast matrices you're using for your models.
This can be especially helpful for supplementary materials in an academic
paper.
</p>
<p>Sometimes when using orthogonal polynomial contrasts from
<code>stats::contr.poly()</code> people will drop higher level polynomials for
parsimony. Note however that these do capture some amount of variation, so
even though they're orthogonal contrasts the lower level polynomials will
have their estimates changed. Moreover, you cannot reduce a contrast matrix
to a matrix smaller than size n*n-1 in the dataframe you pass to a model
fitting function itself, as R will try to fill in the gaps with something
else. If you want to drop contrasts you'll need to use something like
<code>enlist_contrasts(df, x ~ contr.poly - 3:5)</code> and pass this to the
<code>contrasts</code> argument in the model fitting function.
</p>


<h3>Value</h3>

<p>List of named contrast matrices. Internally, if called within
set_contrasts, will return a named list with <code>contrasts</code> equal to the list
of named contrast matrices and <code>data</code> equal to the passed <code>model_data</code> with
any factor coercions applied (so that <code>set_contrasts()</code> doesn't need to do
it a second time).
</p>


<h3>See Also</h3>

<p><code>set_contrasts()</code> <code>glimpse_contrasts()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">my_df &lt;- mtcars
my_df$gear &lt;- factor(my_df$gear)
my_df$carb &lt;- factor(my_df$carb)

# Use formulas where left hand side is the factor column name
# and the right hand side is the contrast scheme you want to use
enlist_contrasts(
  my_df,
  gear ~ scaled_sum_code,
  carb ~ helmert_code,
  verbose = FALSE
)

# Add reference levels with +
enlist_contrasts(
  my_df,
  gear ~ scaled_sum_code + 5,
  carb ~ contr.sum + 6,
  verbose = FALSE
)
# Manually specifying matrix also works
enlist_contrasts(
  my_df,
  gear ~ matrix(c(1, -1, 0, 0, -1, 1), nrow = 3),
  carb ~ forward_difference_code,
  verbose = FALSE
)

# User matrices can be assigned to a variable first, but this may make the
# comparison labels confusing. You should rename them manually to something
# that makes sense. This will invoke use_contrast_matrix, so reference levels
# specified with + will be ignored.
my_gear_contrasts &lt;- matrix(c(1, -1, 0, 0, -1, 1), nrow = 3)
colnames(my_gear_contrasts) &lt;- c("CMP1", "CMP2")
enlist_contrasts(
  my_df,
  gear ~ my_gear_contrasts,
  carb ~ forward_difference_code,
  verbose = FALSE
)


# Will inform you if there are factors you didn't set
enlist_contrasts(my_df, gear ~ scaled_sum_code)

# Use MASS::fractions to pretty print matrices for academic papers:
lapply(enlist_contrasts(my_df, gear ~ scaled_sum_code, carb ~ helmert_code),
       MASS::fractions)

# Use a list of formulas to use the same contrasts with different datasets
my_contrasts &lt;- list(gear ~ scaled_sum_code, carb ~ helmert_code)
enlist_contrasts(my_df,  my_contrasts)
enlist_contrasts(mtcars, my_contrasts)

# Use tidyselect helpers to set multiple variables at once
# These are all equivalent
contr_list1 &lt;- enlist_contrasts(mtcars,
                 cyl ~ sum_code, gear ~ sum_code,
                 verbose = FALSE)

contr_list2 &lt;- enlist_contrasts(mtcars,
                 cyl + gear ~ sum_code,
                 verbose = FALSE)

contr_list3 &lt;- enlist_contrasts(mtcars,
                 c(cyl, gear) ~ sum_code,
                 verbose = FALSE)

contr_list4 &lt;- enlist_contrasts(mtcars,
                 all_of(c('cyl', 'gear')) ~ sum_code,
                 verbose = FALSE)


these_vars &lt;- c("cyl", "gear")
contr_list5 &lt;- enlist_contrasts(mtcars,
                                all_of(these_vars) ~ sum_code,
                                verbose = FALSE)

all.equal(contr_list1, contr_list2)
all.equal(contr_list2, contr_list3)
all.equal(contr_list3, contr_list4)
all.equal(contr_list4, contr_list5)

# You can also use [tidyselect::where()] with class checking helpers:
contr_list6 &lt;- enlist_contrasts(mtcars,
                                where(is.numeric) ~ sum_code,
                                verbose = FALSE)

# Each variable name must only be set ONCE, e.g. these will fail:
try(enlist_contrasts(mtcars,
                     cyl ~ sum_code,
                     cyl ~ scaled_sum_code,
                     verbose = FALSE))
try(enlist_contrasts(mtcars,
                     cyl ~ sum_code,
                     all_of(these_vars) ~ scaled_sum_code,
                     verbose = FALSE))
try(enlist_contrasts(mtcars,
                     cyl ~ sum_code,
                     where(is.numeric) ~ scaled_sum_code,
                     verbose = FALSE))
</code></pre>


</div>