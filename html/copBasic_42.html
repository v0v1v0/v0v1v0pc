<div class="container">

<table style="width: 100%;"><tr>
<td>EMPIRgridderinv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Derivative Inverses of the Grid of the Bivariate Empirical Copula for V with respect to U</h2>

<h3>Description</h3>

<p>Generate a gridded representation of the inverse of the derivatives of the <em>bivariate empirical copula</em> of <code class="reqn">V</code> with respect to <code class="reqn">U</code>.  This function is the empirical analog to <code>derCOPinv</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">EMPIRgridderinv(empgrid=NULL, kumaraswamy=FALSE, dergrid=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>empgrid</code></td>
<td>
<p>The grid from <code>EMPIRgrid</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kumaraswamy</code></td>
<td>
<p>A logical to trigger Kumaraswamy smoothing of the conditional quantile function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dergrid</code></td>
<td>
<p>The results of <code>EMPIRgridder</code> and if left <code>NULL</code> then that function is called internally. There is some fragility at times in the quality of the numerical derivative and the author has provided this argument so that the derivative can be computed externally and then fed to this inversion function; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The gridded values of the inverse of the derivative of <code class="reqn">V</code> with respect <code class="reqn">U</code>.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>See Also</h3>

<p><code>EMPIRcop</code>, <code>EMPIRcopdf</code>, <code>EMPIRgrid</code>, <code>EMPIRgridder2</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
uv &lt;- simCOP(n=10000, cop=PSP, ploton=FALSE, points=FALSE)
fakeU &lt;- lmomco::pp(uv[,1], sort=FALSE)
fakeV &lt;- lmomco::pp(uv[,2], sort=FALSE)
uv &lt;- data.frame(U=fakeU, V=fakeV)

uv.grid &lt;- EMPIRgrid(para=uv, deluv=.1) # CPU hungry
uv.inv1 &lt;- EMPIRgridderinv(empgrid=uv.grid)
uv.inv2 &lt;- EMPIRgridderinv2(empgrid=uv.grid)
plot(uv, pch=16, col=rgb(0,0,0,.1), xlim=c(0,1), ylim=c(0,1),
     xlab="U, NONEXCEEDANCE PROBABILITY", ylab="V, NONEXCEEDANCE PROBABILITY")
lines(qua.regressCOP(f=0.5, cop=PSP), col=2)
lines(qua.regressCOP(f=0.2, cop=PSP), col=2)
lines(qua.regressCOP(f=0.7, cop=PSP), col=2)
lines(qua.regressCOP(f=0.1, cop=PSP), col=2)
lines(qua.regressCOP(f=0.9, cop=PSP), col=2)

med.wrtu &lt;- EMPIRqua.regress(f=0.5, empinv=uv.inv1)
lines(med.wrtu, col=2, lwd=4)
qua.wrtu &lt;- EMPIRqua.regress(f=0.2, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=2)
qua.wrtu &lt;- EMPIRqua.regress(f=0.7, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=2)
qua.wrtu &lt;- EMPIRqua.regress(f=0.1, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=4)
qua.wrtu &lt;- EMPIRqua.regress(f=0.9, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=4)

lines(qua.regressCOP2(f=0.5, cop=PSP), col=4)
lines(qua.regressCOP2(f=0.2, cop=PSP), col=4)
lines(qua.regressCOP2(f=0.7, cop=PSP), col=4)
lines(qua.regressCOP2(f=0.1, cop=PSP), col=4)
lines(qua.regressCOP2(f=0.9, cop=PSP), col=4)

med.wrtv &lt;- EMPIRqua.regress2(f=0.5, empinv=uv.inv2)
lines(med.wrtv, col=4, lwd=4)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.2, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=2)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.7, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=2)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.1, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=4)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.9, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=4)#
## End(Not run)

## Not run: 
# Now try a much more complex shape
para   &lt;- list(alpha=0.15,  beta=0.65, cop1=PLACKETTcop, cop2=PLACKETTcop,
               para1=0.005, para2=1000)
uv &lt;- simCOP(n=30000, cop=composite2COP, para=para)
fakeU &lt;- lmomco::pp(uv[,1], sort=FALSE)
fakeV &lt;- lmomco::pp(uv[,2], sort=FALSE)
uv &lt;- data.frame(U=fakeU, V=fakeV)

uv.grid &lt;- EMPIRgrid(para=uv, deluv=0.05) # CPU hungry
uv.inv1 &lt;- EMPIRgridderinv(empgrid=uv.grid)
uv.inv2 &lt;- EMPIRgridderinv2(empgrid=uv.grid)
plot(uv, pch=16, col=rgb(0,0,0,0.1), xlim=c(0,1), ylim=c(0,1),
     xlab="U, NONEXCEEDANCE PROBABILITY", ylab="V, NONEXCEEDANCE PROBABILITY")
lines(qua.regressCOP(f=0.5, cop=composite2COP, para=para), col=2)
lines(qua.regressCOP(f=0.2, cop=composite2COP, para=para), col=2)
lines(qua.regressCOP(f=0.7, cop=composite2COP, para=para), col=2)
lines(qua.regressCOP(f=0.1, cop=composite2COP, para=para), col=2)
lines(qua.regressCOP(f=0.9, cop=composite2COP, para=para), col=2)

med.wrtu &lt;- EMPIRqua.regress(f=0.5, empinv=uv.inv1)
lines(med.wrtu, col=2, lwd=4)
qua.wrtu &lt;- EMPIRqua.regress(f=0.2, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=2)
qua.wrtu &lt;- EMPIRqua.regress(f=0.7, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=2)
qua.wrtu &lt;- EMPIRqua.regress(f=0.1, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=4)
qua.wrtu &lt;- EMPIRqua.regress(f=0.9, empinv=uv.inv1)
lines(qua.wrtu, col=2, lwd=2, lty=4)

lines(qua.regressCOP2(f=0.5, cop=composite2COP, para=para), col=4)
lines(qua.regressCOP2(f=0.2, cop=composite2COP, para=para), col=4)
lines(qua.regressCOP2(f=0.7, cop=composite2COP, para=para), col=4)
lines(qua.regressCOP2(f=0.1, cop=composite2COP, para=para), col=4)
lines(qua.regressCOP2(f=0.9, cop=composite2COP, para=para), col=4)

med.wrtv &lt;- EMPIRqua.regress2(f=0.5, empinv=uv.inv2)
lines(med.wrtv, col=4, lwd=4)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.2, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=2)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.7, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=2)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.1, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=4)
qua.wrtv &lt;- EMPIRqua.regress2(f=0.9, empinv=uv.inv2)
lines(qua.wrtv, col=4, lwd=2, lty=4)#
## End(Not run)
</code></pre>


</div>