<div class="container">

<table style="width: 100%;"><tr>
<td>cate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The main function for confounder adjusted testing</h2>

<h3>Description</h3>

<p>The main function for confounder adjusted testing
</p>


<h3>Usage</h3>

<pre><code class="language-R">cate(
  formula,
  X.data = NULL,
  Y,
  r,
  fa.method = c("ml", "pc", "esa"),
  adj.method = c("rr", "nc", "lqs", "naive"),
  psi = psi.huber,
  nc = NULL,
  nc.var.correction = TRUE,
  calibrate = TRUE
)

cate.fit(
  X.primary,
  X.nuis = NULL,
  Y,
  r,
  fa.method = c("ml", "pc", "esa"),
  adj.method = c("rr", "nc", "lqs", "naive"),
  psi = psi.huber,
  nc = NULL,
  nc.var.correction = TRUE,
  calibrate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula indicating the known covariates including both primary variables and nuisance variables, which are seperated by <code>|</code>. The variables before <code>|</code> are primary variables and the variables after <code>|</code> are nuisance variables. It's OK if there is no nuisance variables, then <code>|</code> is not needed and <code>formula</code> becomes a typical formula with all the covariates considered primary. When there is confusion about where the intercept should be put, <code>cate</code> will include it in X.nuis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.data</code></td>
<td>
<p>the data frame used for <code>formula</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>outcome, n*p matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of latent factors, can be estimated using the function <code>est.confounder.num</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fa.method</code></td>
<td>
<p>factor analysis method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.method</code></td>
<td>
<p>adjustment method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>derivative of the loss function in robust regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>position of the negative controls,
if d0 &gt; 1, this should be a matrix with 2 columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc.var.correction</code></td>
<td>
<p>correct asymptotic variance based on our formula</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calibrate</code></td>
<td>
<p>if TRUE, use the Median and the Mean Absolute Deviation(MAD) to calibrate the test statistics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.primary</code></td>
<td>
<p>primary variables, n*d0 matrix or data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.nuis</code></td>
<td>
<p>nuisance covarites, n*d1 matrix</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Ideally <code>nc</code> can either be a vector of numbers between 1 and p, if d0 = 1 or the negative controls are the same for every treatment variable, or a 2-column matrix specifying which positions of beta are known to be zero. But this is yet implemented.
</p>


<h3>Value</h3>

<p>a list of objects
</p>

<dl>
<dt>alpha</dt>
<dd>
<p>estimated alpha, r*d1 matrix</p>
</dd>
<dt>alpha.p.value</dt>
<dd>
<p>asymptotic p-value for the global chi squared test of alpha, a vector of length d1</p>
</dd>
<dt>beta</dt>
<dd>
<p>estimated beta, p*d1 matrix</p>
</dd>
<dt>beta.cov.row</dt>
<dd>
<p>estimated row covariance of <code>beta</code>, a length p vector</p>
</dd>
<dt>beta.cov.col</dt>
<dd>
<p>estimated column covariance of <code>beta</code>, a d1*d1 matrix</p>
</dd>
<dt>beta.t</dt>
<dd>
<p>asymptotic z statistics for <code>beta</code></p>
</dd>
<dt>beta.p.value</dt>
<dd>
<p>asymptotic p-values for beta, based on <code>beta.t</code></p>
</dd>
<dt>Y.tilde</dt>
<dd>
<p>the transformed outcome matrix, an n*p matrix</p>
</dd>
<dt>Gamma</dt>
<dd>
<p>estimated factor loadings, p*r matrix</p>
</dd>
<dt>Z</dt>
<dd>
<p>estimated latent factors</p>
</dd>
<dt>Sigma</dt>
<dd>
<p>estimated noise variance matrix, a length p vector</p>
</dd>
</dl>
<h3>Functions</h3>


<ul><li> <p><code>cate.fit</code>: Basic computing function called by <code>cate</code>
</p>
</li></ul>
<h3>References</h3>


<p>J. Wang, Q. Zhao, T. Hastie, and A. B. Owen (2017). Confounder adjustment in multiple testing. Annals of Statistics, 45(5), 1863â€“1894.

</p>


<h3>See Also</h3>

<p><code>wrapper</code> for wrapper functions of some existing methods.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## simulate a dataset with 100 observations, 1000 variables and 5 confounders
data &lt;- gen.sim.data(n = 100, p = 1000, r = 5)
X.data &lt;- data.frame(X1 = data$X1)

## linear regression without any adjustment
output.naive &lt;- cate(~ X1 | 1, X.data, Y = data$Y, r = 0, adj.method = "naive")
## confounder adjusted linear regression
output &lt;- cate(~ X1 | 1, X.data, Y = data$Y, r = 5)
## plot the histograms of unadjusted and adjusted regression statistics
par(mfrow = c(1, 2))
hist(output.naive$beta.t)
hist(output$beta.t)

## simulate a dataset with 100 observations, 1000 variables and 5 confounders
data &lt;- gen.sim.data(n = 100, p = 1000, r = 5)
## linear regression without any adjustment
output.naive &lt;- cate.fit(X.primary = data$X1, X.nuis = NULL, Y = data$Y,
                         r = 0, adj.method = "naive")
## confounder adjusted linear regression
output &lt;- cate.fit(X.primary = data$X1, X.nuis = NULL, Y = data$Y, r = 5)
## plot the histograms of unadjusted and adjusted regression statistics
par(mfrow = c(1, 2))
hist(output.naive$beta.t)
hist(output$beta.t)

</code></pre>


</div>