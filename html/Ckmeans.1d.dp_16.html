<div class="container">

<table style="width: 100%;"><tr>
<td>Univariate Segmentation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal Univariate Segmentation</h2>

<h3>Description</h3>

<p>Perform optimal univariate <code class="reqn">k</code>-segmentation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Cksegs.1d.dp(y, k=c(1,9), x=seq_along(y),
             method=c("quadratic", "linear", "loglinear"),
             estimate.k=c("BIC", "BIC 3.4.12"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector of y values. Values can be negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>either an exact integer number of clusters, or a vector of length two specifying the minimum and maximum numbers of clusters to be examined. The default is <code>c(1,9)</code>. When <code>k</code> is a range, the actual number of clusters is determined by Bayesian information criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an optional numeric vector of data to be clustered. All <code>NA</code> elements must be removed from <code>x</code> before calling this function. The function will run faster on sorted <code>x</code> (in non-decreasing order) than an unsorted input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string to specify the speedup method to the original cubic runtime dynamic programming. The default is <code>"quadratic"</code>, which generates optimal results. The other options do not guarantee optimal solution and differ in runtime or memory usage. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate.k</code></td>
<td>
<p>a character string to specify the method to estimate optimal <code>k</code>. The default is <code>"BIC"</code>. See Details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Cksegs.1d.dp</code> minimizes within-cluster sum of squared distance on <code>y</code>. It offers optimal piece-wise constant approximation of <code>y</code> within clusters of <code>x</code>. Only <code>method="quadratic"</code> guarantees optimality. The "linear" and "loglinear" options are faster but not always optimal and are provided for comparison purposes.
</p>
<p>The Bayesian information criterion (BIC) method to select optimal <code>k</code> is updated to deal with duplicates in the data. Otherwise, the estimated k would be the same with previous versions. Set <code>estimate.k="BIC"</code> to use the latest method; use <code>estimate.k="BIC 3.4.12"</code> to use the BIC method in version 3.4.12 or earlier to estimated <code>k</code> from the given range. This option is effective only when a range for <code>k</code> is provided.
</p>
<p><code>method</code> specifies one of three options to speed up the original dynamic programming taking a runtime cubic in sample size <var>n</var>. The default <code>"quadratic"</code> option, with a runtime of <code class="reqn">O(kn^2)</code>, guarantees optimality. The next two options do not guarantee optimality. The <code>"linear"</code> option, giving a total runtime of <code class="reqn">O(n \lg n + kn)</code> or <code class="reqn">O(kn)</code> (if <code>x</code> is already sorted in ascending order) is the fastest option but uses the most memory (still <code class="reqn">O(kn)</code>); the <code>"loglinear"</code> option, with a runtime of <code class="reqn">O(kn \lg n)</code>, is slightly slower but uses the least memory.
</p>


<h3>Value</h3>

<p>An object of class "<code>Cksegs.1d.dp</code>". It is a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>a vector of clusters assigned to each element in <code>x</code>. Each cluster is indexed by an integer from 1 to <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>a numeric vector of the (weighted) means for each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinss</code></td>
<td>
<p>a numeric vector of the (weighted) within-cluster sum of squares for each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>a vector of the (weighted) number of elements in each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totss</code></td>
<td>
<p>total sum of (weighted) squared distances between each element and the sample mean. This statistic is not dependent on the clustering result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tot.withinss</code></td>
<td>
<p>total sum of (weighted) within-cluster squared distances between each element and its cluster mean. This statistic is minimized given the number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betweenss</code></td>
<td>
<p>sum of (weighted) squared distances between each cluster mean and sample mean. This statistic is maximized given the number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xname</code></td>
<td>
<p>a character string. The actual name of the <code>x</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yname</code></td>
<td>
<p>a character string. The actual name of the <code>y</code> argument.</p>
</td>
</tr>
</table>
<p>The class has a print and a plot method: <code>print.Cksegs.1d.dp</code> and <code>plot.Cksegs.1d.dp</code>.
</p>


<h3>Author(s)</h3>

<p>Joe Song
</p>


<h3>See Also</h3>

<p><code>plot.Cksegs.1d.dp</code> and <code>print.Cksegs.1d.dp</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Ex 1. Segmenting by y

y &lt;- c(1,1,1,2,2,2,4,4,4,4)

res &lt;- Cksegs.1d.dp(y, k=c(1:10))

main &lt;- "k-segs giving 3 clusters\nsucceeded in finding segments"

opar &lt;- par(mfrow=c(1,2))

plot(res, main=main, xlab="x")

res &lt;- Ckmeans.1d.dp(x=seq_along(y), k=c(1:10), y)
main &lt;- "Weighted k-means giving 1 cluster\nfailed to find segments"

plot(res, main=main, xlab="x")

par(opar)

# Ex 2. Segmenting by y

y &lt;- c(1,1,1.1,1, 2,2.5,2, 4,5,4,4)
res &lt;- Cksegs.1d.dp(y, k=c(1:10))
plot(res, xlab="x")

# Ex 3. Segmenting a sinusoidal curve by y
x &lt;- 1:125
y &lt;- sin(x * .2)
res.q &lt;- Cksegs.1d.dp(y, k=8, x=x)
plot(res.q, lwd=3, xlab="x")

# Ex 4. Segmenting by y

y &lt;- rep(c(1,-3,4,-2), each=20)
y &lt;- y + 0.5*rnorm(length(y))
k &lt;- 1:10
res.q &lt;- Cksegs.1d.dp(y, k=k, method="quadratic")
main &lt;- paste("Cksegs (method=\"quadratic\"):\ntot.withinss =",
              format(res.q$tot.withinss, digits=4), "BIC =",
              format(res.q$BIC[length(res.q$size)], digits=4),
              "\nGUARANTEE TO BE OPTIMAL")
plot(res.q, main=main, xlab="x")
res.l &lt;- Cksegs.1d.dp(y, k=k, method="linear")
main &lt;- paste("Cksegs (method=\"linear\"):\ntot.withinss =",
               format(res.l$tot.withinss, digits=4), "BIC =",
              format(res.l$BIC[length(res.l$size)], digits=4),
               "\nFAST BUT MAY NOT BE OPTIMAL")
plot(res.l, main=main, xlab="x")
res.g &lt;- Cksegs.1d.dp(y, k=k, method="loglinear")
main &lt;- paste("Cksegs (method=\"loglinear\"):\ntot.withinss =",
              format(res.g$tot.withinss, digits=4), "BIC =",
              format(res.g$BIC[length(res.g$size)], digits=4),
              "\nFAST BUT MAY NOT BE OPTIMAL")
plot(res.g, main=main, xlab="x")
</code></pre>


</div>