<div class="container">

<table style="width: 100%;"><tr>
<td>sar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating linear-in-mean models with social interactions</h2>

<h3>Description</h3>

<p><code>sar</code> computes quasi-maximum likelihood estimators for linear-in-mean models with social interactions (see Lee, 2004 and Lee et al., 2010).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sar(
  formula,
  Glist,
  lambda0 = NULL,
  fixed.effects = FALSE,
  optimizer = "optim",
  opt.ctr = list(),
  print = TRUE,
  cov = TRUE,
  cinfo = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a class object formula: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code>peer.avg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>an optional starting value of <code class="reqn">\lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.effects</code></td>
<td>
<p>a Boolean indicating whether group heterogeneity must be included as fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>is either <code>nlm</code> (referring to the function nlm) or <code>optim</code> (referring to the function optim).
Arguments for these functions such as, <code>control</code> and <code>method</code> can be set via the argument <code>opt.ctr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.ctr</code></td>
<td>
<p>list of arguments of nlm or optim (the one set in <code>optimizer</code>) such as <code>control</code>, <code>method</code>, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>a Boolean indicating if the estimate should be printed at each step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>). In the case of incomplete information, the model is defined under rational expectations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sar</code> is called.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
In the case of incomplete information models with rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i.</code>
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>list of general information on the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>Maximum Likelihood (ML) estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>covariance matrix of the estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>outputs as returned by the optimizer.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>


<h3>See Also</h3>

<p><code>sart</code>, <code>cdnet</code>, <code>simsar</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

ytmp    &lt;- simsar(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, 
                  theta = theta, data = data) 
data$y  &lt;- ytmp$y

out     &lt;- sar(formula = y ~ x1 + x2 + + gx1 + gx2, Glist = G, 
               optimizer = "optim", data = data)
summary(out)

</code></pre>


</div>