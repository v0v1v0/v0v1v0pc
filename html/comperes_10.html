<div class="container">

<table style="width: 100%;"><tr>
<td>convert-pair-value</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert between long pair-value data and matrix</h2>

<h3>Description</h3>

<p>Functions for conversion between long pair-value data (data frame with
columns for pair identifiers and value column) and matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">long_to_mat(tbl, row_key, col_key, value = NULL, fill = NULL,
  silent = FALSE)

mat_to_long(mat, row_key, col_key, value, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tbl</code></td>
<td>
<p>Data frame with pair-value data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_key</code></td>
<td>
<p>String name of column for first key in pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_key</code></td>
<td>
<p>String name of column for second key in pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>String name of column for value (or <code>NULL</code> for <code>long_to_mat()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>Value to fill for missing pairs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Use <code>TRUE</code> to omit message about guessed value column (see
Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>Matrix with pair-value data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Use <code>TRUE</code> to drop rows with missing value (see Details).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Pair-value data is commonly used in description of pairs of objects.
Pair is described by two keys (usually integer or character) and value is an
object of arbitrary nature.
</p>
<p>In <strong>long format</strong> there are at least three columns: for first key in pair,
for second key and for value (might be more). In <strong>matrix format</strong> pair-value
data is represented as matrix of values with row names as character
representation of first key, column names - second key.
</p>
<p><code>long_to_mat()</code> works as follows:
</p>

<ul>
<li>
<p> Pair identifiers are taken from columns with names <code>row_key</code> (to be used as
row names) and <code>col_key</code> (to be used as column names). Unique identifiers
(and future dimension names) are determined with <code>levels2()</code>. This is a way
to target function on specific set of pairs by using factor columns. <strong>Note</strong>
that <code>NA</code>s are treated as single unknown key and put on last place (in case
of non-factor).
</p>
</li>
<li>
<p> Values are taken from column with name <code>value</code>. <strong>Note</strong> that if <code>value</code>
has length 0 (typically <code>NULL</code>) then <code>long_to_mat()</code> will take first
non-key column. If there is no such column, it will use vector of dummy
values (<code>NA</code>s or <code>fill</code>s). In both cases a message is given if <code>silent = FALSE</code>.
</p>
</li>
<li>
<p> Output is a matrix with described row and column names. Value of pair
"key_1" and "key_2" is stored at intersection of row "key_1" and "key_2".
<strong>Note</strong> that in case of duplicated pairs the value from first occurrence is
taken.
</p>
</li>
</ul>
<p><code>mat_to_long()</code> basically performs inverse operation to <code>long_to_mat()</code> but
pair identifiers are always character. If <code>drop = TRUE</code> it drops rows with
values (but not keys) being missing.
</p>


<h3>Value</h3>

<p><code>long_to_mat()</code> returns a matrix with selected values where row names
indicate first key in pair, col names - second.
</p>
<p><code>mat_to_long()</code> returns a <code>tibble</code> with three columns: the
one for first key in pair, the one for second, and the one for value.
</p>


<h3>Examples</h3>

<pre><code class="language-R">long_data &lt;- data.frame(
  key_1 = c("a", "a", "b"),
  key_2 = c("c", "d", "c"),
  val = 1:3,
  stringsAsFactors = FALSE
)

mat_data &lt;- long_data %&gt;% long_to_mat("key_1", "key_2", "val")
print(mat_data)

# Converts to tibble
mat_data %&gt;% mat_to_long("new_key_1", "new_key_2", "new_val")

# Drops rows with valuus missing
mat_data %&gt;% mat_to_long("new_key_1", "new_key_2", "new_val", drop = TRUE)
</code></pre>


</div>