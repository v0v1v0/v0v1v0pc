<div class="container">

<table style="width: 100%;"><tr>
<td>cfc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cause-specific competing-risk survival analysis
</h2>

<h3>Description</h3>

<p>Using adaptive generalized Newton-Cotes for calculating cumulative incidence functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cfc(f.list, args.list, n, tout, Nmax = 100L, rel.tol = 1e-05, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f.list</code></td>
<td>
<p>In <code>R</code> mode, this is a list of survival functions, one per cause. Each survival function must have the prototype <code>f(t, args, n)</code>, where <code>t</code> is a vector of time-from-index values, <code>args</code> is a list of all arguments needed by the function, and <code>n</code> is the iterator that allows the function to produce a different output for each observation and/or Bayesian sample. The output is a vector of survival probabilities at times <code>t</code> for that particular observation/sample combination with iterator value <code>n</code>. In <code>C++</code> mode, this is a list of lists, one per cause. Each list must contain pointers to three <code>C++</code> functions, in order: 1) survival function of type <code>func</code> with prototype defined as <code>typedef arma::vec (*func)(arma::vec x, void* arg, int n)</code> (using <code>RcppArmadillo</code>'s <code>vec</code> class) and a similar interpetation as its <code>R</code> counterpart, 2) initializer function of type <code>initfunc</code>, with prototype defined as <code>typedef void* (*initfunc)(List arg)</code>, where <code>List</code> is the <code>Rcpp</code> wrapper class for <code>R</code> lists, and 3) resource de-allocator function of type <code>freefunc</code> with this prototype: <code>typedef void (*freefunc)(void *arg)</code>. See vignette for <code>C++</code> example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args.list</code></td>
<td>
<p>List of arguments (each one a list), one per cause, to be supplied to the survival functions in <code>f.list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Range of iterator (starting at <code>1</code>) for survival functions. This can be the product of number of observations, and number of MCMC samplers in a Bayesian survival function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tout</code></td>
<td>
<p>Vector of time points for which cumulative incidence functions are requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nmax</code></td>
<td>
<p>Maximum number of subdivisions in the interval [<code>0</code>, <code>max(tout)</code>] to be created in the adaptive quadrature algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p>Threshold for relative integration error, used as stoppage criterion. It is calculated as the maximum relative error at time point <code>max(tout)</code> across all causes. Each relative error number is the difference between the Simpson-based and trapezoidal-based numbers, divided by the Simpson-based number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of parallel threads to use. This is currrently only implemented in <code>C++</code> mode.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>cfc</code>, which is a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Array of dimensions <code>(length(tout), length(f.list), n)</code>, cumulative incidence functions for all causes and all values of the iterator, evaluated at all time points indicated by <code>tout</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Array of same dimensions as <code>ci</code>, containing the (unadjusted) survival functions for all causes and all values of the iterator, evaluated at all time points indicated by <code>tout</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.maxiter</code></td>
<td>
<p>Binary Array of length <code>n</code>, where <code>1</code> indicates that subdivision process for quadrature problem applied to survival functions at iteration <code>n</code> reached maximum set by <code>Nmax</code> before converging, and <code>0</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.maxiter</code></td>
<td>
<p>Number of iterations that did not converge, i.e., <code>sum(is.maxiter)</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Haller, B., Schmidt, G., &amp; Ulm, K. (2013). Applying competing risks regression models: an overview. Lifetime data analysis, 1-26.
</p>
<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>
<p>Prentice et al (1978). The analysis of failure times in the presence of competing risks. Biometrics, 541-554.
</p>


<h3>See Also</h3>

<p><code>cfc.survreg</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

library("survival") # used for constructing survival formulas
library("BSGW") # used for Bayesian survival regression

data("bmt")
# splitting data into training and prediction sets
idx.train &lt;- sample(1:nrow(bmt), size = 0.7 * nrow(bmt))
idx.pred &lt;- setdiff(1:nrow(bmt), idx.train)
nobs.train &lt;- length(idx.train)
nobs.pred &lt;- length(idx.pred)

# prepare data and formula for Bayesian cause-specific survival regression
# using R package BSGW
out.prep &lt;- cfc.prepdata(Surv(time, cause) ~ platelet + age + tcell, bmt)
f1 &lt;- out.prep$formula.list[[1]]
f2 &lt;- out.prep$formula.list[[2]]
dat &lt;- out.prep$dat
tmax &lt;- out.prep$tmax

# estimating cause-specific models
# set nsmp to larger number in real-world applications
nsmp &lt;- 10
reg1 &lt;- bsgw(f1, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)
reg2 &lt;- bsgw(f2, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)

# defining survival function for this model
survfunc &lt;- function(t, args, n) {
  nobs &lt;- args$nobs; natt &lt;- args$natt; nsmp &lt;- args$nsmp
  alpha &lt;- args$alpha; beta &lt;- args$beta; X &lt;- args$X
  idx.smp &lt;- floor((n - 1) / nobs) + 1
  idx.obs &lt;- n - (idx.smp - 1) * nobs
  return (exp(- t ^ alpha[idx.smp] * 
                exp(sum(X[idx.obs, ] * beta[idx.smp, ]))));
}

# preparing function and argument lists
X.pred &lt;- as.matrix(cbind(1, bmt[idx.pred, c("platelet", "age", "tcell")]))
arg.1 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg1$smp$betas), beta = reg1$smp$beta, X = X.pred)
arg.2 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg2$smp$betas), beta = reg2$smp$beta, X = X.pred)
arg.list &lt;- list(arg.1, arg.2)
f.list &lt;- list(survfunc, survfunc)

# cause-specific competing-risk
# set rel.tol to smaller number in real-world applications
tout &lt;- seq(from = 0.0, to = tmax, length.out = 10)
out.cfc &lt;- cfc(f.list, arg.list, nobs.pred * nsmp, tout, rel.tol = 1e-2)


## End(Not run)
</code></pre>


</div>