<div class="container">

<table style="width: 100%;"><tr>
<td>lattice</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster Lattices</h2>

<h3>Description</h3>

<p>Computations on the lattice of all (hard) partitions, or the lattice
of all dendrograms, or the meet semilattice of all hierarchies
(<code class="reqn">n</code>-trees) of/on a set of objects: meet, join, and comparisons.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cl_meet(x, y)
cl_join(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an ensemble of partitions or dendrograms or hierarchies, or
an R object representing a partition or dendrogram or hierarchy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>an R object representing a partition or dendrogram or
hierarchy.  Ignored if <code>x</code> is an ensemble.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a given finite set of objects <code class="reqn">X</code>, the set <code class="reqn">H(X)</code> of all
(hard) partitions of <code class="reqn">X</code> can be partially ordered by defining a
partition <code class="reqn">P</code> to be “finer” than a partition <code class="reqn">Q</code>, i.e.,
<code class="reqn">P \le Q</code>, if each class of <code class="reqn">P</code> is contained in some class of
<code class="reqn">Q</code>.  With this partial order, <code class="reqn">H(X)</code> becomes a bounded
<dfn>lattice</dfn>, with intersection and union of two elements given by
their greatest lower bound (<dfn>meet</dfn>) and their least upper bound
(<dfn>join</dfn>), respectively.
</p>
<p>Specifically, the meet of two partitions computed by <code>cl_meet</code> is
the partition obtained by intersecting the classes of the partitions;
the classes of the join computed by <code>cl_join</code> are obtained by
joining all elements in the same class in at least one of the
partitions.  Obviously, the least and greatest elements of the
partition lattice are the partitions where each object is in a single
class (sometimes referred to as the “splitter” partition) or in
the same class (the “lumper” partition), respectively.  Meet
and join of an arbitrary number of partitions can be defined
recursively.
</p>
<p>In addition to computing the meet and join, the comparison operations
corresponding to the above partial order as well as <code>min</code>,
<code>max</code>, and <code>range</code> are available at least for R objects
representing partitions inheriting from <code>"cl_partition"</code>.
The summary methods give the meet and join of the given partitions
(for <code>min</code> and <code>max</code>), or a partition ensemble with the meet
and join (for <code>range</code>).
</p>
<p>If the partitions specified by <code>x</code> and <code>y</code> are soft
partitions, the corresponding nearest hard partitions are used.
Future versions may optionally provide suitable “soft” (fuzzy)
extensions for computing meets and joins.
</p>
<p>The set of all dendrograms on <code class="reqn">X</code> can be ordered using pointwise
inequality of the associated ultrametric dissimilarities: i.e., if
<code class="reqn">D</code> and <code class="reqn">E</code> are the dendrograms with ultrametrics <code class="reqn">u</code> and
<code class="reqn">v</code>, respectively, then <code class="reqn">D \le E</code> if <code class="reqn">u_{ij} \le v_{ij}</code>
for all pairs <code class="reqn">(i, j)</code> of objects.  This again yields a lattice
(of dendrograms).  The join of <code class="reqn">D</code> and <code class="reqn">E</code> is the dendrogram
with ultrametrics given by <code class="reqn">\max(u_{ij}, v_{ij})</code> (as this gives
an ultrametric); the meet is the dendrogram with the maximal
ultrametric dominated by <code class="reqn">\min(u_{ij}, v_{ij})</code>, and can be
obtained by applying single linkage hierarchical clustering to the
minima.
</p>
<p>The set of all hierarchies on <code class="reqn">X</code> can be ordered by set-wise
inclusion of the classes: i.e., if <code class="reqn">H</code> and <code class="reqn">G</code> are two
hierarchies, then <code class="reqn">H \le G</code> if all classes of <code class="reqn">H</code> are also
classes of <code class="reqn">G</code>.  This yields a meet semilattice, with meet given
by the classes contained in both hierarchies.  The join only exists if
the union of the classes is a hierarchy.
</p>
<p>In each case, a modular semilattice is obtained, which allows for a
natural metrization via least element (semi)lattice move distances,
see Barthélémy, Leclerc and Monjardet (1981).  These latticial metrics
are given by the BA/C (partitions), Manhattan (dendrograms), and
symdiff (hierarchies) dissimilarities, respectively (see
<code>cl_dissimilarity</code>).
</p>


<h3>Value</h3>

<p>For <code>cl_meet</code> and <code>cl_join</code>, an object of class
<code>"cl_partition"</code> or <code>"cl_dendrogram"</code> with the
class ids or ultrametric dissimilarities of the meet and join of the
partitions or dendrograms, respectively.
</p>


<h3>References</h3>

<p>J.-P. Barthélémy, B. Leclerc and B. Monjardet (1981).
On the use of ordered sets in problems of comparison and consensus of
classification.
<em>Journal of Classification</em>, <b>3</b>, 187–224.
<a href="https://doi.org/10.1007/BF01894188">doi:10.1007/BF01894188</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Two simple partitions of 7 objects.
A &lt;- as.cl_partition(c(1, 1, 2, 3, 3, 5, 5))
B &lt;- as.cl_partition(c(1, 2, 2, 3, 4, 5, 5))
## These disagree on objects 1-3, A splits objects 4 and 5 into
## separate classes.  Objects 6 and 7 are always in the same class.
(A &lt;= B) || (B &lt;= A)
## (Neither partition is finer than the other.)
cl_meet(A, B)
cl_join(A, B)
## Meeting with the lumper (greatest) or joining with the splitter
## (least) partition does not make a difference: 
C_lumper &lt;- as.cl_partition(rep(1, n_of_objects(A)))
cl_meet(cl_ensemble(A, B, C_lumper))
C_splitter &lt;- as.cl_partition(seq_len(n_of_objects(A)))
cl_join(cl_ensemble(A, B, C_splitter))
## Another way of computing the join:
range(A, B, C_splitter)$max
</code></pre>


</div>