<div class="container">

<table style="width: 100%;"><tr>
<td>get_aon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Given an origin-destination matrix, compute All-or-Nothing assignment.</h2>

<h3>Description</h3>

<p>Given an origin-destination matrix, compute All-or-Nothing assignment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_aon(Graph, from, to, demand, algorithm = "bi", constant = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Graph</code></td>
<td>
<p>An object generated by makegraph, or cpp_contract function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>A vector of origins</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>A vector of destinations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demand</code></td>
<td>
<p>A vector describing the flow between each origin-destination pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character. For contracted network : <code>phast</code> or <code>bi</code>. Otherwise : <code>d</code>, <code>bi</code> or <code>nba</code>. Default to <code>bi</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in NBA* algorithm. Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All-or-Nothing assignment (AON) is the simplest method to load flow on a network, since it assume there is no congestion effects.
The assignment algorithm itself is the procedure that loads the origin-destination matrix to the shortest path trees and produces the flows.
Origin-destination matrix is represented via 3 vectors : <code>from</code>, <code>to</code> and <code>demand</code>.
</p>
<p>There is two variants of algorithms, depending the <strong>sparsity</strong> of origin-destination matrix : </p>

<ul>
<li>
<p> recursive one-to-one : Bidirectional search (<code>bi</code>) and Bidirectional A* (<code>nba</code>). Optimal for high sparsity.
</p>
</li>
<li>
<p> recursive one-to-many : Dijkstra (<code>d</code>) and PHAST (<code>phast</code>). Optimal for dense matrix.
</p>
</li>
</ul>
<p>For large network and/or large OD matrix, this function is a lot faster on a contracted network.
In New Bidirectional A star algorithm, euclidean distance is used as heuristic function.
To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>
<p>All algorithms are <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing edges attributes, including flow.
</p>


<h3>Note</h3>

<p>'from', 'to' and 'demand' must be the same length.
</p>


<h3>See Also</h3>

<p>cpp_contract, assign_traffic
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

# Origin-destination trips
trips &lt;- data.frame(from = c(0,0,0,0,1,1,1,1,2,2,2,3,3,4,5,5,5,5,5),
                    to = c(1,2,5,3,2,5,2,4,2,5,2,3,5,2,0,0,3,5,1),
                    flow = c(10,30,15,5,5,2,3,6,4,15,20,2,3,6,2,1,4,5,3))

#Construct graph
graph&lt;-makegraph(edges,directed=TRUE)


# Compute All-or-Nothing assignment
aon &lt;- get_aon(Graph=graph, from=trips$from, to=trips$to, demand = trips$flow, algorithm = "d")
print(aon)
</code></pre>


</div>