<div class="container">

<table style="width: 100%;"><tr>
<td>npCBPS.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>npCBPS.fit</h2>

<h3>Description</h3>

<p>npCBPS.fit
</p>


<h3>Usage</h3>

<pre><code class="language-R">npCBPS.fit(treat, X, corprior, print.level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>treat</code></td>
<td>
<p>A vector of treatment assignments.  Binary or multi-valued
treatments should be factors.  Continuous treatments should be numeric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A covariate matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corprior</code></td>
<td>
<p>Prior hyperparameter controlling the expected amount of
correlation between each covariate and the treatment. Specifically, the
amount of correlation between the k-dimensional covariates, X, and the
treatment T after weighting is assumed to have prior distribution
MVN(0,sigma^2 I_k). We conceptualize sigma^2 as a tuning parameter to be
used pragmatically. It's default of 0.1 ensures that the balance constraints
are not too harsh, and that a solution is likely to exist. Once the
algorithm works at such a high value of sigma^2, the user may wish to
attempt values closer to 0 to get finer balance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>Controls verbosity of output to the screen while npCBPS
runs. At the default of print.level=0, little output is produced. It
print.level&gt;0, it outputs diagnostics including the log posterior
(log_post), the log empirical likelihood associated with the weights
(log_el), and the log prior probability of the (weighted) correlation of
treatment with the covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters to be passed.</p>
</td>
</tr>
</table>
</div>