<div class="container">

<table style="width: 100%;"><tr>
<td>Codings</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coding matrix functions for factors in linear model formulae</h2>

<h3>Description</h3>

<p>These functions provide an alternative to the coding functions supplied
in the <code>stats</code> package, namely <code>contr.treatment</code>, <code>contr.sum</code>,
<code>contr.helmert</code> and <code>contr.poly</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">code_control(
  n,
  contrasts = TRUE,
  sparse = FALSE,
  abbreviate = substring(tolower(Sys.getenv("R_CODING_ABBREVIATE", "yes")[[1]]), 0, 1) ==
    "y"
)

code_control_last(
  n,
  contrasts = TRUE,
  sparse = FALSE,
  abbreviate = substring(tolower(Sys.getenv("R_CODING_ABBREVIATE", "yes")[[1]]), 0, 1) ==
    "y"
)

code_diff(
  n,
  contrasts = TRUE,
  sparse = FALSE,
  abbreviate = substring(tolower(Sys.getenv("R_CODING_ABBREVIATE", "yes")[[1]]), 0, 1) ==
    "y"
)

code_diff_forward(
  n,
  contrasts = TRUE,
  sparse = FALSE,
  abbreviate = substring(tolower(Sys.getenv("R_CODING_ABBREVIATE", "yes")[[1]]), 0, 1) ==
    "y"
)

code_helmert(n, contrasts = TRUE, sparse = FALSE)

code_helmert_forward(n, contrasts = TRUE, sparse = FALSE)

code_deviation(n, contrasts = TRUE, sparse = FALSE)

code_deviation_first(n, contrasts = TRUE, sparse = FALSE)

code_poly(n, contrasts = TRUE, sparse = FALSE)

contr.diff(
  n,
  contrasts = TRUE,
  sparse = FALSE,
  abbreviate = substring(tolower(Sys.getenv("R_CODING_ABBREVIATE", "yes")[[1]]), 0, 1) ==
    "y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Either a positive integer giving the number of levels or the levels
attribute of a factor, supplying both the number of levels via its length and
labels potentially to be used in the <code>dimnames</code> of the result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>Logical: Do you want the <code class="reqn">n \times (n-1)</code> coding
matrix (<code>TRUE</code>) or an <code class="reqn">n \times n</code> full-rank matrix, (as is
sometimes needed by the fitting functions) (<code>FALSE</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>Logical: Do you want the result to be a sparse matrix
object, as generated the the <code>Matrix</code> package?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abbreviate</code></td>
<td>
<p>Logical: should level names be abbreviated in the
generated contrast labels?  Default: TRUE.  May be set globally by
setting the environment variable <code>R_CODING_ABBREVIATE</code> to either
"yes" or "no", with obvious meaning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All functions with names of the form <code>code_xxxx</code> return
coding matrices which, in a simple model, make the intercept term
the simple ("unweighted") average of the class means.  This can be
important in some non-standard ANOVA tables.  The function
<code>contr.diff</code> is an exception, and is offered as a natural companion
to <code>stats::contr.treatment</code>, with which it is closely aligned.
</p>

<dl>
<dt>code_control</dt>
<dd>
<p>Similar to <code>contr.treatment</code>, with
contrasts comparing the class means (the "treatments") with
the first class mean (the "control").</p>
</dd>
<dt>code_control_last</dt>
<dd>
<p>Similar to <code>code_control</code>, but using the final
class mean as the "control".  Cf. <code>contr.SAS</code></p>
</dd>
<dt>code_diff</dt>
<dd>
<p>The contrasts are the successive differences of the treatment means,
<code class="reqn">\mu_{i+i} - \mu_i</code>.  This coding function has no counterpart in the <code>stats</code>
package.  It is suggested as an alternative to the default coding,
<code>contr.poly</code>, for
ordered factors.  It offers a visual check of monotonicity of the class means
with the ordered levels of the factor.  Unlike <code>stats::contr.poly</code>
there is no assumption that the factor levels
are in some sense "equally spaced".</p>
</dd>
<dt>code_diff_forward</dt>
<dd>
<p>Very similar to <code>code_diff</code>, but using forward
differences: <code class="reqn">\mu_i - \mu_{i+1}</code></p>
</dd>
<dt>code_helmert</dt>
<dd>
<p>Similar to <code>contr.helmert</code>, but with a
small scaling change to make the regression coefficients (i.e. the contrasts)
more easily interpretable.  The contrasts now compare each class mean, starting
from the second, with the average of all class means coming prior to it in the
factor levels order.</p>
</dd>
<dt>code_helmert_forward</dt>
<dd>
<p>Similar to <code>code_helmert</code>, but comparing each class
mean, up to the second last, with the average of all class means coming after it in
the factor levels order.</p>
</dd>
<dt>code_deviation</dt>
<dd>
<p>Similar to <code>contr.sum</code>, which is described
as having the "effects" summing to zero.  A more precise description might be to
say that the contrasts are the deviations of each class mean from the average
of them, i.e. <code class="reqn">\mu_i - \bar\mu</code>.  To avoid redundancy, the
last deviation is omitted.</p>
</dd>
<dt>code_deviation_first</dt>
<dd>
<p>Very similar to <code>code_deviation</code>, but omitting
the first deviation to avoid redundancy rather than the last.</p>
</dd>
<dt>code_poly</dt>
<dd>
<p>Similar in effect to <code>contr.poly</code> but
for levels fewer than 15 using an unnormalized basis for the orthogonal polynomials
with integer entries.  (Orthogonal polynomials were originally given in this form
as tables.)  The only advantage over <code>stats::contr.poly</code> is one of display.
Use <code>stats::contr.poly</code> in preference other than for teaching purposes.</p>
</dd>
<dt>contr.diff</dt>
<dd>
<p>Very similar in effect to <code>code_diff</code>, yielding the same
differences as the contrasts, but like <code>stats::contr.treatment</code> using the
first class mean as the intercept coefficient rather than the simple average of
the class means, as with <code>code_diff</code>.  Some would regard this as making it
unsuitable for use in some non-standard ANOVA tables.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A coding matrix, as requested by fitting functions using linear
model formulae with factor predictors.
</p>


<h3>See Also</h3>

<p>The <code>MASS</code> function <code>contr.sdif</code> which is an early
version of <code>code_deviation</code> (by the same author).
</p>


<h3>Examples</h3>

<pre><code class="language-R">(M &lt;- code_control(5))
mean_contrasts(M)
(M &lt;- stats::contr.treatment(5))
mean_contrasts(M)  ## same contrasts; different averaging vector.
mean_contrasts(stats::contr.helmert(6))  ## Interpretation obscure
mean_contrasts(code_helmert(6))          ## each mean with the average preceding
mean_contrasts(code_helmert_forward(6))  ## each mean with the averave succeeding
</code></pre>


</div>