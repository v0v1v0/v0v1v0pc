<div class="container">

<table style="width: 100%;"><tr>
<td>class_to_deseq2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create DESeq2 object for a given cell type</h2>

<h3>Description</h3>

<p>Create a DESeq2 data set (‘dds’ in the
<a href="https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html">DESeq2 vignette</a>)
for the specified class (cell type).
</p>


<h3>Usage</h3>

<pre><code class="language-R">class_to_deseq2(obj, meta_df, class, design = ~condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_df</code></td>
<td>
<p>Data frame where each column helps to identify a pseudobulk.
Typical columns of meta_df are for example patient, treatment and
cell type – anything
that uniquely identifies a replicate / batch / 10x run.
Each row in meta_df corresponds to a single cell in your raw count matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>The name of cellpypes class for which you want to test
for differential expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>A formula based on columns in <code>meta_df</code>.
To test differential expression between two groups
in meta_df$condition, use formula <code>~ condition</code>.
More complex formulas (e.g. with interactions) are possible, for example
<code>~ genotype + treatment + genotype:treatment</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A DESeq2 object (e.g. dds)
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a list with four slots:
</p>

<dl>
<dt><code>raw </code></dt>
<dd>
<p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt>
<dd>
<p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt>
<dd>
<p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt>
<dd>
<p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li>
<p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li>
<p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li>
</ul>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">data("simulated_umis") 
# Meta data
ncells &lt;- ncol(simulated_umis$raw)
dummy_variable &lt;- function(x) factor(sample(x, ncells, replace=TRUE))
meta_data &lt;- data.frame(patient=dummy_variable(paste0("patient", 1:6)),
                        treatment=dummy_variable(c("control", "treated")))

obj &lt;- rule(simulated_umis, "T", "CD3E","&gt;", 1e-4)
 # &gt; 5 s in CRAN check
dds &lt;- class_to_deseq2(obj, meta_data, "T", ~ treatment)

</code></pre>


</div>