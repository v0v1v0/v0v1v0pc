<div class="container">

<table style="width: 100%;"><tr>
<td>MSEbyC.fn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
call a C function to calculate multiscale entropy
</h2>

<h3>Description</h3>

<p>Function to call a C function to calculate multiscale entropy (MSE)
of an equally spaced time series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MSEbyC.fn(x, scaleMax = 10, scaleStep = 1, mMin = 2, mMax = 2, mStep = 1, rMin = 0.15,
rMax = 0.15, I = 400000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A numeric vector, with data for a regularly spaced time series. No missing value is allowed because the C program is not set up to handle missing value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleMax</code></td>
<td>

<p>maximal value of scale factors for coarse graining in the MSE algorithm. The scale factors are a sequence from 1 to a value no more than 'scaleMax' with equal space 'scaleStep'.  Scale factors are positive integers that specify bin size for coarse graining: the number of consecutive observations in 'x' that form a bin and are averaged in the first step of the algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleStep</code></td>
<td>

<p>see 'scaleMax'
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mMin</code></td>
<td>

<p>A sequence from 'mMin' to 'mMax' with equal space of 'mStep' that defines the vector of positive integers that give the window size for the entropy calculations in the second step of the algorithm:  the number of consecutive _bins_ over which similarity between subsequences is of interest.  Typical values in the sequence are 1, 2, or 3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mMax</code></td>
<td>

<p>See 'Min'
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mStep</code></td>
<td>

<p>See 'Min'
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rMin</code></td>
<td>

<p>A sequence from 'rMin' to 'rMax' with equal space of 0.05 that defines  coefficients for similarity thresholds. Typical values in the sequence are 0.15, 0.2.  r*sd(x) must be in the same units as 'x'. Averages in two bins are defined to be similar if they differ by 'r*sd(x)' or less.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rMax</code></td>
<td>

<p>See 'rMin'
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>

<p>the maximal number of points to be used for calculating MSE cFolder: The directory in which .c is held as well as in which temporary files associated with running C are created/removed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function to call a C function to calculate multiscale entropy (MSE)
of an equally spaced time series.
</p>


<h3>Value</h3>

<p>A data frame with with one row for each combination of 'Scale', 'm' and 'rSD'.  Columns are "Scale", "m", "rSD", and "SampEn" (the calculated sample entropy). The data frame will also have an attribute "SD", the standard deviation of 'x'. rSD = r*sd(x)
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
data.df0 &lt;- read.table(paste(dataFolder, dataFiles[1], sep="/"),
        skip=Skip, header=Header, comment.char=Comment.char, sep=Sep)
if( !Header ) {
	data.df0 &lt;- data.df0[, 1:length(columnNames)]
    dimnames(data.df0)[[2]] &lt;-  columnNames
}
if( !is.na(idxNA) ) data.df0[ data.df0[, responseName] == idxNA, responseName] &lt;- NA
for( i in 1:length(timeStamp.column) ) {
	if(i==1) { timeStamp.vec &lt;- data.df0[, timeStamp.column[i] ] } else {
		 timeStamp.vec &lt;- paste0(timeStamp.vec, " ", data.df0[, timeStamp.column[i] ])
	}
}
Time.mat &lt;- timeSeqConversion.fn(time.stamp=timeStamp.vec, time.format=time.format,
            timeUnit=timeUnit)
data.df &lt;- data.frame( timeStamp.vec, Time.mat[,1], data.df0[,responseName] )
dimnames(data.df)[[2]] &lt;- c("timeStamp", "timeSeries", responseName)
data.df &lt;- data.df[ order(data.df[, "timeSeries"]), ]
data.mat &lt;- data.df[, c("timeSeries", responseName)]
data.mat &lt;- data.mat[!is.na(data.mat[,2]), ]
MSE.mat &lt;- MSEbyC.fn(data.mat[,2], scaleMax, scaleStep, mMin=m, mMax=m, mStep=1,
          rMin=r, rMax=r, I=I)
MSE.mat
</code></pre>


</div>