<div class="container">

<table style="width: 100%;"><tr>
<td>sample.curves</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sample points on curves</h2>

<h3>Description</h3>

<p>Samples points uniformly on curves interpolated as linear consequent
segments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sample.curves(curves, ptsPerCurve = as.integer(c(500)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>curves</code></td>
<td>
<p>A list where each element is a function being a list
containing a matrix <code>coords</code> (curves' values, d columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ptsPerCurve</code></td>
<td>
<p>A vector of numbers of points to be sampled on each
curve. If <code>length(ptsPerCurve) &lt; length(curves)</code> then the first entry
of <code>ptsPerCurve</code> is considered only, and corresponds to the number of
points on a curve.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of curves with each entry being a list constiting of [[1]]
the drawn curve being a matrix named <code>coords</code>, [[2]] length of the
curve as in <code>curves</code> named <code>length.init</code>, and [[3]] length of the
drawn curve named <code>length</code>.
</p>


<h3>References</h3>

<p>Lafaye De Micheaux, P., Mozharovskyi, P. and Vimond, M. (2018).
Depth for curve data and applications.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(curveDepth)
# Load digits and transform them to curves
data("mnistShort017")
n &lt;- 10 # cardinality of each class
m &lt;- 50 # number of points to sample
cst &lt;- 1/10 # a threshold constant
alp &lt;- 1/8 # a threshold constant
curves0 &lt;- images2curves(mnistShort017$`0`[, , 1:n])
curves1 &lt;- images2curves(mnistShort017$`1`[, , 1:n])
set.seed(1)
curves0Smpl &lt;- sample.curves(curves0, 2 * m)
curves1Smpl &lt;- sample.curves(curves1, 2 * m)
# Calculate depths
depthSpace = matrix(NA, nrow = n * 2, ncol = 2)
depthSpace[, 1] = depth.curve.Tukey(
  c(curves0Smpl, curves1Smpl), curves0Smpl,
  exactEst = TRUE, minMassObj = cst/m^alp)
depthSpace[, 2] = depth.curve.Tukey(
  c(curves0Smpl, curves1Smpl), curves1Smpl,
  exactEst = TRUE, minMassObj = cst/m^alp)
# Draw the DD-plot
plot(NULL, xlim = c(0, 1), ylim = c(0, 1),
     xlab = paste("Depth w.r.t. '0'"),
     ylab = paste("Depth w.r.t. '1'"),
     main = paste("DD-plot for '0' vs '1'"))
grid()
# Draw the separating rule
dat1 &lt;- data.frame(cbind(
  depthSpace, c(rep(0, n), rep(1, n))))
ddalpha1 &lt;- ddalpha.train(X3 ~ X1 + X2, data = dat1,
                          depth = "ddplot",
                          separator = "alpha")
ddnormal &lt;- ddalpha1$classifiers[[1]]$hyperplane[2:3]
pts &lt;- matrix(c(0, 0, 1, ddnormal[1] / -ddnormal[2]),
              nrow = 2, byrow = TRUE)
lines(pts, lwd = 2)
# Draw the points
points(depthSpace[1:n, ],
       col = "red", lwd = 2, pch = 1)
points(depthSpace[(n + 1):(2 * n), ],
       col = "blue", lwd = 2, pch = 3)
</code></pre>


</div>