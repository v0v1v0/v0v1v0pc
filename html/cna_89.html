<div class="container">

<table style="width: 100%;"><tr>
<td>rreduce</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Eliminate redundancies from a disjunctive normal form (DNF)</h2>

<h3>Description</h3>

<p><code>rreduce</code> eliminates redundancies from disjunctive normal forms (DNF), i.e. disjunctions of conjunctions of literals. If there are several minimal DNF, <code>rreduce</code> selects one at random.</p>


<h3>Usage</h3>

<pre><code class="language-R">rreduce(cond, x = full.ct(cond), niter = 1, full = !missing(x), verbose = FALSE, 
        maxiter = 1000, simplify2constant = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>

<p>A character string specifying a disjunctive normal form; can be either crisp-set or multi-value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A 
<code>configTable</code> or <code>data.frame</code>; can be either crisp-set or multi-value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>

<p>An integer value <code>&gt;=1</code> specifying the number of iterated minimization attempts. The minimal DNFs produced in each iteration are collected and returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>

<p>Logical; if <code>TRUE</code> (the default), redundancies are eliminated relative to <code>full.ct(x)</code>, otherwise relative to <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify2constant</code></td>
<td>

<p>Logical; if <code>TRUE</code> (the default), a tautologous or contradictory <code>cond</code> is reduced to a constant <code>"1"</code> or <code>"0"</code>, respectively. If <code>FALSE</code>, a minimal tautology or contradiction, i.e. <code>"A+a"</code> or <code>"A*a"</code>, will result.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical; if TRUE, the reduction process will be traced in the console. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>Maximal number of iterations. This is a parameter of internal nature, usually not set by the user.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>rreduce</code> successively eliminates conjuncts and disjuncts from a DNF <code>cond</code> as long as the result of <code>condition(cond, x)</code> remains the same. The only required argument is <code>cond</code>. If <code>x</code> is not provided, redundancies are eliminated relative to <code>full.ct(cond)</code>. If <code>x</code> is provided and <code>full = TRUE</code>, redundancies are eliminated relative to <code>full.ct(x)</code>. If <code>x</code> is provided and <code>full = FALSE</code>, redundancies are eliminated relative to <code>x</code>.
</p>
<p>If <code>cond</code> has more than one redundancy-free form, <code>rreduce</code> only returns a randomly chosen one in the default setting of <code>niter = 1</code>. By increasing <code>niter</code> to a value <code>&gt;1</code>, <code>cond</code> is (randomly) minimized <code>niter</code> times. All resulting redundancy-free forms are collected and returned. This provides some insight about the amount of redundancy-free forms that <code>cond</code> has.
</p>


<h3>Value</h3>

<p>Redundancy-free disjunctive normal form (DNF).
</p>


<h3>See Also</h3>

<p><code>full.ct</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Logical redundancies.
cond1 &lt;- "A*b + a*B + A*C + B*C"
rreduce(cond1)
rreduce(cond1, niter = 10)
cond2 &lt;- "A*b + a*B + A*B + a*b"
rreduce(cond2, simplify2constant = FALSE)

# Any Boolean expressions.
cond &lt;- "!(A*B*C)*!(a*b*c)" # or "A + B*!(D + e) &lt;-&gt; C" 
x &lt;- selectCases(cond) 
cond &lt;- getCond(x) # Returns a DNF equivalent to cond, but with many redundancies.
rreduce(cond)      # Repeated execution results in different outputs.
rreduce(cond, verbose = TRUE)      
rreduce(cond, niter = 20) # 20 iterations yield 5 minimal forms.
</code></pre>


</div>