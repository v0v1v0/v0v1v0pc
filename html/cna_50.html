<div class="container">

<table style="width: 100%;"><tr>
<td>full.ct</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate the logically possible value configurations of a given set of factors
</h2>

<h3>Description</h3>

<p>The function <code>full.ct</code> generates a <code>configTable</code> with all (or a specified number of) logically possible value configurations of the factors defined in the input <code>x</code>. It is more flexible than <code>allCombs</code>. 
<code>x</code> can be a <code>configTable</code>, a data frame, an integer, a list specifying the factors' value ranges, or a character string expressing a condition featuring all admissible factor values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">full.ct(x, ...)

## Default S3 method:
full.ct(x, type = "auto", cond = NULL, nmax = NULL, ...)
## S3 method for class 'configTable'
full.ct(x, cond = NULL, nmax = NULL, ...)
## S3 method for class 'cti'
full.ct(x, cond = NULL, nmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>configTable</code>, a data frame, a matrix, an integer, a list specifying the factors' value ranges,  or a character vector featuring all admissible factor values (see the details and examples below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set). (Manual specification of the <code>type</code> only has an effect if <code>x</code> is a data frame or matrix.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>
<p>Optional character vector containing conditions in the syntax of msc, asf or csf. If it is not <code>NULL</code>, only factors appearing in <code>cond</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmax</code></td>
<td>
<p>Maximal number of rows in the output <code>configTable</code>. If <code>nmax</code> is smaller than the total number of logically possible configurations, a random sample of configurations is drawn. The default <code>nmax = NULL</code> selects all logically possible configurations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed to methods.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>full.ct</code> generates all or <code>nmax</code> logically possible value configurations of the factors defined in <code>x</code>, which can either be a character vector or an integer or a list or a data frame or a matrix. </p>

<ul>
<li>
<p>If <code>x</code> is a character vector, it can be a condition of any of the three types of conditions, <em>boolean</em>, <em>atomic</em> or <em>complex</em> (see <code>condition</code>). <code>x</code> must contain at least one factor. Factor names and admissible values are guessed from the Boolean formulas. If <code>x</code> contains multi-value factors, only those values are considered admissible that are explicitly contained in <code>x</code>. Accordingly, in case of multi-value factors, <code>full.ct</code> should be given the relevant factor definitions by means of a list (see below).

</p>
</li>
<li>
<p>If <code>x</code> is an integer, the output is a configuration table of type <code>"cs"</code> with <code>x</code> factors. If <code>x &lt;= 26</code>, the first <code>x</code> capital letters of the alphabet are used as the names of the factors. If <code>x &gt; 26</code>, factors are named "X1" to "Xx". 

</p>
</li>
<li>
<p>If <code>x</code> is a list, <code>x</code> is expected to have named elements each of which provides the factor names with corresponding vectors enumerating their admissible values (i.e. their value ranges). These values must be non-negative integers.

</p>
</li>
<li>
<p>If <code>x</code> is a <code>configTable</code>, data frame, or matrix, <code>colnames(x)</code> are interpreted as factor names and the rows as enumerating the admissible values (i.e. as value ranges). If <code>x</code> is a data frame or a matrix, <code>x</code> is first converted to a <code>configTable</code> (the function <code>configTable</code> is called with <code>type</code> as specified in <code>full.ct</code>), and the <code>configTable</code> method of <code>full.ct</code> is then applied to the result. The <code>configTable</code> method uses all factors and factor values occurring in the <code>configTable</code>. If <code>x</code> is of type <code>"fs"</code>, 0 and 1 are taken as the admissible values.

</p>
</li>
</ul>
<p>The computational demand of generating all logically possible configurations increases exponentially with the number of factors in <code>x</code>. In order to get an output in reasonable time, even when <code>x</code> features more than about 15 factors, the argument <code>nmax</code> allows for specifying a maximal number of configurations to be returned (by random sampling).
</p>
<p>If not all factors specified in <code>x</code> are of interest but only those in a given msc, asf, or csf, <code>full.ct</code> can be correspondingly restricted via the argument <code>cond</code>. For instance, <code>full.ct(d.educate, cond = "D + L &lt;-&gt; E")</code> generates the logically possible value configurations of the factors in the set {D, L, E}, even though <code>d.educate</code> contains further factors. The argument <code>cond</code> is primarily used internally to speed up the execution of various functions in case of high-dimensional data. 
</p>
<p>The main area of application of <code>full.ct</code> is data simulation in the context of inverse search trials benchmarking the output of <code>cna</code> (see examples below). While <code>full.ct</code> generates the relevant space of logically possible configurations of the factors in an analyzed factor set, <code>selectCases</code> selects those configurations from this space that are compatible with a given data generating causal structure (i.e. the ground truth), that is, it selects the empirically possible configurations.
</p>
<p>The method for class "cti" is for internal use only.
</p>


<h3>Value</h3>

<p>A <code>configTable</code> of type <code>"cs"</code> or <code>"mv"</code> with the full enumeration of combinations of the factor values.
</p>


<h3>See Also</h3>

<p><code>configTable</code>, <code>selectCases</code>, <code>allCombs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># x is a character vector.
full.ct("A + B*c")
full.ct("A=1*C=3 + B=2*C=1 + A=3*B=1") 
full.ct(c("A + b*C", "a*D"))
full.ct("!A*-(B + c) + F")
full.ct(c("A=1", "A=2", "B=1", "B=0", "C=13","C=45"))

# x is a data frame.
full.ct(d.educate)
full.ct(d.jobsecurity)
full.ct(d.pban)

# x is a configTable.
full.ct(configTable(d.jobsecurity))
full.ct(configTable(d.pban), cond = "C=1 + F=0 &lt;-&gt; V=1") 

# x is an integer.
full.ct(6)
# Constrain the number of configurations to 1000.
full.ct(30, nmax = 1000) 

# x is a list.
full.ct(list(A = 0:1, B = 0:1, C = 0:1))  # cs
full.ct(list(A = 1:2, B = 0:1, C = 23:25))  # mv

# Simulating crisp-set data.
groundTruth.1 &lt;- "(A*b + C*d &lt;-&gt; E)*(E*H + I*k &lt;-&gt; F)"
fullData &lt;- ct2df(full.ct(groundTruth.1))
idealData &lt;- ct2df(selectCases(groundTruth.1, fullData))
# Introduce 20% data fragmentation.
fragData &lt;- idealData[-sample(1:nrow(idealData), nrow(idealData)*0.2), ] 
# Add 10% random noise.
incompData &lt;- dplyr::setdiff(fullData, idealData)
(realData &lt;- rbind(incompData[sample(1:nrow(incompData), nrow(fragData)*0.1), ], 
  fragData))

# Simulating multi-value data.
groundTruth.2 &lt;- "(JO=3 + TS=1*PE=3 &lt;-&gt; ES=1)*(ES=1*HI=4 + IQ=2*KT=5 &lt;-&gt; FA=1)"
fullData &lt;- ct2df(full.ct(list(JO=1:3, TS=1:2, PE=1:3, ES=1:2, HI=1:4, IQ=1:5, KT=1:5, FA=1:2)))
idealData &lt;- ct2df(selectCases(groundTruth.2, fullData))
# Introduce 20% data fragmentation.
fragData &lt;- idealData[-sample(1:nrow(idealData), nrow(idealData)*0.2), ] 
# Add 10% random noise.
incompData &lt;- dplyr::setdiff(fullData, idealData)
(realData &lt;- rbind(incompData[sample(1:nrow(incompData), nrow(fragData)*0.1), ], 
  fragData))

</code></pre>


</div>