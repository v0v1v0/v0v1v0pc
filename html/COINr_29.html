<div class="container">

<table style="width: 100%;"><tr>
<td>Custom.coin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Custom operation</h2>

<h3>Description</h3>

<p>Custom operation on a coin. This is an experimental new feature so please check
the results carefully.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'coin'
Custom(
  x,
  dset,
  f_cust,
  f_cust_para = NULL,
  write_to = NULL,
  write2log = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A coin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dset</code></td>
<td>
<p>Target data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_cust</code></td>
<td>
<p>Function to apply to the data set. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_cust_para</code></td>
<td>
<p>Optional additional parameters to pass to the function defined
by <code>f_cust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to</code></td>
<td>
<p>Name of data set to write to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write2log</code></td>
<td>
<p>Logical: whether or not to write to the log.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to pass to/from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In this function, the data set named <code>dset</code> is extracted from the coin using
<code>get_dset(coin, dset)</code>. It is passed to the function <code>f_cust</code>, which is required
to return an equivalent but modified data frame, which is then written as a new
data set with name <code>write_to</code>. This is intended to allow arbitrary operations
on coin data sets while staying within the COINr framework, which means that if
<code>Regen()</code> is used, these operations will be re-run, allowing them to be included
in things like sensitivity analysis.
</p>
<p>The format of <code>f_cust</code> is important. It must be a function whose first argument
is called <code>x</code>: this will be the argument that the data is passed to. The data will
be in the same format as extracted via <code>get_dset(coin, dset)</code>, which means it will
have a <code>uCode</code> column. <code>f_cust</code> can have other arguments which are passed
to it via <code>f_cust_para</code>. The function should return a data frame similar to the data
that was passed to it, it must contain have the same column names (meaning you can't
remove indicators), but otherwise is flexible - this means some caution is necessary
to ensure that subsequent operations don't fail. Be careful, for example, to ensure
that there are no duplicates in <code>uCode</code>, and that indicator columns are numeric.
</p>
<p>The function assigned to <code>f_cust</code> is passed to <code>base::do.call()</code>, therefore it can
be passed either as a string naming the function, or as the function itself. Depending
on the context, the latter option may be preferable because this stores the function
within the coin, which makes it portable. Otherwise, if the function is simply
named as a string, you must make sure it is available to access in the environment.
</p>


<h3>Value</h3>

<p>A coin
</p>


<h3>Examples</h3>

<pre><code class="language-R"># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# create function - replaces suspected unreliable point with NA
f_NA &lt;- function(x){ x[3, 10] &lt;- NA; return(x)}

# call function from Custom()
coin &lt;- Custom(coin, dset = "Raw", f_cust = f_NA)
stopifnot(is.na(coin$Data$Custom[3,10]))

</code></pre>


</div>