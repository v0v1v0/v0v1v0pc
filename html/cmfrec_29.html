<div class="container">

<table style="width: 100%;"><tr>
<td>predict_new</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict entries in new 'X' data</h2>

<h3>Description</h3>

<p>Predict entries in columns of the 'X' matrix for new users/rows
given their new 'X' and/or 'U' data at the combinations [row,column] given by the entries in
'user' and 'item' (e.g. passing 'user=c(1,2,3), item=c(1,1,1)' will predict
X[1,1], X[2,1], X[3,1]).
</p>
<p>Note: this function will not perform any internal re-indexing for the data.
If the 'X' to which the data was fit was a 'data.frame', the numeration of the
items will be under 'model$info$item_mapping'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">predict_new(model, ...)

## S3 method for class 'CMF'
predict_new(
  model,
  items,
  rows = NULL,
  X = NULL,
  U = NULL,
  U_bin = NULL,
  weight = NULL,
  nthreads = model$info$nthreads,
  ...
)

## S3 method for class 'CMF_implicit'
predict_new(
  model,
  items,
  rows = NULL,
  X = NULL,
  U = NULL,
  nthreads = model$info$nthreads,
  ...
)

## S3 method for class 'OMF_explicit'
predict_new(
  model,
  items,
  rows = NULL,
  X = NULL,
  U = NULL,
  weight = NULL,
  exact = FALSE,
  nthreads = model$info$nthreads,
  ...
)

## S3 method for class 'OMF_implicit'
predict_new(
  model,
  items,
  rows = NULL,
  X = NULL,
  U = NULL,
  nthreads = model$info$nthreads,
  ...
)

## S3 method for class 'ContentBased'
predict_new(
  model,
  items = NULL,
  rows = NULL,
  U = NULL,
  I = NULL,
  nthreads = model$info$nthreads,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A collective matrix factorization model from this package - see
fit_models for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>items</code></td>
<td>
<p>The item IDs for which to make predictions. If 'X' to which the model
was fit was a 'data.frame', should pass IDs matching to the second column of 'X'
(the item indices, should be a character vector),
otherwise should pass column numbers for 'X', with numeration
starting at 1 (should be an integer vector).
</p>
<p>If passing 'I', will instead take these indices as row numbers for 'I'
(only available for the ContentBased model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>Rows of the new 'X'/'U' passed here for which to make
predictions, with numeration starting at 1 (should be an integer vector).
If not passed and there is only 1 row of data, will predict the entries in
'items' for that same row. If not passed and there is more than 1 row of data,
the number of rows in the data should match with the number of entries in 'items',
and will make predictions for each such combination of &lt;entry in item, row in the data&gt;.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>New 'X' data, with rows denoting new users.
Can be passed in the following formats:</p>

<ul>
<li>
<p> A sparse COO/triplets matrix, either from package
'Matrix' (class 'dgTMatrix'), or from package 'SparseM' (class 'matrix.coo').
</p>
</li>
<li>
<p> A sparse matrix in CSR format, either from package
'Matrix' (class 'dgRMatrix'), or from package 'SparseM' (class 'matrix.csr').
Passing the input as CSR is faster than COO as it will be converted internally.
</p>
</li>
<li>
<p> A sparse row vector from package 'Matrix' (class 'dsparseVector').
</p>
</li>
<li>
<p> A dense matrix from base R (class 'matrix'), with missing entries set as 'NA'/'NaN'.
</p>
</li>
<li>
<p> A dense row vector from base R (class 'numeric'), with missing entries set as 'NA'/'NaN'.
</p>
</li>
</ul>
<p>Dense 'X' data is not supported for 'CMF_implicit' or 'OMF_implicit'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>New 'U' data, with rows denoting new users.
Can be passed in the same formats as 'X', or additionally
as a 'data.frame', which will be internally converted to a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U_bin</code></td>
<td>
<p>New binary columns of 'U'. Must be passed as a dense matrix from
base R or as a 'data.frame'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>Associated observation weights for entries in 'X'. If passed, must
have the same shape as 'X' - that is, if 'X' is a sparse matrix, should be a
numeric vector with length equal to the non-missing elements, if 'X' is a dense
matrix, should also be a dense matrix with the same number of rows and columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>(In the 'OMF_explicit' model)
Whether to calculate 'A' and 'Am' with the regularization applied
to 'A' instead of to 'Am' (if using the L-BFGS method, this is how the model
was fit). This is usually a slower procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>(For the 'ContentBased' model only) New 'I' data for which to make predictions.
Supports the same formats as 'U'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector with the predicted values for the requested combinations
of users (rows in the new data) and items (columns in the old data, unless passing
'I' in which case will be rows of 'I'). Invalid combinations will be filled with NAs.
</p>


<h3>See Also</h3>

<p>predict.cmfrec
</p>


</div>