<div class="container">

<table style="width: 100%;"><tr>
<td>gsi.merge2signary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auxiliary functions to compute user-defined ilr and ipt transforms.</h2>

<h3>Description</h3>

<p>Compute the basis of a clr-plane, to use with isometric log-ratio or planar transform of a (dataset of)
compositions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">          gsi.merge2signary( M )
          gsi.ilrBase2signary( V )
          gsi.optimalilrBase( x )
          gsi.buildilrBase( W=c(1,-1) )
          gsi.signary2ilrBase( W=c(1,-1) )
          gsi.OrderIlr( V )
          </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p> a merge structure (as explained in <code>hclust</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a compositional data set </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p> a signary matrix (as explained below) defining a partition </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p> a matrix of change of basis from clr/cpt to ilr/ipt </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A signary matrix is a matrix with the same shape as an ilr matrix, 
but containing only +1, 0 or -1 values (thus, it is a kind of "extended 
binary"). If the value W[i,j]= +1, then part "i" is involved in 
coordinate "j" in the numerator; if W[i,j]=-1, it is involed
in the denominator, and if W[i,j]=0 then part "i" does not take 
part in coordinate "j".
</p>
<p>Functions <code>gsi.merge2signary</code> and <code>gsi.buildilrBase</code> are 
intended to compute <code>ilrBase</code> matrices associated to user-defined 
partition structures. Function <code>gsi.ilrBase2signary</code> offers the 
inverse functionality.
</p>
<p>Function <code>gsi.OrderIlr</code> returns a list with two elements: 
"ilrBase" and "order". The first one contains the ilr basis with 
coordinates reordered in decreasing number of involved parts (so, 
all parts are involved in the first coordinate, and only two in the 
last). The second one gives a permutation of the parts so that 
involved parts in each coordinate are always together. 
Note that ilrBase does not have its parts permuted!
</p>


<h3>Value</h3>

<p>These functions will not be usually called on themselves, but 
through their wrappers, mainly <code>ilrBase</code>. Functions
<code>gsi.merge2signary</code> and <code>gsi.ilrBase2signary</code> return 
a signary matrix (as explained in "details"), <code>gsi.optimalilrBase</code> 
returns a merge structure (as epxlained in <code>hclust</code>), and
<code>gsi.buildilrBase</code> (and its alias <code>gsi.signary2ilrBase</code>) 
returns an ilr matrix. These functions are thought to be called 
sequentially. <br>
Apart, <code>gsi.OrderIlr</code> reorders both parts and coordinates to 
ease dendrogram-like representations (see <code>CoDaDendrogram</code>).
</p>


<h3>Note</h3>

<p>It is better not to use gsi.* functions directly since they are internal
functions of the package. Use their wrappers.</p>


<h3>Author(s)</h3>

<p>Raimon Tolosana-Delgado, K.Gerald v.d. Boogaart <a href="http://www.stat.boogaart.de">http://www.stat.boogaart.de</a></p>


<h3>References</h3>

<p>Egozcue J.J., V. Pawlowsky-Glahn, G. Mateu-Figueras and
C. Barcel'o-Vidal (2003) Isometric logratio transformations for
compositional data analysis. <em>Mathematical Geology</em>, <b>35</b>(3)
279-300<br></p>


<h3>See Also</h3>

<p><code>ilrBase</code>,<code>ipt</code>,<code>ilr</code>,
<a href="https://ima.udg.edu/Activitats/CoDaWork03/">https://ima.udg.edu/Activitats/CoDaWork03/</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">m &lt;- matrix(data=c(-1,-2,
                  -3,-4,
                   1, 2),ncol=2,nrow=3,byrow=TRUE)
w &lt;- gsi.merge2signary(m)
w
V=gsi.buildilrBase(w)
V
gsi.ilrBase2signary(V)
gsi.OrderIlr(V)
</code></pre>


</div>