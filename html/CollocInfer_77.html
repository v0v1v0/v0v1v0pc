<div class="container">

<table style="width: 100%;"><tr>
<td>Profiling Routines</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Profile Estimation Functions</h2>

<h3>Description</h3>

<p>These functions are wrappers that create lik and proc functions
and run generalized profiling.</p>


<h3>Usage</h3>

<pre><code class="language-R">Profile.LS(fn,data,times,pars,coefs=NULL,basisvals=NULL,lambda,
                        fd.obj=NULL,more=NULL,weights=NULL,quadrature=NULL,
                        likfn = make.id(), likmore = NULL,
                        in.meth='nlminb',out.meth='nls',
                        control.in,control.out,eps=1e-6,active=NULL,posproc=FALSE,
                        poslik=FALSE,discrete=FALSE,names=NULL,sparse=FALSE)

Profile.multinorm(fn,data,times,pars,coefs=NULL,basisvals=NULL,var=c(1,0.01),
                        fd.obj=NULL,more=NULL,quadrature=NULL,
                        in.meth='nlminb',out.meth='optim',
                        control.in,control.out,eps=1e-6,active=NULL,
                        posproc=FALSE,poslik=FALSE,discrete=FALSE,names=NULL,sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p> A function giving the right hand side of a differential/difference equation.  The function should have arguments
</p>

<ul>
<li>
<p>times The times at which the RHS is being evaluated.
</p>
</li>
<li>
<p>x The state values at those times.
</p>
</li>
<li>
<p>p Parameters to be entered in the system.
</p>
</li>
<li>
<p>more An object containing additional inputs to <code>fn</code>
</p>
</li>
</ul>
<p>It should return a matrix of the same dimension of <code>x</code> giving the right hand side values.
</p>
<p>If <code>fn</code> is given as a single function, its derivatives are estimated by finite-differencing with
stepsize <code>eps</code>. Alternatively, a list can be supplied with elements:
</p>

<ul>
<li>
<p>fn Function to calculate the right hand side should accept a matrix of state values at .
</p>
</li>
<li>
<p>dfdx Function to calculate the derivative with respect to <code>x</code>
</p>
</li>
<li>
<p>dfdp Function to calculate the derivative with respect to <code>p</code>
</p>
</li>
<li>
<p>d2fdx2 Function to calculate the second derivative with respect to <code>x</code>
</p>
</li>
<li>
<p>d2fdxdp Function to calculate the second derivative with respect to <code>x</code> and <code>p</code>
</p>
</li>
</ul>
<p>These functions take the same arguments as <code>fn</code> and should output multidimensional arrays with
the dimensions ordered according to time, state, deriv1, deriv2; here derivatives with respect to <code>x</code>
always precede derivatives with respect to <code>p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisvals</code></td>
<td>
<p>Values of the collocation basis to be used. This can either be a basis object from the <code>fda</code> package,
or a list elements:
</p>

<ul>
<li>
<p>bvals.obs A matrix giving the values of the basis at the observation times
</p>
</li>
<li>
<p>bvals A matrix giving the values of the basis at the quadrature times
</p>
</li>
<li>
<p>dbvals A matrix giving the derivative of the basis at the quadrature times
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>(<code>Profile.LS</code> only) Penalty value trading off fidelity to data with fidelity to differential equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>(<code>profile.Cproc</code> or <code>profile.Dproc</code>) A vector of length 2, giving  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fd.obj</code></td>
<td>
<p>(Optional) A functional data object; if this is non-null, <code>coefs</code> and <code>basisvals</code> is extracted from here. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>more</code></td>
<td>
<p>An object specifying additional arguments to <code>fn</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>(<code>Profile.LS</code> only)  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadrature</code></td>
<td>
<p> Quadrature points, should contain two elements (if not NULL)
</p>

<ul>
<li>
<p>qpts Quadrature points; defaults to midpoints between knots
</p>
</li>
<li>
<p>qwts Quadrature weights; defaults to normalizing by the length of <code>qpts</code>.   
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.meth</code></td>
<td>
<p> Inner optimization function to be used, currently one of 'nlminb', 'MaxNR', 'optim' or 'house'.
The last calls <code>SplineEst.NewtRaph</code>. This is fast but has poor convergence.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.meth</code></td>
<td>
<p> Outer optimization function to be used, depending on the type of method
</p>

<ul>
<li>
<p><code>Profile.LS</code> One of 'nls' or 'ProfileGN'; the latter calls <code>Profile.GausNewt</code> which is fast but
may have poor convergence.
</p>
</li>
<li>
<p><code>Profile.multinorm</code> One of 'optim' (defaults to  BFGS routine in <code>optim</code> unless <code>control.out$meth</code>
specifies otherwise), 'nlminb', or 'maxNR'.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.out</code></td>
<td>
<p> Control object for outer optimization function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> Finite differencing step size, if needed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active</code></td>
<td>
<p> Incides indicating which parameters of <code>pars</code> should be estimated; defaults to all of them.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posproc</code></td>
<td>
<p> Should the state vector be constrained to be positive? If this is the case, the state is represented by
an exponentiated basis expansion in the <code>proc</code> object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poslik</code></td>
<td>
<p> Should the state be exponentiated before being compared to the data? When the state is represented
on the log scale (<code>posproc=TRUE</code>), this is an alternative to taking the log of the data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete</code></td>
<td>
<p> Is this a discrete-time or a continuous-time system? If discrete, the derivative is instead
taken to be the value at the next time point. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p> The names of the state variables if not given by the column names of <code>coefs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p> Should sparse matrices be used for basis values? This option can save memory when 
<code>ProfileGausNewt</code> and <code>SplineEstNewtRaph</code> are called. Otherwise sparse matrices will be converted to 
full matrices and this can slow the code down.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>likfn</code></td>
<td>
<p> Defines a map from the trajectory to the observations. This should be in the same form as
<code>fn</code>. If a function is given, derivatives are estimated by finite differencing, otherwise a list
is expected to provide the same derivatives as <code>fn</code>. If <code>poslik=TRUE</code>, the states are
exponentiated before the <code>likfn</code> is evaluated and the derivatives are updated to account for this.
Defaults to the identity transform. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>likmore</code></td>
<td>
<p> A list containing additional inputs to <code>likfn</code> if needed, otherwise set to <code>NULL</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functional all carry out the profiled optimization method of Ramsay et al 2007.
<code>Profile.LS</code> uses a sum of squared errors criteria for both fit to data and the fit of the derivatives
to a differential equation. <code>Profile.multinorm</code> uses multivariate normal approximations.
<code>discrete</code> changes the system to a discrete-time difference equation with the right hand side function
giving the transition function.
</p>
<p>Note that these all call <code>outeropt</code>, which creates
temporary files 'curcoefs.tmp' and 'optcoefs.tmp' to update coefficients as <code>pars</code> evolves. These overwrite
existing files of those names and are deleted before the function terminates.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>Optimized parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>Optimized coefficients at <code>pars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lik</code></td>
<td>
<p>The <code>lik</code> object generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proc</code></td>
<td>
<p>The <code>proc</code> item generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data used in doing the fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>The vector of times at which the observations were made</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>outeropt</code>, <code>ProfileErr</code>, <code>ProfileSSE</code>, <code>LS.setup</code>, <code>multinorm.setup</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
###############################
####   Data             #######
###############################

data(FhNdata)

###############################
####  Basis Object      #######
###############################

knots = seq(0,20,0.2)
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
	norder=norder,breaks=knots)


#### Start from pre-estimated values to speed up optimization

data(FhNest)

spars = FhNestPars
coefs = FhNestCoefs

lambda = 10000

res1 = Profile.LS(make.fhn(),data=FhNdata,times=FhNtimes,pars=spars,coefs=coefs,
  basisvals=bbasis,lambda=lambda,in.meth='nlminb',out.meth='nls')

Covar = Profile.covariance(pars=res1$pars,times=FhNtimes,data=FhNdata,
  coefs=res1$coefs,lik=res1$lik,proc=res1$proc) 


## Not run: 
## Alternative, starting from perturbed coefficients -- takes too long for 
# automatic checks in CRAN

# Initial values for coefficients will be obtained by smoothing

DEfd = smooth.basis(FhNtimes,FhNdata,fdPar(bbasis,1,0.5))   # Smooth to estimate
                                                            # coefficients first
coefs = DEfd$fd$coefs
colnames(coefs) = FhNvarnames


###############################
####     Optimization       ###
###############################

spars = c(0.25,0.15,2.5)          # Perturbed parameters
names(spars)=FhNparnames
lambda = 10000

res1 = Profile.LS(make.fhn(),data=FhNdata,times=FhNtimes,pars=spars,coefs=coefs,
  basisvals=bbasis,lambda=lambda,in.meth='nlminb',out.meth='nls')

par(mfrow=c(2,1))
plotfit.fd(FhNdata,FhNtimes,fd(res1$coefs,bbasis))

## End(Not run)  
  
 
 
  
## Not run: 
####################################################
###  An Explicitly Multivariate Normal Formation ### 
####################################################

var = c(1,0.0001)

res2 = Profile.multinorm(make.fhn(),FhNdata,FhNtimes,pars=res1$pars,
          res1$coefs,bbasis,var=var,out.meth='nlminb', in.meth='nlminb')

## End(Not run)</code></pre>


</div>