<div class="container">

<table style="width: 100%;"><tr>
<td>mleEst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate Ability in IRT Models</h2>

<h3>Description</h3>

<p><code>mleEst</code>, <code>wleEst</code>, <code>bmeEst</code>, and <code>eapEst</code> estimate
ability in IRT models. <code>mleEst</code> is Maximum Likelihood Information, <code>wleEst</code> is
Weighted Likelihood Information (see <b>Details</b>), <code>bmeEst</code> is
Bayesian-Modal Estimation, and <code>eapEst</code> is Expected-A-Posterior Estimation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mleEst( resp, params, range = c(-6, 6), mod = c("brm", "grm"), ... )
wleEst( resp, params, range = c(-6, 6), mod = c("brm", "grm"), ... )
bmeEst( resp, params, range = c(-6, 6), mod = c("brm", "grm"),
        ddist = dnorm, ... )
eapEst( resp, params, range = c(-6, 6), mod = c("brm", "grm"),
        ddist = dnorm, quad = 33, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>resp</code></td>
<td>
<p><b>numeric:</b> either a <code class="reqn">N \times J</code> matrix (where <code class="reqn">N</code> indicates the
number of simulees and <code class="reqn">J</code> indicates the number of items), a
<code class="reqn">N</code> length vector (if there is only one item) or a <code class="reqn">J</code> length
vector (if there is only one simulee).  For the binary response model
(<span class="option">"brm"</span>), <code>resp</code> must solely contain 0s and 1s.  For the
graded response model (<span class="option">"grm"</span>), <code>resp</code> must solely contain
integers <code class="reqn">1, \ldots, K</code>, where <code class="reqn">K</code> is the number of categories, as
indicated by the dimension of <code>params</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p><b>numeric:</b> a vector or matrix of item parameters.  If specified
as a matrix, the rows must index the items, and the columns
must designate the item parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p><b>numeric:</b> a two-element numeric vector indicating the minimum and maximum over
which to optimize a likelihood function (<code>mleEst</code>) or posterior distribution
(<code>bmeEst</code>), find roots to a score function (<code>wleEst</code>), or integrate
over (<code>eapEst</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p><b>character:</b> a character string indicating the IRT model.  Current support
is for the 3-parameter binary response model (<span class="option">"brm"</span>),
and Samejima's graded response model (<span class="option">"grm"</span>).
See <code>simIrt</code> for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ddist</code></td>
<td>
<p><b>function:</b> a function that calculates prior densities for Bayesian
estimation.  For instance, if you wish to specify a normal prior, <code>ddist = dnorm</code>,
and if you wish to specify a uniform prior, <code>ddist = dunif</code>.  Note that
it is standard in R to use <code>d</code>... to indicate a density.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad</code></td>
<td>
<p><b>numeric:</b> a scalar indicating the number of quadrature points when
using <code>eapEst</code>.  See <b>Details</b> for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>ddist</code>, usually distribution parameters
identified by name.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions return estimated "ability" for the binary response model (<span class="option">"brm"</span>)
and the graded response model (<span class="option">"grm"</span>).  The only difference between the functions
is how they estimate ability.
</p>
<p>The function <code>mleEst</code> searches for a maximum of the log-likelihood with respect to
each individual <code class="reqn">\theta_i</code> and uses <code class="reqn">[T(\theta)]^{-1/2}</code> as the corresponding standard
error of measurement (SEM), where <code class="reqn">T(\theta)</code> is the observed test information function
at <code class="reqn">\theta</code>, as described in <code>FI</code>.
</p>
<p>The function <code>bmeEst</code> searches for the maximum of the log-likelihood after a
log-prior is added, which effectively maximizes the posterior distribution for each
individual <code class="reqn">\theta_i</code>.  The SEM of the <code>bmeEst</code> estimator uses the well known
relationship (Keller, 2000, p. 10)
</p>
<p style="text-align: center;"><code class="reqn">V[\theta | \boldsymbol{u}_i]^{-1} = T(\theta) - \frac{\partial \log[p(\theta)]}{\partial \theta^2}</code>
</p>

<p>where <code class="reqn">V[\theta | \boldsymbol{u}_i]</code> is the variance of <code class="reqn">\theta</code> after
taking into consideration the prior distribution and <code class="reqn">p(\theta)</code> is the prior distribution
of <code class="reqn">\theta</code>.  The function <code>bmeEst</code> estimates the second derivative of the prior
distribution uses the <code>hessian</code> function in the <code>numDeriv</code> package.
</p>
<p>The function <code>wleEst</code> searches for the root of a modified score function (i.e.
the first derivative of the log-likelihood with something added to it).  The modification
corrects for bias in fixed length tests, and estimation using this modification results in
what is called Weighted Maximum Likelihood (or alternatively, the Warm estimator) (see Warm,
1989).  So rather than maximizing the likelihood, <code>wleEst</code> finds a root of:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\partial l(\theta)}{\partial \theta} + \frac{H(\theta)}{2I(\theta)}</code>
</p>

<p>where <code class="reqn">l(\theta)</code> is the log-likelihood of <code class="reqn">\theta</code> given a set of responses
and item parameters, <code class="reqn">I(\theta)</code> is expected test information to this point,
and <code class="reqn">H(\theta)</code> is a correction constant defined as:
</p>
<p style="text-align: center;"><code class="reqn"> H(\theta) = \sum_j\frac{p_{ij}^{\prime}p_{ij}^{\prime\prime}}{p_{ij}[1 - p_{ij}]}</code>
</p>

<p>for the binary response model, where <code class="reqn">p_{ij}^{\prime}</code> is the first derivative
of <code class="reqn">p_{ij}</code> with respect to <code class="reqn">\theta</code>, <code class="reqn">p_{ij}^{\prime\prime}</code> is
the second derivative of <code class="reqn">p_{ij}</code> with respect to <code class="reqn">\theta</code>, and <code class="reqn">p_{ij}</code> is the
probability of response, as indicated in the help page for <code>simIrt</code>, and
</p>
<p style="text-align: center;"><code class="reqn"> H(\theta) = \sum_j\sum_k\frac{P_{ijk}^{\prime}P_{ijk}^{\prime\prime}}{P_{ijk}}</code>
</p>

<p>for the graded response model, where <code class="reqn">P_{ijk}^{\prime}</code> is the first derivative
of <code class="reqn">P_{ijk}</code> with respect to <code class="reqn">\theta</code>, <code class="reqn">P_{ijk}^{\prime\prime}</code> is
the second derivative of <code class="reqn">P_{ijk}</code>, and <code class="reqn">P_{ijk}</code> is the probability of responding
in category k as indicated in the help page for <code>simIrt</code>.  The SEM of the <code>wleEst</code>
estimator uses an approximation based on Warm (1989, p. 449):
</p>
<p style="text-align: center;"><code class="reqn"> V(\theta) \approx \frac{T(\theta) + \frac{H(\theta)}{2I(\theta)}}{T^2(\theta)}</code>
</p>

<p>The function <code>eapEst</code> finds the mean and standard deviation of the posterior distribution
given the log-likelihood, a prior distribution (with specified parameters), and the number of
quadrature points using the standard Bayesian identity with summations in place of integrations
(see Bock and Mislevy, 1982). Rather than using the adaptive, quadrature based <code>integrate</code>,
<code>eapEst</code> uses the flexible <code>integrate.xy</code> function in the <code>sfsmisc</code> package. 
As long as the prior distribution is reasonable (such that the joint distribution is relatively smooth),
this method should work.
</p>


<h3>Value</h3>

<p><code>mleEst</code>, <code>wleEst</code>, <code>bmeEst</code>, and <code>eapEst</code> return a list of the
following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>an <code class="reqn">N</code>-length vector of ability values, one for each simulee.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>an <code class="reqn">N</code>-length vector of observed test information, one for each simulee.
Test information is the sum of item information across items.  See <code>FI</code>
for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sem</code></td>
<td>
<p>an <code class="reqn">N</code>-length vector of observed standard error of measurement (or posterior standard
deviation) for each simulee.  See <code>FI</code> for more information.
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For the binary response model (<span class="option">"brm"</span>), it makes no sense to estimate
ability with a non-mixed response pattern (all 0s or all 1s).  The user might want
to include enough items in the model to allow for reasonable estimation.
</p>
<p>Weighted likelihood estimation (<code>wleEst</code>) uses <code>uniroot</code> to find the root
of the modified score function, so that the end points of <span class="option">range</span> must evaluate
to opposite signs (or zero).  Rarely, the end points of <span class="option">range</span> will evaluate
to the same sign, so that <code>uniroot</code> will error.  In these cases, uniroot will
extend the interval until the end points of the (modified) range are opposite signs.
</p>


<h3>Author(s)</h3>

<p>Steven W. Nydick <a href="mailto:swnydick@gmail.com">swnydick@gmail.com</a>
</p>


<h3>References</h3>

<p>Bock, R. D., &amp; Mislevy, R. J.  (1982).  Adaptive EAP estimation of ability in a microcomputer environment.  <em>Applied Psychological Measurement</em>, <em>6</em>, 431 – 444.
</p>
<p>Embretson, S. E., &amp; Reise, S. P.  (2000).  <em>Item Response Theory for Psychologists</em>.  Mahway, NJ: Lawrence Erlbaum Associates.
</p>
<p>Keller (2000).  <em>Ability estimation procedures in computerized adaptive testing</em> (Technical Report).  New York, NY: American Institute of Certified Public Accountants.
</p>
<p>Warm, T. A.  (1989).  Weighted likelihood estimation of ability in item response theory.  <em>Psychometrika</em>, <em>54</em>, 427 – 450.
</p>
<p>van dr Linden, W. J. &amp; Pashley, P. J.  (2010).  Item selection and ability estimation in adaptive testing.  In W. J. van der Linden &amp; C. A. W. Glas (Eds.), <em>Elements of Adaptive Testing</em>.  New York, NY: Springer.
</p>


<h3>See Also</h3>

<p><code>catIrt</code>, <code>simIrt</code>,
<code>hessian</code>, <code>uniroot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

#########################
# Binary Response Model #
#########################
set.seed(888)
# generating random theta:
theta &lt;- rnorm(201)
# generating an item bank under a 2-parameter binary response model:
b.params &lt;- cbind(a = runif(100, .5, 1.5), b = rnorm(100, 0, 2), c = 0)
# simulating responses using specified theta:
b.resp &lt;- simIrt(theta = theta, params = b.params, mod = "brm")$resp


# estimating theta using all four methods:
est.mle1 &lt;- mleEst(resp = b.resp, params = b.params, mod = "brm")$theta
est.wle1 &lt;- wleEst(resp = b.resp, params = b.params, mod = "brm")$theta
est.bme1 &lt;- bmeEst(resp = b.resp, params = b.params, mod = "brm",
                   ddist = dnorm, mean = 0, sd = 1)$theta
est.eap1 &lt;- eapEst(resp = b.resp, params = b.params, mod = "brm",
                   ddist = dnorm, mean = 0, sd = 1, quad = 33)$theta

# eap takes a while!

# all of the methods are highly correlated:
cor(cbind(theta = theta, mle = est.mle1, wle = est.wle1,
                         bme = est.bme1, eap = est.eap1))

# you can force eap to be positive:
est.eap2 &lt;- eapEst(resp = b.resp, params = b.params, range = c(0, 6),
                                  mod = "brm", ddist = dunif, min = 0, max = 6)$theta

est.eap2

# if you only have a single response, MLE will give junk!
mleEst(resp = 0, params = c(1, 0, .2), mod = "brm")$theta

# the others will give you answers that are not really determined by the response:
wleEst(resp = 0, params = c(1, 0, .2), mod = "brm")$theta
bmeEst(resp = 0, params = c(1, 0, .2), mod = "brm")$theta
eapEst(resp = 0, params = c(1, 0, .2), mod = "brm")$theta


#########################
# Graded Response Model #
#########################
set.seed(999)
# generating random theta
theta &lt;- rnorm(400)
# generating an item bank under a graded response model:
g.params &lt;- cbind(a = runif(100, .5, 1.5), b1 = rnorm(100), b2 = rnorm(100),
                                           b3 = rnorm(100), b4 = rnorm(100))
# simulating responses using random theta:
g.mod &lt;- simIrt(params = g.params, theta = theta, mod = "grm")

# pulling out the responses and the parameters:
g.params2 &lt;- g.mod$params[ , -1]       # now the parameters are sorted
g.resp2 &lt;- g.mod$resp

# estimating theta using all four methods:
est.mle3 &lt;- mleEst(resp = g.resp2, params = g.params2, mod = "grm")$theta
est.wle3 &lt;- wleEst(resp = g.resp2, params = g.params2, mod = "grm")$theta
est.bme3 &lt;- bmeEst(resp = g.resp2, params = g.params2, mod = "grm",
                   ddist = dnorm, mean = 0, sd = 1)$theta
est.eap3 &lt;- eapEst(resp = g.resp2, params = g.params2, mod = "grm",
                   ddist = dnorm, mean = 0, sd = 1, quad = 33)$theta

# and the correlations are still pretty high:
cor(cbind(theta = theta, mle = est.mle3, wle = est.wle3,
                         bme = est.bme3, eap = est.eap3))

# note that the graded response model is just a generalization of the brm:
cor(est.mle1, mleEst(resp = b.resp + 1, params = b.params[ , -3], mod = "grm")$theta)
cor(est.wle1, wleEst(resp = b.resp + 1, params = b.params[ , -3], mod = "grm")$theta)
cor(est.bme1, bmeEst(resp = b.resp + 1, params = b.params[ , -3], mod = "grm")$theta)
cor(est.eap1, eapEst(resp = b.resp + 1, params = b.params[ , -3], mod = "grm")$theta)


## End(Not run)

</code></pre>


</div>