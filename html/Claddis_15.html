<div class="container">

<table style="width: 100%;"><tr>
<td>calculate_tree_length</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculates the parsimony length of a set of phylogenetic tree(s)</h2>

<h3>Description</h3>

<p>Given a tree, or set of trees, and a cladistic matrix returns their parsimony length in number of steps.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calculate_tree_length(
  trees,
  cladistic_matrix,
  inapplicables_as_missing = FALSE,
  polymorphism_behaviour,
  uncertainty_behaviour,
  polymorphism_geometry,
  polymorphism_distance,
  state_ages,
  dollo_penalty
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>trees</code></td>
<td>
<p>A tree (<code>phylo</code> object) or set of trees (<code>multiPhylo</code> object).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cladistic_matrix</code></td>
<td>
<p>A character-taxon matrix in the format imported by read_nexus_matrix. These should be discrete with rownames (ytaxon labels) matching the tip labels of <code>trees</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inapplicables_as_missing</code></td>
<td>
<p>Logical that decides whether or not to treat inapplicables as missing (TRUE) or not (FALSE, the default and recommended option).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polymorphism_behaviour</code></td>
<td>
<p>One of either "missing", "uncertainty", "polymorphism", or "random". See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncertainty_behaviour</code></td>
<td>
<p>One of either "missing", "uncertainty", "polymorphism", or "random". See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polymorphism_geometry</code></td>
<td>
<p>Argument passed to make_costmatrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polymorphism_distance</code></td>
<td>
<p>Argument passed to make_costmatrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state_ages</code></td>
<td>
<p>Argument passed to make_costmatrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dollo_penalty</code></td>
<td>
<p>Argument passed to make_costmatrix.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Under the maximum parsimony criterion, a phylogenetic hypothesis is considered optimal if it requires the fewest number of evolutionary "steps" or - to generalise to non-discrete values - minimum total cost. In order to evalulate this criterion we must therefore be able to calculate a tree's "length" (total cost assuming the lowest cost for every character used). Given a set of phylogenetic hypothes(es) and a cladistic matrix this function calculates the minimum length for each tree.
</p>
<p><b>Input data format</b>
</p>
<p>This function operates on a phylogenetic tree, or trees (in <code>ape</code> format), and a cladistic matrix (in <code>cladisticMatrix</code> format). However, the algorithm used is based on the generalised costmatrix approach of Swofford and Maddison (1992) and hence costmatrices need to be defined for each character (this is done internally by calling make_costmatrix), and some of the options are merely passed to this function.
</p>
<p><b>Algorithm</b>
</p>
<p>Technically the Swofford and Maddison (1992) algorithm is designed for ancestral state reconstruction, but as its' first pass of the tree assigns lengths for each possible state at each node the minimum value of these options at the root is also the tree length for that character and hence by skipping the later steps this can be used as a tree length algorithm by simply summing the values across each character. The choice of the Swofford and Maddison algorithm, rather than the Wagner or Fitch algorithms (for ordered and unordered characters, respectively) is to generalize to the broadest range of character types, including asymmetric characters (Camin-Sokal, Dollo, stratigraphic), custom character types (specified using costmatrices or character state trees), as well as to any resolution of tree (i.e., including multifurcating trees - important for establishing maximum costs for homoplasy indices). The only restriction here is that the tree must be rooted such that time's arrow is explicitly present. This is essential, as the root defines the lengths across the whole tree, but also for asymmetric characters directionality must be explicit, as well as some downstream approaches (such as ACCTRAN and DELTRAN). The two obvious drawbacks to this algorithm are that it can be slower and that it is not appropriate for unrooted trees.
</p>
<p><b>Costmatrices and costmatrix options</b>
</p>
<p>Costmatrices are described in detail in the make_costmatrix manual, as are the options that are passed from this function to that one. Thus, the user is directed there for a more in-depth discussion of options.
</p>
<p><b>Inapplicable and missing characters</b>
</p>
<p>In practice these two character types are treated the same for length calculations - in effect these are "free" characters that do not constrain the tree length calculation in the same way that a coded character would (because a coded character's transition cost must be accounted for; Swofford and Maddison 1992). Note that there <em>are</em> reasons to take differences into account in phylogenetic inference itself (see papers by Brazeau et al. 2019 and Goloboff et al. in press). The option to treat them differently here is therefore only important in terms of downstream analyses, such as ancestral state reconstruction (see reconstruct_ancestral_states for details).
</p>
<p><b>Polymorphisms and uncertainties</b>
</p>
<p>Polymorphisms (coded with empersands between states) and uncertainties (coded with slashes between states) can be interpreted in different ways, including those that affect estimates of tree length. Hence four options are provided to the user here:
</p>

<ol>
<li>
<p> Missing (<code>polymorphism_behaviour = "missing"</code> or <code>uncertainty_behaviour = "missing"</code>). Here polymorphisms are simply replaced by the missing character (<code>NA</code>). This removes polymorphisms and uncertainties from the calculation process completely (likely leading to undercounts), and hence is not generally recommended.
</p>
</li>
<li>
<p> Uncertainty (<code>polymorphism_behaviour = "uncertainty"</code> or <code>uncertainty_behaviour = "uncertainty"</code>). This is the intended use of uncertain codings (e.g., <code>0/1</code>) and constrains the tree length calculation to having to explain the <em>least</em> costly transition of those in the uncertainty. This is recommended for uncertain characters (although note that it biases the result towards the shortest possible length), but not truly polymorphic characters (as one or more state acquisitions are being missed, see Nixon and Davis 1991 and make_costmatrix for discussion of this). This is also - to the best of my knowledge - the approach used by most parsimony software, such as PAUP* (Swofford 2003) and TNT (Goloboff et al. 2008; Goloboff and Catalano 2016).
</p>
</li>
<li>
<p> Polymorphism (<code>polymorphism_behaviour = "polymorphism"</code> or <code>uncertainty_behaviour = "polymorphism"</code>). If polymorphisms are real then some means of accounting for the changes that produce them seems appropriate, albeit difficult (see Nixon and Davis 1991 and Swofford and Maddison 1992 for discussions). If this option is applied it triggers the downstream options in <em>make_costmatrix</em> (by internally setting <code>include_polymorphisms = TRUE</code>), and the user should look there for more information. This is tentatively recommended for true polymorphisms (but note that it complicates interpretation), but not uncertainties.
</p>
</li>
<li>
<p> Random (<code>polymorphism_behaviour = "random"</code> or <code>uncertainty_behaviour = "random"</code>). Another means of dealing with multiple-state characters is simply to sample a single state at random for each one, for example as Watanabe (2016) did with their PERDA algorithm. This simplifies the process, but also logically requires running the function multiple times to quantify uncertainty. This is not recommended for true polymorphisms (as interpretation is confounded), but may be appropriate for a less downwards biased tree count than <code>"uncertainty"</code>.
</p>
</li>
</ol>
<p>These choices can also effect ancestral state estimation (see reconstruct_ancestral_states).
</p>
<p><b>Polytomies</b>
</p>
<p>Polytomies are explicitly allowed by the function, but will always be treated as "hard" (i.e., literal multifurcations). Note that typically these will lead to higher tree lengths than fully bifurcating trees and indeed that the maximum cost is typically calculated from the star tree (single multifurcation).
</p>
<p><b>Further constraints</b>
</p>
<p>In future the function will allow restrictions to be placed on the state at particular internal nodes. This can have multiple applications, including (for example) treating some taxa as ancestral such that their states are directly tied to specific nodes, e.g., in stratocladistics (Fisher 1994; Marcot and Fox 2008).
</p>
<p><b>Character weights</b>
</p>
<p>Tree lengths output already include corrections for character weights as supplied in the <code>cladistic_matrix</code> input. So, for example, if a binary character costs two on the tree, but is weighted five then it will contribute a total cosr of 10 to the result.
</p>


<h3>Value</h3>

<p>A list with multiple components, including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>input_trees</code></td>
<td>
<p>The tree(s) used as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input_matrix</code></td>
<td>
<p>The raw (unmodified) <code>cladistic_matrix</code> input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input_options</code></td>
<td>
<p>The various input options used. Output for use by downstream functions, such as ancestral state estimation and stochastic character mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>costmatrices</code></td>
<td>
<p>The costmatrices (one for each character) used. These are typically generated automatically by the funcion, but are output here for later use in ancestral state estimation and stochastic character mapping functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>character_matrix</code></td>
<td>
<p>The single character matrix object used. Essentially the <code>input_matrix</code> modified by the <code>input_options</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>character_lengths</code></td>
<td>
<p>A matrix of characters (rows) and trees (columns) with values indicating the costs. The column sums of this matrix are the <code>tree_lengths</code> values. This output can also be used for homoplasy metrics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>character_weights</code></td>
<td>
<p>A vector of the character weights used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree_lengths</code></td>
<td>
<p>The primary output - the length for each input tree in total cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_values</code></td>
<td>
<p>The values (lengths for each state) for each node acrss trees and characters. This is used by reconstruct_ancestral_states for ancestral state reconstruction.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Graeme T. Lloyd <a href="mailto:graemetlloyd@gmail.com">graemetlloyd@gmail.com</a>
</p>


<h3>References</h3>

<p>Brazeau, M. D., Guillerme, T. and Smith, M. R., 2019. An algorithm for morphological phylogenetic analysis with inapplicable data. <em>Systematic Biology</em>, <b>68</b>, 619-631.
</p>
<p>Fisher, D. C., 1994. Stratocladistics: morphological and temporal patterns and their relation to phylogenetic process. In L. Grande and O. Rieppel (eds.), <em>Interpreting the Hierarchy of Nature</em>. Academic Press, San Diego. pp133–171.
</p>
<p>Goloboff, P. A. and Catalano, S. A., 2016. TNT version 1.5, including a full implementation of phylogenetic morphometrics/ <em>Cladistics</em>, <b>32</b>. 221-238
</p>
<p>Goloboff, P., Farris, J. and Nixon, K., 2008. TNT, a free program for phylogenetic analysis. <em>Cladistics</em>, <b>24</b>, 774-786.
</p>
<p>Goloboff, P. A., De Laet, J., Rios-Tamayo, D. and Szumik, C. A., in press. A reconsideration of inapplicable characters, and an approximation with step‐matrix recoding. <em>Cladistics</em>.
</p>
<p>Marcot, J. D. and Fox, D. L., 2008. StrataPhy: a new computer program for stratocladistic analysis. <em>Palaeontologia Electronica</em>, <b>11</b>, 5A.
</p>
<p>Nixon, K. C. and Davis, J. I., 1991. Polymorphic taxa, missing values and cladistic analysis. <em>Cladistics</em>, <b>7</b>, 233-241.
</p>
<p>Swofford, D. L., 2003. <em>PAUP*. Phylogenetic Analysis Using Parsimony (*and Other Methods). Version 4</em>. Sinauer Associates, Sunderland, Massachusetts.
</p>
<p>Swofford, D. L. and Maddison, W. P., 1992. Parsimony, character-state reconstructions, and evolutionary inferences. <em>In</em> R. L. Mayden (ed.) Systematics, Historical Ecology, and North American Freshwater Fishes. Stanford University Press, Stanford, p187-223.
</p>
<p>Watanabe, A., 2016. The impact of poor sampling of polymorphism on cladistic analysis. <em>Cladistics</em>, <b>32</b>, 317-334.
</p>


<h3>See Also</h3>

<p>make_costmatrix, reconstruct_ancestral_states
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Use Gauthier 1986 as example matrix:
cladistic_matrix &lt;- Claddis::gauthier_1986

# Use one of the MPTs from a TNT analysis as the tree:
tree &lt;- ape::read.tree(
  text = paste(
    "(Outgroup,(Ornithischia,(Sauropodomorpha,(Ceratosauria,Procompsognathus,",
    "Liliensternus,(Carnosauria,(Ornithmimidae,Saurornitholestes,Hulsanpes,(Coelurus,",
    "Elmisauridae,(Compsognathus,(Ornitholestes,Microvenator,Caenagnathidae,",
    "(Deinonychosauria,Avialae))))))))));",
    sep = ""
  )
)

# Calculate tree length (and only use tree lengths from output):
calculate_tree_length(
  trees = tree,
  cladistic_matrix = cladistic_matrix,
  inapplicables_as_missing = TRUE,
  polymorphism_behaviour = "uncertainty",
  uncertainty_behaviour = "uncertainty",
  polymorphism_geometry = "simplex",
  polymorphism_distance = "euclidean",
  state_ages = c(200, 100),
  dollo_penalty = 999
)$tree_lengths

</code></pre>


</div>