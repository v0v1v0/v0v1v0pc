<div class="container">

<table style="width: 100%;"><tr>
<td>multiply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>multiply a colorSpec object by scalar, vector, or matrix</h2>

<h3>Description</h3>

<p>multiply spectra by coefficients and return modified object
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'colorSpec'
multiply( x, s )

## S3 method for class 'colorSpec'
normalize( x, norm='L1' )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <b>colorSpec</b> object with M spectra</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a scalar, an M-vector, or an MxP matrix. 
In the case of a matrix, assigning <code>colnames(s)</code> is recommended;
see <b>Details</b>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>one of <code>'L1'</code>, <code>'L2'</code>, or <code>'Linf'</code>, specifying one of the standard vector norms <code class="reqn">L^1, L^2, or L^{inf}</code>. <br><code>norm</code> can also be a numeric wavelength (e.g. 560 nm), and then the spectrum is scaled to have value 1 at this wavelength.  Of course, this is not a true vector norm. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>multiply()</code>:<br>
If <code>s</code> is an  MxP  matrix, say <b>S</b>, and one thinks of the spectra as
organized in an  NxM  matrix <b>X</b>, 
then the new spectra are defined by the matrix <b>XS</b>, which is  NxP.
If the P column names of <code>s</code> are set, then they are copied to the 
<code>specnames</code> of the output.
Otherwise, default spectrum names are assigned as in   
<code>colorSpec()</code>, with a warning. <br>
If <code>s</code> is an M-vector, then <b>S</b>=<code>diag(s)</code> is computed and used in the previous sentence.
This has the effect of multiplying spectrum i by <code>s</code>[i].<br>
If <code>s</code> is a scalar then every spectrum is multiplied by <code>s</code>.<br>
The multiplication may produce negative entries, but no check is made for this.<br>  
WARNING: An M-vector and an Mx1 matrix may yield quite different results.
</p>
<p>For <code>normalize()</code>:<br><code>normalize()</code> calls <code>multiply()</code> with <code>s</code> = an M-vector.
If the norm of a spectrum is 0, then it is left unchanged.   
</p>


<h3>Value</h3>

<p><code>multiply</code> returns a <b>colorSpec</b> object with the matrix of spectra
of <code>x</code> multiplied by <code>s</code>.
</p>
<p><code>normalize</code> returns a <b>colorSpec</b> object with each spectrum
of <code>x</code> scaled to have given norm equal to 1.
</p>
<p>In both functions, the <code>quantity</code> and <code>wavelength</code> are preserved.  
</p>


<h3>Note</h3>

<p>If <code>x</code> is organized as a matrix, and <code>s</code> is a scalar,
the one can use the simpler and equivalent <code>s*x</code>.
</p>


<h3>See Also</h3>

<p><code>product()</code>,
<code>quantity()</code>,
<code>wavelength()</code>,
<code>specnames()</code>,  
<code>colorSpec()</code>
</p>


</div>