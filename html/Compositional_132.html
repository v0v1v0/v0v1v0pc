<div class="container">

<table style="width: 100%;"><tr>
<td>Helper functions for the Kullback-Leibler regression</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Helper functions for the Kullback-Leibler regression
</h2>

<h3>Description</h3>

<p>Helper functions for the Kullback-Leibler regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kl.compreg2(y, x, con = TRUE, xnew = NULL, tol = 1e-07, maxiters = 50)
klcompreg.boot(y, x, der, der2, id, b1, n, p, d, tol = 1e-07, maxiters = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>A matrix with the compositional data (dependent variable). Zero values are allowed. For the klcompreg.boot the first column is removed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>The predictor variable(s), they can be either continuous or categorical or both. In the klcompreg.boot this is the design matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con</code></td>
<td>

<p>If this is TRUE (default) then the constant term is estimated, otherwise the model includes no constant term.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xnew</code></td>
<td>

<p>If you have new data use it, otherwise leave it NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>The tolerance value to terminate the Newton-Raphson procedure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiters</code></td>
<td>

<p>The maximum number of Newton-Raphson iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>der</code></td>
<td>

<p>An vector to put the first derivative there.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>der2</code></td>
<td>

<p>An empty matrix to put the second derivatives there, the Hessian matrix will be put here.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>A help vector with indices.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>

<p>The matrix with the initial estimated coefficients.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>The sample size
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>The number of columns of the design matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The dimensionality of the simplex, that is the number of columns of the compositional data minus 1.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These are help functions for the <code>kl.compreg</code> function. They are not to be called directly by the user.
</p>


<h3>Value</h3>

<p>For kl.compreg2 a list including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>iters</code></td>
<td>

<p>The nubmer of iterations required by the Newton-Raphson.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>

<p>The loglikelihood.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>be</code></td>
<td>

<p>The beta coefficients.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>

<p>The fitted or the predicted values (if xnew is not NULL).
</p>
</td>
</tr>
</table>
<p>For klcompreg.boot a list including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>

<p>The loglikelihood.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>be</code></td>
<td>

<p>The beta coefficients.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Murteira, Jose MR, and Joaquim JS Ramalho 2016. Regression analysis of multivariate fractional data.
Econometric Reviews 35(4): 515-552.
</p>


<h3>See Also</h3>

<p><code> diri.reg, js.compreg, ols.compreg, comp.reg
</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  library(MASS)
  x &lt;- as.vector(fgl[, 1])
  y &lt;- as.matrix(fgl[, 2:9])
  y &lt;- y / rowSums(y)
  mod1&lt;- kl.compreg(y, x, B = 1, ncores = 1)
  mod2 &lt;- js.compreg(y, x, B = 1, ncores = 1)
</code></pre>


</div>