<div class="container">

<table style="width: 100%;"><tr>
<td>customizedGlmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
fit glmnet using customized training
</h2>

<h3>Description</h3>

<p>Fit a regularized lasso model using customized training
</p>


<h3>Usage</h3>

<pre><code class="language-R">customizedGlmnet(xTrain, yTrain, xTest, groupid = NULL, G = NULL,
    family = c("gaussian", "binomial", "multinomial"), dendrogram = NULL,
    dendrogramTestIndices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xTrain</code></td>
<td>

<p>an n-by-p matrix of training covariates
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yTrain</code></td>
<td>

<p>a length-n vector of training responses. Numeric for family = <code>"gaussian"</code>.
Factor or character for <code>family = "binomial"</code> or
<code>family = "multinomial"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xTest</code></td>
<td>

<p>an m-by-p matrix of test covariates
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupid</code></td>
<td>

<p>an optional length-m vector of group memberships for the test set. If
specified, customized training subsets are identified using the union of
nearest neighbor sets for each test group. Either <code>groupid</code> or <code>G</code>
must be specified
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>

<p>a positive integer indicating the number of clusters for the joint clustering
of the test and training data. Ignored if <code>groupid</code> is specified. Either
<code>groupid</code> or <code>G</code> must be specified
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>response type
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dendrogram</code></td>
<td>

<p>optional output from <code>hclust</code> on the joint covariate data. Used by
<code>cv.customizedGlmnet</code> so that clustering is not computed redundantly
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dendrogramTestIndices</code></td>
<td>

<p>optional set of indices (corresponding to dendrogram) held out in
cross-validation. Used by <code>cv.customizedGlmnet</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Identify customized training subsets of the training data through one of two
methods: (1) If groupid is specified, grouping the test data, then for each
test group find the 10 nearest neighbors of each observation in the group and
use the union of these nearest neighbor sets as the customized training set or
(2) If G is specified, jointly cluster the test and training data using
hierarchical clustering with complete linkage. Within each cluster, the
training data are used as the customized training subset for the test data.
Once the customized training subsets have been identified, use glmnet to fit an
l1-regularized regression model to each.
</p>


<h3>Value</h3>

<p>an object with class <code>customizedGlmnet</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the call that produced this object
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CTset</code></td>
<td>

<p>a list containing the customized training subsets for each test group
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>a list containing the glmnet fit for each test group
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupid</code></td>
<td>

<p>a length-m vector containing the group memberships of the test data
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a list containing <code>train</code> (which is the input <code>xTrain</code>) and
<code>test</code> (which is the input <code>xTest</code>). Specified in function call
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>training response vector (specified in function call)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>response type (specified in function call)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard</code></td>
<td>

<p>the fit of <code>glmnet</code> to the entire training set using standard training
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Scott Powers, Trevor Hastie, Robert Tibshirani
</p>


<h3>References</h3>

<p>Scott Powers, Trevor Hastie and Robert Tibshirani (2015) "Customized training
with an application to mass specrometric imaging of gastric cancer data."
Annals of Applied Statistics 9, 4:1709-1725.
</p>


<h3>See Also</h3>

<p><code>print.customizedGlmnet</code>, <code>predict.customizedGlmnet</code>,
<code>plot.customizedGlmnet</code>, <code>cv.customizedGlmnet</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(glmnet)

# Simulate synthetic data

n = m = 150
p = 50
q = 5
K = 3
sigmaC = 10
sigmaX = sigmaY = 1
set.seed(5914)

beta = matrix(0, nrow = p, ncol = K)
for (k in 1:K) beta[sample(1:p, q), k] = 1
c = matrix(rnorm(K*p, 0, sigmaC), K, p)
eta = rnorm(K)
pi = (exp(eta)+1)/sum(exp(eta)+1)
z = t(rmultinom(m + n, 1, pi))
x = crossprod(t(z), c) + matrix(rnorm((m + n)*p, 0, sigmaX), m + n, p)
y = rowSums(z*(crossprod(t(x), beta))) + rnorm(m + n, 0, sigmaY)

x.train = x[1:n, ]
y.train = y[1:n]
x.test = x[n + 1:m, ]
y.test = y[n + 1:m]


# Example 1: Use clustering to fit the customized training model to training
# and test data with no predefined test-set blocks

fit1 = customizedGlmnet(x.train, y.train, x.test, G = 3,
    family = "gaussian")

# Print the customized training model fit:
fit1

# Extract nonzero regression coefficients for each group:
nonzero(fit1, lambda = 10)

# Compute test error using the predict function:
mean((y.test - predict(fit1, lambda = 10))^2)

# Plot nonzero coefficients by group:
plot(fit1, lambda = 10)


# Example 2: If the test set has predefined blocks, use these blocks to define
# the customized training sets, instead of using clustering.
group.id = apply(z == 1, 1, which)[n + 1:m]

fit2 = customizedGlmnet(x.train, y.train, x.test, group.id)

# Print the customized training model fit:
fit2

# Extract nonzero regression coefficients for each group:
nonzero(fit2, lambda = 10)

# Compute test error using the predict function:
mean((y.test - predict(fit2, lambda = 10))^2)

# Plot nonzero coefficients by group:
plot(fit2, lambda = 10)
</code></pre>


</div>