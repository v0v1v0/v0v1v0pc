<div class="container">

<table style="width: 100%;"><tr>
<td>rank.condition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Positive Definiteness of a Matrix, Rank and Condition Number</h2>

<h3>Description</h3>

<p><code>is.positive.definite</code> tests whether all eigenvalues of a symmetric matrix
are positive.  
</p>
<p><code>make.positive.definite</code> computes the nearest positive definite of a
real symmetric matrix, using the algorithm of NJ Higham (1988) &lt;DOI:10.1016/0024-3795(88)90223-6&gt;.
</p>
<p><code>rank.condition</code> estimates the rank and the condition
of a matrix by 
computing its singular values D[i] (using  <code>svd</code>).
The rank of the matrix is the number of singular values <code>D[i] &gt; tol</code>)
and the condition is the ratio  of the largest and the smallest
singular value.   
</p>
<p>The definition <code>tol= max(dim(m))*max(D)*.Machine$double.eps</code> 
is exactly compatible with the conventions used in "Octave" or "Matlab".
</p>
<p>Also note that it is not checked whether the input matrix m is real and symmetric.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.positive.definite(m, tol, method=c("eigen", "chol"))
make.positive.definite(m, tol)
rank.condition(m, tol)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a matrix (assumed to be real and symmetric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for singular values and for absolute eigenvalues
-  only those with values larger than
tol are considered non-zero (default:
<code>tol = max(dim(m))*max(D)*.Machine$double.eps</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Determines the method to check for positive definiteness:
eigenvalue computation (<code>eigen</code>, default) or Cholesky decomposition
(<code>chol</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>is.positive.definite</code> returns
a logical value (<code>TRUE</code> or <code>FALSE</code>).
</p>
<p><code>rank.condition</code> returns a list object with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>Rank of the matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>Condition number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance.</p>
</td>
</tr>
</table>
<p><code>make.positive.definite</code> returns a symmetric positive definite matrix.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code>svd</code>, <code>pseudoinverse</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R"># load corpcor library
library("corpcor")

# Hilbert matrix
hilbert = function(n) { i = 1:n; 1 / outer(i - 1, i, "+") }

# positive definite ?
m = hilbert(8)
is.positive.definite(m)

# numerically ill-conditioned
m = hilbert(15)
rank.condition(m)

# make positive definite
m2 = make.positive.definite(m)
is.positive.definite(m2)
rank.condition(m2)
m2 - m
</code></pre>


</div>