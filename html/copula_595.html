<div class="container">

<table style="width: 100%;"><tr>
<td>fitMvdc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of Multivariate Models Defined via Copulas</h2>

<h3>Description</h3>

<p>Fitting copula-based multivariate distributions
(<code>"mvdc"</code>) to multivariate data,
estimating both the marginal and the copula parameters.
</p>
<p>If you assume (non parametric) margins, in other words, take the
empirical distributions for all margins, you can use
<code>fitCopula(*, pobs(x))</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">loglikMvdc(param, x, mvdc)
fitMvdc(data, mvdc, start, optim.control = list(), method = "BFGS",
        lower = -Inf, upper = Inf,
        estimate.variance = fit$convergence == 0, hideWarnings = TRUE)

## S3 method for class 'fittedMV'
coef(object, SE = FALSE, orig = TRUE, ...)
## S3 method for class 'fittedMV'
logLik(object, ...)
## S3 method for class 'fittedMV'
vcov(object, orig = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>a vector of parameter values.  When specifying parameters for
<code>mvdc</code> objects, the parameters must be ordered with the
marginals first and the copula parameters last.  When the
<code>mvdc</code> object has <code>marginsIdentical = TRUE</code>, only the
parameters of one marginal must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mvdc</code></td>
<td>
<p>a <code>"mvdc"</code> object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a vector of starting value for <code>"param"</code>.  See
<code>"param"</code> above for ordering of this vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.control</code></td>
<td>
<p>a list of controls to be passed to <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method for <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>bounds on each parameter, passed to
<code>optim</code>, typically “box constraints” for
<code>method = "L-BFGS-B"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate.variance</code></td>
<td>
<p>logical; if true (as by default, if the
optimization converges), the asymptotic variance is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hideWarnings</code></td>
<td>
<p>logical indicating if warning messages from
likelihood maximization, e.g., from evaluating at invalid parameter
values, should be suppressed (via <code>suppressWarnings</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object of class <code>"fitMvdc"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE</code></td>
<td>
<p>for the <code>coef</code> method, a logical indicating if
standard errors should be returned in addition to the estimated
parameters (in a <code>matrix</code>).  This is equivalent, but
more efficient than, e.g., <code>coef(summary(object))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orig</code></td>
<td>
<p><code>logical</code>, relevant currently only for
<code>mixCopula</code> fits with free weights.  <code>orig</code> indicates
if the weights should be shown in original scale (<code>orig=TRUE</code>) or
in the transformed log- aka lambda-space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>potentially further arguments to methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The return value <code>loglikMvdc()</code> is the log likelihood evaluated
for the given value of <code>param</code>.
</p>
<p>The return value of <code>fitMvdc()</code> is an object of class
<code>"fitMvdc"</code> 
(see there), containing slots (among others!):
</p>
<table>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>the estimate of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.est</code></td>
<td>
<p>large-sample (i.e., asymptotic) variance estimate of the parameter
estimator (filled with <code>NA</code> if <code>estimate.variance = FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mvdc</code></td>
<td>
<p>the <em>fitted</em> multivariate distribution, see
<code>mvdc</code>.</p>
</td>
</tr>
</table>
<p>The <code>summary()</code> method for <code>"fitMvdc"</code> objects
returns a S3 “class” <code>"summary.fitMvdc"</code>, simply a list
with components <code>method</code>, <code>loglik</code>, and <code>convergence</code>,
all three from corresponding slots of the
<code>"fitMvdc"</code> objects, and
</p>
<table><tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a matrix of estimated coefficients, standard
errors, t values and p-values.</p>
</td>
</tr></table>
<h3>Note</h3>

<p>User-defined marginal distributions can be used as long as the
<code>"{dpq}"</code> functions are defined.
See <code>vignette("AR_Clayton", package="copula")</code>.
</p>
<p>When covariates are available for marginal distributions or for the copula,
one can construct the loglikelihood function and feed it to <code>"optim"</code>
to estimate all the parameters.
</p>
<p>Finally, note that some of the fitting functions generate error
messages because invalid parameter values are tried during the
optimization process (see <code>optim</code>).  This should be rarer
since 2013, notably for likelihood based methods (as the likelihood
is now rather set to <code>-Inf</code> than giving an error).
</p>
<p>Previously, <code>loglikMvdc()</code> had an argument <code>hideWarnings</code>;
nowadays, do use <code>suppressWarnings(..)</code> if you are sure
you do not want to see them.
</p>


<h3>See Also</h3>

<p><code>mvdc</code> and <code>mvdc</code>;
further, <code>Copula</code>, <code>fitCopula</code>,
<code>gofCopula</code>.
</p>
<p>For fitting univariate marginals, <code>fitdistr()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">G3 &lt;- gumbelCopula(3, dim=2)
gMvd2  &lt;- mvdc(G3, c("exp","exp"),
               param = list(list(rate=2), list(rate=4)))
## with identical margins:
gMvd.I &lt;- mvdc(G3, "exp",
               param = list(rate=3), marginsIdentical=TRUE)

(Xtras &lt;- copula:::doExtras()) # determine whether examples will be extra (long)
n &lt;- if(Xtras) 10000 else 200 # sample size (realistic vs short for example)

set.seed(11)
x &lt;- rMvdc(n, gMvd2)
## Default:     hideWarnings = FALSE .. i.e. show warnings here
fit2 &lt;- fitMvdc(x, gMvd2, start = c(1,1, 2))
fit2
confint(fit2)
summary(fit2) # slightly more
## The estimated, asymptotic var-cov matrix [was used for confint()]:
vcov(fit2)

## with even more output for the "identical margin" case:
fitI &lt;- fitMvdc(x, gMvd.I, start = c(3, 2),
                optim.control=list(trace= TRUE, REPORT= 2))
summary(fitI)
coef(fitI, SE = TRUE)
stopifnot(is.matrix(coef(fitI, SE = TRUE)),
          is.matrix(print( confint(fitI) )) )

## a wrong starting value can already be *the* problem:
f2 &lt;- try(fitMvdc(x, gMvd.I, start = c(1, 1),
           optim.control=list(trace= TRUE, REPORT= 2)))
##--&gt; Error in optim( ... ) : non-finite finite-difference value [2]

##==&gt; "Solution" :  Using a more robust (but slower) optim() method:
fI.2 &lt;- fitMvdc(x, gMvd.I, start = c(1, 1), method = "Nelder",
                optim.control=list(trace= TRUE))
fI.2


</code></pre>


</div>