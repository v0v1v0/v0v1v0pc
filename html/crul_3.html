<div class="container">

<table style="width: 100%;"><tr>
<td>AsyncQueue</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>AsyncQueue</h2>

<h3>Description</h3>

<p>An AsyncQueue client
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Super class</h3>

<p><code>crul::AsyncVaried</code> -&gt; <code>AsyncQueue</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>bucket_size</code></dt>
<dd>
<p>(integer) number of requests to send at once</p>
</dd>
<dt><code>sleep</code></dt>
<dd>
<p>(integer) number of seconds to sleep between each bucket</p>
</dd>
<dt><code>req_per_min</code></dt>
<dd>
<p>(integer) requests per minute</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AsyncQueue-print"><code>AsyncQueue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-new"><code>AsyncQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-request"><code>AsyncQueue$request()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-responses"><code>AsyncQueue$responses()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-parse"><code>AsyncQueue$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-status_code"><code>AsyncQueue$status_code()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-status"><code>AsyncQueue$status()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-content"><code>AsyncQueue$content()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-times"><code>AsyncQueue$times()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncQueue-clone"><code>AsyncQueue$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="crul" data-topic="AsyncVaried" data-id="requests"><a href="../../crul/html/AsyncVaried.html#method-AsyncVaried-requests"><code>crul::AsyncVaried$requests()</code></a></span></li>
</ul></details><hr>
<a id="method-AsyncQueue-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>print method for AsyncQueue objects
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>self</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>ignored</p>
</dd>
</dl>
</div>


<hr>
<a id="method-AsyncQueue-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>AsyncQueue</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$new(
  ...,
  .list = list(),
  bucket_size = 5,
  sleep = NULL,
  req_per_min = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>..., .list</code></dt>
<dd>
<p>Any number of objects of class <code>HttpRequest()</code>,
must supply inputs to one of these parameters, but not both</p>
</dd>
<dt><code>bucket_size</code></dt>
<dd>
<p>(integer) number of requests to send at once.
default: 5. See Details.</p>
</dd>
<dt><code>sleep</code></dt>
<dd>
<p>(integer) seconds to sleep between buckets.
default: NULL (not set)</p>
</dd>
<dt><code>req_per_min</code></dt>
<dd>
<p>(integer) maximum number of requests per minute.
if <code>NULL</code> (default), its ignored</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Must set either <code>sleep</code> or <code>req_per_min</code>. If you set
<code>req_per_min</code> we calculate a new <code>bucket_size</code> when <code style="white-space: pre;">⁠$new()⁠</code> is
called
</p>



<h5>Returns</h5>

<p>A new <code>AsyncQueue</code> object
</p>


<hr>
<a id="method-AsyncQueue-request"></a>



<h4>Method <code>request()</code>
</h4>

<p>Execute asynchronous requests
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$request()</pre></div>



<h5>Returns</h5>

<p>nothing, responses stored inside object, though will print
messages if you choose verbose output
</p>


<hr>
<a id="method-AsyncQueue-responses"></a>



<h4>Method <code>responses()</code>
</h4>

<p>List responses
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$responses()</pre></div>



<h5>Returns</h5>

<p>a list of <code>HttpResponse</code> objects, empty list before
requests made
</p>


<hr>
<a id="method-AsyncQueue-parse"></a>



<h4>Method <code>parse()</code>
</h4>

<p>parse content
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$parse(encoding = "UTF-8")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encoding</code></dt>
<dd>
<p>(character) the encoding to use in parsing.
default:"UTF-8"</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>character vector, empty character vector before
requests made
</p>


<hr>
<a id="method-AsyncQueue-status_code"></a>



<h4>Method <code>status_code()</code>
</h4>

<p>Get HTTP status codes for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$status_code()</pre></div>



<h5>Returns</h5>

<p>numeric vector, empty numeric vector before requests made
</p>


<hr>
<a id="method-AsyncQueue-status"></a>



<h4>Method <code>status()</code>
</h4>

<p>List HTTP status objects
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$status()</pre></div>



<h5>Returns</h5>

<p>a list of <code>http_code</code> objects, empty list before requests made
</p>


<hr>
<a id="method-AsyncQueue-content"></a>



<h4>Method <code>content()</code>
</h4>

<p>Get raw content for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$content()</pre></div>



<h5>Returns</h5>

<p>raw list, empty list before requests made
</p>


<hr>
<a id="method-AsyncQueue-times"></a>



<h4>Method <code>times()</code>
</h4>

<p>curl request times
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$times()</pre></div>



<h5>Returns</h5>

<p>list of named numeric vectors, empty list before requests made
</p>


<hr>
<a id="method-AsyncQueue-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncQueue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other async: 
<code>Async</code>,
<code>AsyncVaried</code>,
<code>HttpRequest</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Using sleep (note this works with retry requests)
reqlist &lt;- list(
  HttpRequest$new(url = "https://hb.opencpu.org/get")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/post")$post(),
  HttpRequest$new(url = "https://hb.opencpu.org/put")$put(),
  HttpRequest$new(url = "https://hb.opencpu.org/delete")$delete(),
  HttpRequest$new(url = "https://hb.opencpu.org/get?g=5")$get(),
  HttpRequest$new(
    url = "https://hb.opencpu.org/post")$post(body = list(y = 9)),
  HttpRequest$new(
    url = "https://hb.opencpu.org/get")$get(query = list(hello = "world")),
  HttpRequest$new(url = "https://ropensci.org")$get(),
  HttpRequest$new(url = "https://ropensci.org/about")$get(),
  HttpRequest$new(url = "https://ropensci.org/packages")$get(),
  HttpRequest$new(url = "https://ropensci.org/community")$get(),
  HttpRequest$new(url = "https://ropensci.org/blog")$get(),
  HttpRequest$new(url = "https://ropensci.org/careers")$get(),
  HttpRequest$new(url = "https://hb.opencpu.org/status/404")$retry("get")
)
out &lt;- AsyncQueue$new(.list = reqlist, bucket_size = 5, sleep = 3)
out
out$bucket_size # bucket size
out$requests() # list requests
out$request() # make requests
out$responses() # list responses

# Using requests per minute
if (interactive()) {
x="https://raw.githubusercontent.com/ropensci/roregistry/gh-pages/registry.json"
z &lt;- HttpClient$new(x)$get()
urls &lt;- jsonlite::fromJSON(z$parse("UTF-8"))$packages$url
repos = Filter(length, regmatches(urls, gregexpr("ropensci/[A-Za-z]+", urls)))
repos = unlist(repos)
auth &lt;- list(Authorization = paste("token", Sys.getenv('GITHUB_PAT')))
reqs &lt;- lapply(repos[1:50], function(w) {
  HttpRequest$new(paste0("https://api.github.com/repos/", w), headers = auth)$get()
})

out &lt;- AsyncQueue$new(.list = reqs, req_per_min = 30)
out
out$bucket_size
out$requests()
out$request()
out$responses()
}
## End(Not run)
</code></pre>


</div>