<div class="container">

<table style="width: 100%;"><tr>
<td>stabtaildepf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of the Stable Tail Dependence Function</h2>

<h3>Description</h3>

<p>Kiriliouk <em>et al.</em> (2016, pp. 364–366) describe a technique for estimation of a <em>empirical stable tail dependence function</em> for a random sample. The function is defined as
</p>
<p style="text-align: center;"><code class="reqn">\widehat{l}(x,y) = \frac{1}{k}\sum_{i=1}^n \mathbf{1}\bigl[ R_{i,x,n} &gt; n + 1 - kx \mbox{\ or\ } R_{i,y,n} &gt; n + 1 - ky \bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">\mathbf{1}[\cdot]</code> is an <em>indicator function</em>, <code class="reqn">R</code> denotes the <code>rank()</code> of the elements and <code class="reqn">k \in [1,\ldots,n]</code> and <code class="reqn">k</code> is intended to be “large enough” that <code class="reqn">\widehat{l}(x,y)</code> has converged to a limit.
</p>
<p>The “Capéraà–Fougères smooth” of the empirical stable tail dependence function is defined for a coordinate pair <code class="reqn">(x,y)</code> as
</p>
<p style="text-align: center;"><code class="reqn">\widehat{l}_{CF}(x,y) = 2 \sum_{i \in I_n} \widehat{p}_{3,i} \times \mathrm{max}\bigl[\widehat{W}_i x,\, (1-\widehat{W}_i) y \bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">\widehat{p}_{3,i}</code> are the weights for the <em>maximum Euclidean likelihood</em> estimator (see <code>spectralmeas</code>) and <code class="reqn">\widehat{W}_i</code> are the <em>pseudo-polar angles</em> (see <code>spectralmeas</code>) for the index set <code class="reqn">I_n</code> defined by <code class="reqn">I_n = \{i = 1, \ldots, n : \widehat{S}_i &gt; \widehat{S}_{(k{+}1)}\}</code>, where <code class="reqn">\widehat{S}_{(k+1)}</code> denotes the <code class="reqn">(k{+}1)</code>-th largest observation of the pseudo-polar radii <code class="reqn">\widehat{S}_i</code> where the cardinality of <code class="reqn">I_n</code> is exactly <code class="reqn">k</code> elements long. (Tentatively, then this definition of <code class="reqn">I_n</code> is ever so slightly different than in <code>spectralmeas</code>.)  Lastly, see the multiplier of <code class="reqn">2</code> on the smooth form, and this multiplier is missing in Kiriliouk <em>et al.</em> (2016, p. 365) but shown in Kiriliouk <em>et al.</em> (2016, eq. 17.14, p. 360). Numerical experiments indicate that the <code class="reqn">2</code> is needed for <code class="reqn">\widehat{l}_{CF}(x,y)</code> but evidently not in <code class="reqn">\widehat{l}(x,y)</code>.
</p>
<p>The visualization of <code class="reqn">l(x,y)</code> commences by setting a constant (<code class="reqn">c &gt; 0</code>) as <code class="reqn">c_i \in 0.2,0.4,0.6,0.8</code> (say). The <code class="reqn">y</code> are solved for <code class="reqn">x \in [0,\ldots,c_i]</code> through the <code class="reqn">l(x,y)</code> for each of the <code class="reqn">c_i</code>. Each solution set constitutes a <em>level set</em> for the stable tail dependence function. If the bivariate data have <em>asymptotic independence</em> (to the right), then a level set or the level sets for all the <code class="reqn">c</code> are equal to the lines <code class="reqn">x + y = c</code>. Conversely, if the bivariate data have <em>asymptotic dependence</em> (to the right), then the level sets will make 90-degree bends for <code class="reqn">\mathrm{max}(x,y) = c</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stabtaildepf(uv=NULL, xy=NULL, k=function(n) as.integer(0.5*n), levelset=TRUE,
             ploton=TRUE, title=TRUE, delu=0.01, smooth=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>uv</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> of <code class="reqn">u</code> and <code class="reqn">v</code> nonexceedance probabilities in the respective <code class="reqn">X</code> (horizontal) and <code class="reqn">Y</code> (vertical) directions. Note, <code>rank()</code>s are called on these so strictly speaking this need not be as nonexceedance probabilities. This is not an optional argument;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>A vector of the scalar coordinates <code class="reqn">(x,y)</code>, which are “the relative distances to the upper endpoints of [these respective] variables” (Kiriliouk <em>et al.</em>, 2016, p. 356). This is a major point of nomenclature confusion. If these are in probability units, they are <em>exceedance probabilities</em>. Though tested for <code>NULL</code> and a warning issued, these can be <code>NULL</code> only if <code>levelset=TRUE</code> but can be set to <code>xy=NA</code> if <code>levelset=FALSE</code> and <code>smooth=TRUE</code> (see discussion in <b>Note</b>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The <code class="reqn">k</code> for both the <code class="reqn">\widehat{l}(x,y)</code> and <code class="reqn">\widehat{l}_{CF}</code>, though the effect of <code class="reqn">k</code> might not quite be the same for each. The default seems to work fairly well;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levelset</code></td>
<td>
<p>A logical triggering the construction of the level sets for <code class="reqn">c</code> <code class="reqn">=</code> <code>seq(0.1,</code> <code>1,</code> <code>by=0.1)</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ploton</code></td>
<td>
<p>A logical to call the <code>plot()</code> function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>A logical to trigger a title for the plot if <code>ploton=TRUE</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delu</code></td>
<td>
<p>The <code class="reqn">\Delta x</code> for a sequence of <code class="reqn">x</code> <code class="reqn">=</code> <code>seq(0,c,by=delu)</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>A logical controlling whether <code class="reqn">\widehat{l}(x,y)</code> or the Capéraà–Fougères smooth function <code class="reqn">\widehat{l}_{CF}(x,y)</code> is used; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Varies according to argument settings. In particular, the <code>levelset=TRUE</code> will cause an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> to be returned with the elements having the character string of the respective <code class="reqn">c</code> values and the each holding a <code>data.frame</code> of the <code class="reqn">(x,y)</code> coordinates.
</p>


<h3>Note</h3>

<p>This function is also called in a secondary recursion mode. The default <code>levelset=TRUE</code> makes a secondary call with <code>levelset=FALSE</code> to compute the <code class="reqn">\widehat{l}(x,y)</code> for the benefit of the looping on the one-dimensional root to solve for a single <code class="reqn">y</code> in <code class="reqn">\widehat{l}(x,y) = c</code> given a single <code class="reqn">x</code>. If <code>levelset=TRUE</code> and <code>smooth=TRUE</code>, then a secondary call with <code>smooth=TRUE</code> and <code>levelset=FALSE</code> is made to internally return an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> containing scalar <code class="reqn">N_n</code> and vectors <code class="reqn">\widehat{W}_n</code> and <code class="reqn">\widehat{p}_{3,i}</code> for similar looping and one-dimensional rooting for <code class="reqn">\widehat{l}_{CF}(x,y)</code>.
</p>
<p>If <code>levelset=FALSE</code>, then <code>xy</code> is required to hold the <code class="reqn">(x,y)</code> coordinate pair of interest. A demonstration follows and shows the limiting behavior of a random sample from the <code>N4212cop</code> copula.
</p>
<pre>
  n &lt;- 2000 # very CPU intensive this and the next code snippet
  UV &lt;- simCOP(n=n, cop=N4212cop, para=pi); k &lt;- 1:n
  lhat &lt;- sapply(k, function(j)
                 stabtaildepf(xy=c(0.1, 0.1), uv=UV, levelset=FALSE, k=j))
  plot(k, lhat, xlab="k in [1,n]", cex=0.8, lwd=0.8, type="b",
                ylab="Empirical Stable Tail Dependence Function")
  mtext("Empirical function in the 0.10 x 0.10 Pr square (upper left corner)")
</pre>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> that can be used to compute <code class="reqn">\widehat{l}_{CF}(x,y)</code> is retrievable by
</p>
<pre>
  x &lt;- 0.1; y &lt;- 0.1; k &lt;- 1:(n-1)
  lhatCF &lt;- sapply(k, function(j) {
     Hlis &lt;- stabtaildepf(xy=NA, uv=UV, levelset=FALSE, smooth=TRUE, k=j)
     2*sum(Hlis$p3 * sapply(1:Hlis$Nn, function(i) {
                 max(c(Hlis$Wn[i]*x, (1-Hlis$Wn[i])*y)) }))
  })
  lines(k, lhatCF, col="red")
</pre>
<p>The smooth line (red) of <code>lhatCF</code> is somewhat closer to the limiting behavior of <code>lhat</code>, but it is problematic to determine computational consistency. Mathematical consistency with Kiriliouk <em>et al.</em> (2016) appears to be achieved. The <b>Examples</b> section TODO.
</p>


<h3>Author(s)</h3>

<p>William Asquith <a href="mailto:william.asquith@ttu.edu">william.asquith@ttu.edu</a></p>


<h3>References</h3>

<p>Beirlant, J., Escobar-Bach, M., Goegebeur, Y., Guillou, A., 2016, Bias-corrected estimation of stable tail dependence function: Journal Multivariate Analysis, v. 143, pp. 453–466, <a href="https://doi.org/10.1016/j.jmva.2015.10.006">doi:10.1016/j.jmva.2015.10.006</a>.
</p>
<p>Kiriliouk, Anna, Segers, Johan, Warchoł, Michał, 2016, Nonparameteric estimation of extremal dependence: <em>in</em> Extreme Value Modeling and Risk Analysis, D.K. Dey and Jun Yan <em>eds.</em>, Boca Raton, FL, CRC Press, ISBN 978–1–4987–0129–7.
</p>


<h3>See Also</h3>

<p><code>psepolar</code>, <code>spectralmeas</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
UV &lt;- simCOP(n=1200, cop=GLcop, para=2.1) # Galambos copula
tmp1 &lt;- stabtaildepf(UV) # the lines are curves (strong tail dependence)
tmp2 &lt;- stabtaildepf(UV, smooth=TRUE, ploton=FALSE, col="red") #
## End(Not run)
</code></pre>


</div>