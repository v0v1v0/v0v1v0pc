<div class="container">

<table style="width: 100%;"><tr>
<td>across</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Apply Functions Across Multiple Columns
</h2>

<h3>Description</h3>

<p><code>across()</code> can be used inside <code>fmutate</code> and <code>fsummarise</code> to apply one or more functions to a selection of columns. It is overall very similar to <code>dplyr::across</code>, but does not support some <code>rlang</code> features, has some additional features (arguments), and is optimized to work with <em>collapse</em>'s, <code>.FAST_FUN</code>, yielding much faster computations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">across(.cols = NULL, .fns, ..., .names = NULL,
       .apply = "auto", .transpose = "auto")

# acr(...) can be used to abbreviate across(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.cols</code></td>
<td>
<p>select columns using column names and expressions (e.g. <code>a:b</code> or <code>c(a, b, c:f)</code>), column indices, logical vectors, or functions yielding a logical value e.g. <code>is.numeric</code>. <code>NULL</code> applies functions to all columns except for grouping columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fns</code></td>
<td>
<p>A function, character vector of functions or list of functions. Vectors / lists can be named to yield alternative names in the result (see <code>.names</code>). This argument is evaluated inside <code>substitute()</code>, and the content (not the names of vectors/lists) is checked against <code>.FAST_FUN</code> and <code>.OPERATOR_FUN</code>. Matching functions receive vectorized execution, other functions are applied to the data in a standard way.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to <code>.fns</code>. Arguments are evaluated in the data environment and split by groups as well (for non-vectorized functions, if of the same length as the data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.names</code></td>
<td>
<p>controls the naming of computed columns. <code>NULL</code> generates names of the form <code>coli_funj</code> if multiple functions are used. <code>.names = TRUE</code> enables this for a single function, <code>.names = FALSE</code> disables it for multiple functions (sensible for functions such as <code>.OPERATOR_FUN</code> that rename columns (if <code>.apply = FALSE</code>)). Setting <code>.names = "flip"</code> generates names of the form <code>funj_coli</code>. It is also possible to supply a function with two arguments for column and function names e.g. <code>function(c, f) paste0(f, "_", c)</code>. Finally, you can supply a custom vector of names which must match <code>length(.cols) * length(.fns)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.apply</code></td>
<td>
<p>controls whether functions are applied column-by-column (<code>TRUE</code>) or to multiple columns at once (<code>FALSE</code>). The default, <code>"auto"</code>, does the latter for vectorized functions, which have an efficient data frame method. It can also be sensible to use <code>.apply = FALSE</code> for non-vectorized functions, especially multivariate functions like <code>lm</code> or <code>pwcor</code>, or functions renaming the data. See Examples.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.transpose</code></td>
<td>
<p>with multiple <code>.fns</code>, <code>.transpose</code> controls whether the result is ordered first by column, then by function (<code>TRUE</code>), or vice-versa (<code>FALSE</code>). <code>"auto"</code> does the former if all functions yield results of the same dimensions (dimensions may differ if <code>.apply = FALSE</code>). See Examples.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p><code>across</code> does not support <em>purr</em>-style lambdas, and does not support <code>dplyr</code>-style predicate functions e.g. <code>across(where(is.numeric), sum)</code>, simply use <code>across(is.numeric, sum)</code>. In contrast to <code>dplyr</code>, you can also compute on grouping columns.
</p>



<h3>See Also</h3>

<p><code>fsummarise</code>, <code>fmutate</code>, Fast Data Manipulation, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Basic (Weighted) Summaries
fsummarise(wlddev, across(PCGDP:GINI, fmean, w = POP))

wlddev |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, fmean, w = POP))

# Note that for these we don't actually need across...
fselect(wlddev, PCGDP:GINI) |&gt; fmean(w = wlddev$POP, drop = FALSE)
wlddev |&gt; fgroup_by(region, income) |&gt;
    fselect(PCGDP:GINI, POP) |&gt; fmean(POP, keep.w = FALSE)
collap(wlddev, PCGDP + LIFEEX + GINI ~ region + income, w = ~ POP, keep.w = FALSE)

# But if we want to use some base R function that reguires argument splitting...
wlddev |&gt; na_omit(cols = "POP") |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, weighted.mean, w = POP, na.rm = TRUE))

# Or if we want to apply different functions...
wlddev |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, list(mu = fmean, sd = fsd), w = POP),
               POP_sum = fsum(POP), OECD = fmean(OECD))
# Note that the above still detects fmean as a fast function, the names of the list
# are irrelevant, but the function name must be typed or passed as a character vector,
# Otherwise functions will be executed by groups e.g. function(x) fmean(x) won't vectorize

# Same, naming in a different way
wlddev |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, list(mu = fmean, sd = fsd), w = POP, .names = "flip"),
               sum_POP = fsum(POP), OECD = fmean(OECD))

# Or we want to do more advanced things..
# Such as nesting data frames..
qTBL(wlddev) |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(c(PCGDP, LIFEEX, ODA),
               function(x) list(Nest = list(x)),
               .apply = FALSE))
# Or linear models..
qTBL(wlddev) |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(c(PCGDP, LIFEEX, ODA),
               function(x) list(Mods = list(lm(PCGDP ~., x))),
               .apply = FALSE))
# Or cumputing grouped correlation matrices
qTBL(wlddev) |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(c(PCGDP, LIFEEX, ODA),
      function(x) qDF(pwcor(x), "Variable"), .apply = FALSE))

# Here calculating 1- and 10-year lags and growth rates of these variables
qTBL(wlddev) |&gt; fgroup_by(country) |&gt;
    fmutate(across(c(PCGDP, LIFEEX, ODA), list(L, G),
                   n = c(1, 10), t = year, .names = FALSE))

# Same but variables in different order
qTBL(wlddev) |&gt; fgroup_by(country) |&gt;
    fmutate(across(c(PCGDP, LIFEEX, ODA), list(L, G), n = c(1, 10),
                   t = year, .names = FALSE, .transpose = FALSE))

</code></pre>


</div>