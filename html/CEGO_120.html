<div class="container">

<table style="width: 100%;"><tr>
<td>testFunctionGeneratorSim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation-based Test Function Generator, Data Interface</h2>

<h3>Description</h3>

<p>Generate test functions for assessment of optimization algorithms with
non-conditional or conditional simulation, based on real-world data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">testFunctionGeneratorSim(
  x,
  y,
  xsim,
  distanceFunction,
  controlModel = list(),
  controlSimulation = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>list of samples in input space, training data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>column vector of observations for each sample, training data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xsim</code></td>
<td>
<p>list of samples in input space, for simulation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.  It can also be a list of several distance functions. In this case, Maximum Likelihood Estimation (MLE) is used 
to determine the most suited distance measure.
The distance function may have additional parameters. For that case, see distanceParametersLower/Upper in the controls.
If distanceFunction is missing, it can also be provided in the control list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controlModel</code></td>
<td>
<p>(list), with the options for the model building procedure,
it will be passed to the <code>modelKriging</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controlSimulation</code></td>
<td>
<p>(list), with the parameters of the simulation:
</p>

<dl>
<dt><code>nsim</code></dt>
<dd>
<p> the number of simulations, or test functions, to be created.</p>
</dd>
<dt><code>conditionalSimulation</code></dt>
<dd>
<p> whether (TRUE) or not (FALSE) to use conditional simulation.</p>
</dd>
<dt><code>simulationSeed</code></dt>
<dd>
<p> a random number generator seed. Defaults to NA; which means no seed is set. For sake of reproducibility, set this to some integer value.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list with the following elements: <code>fun</code> is a list of functions, where each function is the interpolation of one simulation realization. The length of the list depends on the nsim parameter.
<code>fit</code> is the result of the modeling procedure, that is, the model fit of class <code>modelKriging</code>.
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>
<p>Zaefferer, M.; Fischbach, A.; Naujoks, B. &amp; Bartz-Beielstein, T. Simulation Based Test Functions for Optimization Algorithms Proceedings of the Genetic and Evolutionary Computation Conference 2017, ACM, 2017, 8.
</p>


<h3>See Also</h3>

<p><code>modelKriging</code>, <code>simulate.modelKriging</code>, <code>createSimulatedTestFunction</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">nsim &lt;- 10
seed &lt;- 12345
n &lt;- 6
set.seed(seed)
#target function:
fun &lt;- function(x){
  exp(-20* x) + sin(6*x^2) + x
}
# "vectorize" target
f &lt;- function(x){sapply(x,fun)}
dF &lt;- function(x,y)(sum((x-y)^2)) #sum of squares 
# plot params
par(mfrow=c(4,1),mar=c(2.3,2.5,0.2,0.2),mgp=c(1.4,0.5,0))
#test samples for plots
xtest &lt;- as.list(seq(from=-0,by=0.005,to=1))
plot(xtest,f(xtest),type="l",xlab="x",ylab="Obj. function")
#evaluation samples (training)
xb &lt;- as.list(runif(n))
yb &lt;- f(xb)
# support samples for simulation
x &lt;- as.list(sort(c(runif(100),unlist(xb))))
# fit the model	and simulate: 
res &lt;- testFunctionGeneratorSim(xb,yb,x,dF,
   list(algThetaControl=list(method="NLOPT_GN_DIRECT_L",funEvals=100),
     useLambda=FALSE),
   list(nsim=nsim,conditionalSimulation=FALSE))
fit &lt;- res$fit
fun &lt;- res$fun
#predicted obj. function values
ypred &lt;- predict(fit,as.list(xtest))$y
plot(unlist(xtest),ypred,type="l",xlab="x",ylab="Estimation")
points(unlist(xb),yb,pch=19)
##############################	
# plot non-conditional simulation
##############################
ynew &lt;- NULL
for(i in 1:nsim)
  ynew &lt;- cbind(ynew,fun[[i]](xtest))
rangeY &lt;- range(ynew)
plot(unlist(xtest),ynew[,1],type="l",ylim=rangeY,xlab="x",ylab="Simulation")
for(i in 2:nsim){
  lines(unlist(xtest),ynew[,i],col=i,type="l")
}
##############################	
# create and plot test function, conditional
##############################
fun &lt;- testFunctionGeneratorSim(xb,yb,x,dF,
   list(algThetaControl=
     list(method="NLOPT_GN_DIRECT_L",funEvals=100),
			useLambda=FALSE),
   list(nsim=nsim,conditionalSimulation=TRUE))$fun
ynew &lt;- NULL
for(i in 1:nsim)
  ynew &lt;- cbind(ynew,fun[[i]](xtest))
rangeY &lt;- range(ynew)
plot(unlist(xtest),ynew[,1],type="l",ylim=rangeY,xlab="x",ylab="Conditional sim.")
for(i in 2:nsim){
  lines(unlist(xtest),ynew[,i],col=i,type="l")
}
points(unlist(xb),yb,pch=19)

</code></pre>


</div>