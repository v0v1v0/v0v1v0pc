<div class="container">

<table style="width: 100%;"><tr>
<td>print.tunecpfa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Print Method for Tuning for Classification with Parallel Factor Analysis
</h2>

<h3>Description</h3>

<p>Prints summary of results from a 'tunecpfa' model object obtained using function <code>tunecpfa</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tunecpfa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A fit object of class 'tunecpfa' from function <code>tunecpfa</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional print arguments.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Prints names of the models and methods used to create the input 'tunecpfa' model object. Prints misclassification error rates and estimation times in seconds.
</p>


<h3>Value</h3>

<p>Returns a summary of the 'tunecpfa' model object.
</p>


<h3>Author(s)</h3>

<p>Matthew Snodgress &lt;snodg031@umn.edu&gt;
</p>


<h3>References</h3>

<p>See help file for function <code>tunecpfa</code> for a list of references.
</p>


<h3>Examples</h3>

<pre><code class="language-R">########## Parafac example with 3-way array and binary response ##########

# set seed and specify dimensions of a three-way tensor
set.seed(3)
mydim &lt;- c(10, 11, 80)
nf &lt;- 3

# create correlation matrix between response and third mode's weights 
rho.cc &lt;- .35
rho.cy &lt;- .75
cormat.values &lt;- c(1, rho.cc, rho.cc, rho.cy, rho.cc, 1, rho.cc, rho.cy, 
                   rho.cc, rho.cc, 1, rho.cy, rho.cy, rho.cy, rho.cy, 1)
cormat &lt;- matrix(cormat.values, nrow = (nf + 1), ncol = (nf + 1))

# sample from a multivariate normal with specified correlation structure
ymean &lt;- Cmean &lt;- 2
mu &lt;- as.matrix(c(Cmean, Cmean, Cmean, ymean))
eidecomp &lt;- eigen(cormat, symmetric = TRUE)
L.sqrt &lt;- diag(eidecomp$values^0.5)
cormat.sqrt &lt;- eidecomp$vectors %*% L.sqrt %*% t(eidecomp$vectors)
Z &lt;- matrix(rnorm(mydim[3] * (nf + 1)), nrow = mydim[3], ncol = (nf + 1))
Xw &lt;- rep(1, mydim[3]) %*% t(mu) + Z %*% cormat.sqrt
Cmat &lt;- Xw[, 1:nf]

# create a random three-way data tensor with C weights related to a response
Amat &lt;- matrix(rnorm(mydim[1] * nf), nrow = mydim[1], ncol = nf)
Bmat &lt;- matrix(runif(mydim[2] * nf), nrow = mydim[2], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))  
X &lt;- Xmat + Emat

# create a binary response by dichotomizing at the specified response mean
y &lt;- factor(as.numeric(Xw[ , (nf + 1)] &gt; ymean))

# initialize
alpha &lt;- seq(0, 1, length = 2)
gamma &lt;- c(0, 0.01)
cost &lt;- c(1, 2)
method &lt;- c("PLR", "SVM")
family &lt;- "multinomial"
parameters &lt;- list(alpha = alpha, gamma = gamma, cost = cost)
model &lt;- "parafac"
nfolds &lt;- 3
nstart &lt;- 3

# constrain first mode weights to be orthogonal
const &lt;- c("orthog", "uncons", "uncons")

# fit Parafac models and use third mode to tune classification methods
tune.object &lt;- tunecpfa(x = X, y = y, model = model, nfac = nf, 
                        nfolds = nfolds, method = method, family = family, 
                        parameters = parameters, parallel = FALSE, 
                        const = const, nstart = nstart)
                         
# print summary of output
print(tune.object)
</code></pre>


</div>