<div class="container">

<table style="width: 100%;"><tr>
<td>V.fun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variance matrix for observations</h2>

<h3>Description</h3>

<p>Determines the variance/covariance matrix for the observations and code
run points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">V.fun(D1, D2, H1, H2,  extractor,
E.theta, Edash.theta, give.answers=FALSE, test.for.symmetry=FALSE, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D1</code></td>
<td>
<p>Matrix of code run points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D2</code></td>
<td>
<p>Matrix of observation points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H1</code></td>
<td>
<p>Regression function for <code>D1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H2</code></td>
<td>
<p>Regression function for <code>D2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extractor</code></td>
<td>
<p>Function to extract <code>x.star</code> and <code>t.vec</code>
from <code>D1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Edash.theta</code></td>
<td>
<p>Function to return expectation of <code>H</code> with respect
to the alternative distribution of <code class="reqn">\theta</code>;
<code>Edash.theta.toy</code> is the example for the toy dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.theta</code></td>
<td>
<p>Expectation of <code>h</code> WRT theta over the apriori
distribution.  Note that this function must be updated if <code>h1()</code> changes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give.answers</code></td>
<td>
<p>Boolean (defaulting to <code>FALSE</code>) with
<code>TRUE</code> meaning to return a list whose elements are <code>V</code> and
its constituent parts, viz <code>line1</code> to <code>line6</code>.  This
argument is used mainly for debugging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.for.symmetry</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to
calculate each element of <code class="reqn">C</code> explicitly, and default
<code>FALSE</code> meaning to calculate only the elements of <code class="reqn">C</code>
that lie on or over the diagonal and use the fact that <code class="reqn">C</code>
is symmetric to calculate the other matrix elements.  For <code class="reqn">n</code>
observations, this means <code class="reqn">n(n+1)/2</code> evaluations, compared with
<code class="reqn">n^2</code> for the full case.  The time saving is considerable, even
for small matrices.
</p>
<p>Set this argument to <code>TRUE</code> only when debugging, or testing
accuracy</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>Hyperparameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See KOH2001 for full details on page 3 of the supplement
</p>


<h3>Value</h3>

<p>If <code>give.answers</code> is the default value of <code>FALSE</code>,
returns a matrix of covariances for use in <code>p.page4()</code>.
</p>
<p>If <code>give.answers</code> is <code>TRUE</code>, returns a named list of (currently)
17 elements.  Elements one to six are lines one to six respectively from
page 3 of the supplement; subsequent lines give intermediate steps in
the calculation.  The final element is the matrix is the covariances
as returned when <code>give.answers</code> is <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>This function takes a long time to run</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001. <em>Bayesian
calibration of computer models</em>.  Journal of the Royal Statistical
Society B, 63(3) pp425-464
</p>
</li>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001.  <em>Supplementary details on
Bayesian calibration of computer models</em>, Internal report, University
of Sheffield.  Available at
<a href="http://www.tonyohagan.co.uk/academic/ps/calsup.ps">http://www.tonyohagan.co.uk/academic/ps/calsup.ps</a>
</p>
</li>
<li>
<p>R. K. S. Hankin 2005. <em>Introducing BACCO, an R bundle for
Bayesian analysis of computer code output</em>, Journal of Statistical
Software, 14(16)
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>tt.fun</code>,<code>p.page4</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(toys)
(jj &lt;-V.fun(D1=D1.toy, D2=D2.toy, H1=H1.toy, H2=H2.toy, 
  extractor=extractor.toy, 
  Edash.theta=Edash.theta.toy,
  E.theta=E.theta.toy,  phi=phi.toy))


## Now note that V.fun() changes with the PRIOR used for theta:
phi.different.theta &lt;-  phi.change(old.phi=phi.toy,
     theta.apriori.mean=c(100,100,100),phi.fun=phi.fun.toy)
V.fun(D1=D1.toy, D2=D2.toy, H1=H1.toy, H2=H2.toy, 
  extractor=extractor.toy, 
  Edash.theta=Edash.theta.toy,
  E.theta=E.theta.toy,  phi=phi.different.theta)
## different!


## Now compare jj above with V.fun() calculated with
## different phi2:

phi.toy.new &lt;- phi.change(phi.fun=phi.fun.toy, old.phi = phi.toy, psi2=c(8,8,8))

V.fun(D1=D1.toy, D2=D2.toy, H1=H1.toy, H2=H2.toy, 
  extractor=extractor.toy, 
  Edash.theta=Edash.theta.toy,
  E.theta=E.theta.toy,  phi=phi.toy.new)

## different!



## Not run: 
data(toys)
set.seed(0)
jj &lt;- create.new.toy.datasets(D1=D1.toy , D2=D2.toy)
y.toy &lt;- jj$y.toy
z.toy &lt;- jj$z.toy
d.toy &lt;- jj$d.toy

v.fun &lt;- function(...){V.fun(D1=D1.toy, D2=D2.toy, H1=H1.toy, H2=H2.toy, 
     extractor=extractor.toy, Edash.theta=Edash.theta.toy,
     E.theta=E.theta.toy, phi=phi.toy, give=TRUE)}

Rprof(file="~/f.txt");ignore &lt;- v.fun();Rprof(file=NULL)
system("cd ; R CMD Rprof ~/f.txt &gt; ~/ff.txt")

## End(Not run)
</code></pre>


</div>