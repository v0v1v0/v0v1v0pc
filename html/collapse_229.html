<div class="container">

<table style="width: 100%;"><tr>
<td>flag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast Lags and Leads for Time Series and Panel Data
</h2>

<h3>Description</h3>

<p><code>flag</code> is an S3 generic to compute (sequences of) lags and leads. <code>L</code> and <code>F</code> are wrappers around <code>flag</code> representing the lag- and lead-operators, such that <code>L(x,-1) = F(x,1) = F(x)</code> and <code>L(x,-3:3) = F(x,3:-3)</code>. <code>L</code> and <code>F</code> provide more flexibility than <code>flag</code> when applied to data frames (i.e.  column subsetting, formula input and id-variable-preservation capabilities...), but are otherwise identical.
</p>
<p><em>Note:</em> Since v1.9.0, <code>F</code> is no longer exported, but can be accessed using <code>collapse:::F</code>, or through setting <code>options(collapse_export_F = TRUE)</code> before loading the package. The syntax is the same as <code>L</code>.
</p>



<h3>Usage</h3>

<pre><code class="language-R">flag(x, n = 1, ...)
   L(x, n = 1, ...)

## Default S3 method:
flag(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = TRUE, ...)
## Default S3 method:
L(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = .op[["stub"]], ...)

## S3 method for class 'matrix'
flag(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = length(n) &gt; 1L, ...)
## S3 method for class 'matrix'
L(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = .op[["stub"]], ...)

## S3 method for class 'data.frame'
flag(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = length(n) &gt; 1L, ...)
## S3 method for class 'data.frame'
L(x, n = 1, by = NULL, t = NULL, cols = is.numeric,
  fill = NA, stubs = .op[["stub"]], keep.ids = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
flag(x, n = 1, fill = NA, stubs = length(n) &gt; 1L, shift = "time", ...)
## S3 method for class 'pseries'
L(x, n = 1, fill = NA, stubs = .op[["stub"]], shift = "time", ...)

## S3 method for class 'pdata.frame'
flag(x, n = 1, fill = NA, stubs = length(n) &gt; 1L, shift = "time", ...)
## S3 method for class 'pdata.frame'
L(x, n = 1, cols = is.numeric, fill = NA, stubs = .op[["stub"]],
  shift = "time", keep.ids = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
flag(x, n = 1, t = NULL, fill = NA, stubs = length(n) &gt; 1L, keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
L(x, n = 1, t = NULL, fill = NA, stubs = .op[["stub"]], keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df'). Data must not be numeric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer. A vector indicating the lags / leads to compute (passing negative integers to <code>flag</code> or <code>L</code> computes leads, passing negative integers to <code>F</code> computes lags).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a factor, <code>GRP</code> object, or atomic vector / list of vectors (internally grouped with <code>group</code>) used to group <code>x</code>. <em>Note</em> that without <code>t</code>, all values in a group need to be consecutive and in the right order. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p><em>data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>a time vector or list of vectors. Data frame methods also allows one-sided formula i.e. <code>~time</code>. grouped_df method supports lazy-evaluation i.e. <code>time</code> (no quotes). Either support wrapping a transformation function e.g. <code>~timeid(time)</code>, <code>qG(time)</code> etc.. See also Details on how <code>t</code> is processed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns to lag using a function, column names, indices or a logical vector. Default: All numeric variables. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>value to insert when vectors are shifted. Default is <code>NA</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stubs</code></td>
<td>
<p>logical. <code>TRUE</code> (default) will rename all lagged / leaded columns by adding a stub or prefix "L<code>n</code>." / "F<code>n</code>.".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> performs a fully identified time-lag (if the index contains a time variable), whereas <code>"row"</code> performs a simple (group) lag, where observations are shifted based on the present order of rows (in each group). The latter is significantly faster, but requires time series / panels to be regularly spaced and sorted by time within each group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.ids</code></td>
<td>
<p><em>data.frame / pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all variables passed to <code>by</code> or <code>t</code> using formulas). <em>Note</em>: For 'grouped_df' / 'pdata.frame' identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a single integer is passed to <code>n</code>, and <code>g/by</code> and <code>t</code> are left empty, <code>flag/L/F</code> just returns <code>x</code> with all columns lagged / leaded by <code>n</code>. If <code>length(n)&gt;1</code>, and <code>x</code> is an atomic vector (time series), <code>flag/L/F</code> returns a (time series) matrix with lags / leads computed in the same order as passed to <code>n</code>. If instead <code>x</code> is a matrix / data frame, a matrix / data frame with <code>ncol(x)*length(n)</code> columns is returned where columns are sorted first by variable and then by lag (so all lags computed on a variable are grouped together). <code>x</code> can be of any standard data type.
</p>
<p>With groups/panel-identifiers supplied to <code>g/by</code>, <code>flag/L/F</code> efficiently computes a panel-lag/lead by shifting the entire vector(s) but inserting <code>fill</code> elements in the right places. If <code>t</code> is left empty, the data needs to be ordered such that all values belonging to a group are consecutive and in the right order. It is not necessary that the groups themselves are alphabetically ordered. If a time-variable is supplied to <code>t</code> (or a list of time-variables uniquely identifying the time-dimension), the series / panel is fully identified and lags / leads can be securely computed even if the data is unordered / irregular.
</p>





<p><b>Note</b> that the <code>t</code> argument is processed as follows: If <code>is.factor(t) || (is.numeric(t) &amp;&amp; !is.object(t))</code> (i.e. <code>t</code> is a factor or plain numeric vector), it is assumed to represent unit timesteps (e.g. a 'year' variable in a typical dataset), and thus coerced to integer using <code>as.integer(t)</code> and directly passed to C++ without further checks or transformations at the R-level. Otherwise, if <code>is.object(t) &amp;&amp; is.numeric(unclass(t))</code> (i.e. <code>t</code> is a numeric time object, most likely 'Date' or 'POSIXct'), this object is passed through <code>timeid</code> before going to C++. Else (e.g. <code>t</code> is character), it is passed through <code>qG</code> which performs ordered grouping. If <code>t</code> is a list of multiple variables, it is passed through <code>finteraction</code>. You can customize this behavior by calling any of these functions (including <code>unclass/as.integer</code>) on your time variable beforehand.
</p>
<p>At the C++ level, if both <code>g/by</code> and <code>t</code> are supplied, <code>flag</code> works as follows: Use two initial passes to create an ordering through which the data are accessed. First-pass: Calculate minimum and maximum time-value for each individual. Second-pass: Generate an internal ordering vector (<code>o</code>) by placing the current element index into the vector slot obtained by adding the cumulative group size and the current time-value subtracted its individual-minimum together. This method of computation is faster than any sort-based method and delivers optimal performance if the panel-id supplied to <code>g/by</code> is already a factor variable, and if <code>t</code> is an integer/factor variable. For irregular time/panel series, <code>length(o) &gt; length(x)</code>, and <code>o</code> represents the unobserved 'complete series'. If <code>length(o) &gt; 1e7 &amp;&amp; length(o) &gt; 3*length(x)</code>, a warning is issued to make you aware of potential performance implications of the oversized ordering vector.
</p>


<p>The 'indexed_series' ('pseries') and 'indexed_frame' ('pdata.frame')  methods automatically utilize the identifiers attached to these objects, which are already factors, thus lagging is quite efficient. However, the internal ordering vector still needs to be computed, thus if data are known to be ordered and regularly spaced, using <code>shift = "row"</code> to toggle a simple group-lag (same as utilizing <code>g</code> but not <code>t</code> in other methods) can yield a significant performance gain.
</p>



<h3>Value</h3>

<p><code>x</code> lagged / leaded <code>n</code>-times, grouped by <code>g/by</code>, ordered by <code>t</code>. See Details and Examples.
</p>


<h3>See Also</h3>

<p><code>fdiff</code>, <code>fgrowth</code>, Time Series and Panel Series, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simple Time Series: AirPassengers
L(AirPassengers)                      # 1 lag
flag(AirPassengers)                   # Same
L(AirPassengers, -1)                  # 1 lead

head(L(AirPassengers, -1:3))          # 1 lead and 3 lags - output as matrix

## Time Series Matrix of 4 EU Stock Market Indicators, 1991-1998
tsp(EuStockMarkets)                                     # Data is recorded on 260 days per year
freq &lt;- frequency(EuStockMarkets)
plot(stl(EuStockMarkets[,"DAX"], freq))                 # There is some obvious seasonality
head(L(EuStockMarkets, -1:3 * freq))                    # 1 annual lead and 3 annual lags
summary(lm(DAX ~., data = L(EuStockMarkets,-1:3*freq))) # DAX regressed on its own annual lead,
                                                        # lags and the lead/lags of the other series
## World Development Panel Data
head(flag(wlddev, 1, wlddev$iso3c, wlddev$year))        # This lags all variables,
head(L(wlddev, 1, ~iso3c, ~year))                       # This lags all numeric variables
head(L(wlddev, 1, ~iso3c))                              # Without t: Works because data is ordered
head(L(wlddev, 1, PCGDP + LIFEEX ~ iso3c, ~year))       # This lags GDP per Capita &amp; Life Expectancy
head(L(wlddev, 0:2, ~ iso3c, ~year, cols = 9:10))       # Same, also retaining original series
head(L(wlddev, 1:2, PCGDP + LIFEEX ~ iso3c, ~year,      # Two lags, dropping id columns
       keep.ids = FALSE))

# Regressing GDP on its's lags and life-Expectancy and its lags
summary(lm(PCGDP ~ ., L(wlddev, 0:2, ~iso3c, ~year, 9:10, keep.ids = FALSE)))

## Indexing the data: facilitates time-based computations
wldi &lt;- findex_by(wlddev, iso3c, year)
head(L(wldi, 0:2, cols = 9:10))                              # Again 2 lags of GDP and LIFEEX
head(L(wldi$PCGDP))                                          # Lagging an indexed series
summary(lm(PCGDP ~ L(PCGDP,1:2) + L(LIFEEX,0:2), wldi))      # Running the lm again
summary(lm(PCGDP ~ ., L(wldi, 0:2, 9:10, keep.ids = FALSE))) # Same thing

## Using grouped data:
library(magrittr)
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(PCGDP,LIFEEX) |&gt; flag(0:2)
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(year,PCGDP,LIFEEX) |&gt; flag(0:2,year) # Also using t (safer)
</code></pre>


</div>