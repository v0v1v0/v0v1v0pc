<div class="container">

<table style="width: 100%;"><tr>
<td>all_equal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Are all values of x nearly equal (within a tolerance) to all values of y?</h2>

<h3>Description</h3>

<p>A memory-efficient alternative to <code>all.equal.numeric()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">all_equal(
  x,
  y,
  tol = getOption("cppdoubles.tolerance", sqrt(.Machine$double.eps)),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A double vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A double vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A double vector of tolerances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should <code>NA</code> values be ignored? Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>all_equal</code> compares each pair of
double-precision floating point numbers
in the same way as <code>double_equal</code>.
If any numbers differ, the algorithm breaks immediately,
which can offer significant speed when there are differences at
the start of a vector.
All arguments are recycled except <code>na.rm</code>.
</p>


<h3>Value</h3>

<p>A logical vector of length 1.
</p>
<p>The result should match <code>all(double_equal(x, y))</code>, including the way
<code>NA</code> values are handled.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(cppdoubles)
library(bench)
x &lt;- seq(0, 1, 0.2)
y &lt;- sqrt(x)^2

all_equal(x, y)

# Comparison to all.equal
z &lt;- runif(10^4, 1, 100)
ones &lt;- rep(1, length(z))
mark(base = isTRUE(all.equal(z, z)),
            cppdoubles = all_equal(z, z),
            iterations = 100)
mark(base = isTRUE(all.equal(z, ones)),
            cppdoubles = all_equal(z, ones),
            iterations = 100)

</code></pre>


</div>