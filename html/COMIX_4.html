<div class="container">

<table style="width: 100%;"><tr>
<td>comix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>This function generates a sample from the posterior of COMIX.</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior of COMIX.
</p>


<h3>Usage</h3>

<pre><code class="language-R">comix(Y, C, prior = NULL, pmc = NULL, state = NULL, ncores = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Matrix of the data. Each row represents an observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>Vector of the group label of each observation. Labels must be integers starting from 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>A list giving the prior information. If unspecified, a default prior is used.
The list includes the following parameters:
</p>

<ul>
<li> <p><code>zeta</code>: Coarsening parameter. A number between 0 and 1. <code>zeta</code> = 1: sample from standard posterior;
<code>zeta</code> &lt; 1: sample from power posterior. The lower <code>zeta</code> is, the more flexible the kernels become.
</p>
</li>
<li> <p><code>K</code>: Maximal number of mixture components.
</p>
</li>
<li> <p><code>eta_prior</code> Parameters for gamma prior for concentration parameter of the stick breaking process
prior for the weights.
</p>
</li>
<li> <p><code>m0</code>: Number of degrees of freedom for the inverse Wishart prior for Sigma, the covariance matrix
of the kernels. 
</p>
</li>
<li> <p><code>Lambda</code>: Mean parameter for the inverse Wishart prior for Sigma, the covariance matrix
of the kernels. 
</p>
</li>
<li> <p><code>b0</code>: Mean parameter for the multivariate normal distribution that is the prior for the
group mean parameter xi0.
</p>
</li>
<li> <p><code>B0</code>: Covariance parameter for the multivariate normal distribution that is the prior for the
group mean parameter xi0.
</p>
</li>
<li> <p><code>e0</code>: Number of degrees of freedom for the inverse Wishart prior for <code class="reqn">E_k</code>, the 
covariance matrix of the multivariate normal from which <code class="reqn">\xi_{j,k}</code> are drawn.
</p>
</li>
<li> <p><code>E0</code>: Mean parameter for the inverse Wishart prior for <code class="reqn">E_k</code>, the 
covariance matrix of the multivariate normal from which <code class="reqn">\xi_{j,k}</code> are drawn.
</p>
</li>
<li> <p><code>merge_step</code>: Introduce step to merge mixture components with small KL divergence. Default 
is <code>merge_step = TRUE</code>.
</p>
</li>
<li> <p><code>merge_par</code>: Parameter controlling merging radius. Default is <code>merge_par = 0.1</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmc</code></td>
<td>
<p>A list giving the Population Monte Carlo (PMC) parameters:
</p>

<ul>
<li> <p><code>npart</code>: Number of PMC particles.
</p>
</li>
<li> <p><code>nburn</code>: Number of burn-in steps
</p>
</li>
<li> <p><code>nsave</code>: Number of steps in the chain after burn-in.
</p>
</li>
<li> <p><code>nskip</code>: Thinning parameter, number of steps to skip between saving steps after burn-in.
</p>
</li>
<li> <p><code>ndisplay</code>: Display status of chain after every <code>ndisplay</code> steps.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>A list giving the initial cluster labels:
</p>

<ul><li> <p><code>t</code>: An integer vector, same length as the number of rows of <code>Y</code>, with cluster labels
between <code>1</code> and <code>K</code>.
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>The number of CPU cores to utilize in parallel. Defaults to 2.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class COMIX, a list of 4:
</p>

<p><code>chain</code>, a named list:
</p>

<ul>
<li>  <p><code>t</code>: an <code>nsave</code> <code class="reqn">\times</code> <code>nrow(Y)</code> matrix with estimated cluster labels
for each saved step of the chain and each observation in the data <code>Y</code>.
</p>
</li>
<li>  <p><code>z</code>: a <code>nsave</code> <code class="reqn">\times</code> <code>nrow(Y)</code> matrix with estimated values of 
the latent <code class="reqn">z_{i,j}</code> variable for the parameterization of the
multivariate skew normal distribution used in the sampler for each saved step of 
the chain and each observation in the data <code>Y</code>.
</p>
</li>
<li>  <p><code>W</code>: an <code>length(unique(C))</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> 
</p>
</li>
<li>  <p><code>nsave</code>: array storing the estimated sample- and cluster-specific weights for each 
saved step of the chain.
</p>
</li>
<li>  <p><code>xi</code>: an <code>length(unique(C))</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated sample- and cluster-specific
multivariate skew normal location parameters of the kernel for each saved step of the chain.
</p>
</li>
<li>  <p><code>xi0</code>: an <code>ncol(Y)</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> 
</p>
</li>
<li>  <p><code>nsave</code>: array storing the estimated cluster-specific 
group location parameters for each saved step of the chain.
</p>
</li>
<li>  <p><code>psi</code>: an <code>ncol(Y)</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> <code>nsave</code>
array storing the estimated cluster-specific skew parameters of the kernels in
the parameterization of the
multivariate skew normal distribution used in the sampler
for each saved step of the chain.
</p>
</li>
<li>  <p><code>G</code>: an  <code>ncol(Y)</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated cluster-specific
multivariate skew normal scale matrix (in row format) of the kernel
used in the sampler for each saved step of the chain.
</p>
</li>
<li>  <p><code>E</code>: an  <code>ncol(Y)</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated covariance matrix 
(in row format) of the multivariate normal distribution from which the  
sample- and cluster-specific location parameters are drawn for each saved step 
of the chain.
</p>
</li>
<li> <p><code>eta</code>: a <code>nsave</code> <code class="reqn">\times</code> <code>1</code> matrix storing the
estimated Dirichlet Process Mixture concentration parameter for each saved step of the chain.
</p>
</li>
<li> <p><code>Sigma</code>: an  <code>ncol(Y)</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated cluster-specific
multivariate skew normal scale matrix (in row format) of the kernel for each saved step of the chain.
</p>
</li>
<li> <p><code>alpha</code>: an <code>ncol(Y)</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> <code>nsave</code>
array storing the estimated cluster-specific skew parameters of the
kernel's multivariate skew normal distribution
for each saved step of the chain.
</p>
</li>
</ul>
<ul>
<li> <p><code>data</code>, a named list that includes the matrix of the data <code>Y</code>
and <code>C</code> the vector of the group label of each observation.
</p>
</li>
<li> <p><code>prior</code> and <code>pmc</code>, the lists, as above, that were provided as inputs to 
the function.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )


# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)

# Generate calibrated data:
cal &lt;- calibrateNoDist(res_relab)

# Compare raw and calibrated data: (see plot in vignette)
# par(mfrow=c(1, 2))
# plot(Y, col = C, xlim = range(Y[,1]), ylim = range(Y[,2]) )

# Get posterior estimates for the model parameters:
res_summary &lt;- summarizeChain(res_relab)
# Check for instance, the cluster assignment labels:
table(res_summary$t)
# Indeed the same as 
colSums(njk)

# Or examine the skewness parameter for the non-trivial clusters:
res_summary$alpha[ , unique(res_summary$t)]
# And compare those to
cbind(alpha1, alpha2)

# (see vignette for a more detailed example)
</code></pre>


</div>