<div class="container">

<table style="width: 100%;"><tr>
<td>ccfkms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clustering with Conjugate Convex Functions</h2>

<h3>Description</h3>

<p>Partition a data set into convex sets using conjugate convex functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ccfkms(x, n, p = NULL, par = 2, max.iter = 100, opt.std = FALSE,
       opt.retry = 0, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>optional number of prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a matrix of initial prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>type or parameter of conjugate convex function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.std</code></td>
<td>
<p>optionally standardize the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.retry</code></td>
<td>
<p>number of retries.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>optionally turn on debugging output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two types of conjugate convex functions are available: one that is based on 
powers of the norm of the prototype vectors and another that is based on a 
logarithmic transformation of the norm. Both are intended to obtain more 
robust partitions.
</p>
<p>Using <code>par</code> = 2 is equivalent to performing ordinary k-means with
Euclidean distances. <code>par</code> = 1 is equivalent to LVQ of Kohonen type 
(the directions of the prototypes from the center of the data are used), 
and <code>par</code> = 0 is equivalent to using 2*ln(cosh(|p|))/2.
</p>
<p>Internally the algorithm uses sparse data structures and avoids computations 
with zero data values. Thus, the data must not be centered (the algorithm 
does this internally with the option to further standardize the data). For 
dense data this is slightly inefficient.
</p>
<p>If initial prototypes are omitted the number of prototypes must be specified.
In this case the initial prototypes are drawn from the data (without 
replacement).
</p>
<p>If the number of retries is greater than zero the best among that number 
of trial solutions is returned. Note that the number of prototypes must be
specified as the initial prototypes are sampled from the data.
</p>
<p>The debugging output shows the iteration number, the inverted information 
and the variance of the current partition as a percentage of the total (if 
each data point were a cluster), and the number of active prototypes (those 
with at least one member, i.e. a data point that is not closer to any 
other prototype).
</p>
<p>Note that the algorithm uses tie-breaking when it determines the cluster
memberships of the samples.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>a matrix of cluster means (final prototypes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>a vector of cluster sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a factor of cluster labels (indexes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.inf</code></td>
<td>
<p>the inverted information of the partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>see above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.std</code></td>
<td>
<p>see above.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Support for data matrices <code>x</code> in sparse <code>dgTMatrix</code> and 
<code>dgCMatrix</code> format (see package <span class="pkg">Matrix</span>) is experimental. 
Support for the <code>dgRMatrix</code> format is currently suspended
due to problems with package <span class="pkg">Matrix</span>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>Helmut Strasser and Klaus Poetzelberger. Data Compression by 
Unsupervised Classification. <em>SFB Report Series</em>, No. 10, 1997.
</p>


<h3>See Also</h3>

<p><code>kmeans</code>, <code>cmeans</code>, <code>kkmeans</code> for similar or related
clustering techniques.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### extend proximus example
x &lt;- rlbmat()
rownames(x) &lt;- seq(dim(x)[1])
cm &lt;- ccfkms(x, n=4, opt.retry=10)
pcm &lt;- predict(cm, x)
## Not run: 
### using sparse data may be more time-efficient
### depending on the goodness of the implementation
### of subset, etc. in package Matrix.
require(Matrix)
#sx &lt;- as(x, "dgRMatrix")    # currently broken
sx &lt;- as(x, "dgCMatrix")
system.time(scm &lt;- ccfkms(sx, n=4, opt.retry=50))
system.time(cm &lt;- ccfkms(x, n=4, opt.retry=50))

## End(Not run)
</code></pre>


</div>