<div class="container">

<table style="width: 100%;"><tr>
<td>clarke_test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clarke Test</h2>

<h3>Description</h3>

<p>‘clarke_test' returns results from Kevin Clarke’s distribution-free test
of non-nested models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clarke_test(model1, model2, level=0.05, digits=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model1</code></td>
<td>
<p>A fitted statistical model of a supported class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model2</code></td>
<td>
<p>A fitted statistical model of a supported class
whose dependent variable is the same as that of <code>model1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Numeric: significance level for the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Integer: number of digits to print</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>'clarke_test' is a more modularized version of the [clarke()] function from
the [games] package.  The main innovation is that the 'nonnest' function
calls a generic 'indivLogLiks' function, so additional methods can be easily
written for different classes of models. The function
currently supports binomial, poisson and negative
binomial GLMs, ordinal models estimated with either
<code>polr</code> from the <code>MASS</code> package
or <code>clm</code> from the <code>ordinal</code>
package and multinomial models estimated with either
<code>multinom</code> from the <code>nnet</code>
package.  Users can also write new
methods for both <code>indivLogLiks</code> and <code>nparams</code>
that would get called by the generic function.
</p>


<h3>Value</h3>

<p>Typical use will be to run the function interactively and examine
the printed output.  The functions return an object of class
<code>nonnest.test</code>, which is a list containing: </p>

<dl>
<dt><code>stat</code></dt>
<dd>
<p>The test statistic</p>
</dd>
<dt><code>level</code></dt>
<dd>
<p>Significance level for the test</p>
</dd>
<dt><code>digits</code></dt>
<dd>
<p>Number of digits to print</p>
</dd>
<dt><code>loglik1</code></dt>
<dd>
<p>Vector of observationwise log-likelihoods for
<code>model1</code></p>
</dd>
<dt><code>loglik2</code></dt>
<dd>
<p>Vector of observationwise log-likelihoods for
<code>model2</code></p>
</dd>
<dt><code>nparams</code></dt>
<dd>
<p>Integer vector containing the number of parameters
fitted in <code>model1</code> and <code>model2</code> respectively</p>
</dd>
<dt><code>nobs</code></dt>
<dd>
<p>Number of observations of the dependent variable being
modeled</p>
</dd>
</dl>
<p>An object of class <code>nonnest.test</code> with the following values:
</p>

<dl>
<dt>stat</dt>
<dd>
<p>The number of times model 1 is better than model 2</p>
</dd>
<dt>test</dt>
<dd>
<p>Will always be "clarke".</p>
</dd>
<dt>level</dt>
<dd>
<p>The chosen confidence level for the test</p>
</dd>
<dt>digits</dt>
<dd>
<p>The number of digits to print</p>
</dd>
<dt>loglik1</dt>
<dd>
<p>Individual log-likelihoods for model 1</p>
</dd>
<dt>loglik2</dt>
<dd>
<p>Individual log-likelihoods for model 2</p>
</dd>
<dt>nparams</dt>
<dd>
<p>A vector giving the number of parameters in models 1 and 2,
respectively</p>
</dd>
<dt>nobs</dt>
<dd>
<p>Number of observations in the model</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Brenton Kenkel (<a href="mailto:brenton.kenkel@gmail.com">brenton.kenkel@gmail.com</a>) modified by
Dave Armstrong (<a href="mailto:dave@quantoid.net">dave@quantoid.net</a>)
</p>


<h3>References</h3>

<p>Kevin Clarke.  2007.  "A Simple Distribution-Free Test for
Nonnested Hypotheses."  <em>Political Analysis</em> 15(3): 347–363.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(conflictData)
## Linear Model
lm1 &lt;- lm(riots ~ log(rgdpna_pc) + log(pop*1000) +
    polity2, data=conflictData)
lm2 &lt;- lm(riots ~ rgdpna_pc + pop +
    polity2, data=conflictData)
clarke_test(lm1, lm2)

## Binomial GLM
glm1 &lt;- glm(conflict_binary ~ log(rgdpna_pc) +
          log(pop*1000) + polity2, data=conflictData,
          family=binomial)
glm2 &lt;- glm(conflict_binary ~ rgdpna_pc + pop +
          polity2, data=conflictData,
          family=binomial)
clarke_test(glm1, glm2)

## Poisson GLM
glm1a &lt;- glm(riots ~ log(rgdpna_pc) +
              log(pop*1000) + polity2,
             data=conflictData,
             family=poisson)
glm2a &lt;- glm(riots ~ rgdpna_pc + pop +
              polity2, data=conflictData,
            family=poisson)
clarke_test(glm1a, glm2a)

## Negative Binomial GLM
library(MASS)
glm1b &lt;- glm.nb(riots ~ log(rgdpna_pc) +
               log(pop*1000) + polity2,
               data=conflictData)
glm2b &lt;- glm.nb(riots ~ rgdpna_pc + pop +
               polity2, data=conflictData)
clarke_test(glm1b, glm2b)

## Ordered Logit: polr
library(MASS)
ol1 &lt;- polr(as.factor(Amnesty) ~ log(rgdpna_pc) +
                  log(pop*1000) + polity2,
                data=conflictData)
ol2 &lt;- polr(as.factor(Amnesty) ~ scale(rgdpna_pc) +
            scale(pop) + polity2,
            data=conflictData)
clarke_test(ol1, ol2)

## Ordered Logit: clm
library(ordinal)
ol1a &lt;- clm(as.factor(Amnesty) ~ log(rgdpna_pc) +
              log(pop*1000) + polity2,
            data=conflictData)
ol2a &lt;- clm(as.factor(Amnesty) ~ scale(rgdpna_pc) +
            scale(pop) + polity2,
            data=conflictData)
clarke_test(ol1a, ol2a)

## Multinomial Logit: multinom

library(nnet)
ml1 &lt;- multinom(as.factor(Amnesty) ~ log(rgdpna_pc) +
              log(pop*1000) + polity2,
            data=conflictData)
ml2 &lt;- multinom(as.factor(Amnesty) ~ scale(rgdpna_pc) +
              scale(pop) + polity2,
            data=conflictData)
clarke_test(ml1, ml2)


## Multinomial Logit: multinom


</code></pre>


</div>