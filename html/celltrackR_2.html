<div class="container">

<table style="width: 100%;"><tr>
<td>aggregate.tracks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Summary Statistics of Subtracks</h2>

<h3>Description</h3>

<p>Computes a given measure on subtracks of a given track set, applies a summary
statistic for each subtrack length, and returns the results in a convenient form.
This important workhorse function facilitates many common motility analyses
such as mean square displacement, turning angle, and autocorrelation plots.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tracks'
aggregate(
  x,
  measure,
  by = "subtracks",
  FUN = mean,
  subtrack.length = seq(1, (maxTrackLength(x) - 1)),
  max.overlap = max(subtrack.length),
  na.rm = FALSE,
  filter.subtracks = NULL,
  count.subtracks = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the tracks object whose subtracks are to be considered.
If a single track is given, it will be coerced to a tracks object
using <code>wrapTrack</code> (but note that this requires an explicit call
<code>aggregate.tracks</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p>the measure that is to be computed on the subtracks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>a string that indicates how grouping is performed. Currently, two
kinds of grouping are supported:
</p>

<ul>
<li>
<p> "subtracks"  Apply <code>measure</code> to all subtracks according to
the parameters <code>subtrack.length</code> and <code>max.overlap</code>.
</p>
</li>
<li>
<p> "prefixes"   Apply <code>measure</code> to all prefixes (i.e., subtracks starting
from a track's initial position) according to the parameter <code>subtrack.length</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>a summary statistic to be computed on the measures of subtracks with the
same length. Can be a function or a string.
If a string is given, it is first matched to the following builtin values:
</p>

<ul>
<li>
<p> "mean.sd"  Outputs the mean and <code class="reqn">mean - sd</code> as lower and
<code class="reqn">mean + sd</code> as upper bound 
</p>
</li>
<li>
<p> "mean.se" Outputs the mean and <code class="reqn">mean - se</code> as lower and
<code class="reqn">mean + se</code> as upper bound 
</p>
</li>
<li>
<p> "mean.ci.95" Outputs the mean and upper and lower bound of a
parametric 95 percent confidence interval.
</p>
</li>
<li>
<p> "mean.ci.99" Outputs the mean and upper and lower bound of a
parametric 95 percent confidence intervall.
</p>
</li>
<li>
<p> "iqr" Outputs the interquartile range, that is, the median, and the
25-percent-quartile as a lower and and the 75-percent-quartile as an
upper bound
</p>
</li>
</ul>
<p>If the string is not equal to any of these, it is passed on to
<code>match.fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subtrack.length</code></td>
<td>
<p>an integer or a vector of integers defining which subtrack
lengths are considered. In particular, <code>subtrack.length=1</code>
corresponds to a "step-based analysis" (Beltman et al, 2009).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.overlap</code></td>
<td>
<p>an integer controlling what to do with overlapping subtracks.
A maximum overlap of <code>max(subtrack.length)</code> will imply
that all subtracks are considered. For a maximum overlap of 0, only non-overlapping
subtracks are considered. A negative overlap can be used to ensure that only subtracks
a certain distance apart are considered. In general, for non-Brownian motion there will
be correlations between subsequent steps, such that a negative overlap may be necessary
to get a proper error estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then <code>NA</code>'s and <code>NaN</code>'s
are removed prior to computing the summary statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.subtracks</code></td>
<td>
<p>a function that can be supplied to exclude certain subtracks
from an analysis. For instance, one may wish to compute angles only between steps of
a certain minimum length (see Examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count.subtracks</code></td>
<td>
<p>logical. If <code>TRUE</code>, the returned dataframe contains an
extra column <code>ntracks</code> showing the number of subtracks of each length. This is 
useful to keep track of since the returned <code>value</code> estimates for high 
<code>i</code> are often based on very few subtracks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or used by methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For every number of segments <code class="reqn">i</code> in the set defined by
<code>subtrack.length</code>, all subtracks of any track in the input
<code>tracks</code> object that consist of exactly <code class="reqn">i</code> segments are
considered. The input <code>measure</code> is applied to the subtracks individually,
and the <code>statistic</code> is applied to the resulting values.
</p>


<h3>Value</h3>

<p>A data frame with one row for every <code class="reqn">i</code>
specified by <code>subtrack.length</code>. The first column contains the values
of <code class="reqn">i</code> and the remaining columns contain the values of the summary statistic
of the measure values of tracks having exactly <code class="reqn">i</code> segments.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789â€“798. doi:10.1038/nri2638
</p>


<h3>Examples</h3>

<pre><code class="language-R">## A mean square displacement plot with error bars.
dat &lt;- aggregate(TCells, squareDisplacement, FUN="mean.se")
with( dat ,{
  plot( mean ~ i, xlab="time step",
  	ylab="mean square displacement", type="l" )
  segments( i, lower, y1=upper )
} )

## Note that the values at high i are often based on very few subtracks:
msd &lt;- aggregate( TCells, squareDisplacement, count.subtracks = TRUE )
tail( msd )

## Compute a turning angle plot for the B cell data, taking only steps of at least
## 1 micrometer length into account
check &lt;- function(x) all( sapply( list(head(x,2),tail(x,2)), trackLength ) &gt;= 1.0 )
plot( aggregate( BCells, overallAngle, subtrack.length=1:10,
  filter.subtracks=check )[,2], type='l' )

## Compare 3 different variants of a mean displacement plot
# 1. average over all subtracks
plot( aggregate( TCells, displacement ), type='l' )
# 2. average over all non-overlapping subtracks
lines( aggregate( TCells, displacement, max.overlap=0 ), col=2 )
# 3. average over all subtracks starting at 1st position
lines( aggregate( TCells, displacement, by="prefixes" ), col=3 )

</code></pre>


</div>