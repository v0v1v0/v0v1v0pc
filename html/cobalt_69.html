<div class="container">

<table style="width: 100%;"><tr>
<td>splitfactor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split and Unsplit Factors into Dummy Variables</h2>

<h3>Description</h3>

<p><code>splitfactor()</code> splits factor variables into dummy (0/1) variables. This can be useful when functions do not process factor variables well or require numeric matrices to operate. <code>unsplitfactor()</code> combines dummy variables into factor variables, undoing the operation of <code>splitfactor()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">splitfactor(
  data,
  var.name,
  drop.level = NULL,
  drop.first = TRUE,
  drop.singleton = FALSE,
  drop.na = TRUE,
  sep = "_",
  replace = TRUE,
  split.with = NULL,
  check = TRUE
)

unsplitfactor(
  data,
  var.name,
  dropped.level = NULL,
  dropped.na = TRUE,
  sep = "_",
  replace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.frame</code> containing the variables to be split or unsplit. In <code>splitfactor()</code>, can be a factor variable to be split.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.name</code></td>
<td>
<p>For <code>splitfactor()</code>, the names of the factor variables to split. If not specified, will split all factor variables in <code>data</code>. If <code>data</code> is a factor, the stem for each of the new variables to be created. For <code>unsplitfactor()</code>, the name of the previously split factor. If not specified and <code>data</code> is the output of a call to <code>splitfactor()</code>, all previously split variables will be unsplit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.level</code></td>
<td>
<p>The name of a level of <code>var.name</code> for which to drop the dummy variable. Only works if there is only one variable to be split.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.first</code></td>
<td>
<p>Whether to drop the first dummy created for each factor. If <code>"if2"</code>, will only drop the first category if the factor has exactly two levels. The default is to always drop the first dummy (<code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.singleton</code></td>
<td>
<p>Whether to drop a factor variable if it only has one level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.na</code></td>
<td>
<p>If <code>NA</code>s are present in the variable, how to handle them. If <code>TRUE</code>, no new dummy will be created for <code>NA</code> values, but all created dummies will have <code>NA</code> where the original variable was <code>NA</code>. If <code>FALSE</code>, <code>NA</code> will be treated like any other factor level, given its own column, and the other dummies will have a value of 0 where the original variable is <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>A character separating the the stem from the value of the variable for each dummy. For example, for <code>"race_black"</code>, <code>sep = "_"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Whether to replace the original variable(s) with the new variable(s) (<code>TRUE</code>) or the append the newly created variable(s) to the end of the data set (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.with</code></td>
<td>
<p>A list of vectors or factors with lengths equal to the number of columns of <code>data</code> that are to be split in the same way <code>data</code> is. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>Whether to make sure the variables specified in <code>var.name</code> are actually factor (or character) variables. If splitting non-factor (or non-character) variables into dummies, set <code>check = FALSE</code>. If <code>check = FALSE</code> and <code>data</code> is a <code>data.frame</code>, an argument to <code>var.name</code> must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropped.level</code></td>
<td>
<p>The value of each original factor variable whose dummy was dropped when the variable was split. If left empty and a dummy was dropped, the resulting factor will have the value <code>NA</code> instead of the dropped value. There should be one entry per variable to unsplit. If no dummy was dropped for a variable, an entry is still required, but it will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropped.na</code></td>
<td>
<p>If <code>TRUE</code>, will assume that <code>NA</code>s in the variables to be unsplit correspond to <code>NA</code> in the unsplit factor (i.e., that <code>drop.na = TRUE</code> was specified in <code>split.factor()</code>). If <code>FALSE</code>, will assume there is a dummy called "var.name_stem_NA" (e.g., "x_NA") that contains 1s where the unsplit factor should be <code>NA</code> (i.e., that <code>drop.na = FALSE</code> was specified in <code>split.factor()</code>. If <code>NA</code>s are stored in a different column with the same stem, e.g., "x_miss", that name (e.g., "miss") can be entered instead.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If there are <code>NA</code>s in the variable to be split, the new variables created by <code>splitfactor()</code> will have <code>NA</code> where the original variable is <code>NA</code>.
</p>
<p>When using <code>unsplitfactor()</code> on a <code>data.frame</code> that was generated with <code>splitfactor()</code>, the arguments <code>dropped.na</code>, and <code>sep</code> are unnecessary.
</p>
<p>If <code>split.with</code> is supplied, the elements will be split in the same way <code>data</code> is. For example, if <code>data</code> contained a 4-level factor that was to be split, the entries of <code>split.with</code> at the same index as the factor and would be duplicated so that resulting entries will have the same length as the number of columns of <code>data</code> after being split. The resulting values are stored in the <code>"split.with"</code> attribute of the output object. See Examples.
</p>


<h3>Value</h3>

<p>For <code>splitfactor()</code>, a <code>data.frame</code> containing the original data set with the newly created dummies. For <code>unsplitfactor()</code>. a <code>data.frame</code> containing the original data set with the newly created factor variables.
</p>


<h3>See Also</h3>

<p><code>model.matrix()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("lalonde", package = "cobalt")

lalonde.split &lt;- splitfactor(lalonde, "race", 
                             replace = TRUE, 
                             drop.first = TRUE)
# A data set with "race_hispan" and "race_white" instead
# of "race".

lalonde.unsplit &lt;- unsplitfactor(lalonde.split, "race", 
                                 replace = TRUE,
                                 dropped.level = "black")

all.equal(lalonde, lalonde.unsplit) #TRUE

# Demonstrating the use of split.with:
to.split &lt;- list(letters[1:ncol(lalonde)],
                 1:ncol(lalonde))

lalonde.split &lt;- splitfactor(lalonde, split.with = to.split,
                             drop.first = FALSE)
attr(lalonde.split, "split.with")


</code></pre>


</div>