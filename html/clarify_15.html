<div class="container">

<table style="width: 100%;"><tr>
<td>sim_apply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a function to simulated parameter values</h2>

<h3>Description</h3>

<p><code>sim_apply()</code> applies a function that produces quantities of
interest to each set of simulated coefficients produced by <code>sim()</code>; these
calculated quantities form the posterior sampling distribution for the
quantities of interest. Capabilities are available for parallelization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_apply(sim, FUN, verbose = TRUE, cl = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>a <code>clarify_sim</code> object; the output of a call to <code>sim()</code> or
<code>misim()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>a function to be applied to each set of simulated coefficients.
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>; whether to display a text progress bar indicating
progress and estimated time remaining for the procedure. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a cluster object created by <code>parallel::makeCluster()</code>, or an
integer to indicate the number of child-processes (integer values are
ignored on Windows) for parallel evaluations. See <code>pbapply::pblapply()</code> for
details. If <code>NULL</code>, no parallelization will take place.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments passed to <code>FUN</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sim_apply()</code> applies a function, <code>FUN</code>, to each set of simulated
coefficients, similar to <code>apply()</code>. This function should return a numeric
vector containing one or more estimated quantities. This should be a named
vector to more easily keep track of the meaning of each estimated quantity.
Care should be taken to ensure that the returned vector is the same length
each time <code>FUN</code> is called. <code>NA</code>s are allowed in the output but should be
avoided if possible.
</p>
<p>The arguments to <code>FUN</code> can be specified in a few ways. If <code>FUN</code> has an
argument called <code>coefs</code>, a simulated set of coefficients will be passed to
this argument, and <code>FUN</code> should compute and return a quantity based on the
coefficients (e.g., the difference between two coefficients if one wants to
test whether two coefficients are equal). If <code>FUN</code> has an argument called
<code>fit</code>, a model fit object of the same type as the one originally supplied
to <code>sim()</code> (e.g., an <code>lm</code> or <code>glm</code> object) will be passed to this argument,
where the coefficients of the fit object have been replaced by the
simulated coefficients generated by <code>sim()</code>, and <code>FUN</code> should compute and
return a quantity based on the model fit (e.g., a computation based on the
output of <code>predict()</code>). If neither <code>coefs</code> nor <code>fit</code> are the names of
arguments to <code>FUN</code>, the model fit object with replaced coefficients will be
supplied to the first argument of <code>FUN</code>.
</p>
<p>When custom coefficients are supplied to <code>sim()</code>, i.e., when the <code>coefs</code>
argument to <code>sim()</code> is not left at its default value, <code>FUN</code> must accept a
<code>coefs</code> argument and a warning will be thrown if it accepts a <code>fit</code>
argument. This is because <code>sim_apply()</code> does not know how to reconstruct
the original fit object with the new coefficients inserted. The quantities
computed by <code>sim_apply()</code> must therefore be computed directly from the
coefficients.
</p>
<p>If <code>FUN</code> is not supplied at all, the simulated values of the coefficients will be returned in the output with a warning. Set <code>FUN</code> to <code>NULL</code> or <code>verbose</code> to <code>FALSE</code> to suppress this warning.
</p>


<h4>
<code>sim_apply()</code> with multiply imputed data</h4>

<p>When using <code>misim()</code> and <code>sim_apply()</code> with multiply imputed data, the
coefficients are supplied to the model fit corresponding to the imputation
identifier associated with each set of coefficients, which means if <code>FUN</code>
uses a dataset extracted from a model (e.g., using <code>insight::get_data()</code>), it will do so from the model fit in
the corresponding imputation.
</p>
<p>The original estimates (see Value below) are computed as the mean of the
estimates across the imputations using the original coefficients averaged
across imputations. That is, first, the coefficients estimated in the
models in the imputed datasets are combined to form a single set of pooled
coefficients; then, for each imputation, the quantities of interest are
computed using the pooled coefficients; finally, the mean of the resulting
estimates across the imputations are taken as the "original" estimates.
Note this procedure is only valid for quantities with symmetric sampling
distributions, which excludes quantities like risk ratios and odds ratios,
but includes log risk ratios and log odds ratios. The desired quantities
can be transformed from their log versions using
<code>transform()</code>.
</p>



<h3>Value</h3>

<p>A <code>clarify_est</code> object, which is a matrix with a column for each
estimated quantity and a row for each simulation. The original estimates
(<code>FUN</code> applied to the original coefficients or model fit object) are stored
in the attribute <code>"original"</code>. The <code>"sim_hash"</code> attribute contains the
simulation hash produced by <code>sim()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>sim()</code> for generating the simulated coefficients
</p>
</li>
<li> <p><code>summary.clarify_est()</code> for computing p-values and confidence intervals for
the estimated quantities
</p>
</li>
<li> <p><code>plot.clarify_est()</code> for plotting estimated
quantities and their simulated posterior sampling distribution.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
data("lalonde", package = "MatchIt")
fit &lt;- lm(re78 ~ treat + age + race + nodegree + re74,
          data = lalonde)
coef(fit)

set.seed(123)
s &lt;- sim(fit, n = 500)

# Function to compare predicted values for two units
# using `fit` argument
sim_fun &lt;- function(fit) {
  pred1 &lt;- unname(predict(fit, newdata = lalonde[1,]))
  pred2 &lt;- unname(predict(fit, newdata = lalonde[2,]))
  c(pred1 = pred1, pred2 = pred2)
}

est &lt;- sim_apply(s, sim_fun, verbose = FALSE)

# Add difference between predicted values as
# additional quantity
est &lt;- transform(est, `diff 1-2` = pred1 - pred2)

# Examine estimates and confidence intervals
summary(est)

# Function to compare coefficients using `coefs`
# argument
sim_fun &lt;- function(coefs) {
  setNames(coefs["racewhite"] - coefs["racehispan"],
           "wh - his")
}

est &lt;- sim_apply(s, sim_fun, verbose = FALSE)

# Examine estimates and confidence intervals
summary(est)

# Another way to do the above:
est &lt;- sim_apply(s, FUN = NULL)
est &lt;- transform(est,
                 `wh - his` = `racewhite` - `racehispan`)

summary(est, parm = "wh - his")

</code></pre>


</div>