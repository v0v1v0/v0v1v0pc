<div class="container">

<table style="width: 100%;"><tr>
<td>SamplePCA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "SamplePCA"</h2>

<h3>Description</h3>

<p>Perform principal components analysis on the samples (columns) from a
microarray or proteomics experiment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SamplePCA(data, splitter=0, usecor=FALSE, center=TRUE)
## S4 method for signature 'SamplePCA,missing'
plot(x, splitter=x@splitter, col, main='', which=1:2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code>ExpressionSet</code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitter</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then splitter
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>splitter</code> can be a character string that
names one of the factor columns in the associated
<code>phenoData</code> subobject.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>A logical value; should the rows of the data matrix be
centered first?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usecor</code></td>
<td>
<p>A logical value; should the rows of the data matrix be
scaled to have standard deviation 1?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>SamplePCA</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>A list of colors to represent each level of the
<code>splitter</code> in the plot. If this parameter is missing, the
function will select colors automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>A character string; the plot title</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>A numeric vector of length two specifying which two principal
components should be included in the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional graphical parameters for <code>plot</code></p>
</td>
</tr>
</table>
<p>.
</p>


<h3>Details</h3>

<p>The main reason for developing the <code>SamplePCA</code> class is that the
<code>princomp</code> function is very inefficient when the number of
variables (in the microarray setting, genes) far exceeds the number of
observations (in the microarray setting, biological samples).  The
<code>princomp</code> function begins by computing the full covariance
matrix, which gets rather large in a study involving tens of thousands
of genes.  The <code>SamplePCA</code> class, by contrast, uses singular
value decomposition (<code>svd</code>) on the original data matrix to
compute the principal components.
</p>
<p>The base functions <code>screeplot</code>, which produces  a barplot of the
percentage of variance explained by each component, and <code>plot</code>,
which produces a scatter plot comparing two selected components
(defaulting to the first two), have been generalized as methods for
the <code>SamplePCA</code> class.  You can add sample labels to the scatter
plot using either the <code>text</code> or <code>identify</code> methods.  One
should, however, note that the current implementaiton of these methods
only works when plotting the first two components.
</p>


<h3>Value</h3>

<p>The <code>SamplePCA</code> function constructs and returns an object of the
<code>SamplePCA</code> class.  We assume that the input data matrix has N
columns (of biological samples) and P rows (of genes). 
</p>
<p>The <code>predict</code> method returns a matrix whose size is the number of
columns in the input by the number of principal components.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be created using the <code>SamplePCA</code> function. In the
simplest case, you simply pass in a data matrix and a logical vector,
<code>splitter</code>, assigning classes to the columns, and the constructor
performs principal components analysis on the column.  The
<code>splitter</code> is ignored by the constructor and is simply saved to
be used by the plotting routines.  If you omit the <code>splitter</code>,
then no grouping structure is used in the plots.
</p>
<p>If you pass <code>splitter</code> as a factor instead of a logical vector,
then the plotting routine will distinguish all levels of the factor.
The code is likely to fail, however, if one of the levels of the
factor has zero representatives among the data columns.
</p>
<p>We can also perform PCA on
<code>ExpressionSet</code> objects 
from the BioConductor libraries. In this case, we pass in an
<code>ExpressionSet</code> object along with a character string containing the
name of a factor to use for splitting the data.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>scores</code>:</dt>
<dd>
<p>A <code>matrix</code> of size NxN, where N is the
number of columns in the input, representing the projections of
the input columns onto the first N principal components. </p>
</dd>
<dt>
<code>variances</code>:</dt>
<dd>
<p>A <code>numeric</code> vector of length N; the
amount of the total variance explained by each principal component.</p>
</dd>
<dt>
<code>components</code>:</dt>
<dd>
<p>A <code>matrix</code> of size PxN (the same size
as the input matrix) containing each of the first P principal
components as columns.</p>
</dd>
<dt>
<code>splitter</code>:</dt>
<dd>
<p>A logical vector or factor of length N
classifying the columns into known groups.</p>
</dd>
<dt>
<code>usecor</code>:</dt>
<dd>
<p>A <code>logical</code> value; was the data standardized?</p>
</dd>
<dt>
<code>shift</code>:</dt>
<dd>
<p>A <code>numeric</code> vector of length P; the mean
vector of the input data, which is used for centering by the
<code>predict</code> method.</p>
</dd>
<dt>
<code>scale</code>:</dt>
<dd>
<p>A <code>numeric</code> vector of length P; the
standard deviation of the input data, which is used for scaling by
the <code>predict</code> method.</p>
</dd>
<dt>
<code>call</code>:</dt>
<dd>
<p>An object of class <code>call</code> that records
how the object was created. </p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>plot</dt>
<dd>
<p><code>signature(x = SamplePCA, y = missing)</code>: Plot the
samples in a two-dimensional principal component space. </p>
</dd>
<dt>predict</dt>
<dd>
<p><code>signature(object = SamplePCA)</code>: Project new
data into the principal component space. </p>
</dd>
<dt>screeplot</dt>
<dd>
<p><code>signature(x = SamplePCA)</code>: Produce a bar
chart of the variances explained by each principal component. </p>
</dd>
<dt>summary</dt>
<dd>
<p><code>signature(object = SamplePCA)</code>: Write out a
summary of the object.</p>
</dd>
<dt>identify</dt>
<dd>
<p><code>signature(object = SamplePCA)</code>: interactively
identify points in the plot of a <code>SamplePCA</code> object.</p>
</dd>
<dt>text</dt>
<dd>
<p><code>signature(object = SamplePCA)</code>: Add sample
identifiers to the scatter plot of a <code>SamplePCA</code> object,
using the base <code>text</code> function.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code>princomp</code>,
<code>GenePCA</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">showClass("SamplePCA")

## simulate data from three different groups
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)
kind &lt;- factor(rep(c('red', 'green', 'blue'), each=10))
colnames(dd) &lt;- paste(kind, rep(1:10, 3), sep='')

## perform PCA
spc &lt;- SamplePCA(dd, splitter=kind)

## plot the results
plot(spc, col=levels(kind))

## mark the group centers
x1 &lt;- predict(spc, matrix(apply(d1, 1, mean), ncol=1))
points(x1[1], x1[2], col='red', cex=2)
x2 &lt;- predict(spc, matrix(apply(d2, 1, mean), ncol=1))
points(x2[1], x2[2], col='green', cex=2)
x3 &lt;- predict(spc, matrix(apply(d3, 1, mean), ncol=1))
points(x3[1], x3[2], col='blue', cex=2)

## check out the variances
screeplot(spc)

## cleanup
rm(d1, d2, d3, dd,kind, spc, x1, x2, x3)
</code></pre>


</div>