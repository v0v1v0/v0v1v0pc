<div class="container">

<table style="width: 100%;"><tr>
<td>mock</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mocking HTTP requests</h2>

<h3>Description</h3>

<p>Works for both synchronous requests via <code>HttpClient()</code> and async
requests via <code>Async()</code> and <code>AsyncVaried()</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">mock(on = TRUE)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>on</code></td>
<td>
<p>(logical) turn mocking on with <code>TRUE</code> or turn off with <code>FALSE</code>.
By default is <code>FALSE</code></p>
</td>
</tr></table>
<h3>Details</h3>

<p><code>webmockr</code> package required for mocking behavior
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

if (interactive()) {
  library(webmockr)
  library(crul)

  URL &lt;- "https://hb.opencpu.org"

  # turn on mocking
  crul::mock()

  # stub a request
  stub_request("get", file.path(URL, "get"))

  # create an HTTP client
  (x &lt;- HttpClient$new(url = URL))

  # make a request - matches stub - no real request made
  x$get('get')

  # allow net connect
  webmockr::webmockr_allow_net_connect()
  x$get('get', query = list(foo = "bar"))
  webmockr::webmockr_disable_net_connect()
  x$get('get', query = list(foo = "bar"))

  # With Async
  urls &lt;- c(
   file.path(URL, "get"),
   file.path(URL, "anything"),
   file.path(URL, "encoding/utf8")
  )
  
  for (u in urls) {
    webmockr::stub_request("get", u) %&gt;% 
      webmockr::to_return(body = list(mocked = TRUE))
  }

  async_con &lt;- Async$new(urls = urls)
  async_resp &lt;- async_con$get()
  lapply(async_resp, \(x) x$parse("UTF-8"))
}


## End(Not run)
</code></pre>


</div>