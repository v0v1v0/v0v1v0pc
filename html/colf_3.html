<div class="container">

<table style="width: 100%;"><tr>
<td>colf_nlxb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nash Variant of the Marquardt algorithm on a linear objective function</h2>

<h3>Description</h3>

<p>Non linear least squares solution via qr linear solver on a linear objective function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">colf_nlxb(formula, data, start = NULL, trace = FALSE, lower = -Inf,
  upper = Inf, na.action = c("na.omit", "na.fail", "na.exclude"),
  masked = NULL, control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The formula. This has the same syntax and supports the same features as the 
formula in <code>lm</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the data of the variables in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>An atomic vector of same length as the number of parameters. If not provided a 
cheap guess will be made. If categorical variables are included these need to be takent into 
consideration as number of categories minus one. See examples and details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Logical. Defaults to FALSE. Set to TRUE if you want the intermediate progress to be 
reported</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Lower bounds of the parameters (atomic vector). If a single number, this will be 
applied to all parameters. Defaults to -Inf (unconstrained).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>Upper bounds of the parameters (atomic vector). If a single number, this will be 
applied to all parameters. Defaults to Inf (unconstrained).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function which indicates what should happen if NAs are present in the data
set. Defaults to options('na.action'). na.fail, or na.exclude can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>masked</code></td>
<td>
<p>Character vector of parameter names. These parameters will not be altered 
by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of controls for the algorithm. These are:
</p>

<ul>
<li>
<p> watch - Monitor progress. Logical, defaults to FALSE
</p>
</li>
<li>
<p> phi - Adds phi*identity to Jacobian inner product. Defaults to 1.
</p>
</li>
<li>
<p> lamda - Initial Marquardt adjustment. Defaults to 0.0001.
</p>
</li>
<li>
<p> offset - Shift to test floating point equality. Defaults to 100.
</p>
</li>
<li>
<p> laminc - Factor to use to increase lamda. Defaults to 10.
</p>
</li>
<li>
<p> lamdec - Factor to use to decrease lamda (lamdec / laminc). Defaults to 4.
</p>
</li>
<li>
<p> femax - Maximum evaluations of sum of squares function. Defaults to 10000.
</p>
</li>
<li>
<p> jemax - Maximum evaluations of the Jacobian. Defaults to 5000.
</p>
</li>
<li>
<p> rofftest - Use a termination of the relative offset orthogonality type. 
</p>
</li>
<li>
<p> smallsstest - Exit the function if the sum of squares falls below 
(100 * .Machine$double.eps)^4 times the initial sumsquares. Defaults to TRUE.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to optimiser</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>colf_nlxb</code> uses Nash's (Nash, 1979) variant of the Marquardt algorithm, in an attempt to
find the minimum of the residual sum of squares. The algorithm is applied on a linear objective
function.
</p>
<p>The function provides an easy way to apply the optimizer on a linear objective function in a 
similar way to <code>lm</code>.
</p>
<p>start, lower and upper, if provided, can be either an atomic vector which has the same length as
the number of parameters or a single number which will be replicated to match the length of the 
parameters. If categorical variables exist in the function these will be dummified. Out of one
categorical variable, n - 1 will be created where n is the total number of categories in the 
variable. This needs to be taken into account when providing an atomic vector for start, lower or
upper. Also, as with <code>lm</code> an intercept will be added which also needs to be taken into 
account.
</p>


<h3>Value</h3>

<p>Same as nlxb
</p>


<h3>See Also</h3>

<p>nlxb
</p>


<h3>Examples</h3>

<pre><code class="language-R">#no constraints
colf_nlxb(mpg ~ cyl + disp, mtcars)

#no intercept
colf_nlxb(mpg ~ 0 + cyl + disp, mtcars)

#including categorical variables. These will be dummified.
colf_nlxb(Sepal.Length ~ Sepal.Width + Species, iris)

#lower boundary will be replicated for all parameters 
colf_nlxb(Sepal.Length ~ Sepal.Width + Species, iris, lower = 0.5)

#species is categorical and contains 3 categories, thus we need to specify 4 lower bounds:
#the first one for the intercept.
#the second one for Sepal.Width 
#the two next for the dummy variables constructed from Species. 
colf_nlxb(Sepal.Length ~ Sepal.Width + Species, iris, lower = rep(0.5, 4))

</code></pre>


</div>