<div class="container">

<table style="width: 100%;"><tr>
<td>convex_clusterpath</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Minimize the convex clustering loss function</h2>

<h3>Description</h3>

<p>Minimizes the convex clustering loss function for a given set of
values for lambda.
</p>


<h3>Usage</h3>

<pre><code class="language-R">convex_clusterpath(
  X,
  W,
  lambdas,
  tau = 0.001,
  center = TRUE,
  scale = TRUE,
  eps_conv = 1e-06,
  burnin_iter = 25,
  max_iter_conv = 5000,
  save_clusterpath = TRUE,
  target_losses = NULL,
  save_losses = FALSE,
  save_convergence_norms = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> numeric matrix. This function assumes that each
row represents an object with <code class="reqn">p</code> attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>A <code>sparseweights</code> object, see sparse_weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>A vector containing the values for the penalty parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Parameter to compute the threshold to fuse clusters. Default is
0.001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>If <code>TRUE</code>, center <code>X</code> so that each column has mean
zero. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If <code>TRUE</code>, scale the loss function to ensure that the
cluster solution is invariant to the scale of <code>X</code>. Default is
<code>TRUE</code>. Not recommended to set to <code>FALSE</code> unless comparing to
algorithms that minimize the unscaled convex clustering loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps_conv</code></td>
<td>
<p>Parameter for determining convergence of the minimization.
Default is 1e-6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin_iter</code></td>
<td>
<p>Number of updates of the loss function that are done
without step doubling. Default is 25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_conv</code></td>
<td>
<p>Maximum number of iterations for minimizing the loss
function. Default is 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_clusterpath</code></td>
<td>
<p>If <code>TRUE</code>, store the solution that minimized
the loss function for each lambda. Is required for drawing the clusterpath.
Default is <code>FALSE</code>. To store the clusterpath coordinates, <code class="reqn">n</code> x
<code class="reqn">p</code> x <code class="reqn">no. lambdas</code> have to be stored, this may require too much
memory for large data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_losses</code></td>
<td>
<p>The values of the loss function that are used to
determine convergence of the algorithm (tested as: loss - target &lt;=
<code>eps_conv</code> * target). If the input is not <code>NULL</code>, it should be a
vector with the same length as <code>lambdas</code>. Great care should be exercised
to make sure that the target losses correspond to attainable values for the
minimization. The inputs (<code>X</code>, <code>W</code>, <code>lambdas</code>) should be the
same, but also the same version of the loss function (centered, scaled)
should be used. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_losses</code></td>
<td>
<p>If <code>TRUE</code>, return the values of the loss function
attained during minimization for each value of lambda. Default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_convergence_norms</code></td>
<td>
<p>If <code>TRUE</code>, return the norm of the
difference between consecutive iterates during minimization for each value
of lambda. Default is <code>FALSE</code>. If timing the algorithm is of importance,
do not set this to <code>TRUE</code>, as additional computations are done for
bookkeeping that are irrelevant to the optimization.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>cvxclust</code> object containing the following
</p>
<table>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>A dataframe containing for each value for lambda: the
number of different clusters, and the value of the loss function at the
minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>The merge table containing the order at which the
observations in <code>X</code> are clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>The value for lambda at which each reduction in the
number of clusters occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>The order of the observations in <code>X</code> in order to
draw a dendrogram without conflicting branches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elapsed_time</code></td>
<td>
<p>The number of seconds that elapsed while
running the code. Note that this does not include the time required for
input checking and possibly scaling and centering <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordinates</code></td>
<td>
<p>The clusterpath coordinates. Only part of the
output in case that <code>save_clusterpath=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>The values for lambda for which a clustering was
found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps_fusions</code></td>
<td>
<p>The threshold for cluster fusions that was used by
the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_clusters</code></td>
<td>
<p>The different numbers of clusters that have been
found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of observations in <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>losses</code></td>
<td>
<p>Optional: if <code>save_losses = TRUE</code>, the values of
the loss function during minimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence_norms</code></td>
<td>
<p>Optional: if
<code>save_convergence_norms = TRUE</code>, the norms of the differences between
consecutive iterates during minimization.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>convex_clustering, sparse_weights
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
data(two_half_moons)
data = as.matrix(two_half_moons)
X = data[, -3]
y = data[, 3]

# Get sparse weights in dictionary of keys format with k = 5 and phi = 8
W = sparse_weights(X, 5, 8.0)

# Set a sequence for lambda
lambdas = seq(0, 2400, 1)

# Compute clusterpath
res = convex_clusterpath(X, W, lambdas)

# Get cluster labels for two clusters
labels = clusters(res, 2)

# Plot the clusterpath with colors based on the cluster labels
plot(res, col = labels)

</code></pre>


</div>