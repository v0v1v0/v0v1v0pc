<div class="container">

<table style="width: 100%;"><tr>
<td>gdina</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimating the Generalized DINA (GDINA) Model
</h2>

<h3>Description</h3>

<p>This function implements the generalized DINA model for dichotomous
attributes (GDINA; de la Torre, 2011) and polytomous attributes
(pGDINA; Chen &amp; de la Torre, 2013, 2018).
In addition, multiple group estimation
is also possible using the <code>gdina</code> function. This function also
allows for the estimation of a higher order GDINA model
(de la Torre &amp; Douglas, 2004).
Polytomous item responses are treated by specifying a sequential
GDINA model (Ma &amp; de la Torre, 2016; Tutz, 1997).
The simulataneous modeling of skills and misconceptions (bugs) can be
also estimated within the GDINA framework (see Kuo, Chen &amp; de la Torre, 2018;
see argument <code>rule</code>).
</p>
<p>The estimation can also be conducted by posing monotonocity
constraints (Hong, Chang, &amp; Tsai, 2016) using the argument <code>mono.constr</code>.
Moreover, regularization methods SCAD, lasso, ridge, SCAD-L2 and
truncated <code class="reqn">L_1</code> penalty (TLP) for item parameters
can be employed (Xu &amp; Shang, 2018).
</p>
<p>Normally distributed priors can be specified for item parameters
(item intercepts and item slopes). Note that (for convenience) the
prior specification holds simultaneously for all items.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gdina(data, q.matrix, skillclasses=NULL, conv.crit=0.0001, dev.crit=.1,  maxit=1000,
    linkfct="identity", Mj=NULL, group=NULL, invariance=TRUE,method=NULL,
    delta.init=NULL, delta.fixed=NULL, delta.designmatrix=NULL,
    delta.basispar.lower=NULL, delta.basispar.upper=NULL, delta.basispar.init=NULL,
    zeroprob.skillclasses=NULL, attr.prob.init=NULL, attr.prob.fixed=NULL,
    reduced.skillspace=NULL, reduced.skillspace.method=2, HOGDINA=-1, Z.skillspace=NULL,
    weights=rep(1, nrow(data)), rule="GDINA", bugs=NULL, regular_lam=0,
    regular_type="none", regular_alpha=NA, regular_tau=NA, regular_weights=NULL,
    mono.constr=FALSE, prior_intercepts=NULL, prior_slopes=NULL, progress=TRUE,
    progress.item=FALSE, mstep_iter=10, mstep_conv=1E-4, increment.factor=1.01,
    fac.oldxsi=0, max.increment=.3, avoid.zeroprobs=FALSE, seed=0,
    save.devmin=TRUE, calc.se=TRUE, se_version=1, PEM=TRUE, PEM_itermax=maxit,
    cd=FALSE, cd_steps=1, mono_maxiter=10, freq_weights=FALSE, optimizer="CDM", ...)

## S3 method for class 'gdina'
summary(object, digits=4, file=NULL,  ...)

## S3 method for class 'gdina'
plot(x, ask=FALSE,  ...)

## S3 method for class 'gdina'
print(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A required <code class="reqn">N \times J</code> data matrix
containing integer responses, 0, 1, ..., K. Polytomous
item responses are treated by the sequential GDINA model.
<code>NA</code> values are allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.matrix</code></td>
<td>
<p>A required integer <code class="reqn">J \times K</code> matrix containing
attributes not required or required, 0 or 1, to master the items in case
of dichotomous attributes or integers in case of polytomous attributes.
For polytomous item responses the Q-matrix must also include the
item name and item category, see Example 11.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skillclasses</code></td>
<td>
<p>An optional matrix for determining the skill space.
The argument can be used if a user wants less than <code class="reqn">2^K</code> skill classes.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>conv.crit</code></td>
<td>

<p>Convergence criterion for maximum absolute change in item parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.crit</code></td>
<td>

<p>Convergence criterion for maximum absolute change in deviance
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linkfct</code></td>
<td>

<p>A string which indicates the link function for the GDINA model.
Options are <code>"identity"</code> (identity link),
<code>"logit"</code> (logit link) and <code>"log"</code> (log link). The default is the
<code>"identity"</code> link. Note that the link function is chosen
for the whole model (i.e. for all items).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mj</code></td>
<td>

<p>A list of design matrices and labels for each item.
The definition of <code>Mj</code> follows the
definition of <code class="reqn">M_j</code> in de la Torre (2011).
Please study the value <code>Mj</code> of the function in
default analysis. See Example 3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A vector of group identifiers for multiple group
estimation. Default is <code>NULL</code> (no multiple group estimation).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invariance</code></td>
<td>
<p>Logical indicating whether invariance of item parameters
is assumed for multiple group models. If a subset of items should
be treated as noninvariant, then <code>invariance</code> can be a vector
of item names.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Estimation method for item parameters (see)
(de la Torre, 2011). The default <code>"WLS"</code>
weights probabilities attribute classes by a weighting
matrix <code class="reqn">W_j</code> of expected frequencies,
whereas the method <code>"ULS"</code> perform unweighted least squares
estimation on expected frequencies.
The method <code>"ML"</code> directly maximizes the log-likelihood
function.  The <code>"ML"</code> method is a bit slower but can be
much more stable, especially in the case of the RRUM model.
Only for the RRUM model, the default is changed to
<code>method="ML"</code> if not specified otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.init</code></td>
<td>
<p>List with initial <code class="reqn">\delta</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.fixed</code></td>
<td>
<p>List with fixed <code class="reqn">\delta</code> parameters.
For free estimated parameters <code>NA</code> must be declared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.designmatrix</code></td>
<td>

<p>A design matrix for restrictions on delta. See Example 4.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.basispar.lower</code></td>
<td>

<p>Lower bounds for delta basis parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.basispar.upper</code></td>
<td>

<p>Upper bounds for delta basis parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.basispar.init</code></td>
<td>

<p>An optional vector of starting values for the basis parameters of delta.
This argument only applies when using a designmatrix for delta,
i.e. <code>delta.designmatrix</code> is not <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroprob.skillclasses</code></td>
<td>
<p>An optional vector of integers which indicates which skill
classes should have zero probability. Default is NULL
(no skill classes with zero probability).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr.prob.init</code></td>
<td>
<p>Initial probabilities of skill distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr.prob.fixed</code></td>
<td>
<p>Vector or matrix with fixed probabilities of skill distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduced.skillspace</code></td>
<td>
<p>A logical which indicates if the latent class skill space dimension
should be reduced (see Xu &amp; von Davier, 2008). The default is <code>NULL</code>
which applies skill space reduction for more than four skills.
The dimensional reduction is only well defined for more than three skills.
If the argument <code>zeroprob.skillclasses</code> is not <code>NULL</code>, then
<code>reduced.skillspace</code> is set to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduced.skillspace.method</code></td>
<td>
<p>Computation method for skill space reduction
in case of <code>reduced.skillspace=TRUE</code>. The default is <code>2</code>
which is computationally more efficient but introduced in <span class="pkg">CDM</span> 2.6.
For reasons of compatibility of former <span class="pkg">CDM</span> versions (<code class="reqn">\le</code> 2.5),
<code>reduced.skillspace.method=1</code> uses the older implemented
method. In case of non-convergence with the new method, please try
the older method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HOGDINA</code></td>
<td>
<p>Values of -1, 0 or 1 indicating if a higher order GDINA
model (see Details) should be estimated.
The default value of -1 corresponds to the case that no higher order
factor is assumed to exist. A value of 0 corresponds to independent
attributes. A value of 1 assumes the existence of a higher order
factor. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.skillspace</code></td>
<td>
<p>A user specified design matrix for the skill space reduction
as described in Xu and von Davier (2008). See in the Examples section for
applications. See Example 6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>An optional vector of sample weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>

<p>A string or a vector of itemwise condensation rules. Allowed entries are
<code>GDINA</code>, <code>DINA</code>, <code>DINO</code>, <code>ACDM</code> (additive
cognitive diagnostic model) and <code>RRUM</code> (reduced reparametrized
unified model, RRUM, see Details).
The rule <code>GDINA1</code> applies
only main effects in the GDINA model which is equivalent to <code>ACDM</code>.
The rule <code>GDINA2</code> applies to all main effects and second-order
interactions of the attributes. If some item is specified as <code>RRUM</code>,
then for all the items the reduced RUM will be estimated which means
that the log link function and the <code>ACDM</code> condensation rule is used.
In the output, the entry <code>rrum.params</code> contains the parameters
transformed in the RUM parametrization.
If <code>rule</code> is a string, the condensation rule applies to all items.
If <code>rule</code> is a vector, condensation rules can be specified itemwise.
The default is <code>GDINA</code> for all items.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bugs</code></td>
<td>
<p>Character vector indicating which columns in the Q-matrix
refer to bugs (misconceptions). This is only available if some <code>rule</code>
is set to <code>"SISM"</code>. Note that bugs must be included as last columns
in the Q-matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_lam</code></td>
<td>
<p>Regularization parameter <code class="reqn">\lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_type</code></td>
<td>
<p>Type of regularization. Can be <code>scad</code> (SCAD penalty),
<code>lasso</code> (lasso penalty), <code>ridge</code> (ridge penalty),
<code>elnet</code> (elastic net), <code>scadL2</code> (SCAD-<code class="reqn">L_2</code>;
Zeng &amp; Xie, 2014), <code>tlp</code> (truncated <code class="reqn">L_1</code> penalty; Xu &amp; Shang, 2018;
Shen, Pan, &amp; Zhu, 2012), <code>mcp</code> (MCP penalty; Zhang, 2010)
or <code>none</code> (no regularization).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_alpha</code></td>
<td>
<p>Regularization parameter <code class="reqn">\alpha</code>
(applicable for elastic net or SCAD-L2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_tau</code></td>
<td>
<p>Regularization parameter <code class="reqn">\tau</code> for truncated
<code class="reqn">L_1</code> penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_weights</code></td>
<td>
<p>Optional list of item parameter weights used for
penalties in regularized estimation (see Example 13)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mono.constr</code></td>
<td>
<p>Logical indicating whether monotonicity constraints
should be fulfilled in estimation (implemented by the increasing penalty method; see
Nash, 2014, p. 156).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_intercepts</code></td>
<td>
<p>Vector with mean and standard deviation for prior
of random intercepts (applies to all items)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_slopes</code></td>
<td>
<p>Vector with mean and standard deviation for prior
of random slopes (applies to all items and all parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>An optional logical indicating whether the function
should print the progress of iteration in the estimation process.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress.item</code></td>
<td>

<p>An optional logical indicating whether item wise progress should
be displayed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstep_iter</code></td>
<td>
<p>Number of iterations in M-step if <code>method="ML"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstep_conv</code></td>
<td>
<p>Convergence criterion in M-step if <code>method="ML"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>increment.factor</code></td>
<td>
<p>A factor larger than 1 (say 1.1) to control
maximum increments in item parameters. This parameter
can be used in case of nonconvergence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac.oldxsi</code></td>
<td>
<p>A convergence acceleration factor between 0 and 1 which
defines the weight of previously estimated values in
current parameter updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.increment</code></td>
<td>
<p>Maximum size of change in increments in M steps
of EM algorithm when <code>method="ML"</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avoid.zeroprobs</code></td>
<td>
<p>An optional logical indicating whether for estimating
item parameters probabilities occur. Especially if
not a skill classes are used, it is recommended to switch
the argument to <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Simulation seed for initial parameters. A value of zero corresponds
to deterministic starting values, an integer value different from
zero to random initial values with <code>set.seed(seed)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.devmin</code></td>
<td>
<p>An optional logical indicating whether intermediate
estimates should be saved corresponding to minimal deviance.
Setting the argument to <code>FALSE</code> could help for preventing
working memory overflow.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc.se</code></td>
<td>
<p>Optional logical indicating whether standard
errors should be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se_version</code></td>
<td>
<p>Integer for calculation method of standard errors.
<code>se_version=1</code> is based on the observed log likelihood and included
since <span class="pkg">CDM</span> 5.1 and is the default. Comparability with
previous <span class="pkg">CDM</span> versions can be obtained with <code>se_version=0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PEM</code></td>
<td>
<p>Logical indicating whether the P-EM acceleration should be
applied (Berlinet &amp; Roland, 2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PEM_itermax</code></td>
<td>
<p>Number of iterations in which the P-EM method should be
applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd</code></td>
<td>
<p>Logical indicating whether coordinate descent algorithm should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd_steps</code></td>
<td>
<p>Number of steps for each parameter in coordinate descent algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mono_maxiter</code></td>
<td>
<p>Maximum number of iterations for fulfilling the
monotonicity constraint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq_weights</code></td>
<td>
<p>Logical indicating whether frequency weights should
be used. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>String indicating which optimizer should be used in
M-step estimation in case of <code>method="ML"</code>.
The internal optimizer of <span class="pkg">CDM</span> can be requested by
<code>optimizer="CDM"</code>. The optimization with <code>stats::optim</code>
can be requested by <code>optimizer="optim"</code>.
For the RRUM model, it is always chosen
<code>optimizer="optim"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A required object of class <code>gdina</code>, obtained
from a call to the function <code>gdina</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits after decimal separator to display.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A required object of class <code>gdina</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>A logical indicating whether every separate item should
be displayed in <code>plot.gdina</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The estimation is based on an EM algorithm as described in de la Torre (2011).
Item parameters are contained in the <code>delta</code> vector which is a list where
the <code class="reqn">j</code>th entry corresponds to item parameters of the <code class="reqn">j</code>th item.
</p>
<p>The following description refers to the case of dichotomous attributes.
For using polytomous attributes see Chen and de la Torre (2013) and
Example 7 for a definition of the Q-matrix. In this case, <code class="reqn">Q_{ik}=l</code>
means that the <code class="reqn">i</code>th item requires the mastery (at least) of level
<code class="reqn">l</code> of attribute <code class="reqn">k</code>.
</p>
<p>Assume that two skills <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> are required for
mastering item <code class="reqn">j</code>. Then the GDINA model can be written as
</p>
<p style="text-align: center;"><code class="reqn"> g [ P( X_{nj}=1 | \alpha_n ) ]=\delta_{j0} + \delta_{j1} \alpha_{n1} +
            \delta_{j2} \alpha_{n2} + \delta_{j12} \alpha_{n1} \alpha_{n2}
        </code>
</p>

<p>which is a two-way GDINA-model (the <code>rule="GDINA2"</code> specification) with a
link function <code class="reqn">g</code> (which can be the identity, logit or logarithmic link).
If the specification
<code>ACDM</code> is chosen, then <code class="reqn">\delta_{j12}=0</code>.
The DINA model (<code>rule="DINA"</code>) assumes <code class="reqn"> \delta_{j1}=\delta_{j2}=0</code>.
</p>
<p>For the reduced RUM model (<code>rule="RRUM"</code>), the item response model is
</p>
<p style="text-align: center;"><code class="reqn">P(X_{nj}=1 | \alpha_n )=\pi_i^\ast \cdot r_{i1}^{1-\alpha_{i1} }
    \cdot r_{i2}^{1-\alpha_{i2} } </code>
</p>
<p> From this equation, it is obvious, that
this model is equivalent to an additive model (<code>rule="ACDM"</code>) with
a logarithmic link function (<code>linkfct="log"</code>).
</p>
<p>If a reduced skillspace (<code>reduced.skillspace=TRUE</code>) is employed, then the
logarithm of probability distribution of the attributes is modeled as a
log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log P[ ( \alpha_{n1}, \alpha_{n2}, \ldots, \alpha_{nK} ) ]
    =\gamma_0 + \sum_k \gamma_k \alpha_{nk} +
      \sum_{k &lt; l} \gamma_{kl} \alpha_{nk} \alpha_{nl} </code>
</p>

<p>If a higher order DINA model is assumed (<code>HOGDINA=1</code>), then a higher order
factor <code class="reqn">\theta_n</code> for the attributes is assumed:
</p>
<p style="text-align: center;"><code class="reqn">P( \alpha_{nk}=1 | \theta_n )=\Phi ( a_k \theta_n + b_k ) </code>
</p>

<p>For <code>HOGDINA=0</code>, all attributes <code class="reqn">\alpha_{nk}</code> are assumed to be
independent of each other:
</p>
<p style="text-align: center;"><code class="reqn"> P[ ( \alpha_{n1}, \alpha_{n2}, \ldots, \alpha_{nK} ) ]
    =\prod_k P( \alpha_{nk} ) </code>
</p>

<p>Note that the noncompensatory reduced RUM (NC-RRUM) according
to Rupp and Templin (2008) is the GDINA model with the arguments
<code>rule="ACDM"</code> and <code>linkfct="log"</code>. NC-RRUM can also be
obtained by choosing <code>rule="RRUM"</code>.
</p>
<p>The compensatory RUM (C-RRUM) can be obtained by using the arguments
<code>rule="ACDM"</code> and <code>linkfct="logit"</code>.
</p>
<p>The cognitive diagnosis model for identifying
skills and misconceptions (SISM; Kuo, Chen &amp; de la Torre, 2018) can be
estimated with <code>rule="SISM"</code> (see Example 12).
</p>
<p>The <code>gdina</code> function internally parameterizes the GDINA model as
</p>
<p style="text-align: center;"><code class="reqn"> g [ P( X_{nj}=1 | \alpha_n ) ]=\bm{M}_j ( \alpha _n )
    \bm{\delta}_j
        </code>
</p>

<p>with item-specific design matrices <code class="reqn">\bm{M}_j (\alpha _n ) </code> and item parameters
<code class="reqn">\bm{\delta}_j</code>. Only those attributes are modelled which correspond
to non-zero entries in the Q-matrix. Because the Q-matrix (in <code>q.matrix</code>)
and the design matrices (in <code>M_j</code>; see Example 3) can be
specified by the user, several
cognitive diagnosis models can be estimated. Therefore, some additional extensions
of the DINA model can also be estimated using the <code>gdina</code> function.
These models include the DINA model with multiple strategies
(Huo &amp; de la Torre, 2014)
</p>


<h3>Value</h3>

<p>An object of class <code>gdina</code> with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>Data frame of item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>List with basis item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.delta</code></td>
<td>
<p>Standard errors of basis item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probitem</code></td>
<td>
<p>Data frame with model implied conditional item probabilities
<code class="reqn">P(X_i=1 | \bm{\alpha})</code>. These probabilities are displayed
in <code>plot.gdina</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemfit.rmsea</code></td>
<td>
<p>The RMSEA item fit index (see <code>itemfit.rmsea</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.rmsea</code></td>
<td>
<p>Mean of RMSEA item fit indexes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike</code></td>
<td>
<p>Log-likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Number of groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Sample size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AIC</code></td>
<td>
<p>AIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC</code></td>
<td>
<p>BIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CAIC</code></td>
<td>
<p>CAIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Npars</code></td>
<td>
<p>Total number of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nipar</code></td>
<td>
<p>Number of item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nskillpar</code></td>
<td>
<p>Number of parameters for skill class distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nskillclasses</code></td>
<td>
<p>Number of skill classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varmat.delta</code></td>
<td>
<p>Covariance matrix of <code class="reqn">\delta</code> item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posterior</code></td>
<td>
<p>Individual posterior distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>like</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Original data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.matrix</code></td>
<td>
<p>Used Q-matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>Individual patterns, individual MLE and MAP classifications
and their corresponding probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attribute.patt</code></td>
<td>
<p>Probabilities of skill classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skill.patt</code></td>
<td>
<p>Marginal skill probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subj.pattern</code></td>
<td>
<p>Individual subject pattern</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attribute.patt.splitted</code></td>
<td>
<p>Splitted attribute pattern</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pjk</code></td>
<td>
<p>Array of item response probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mj</code></td>
<td>
<p>Design matrix <code class="reqn">M_j</code> in GDINA algorithm (see de la Torre, 2011)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Aj</code></td>
<td>
<p>Design matrix <code class="reqn">A_j</code> in GDINA algorithm (see de la Torre, 2011)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>Used condensation rules</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linkfct</code></td>
<td>
<p>Used link function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.designmatrix</code></td>
<td>
<p>Designmatrix for item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduced.skillspace</code></td>
<td>
<p>A logical if skillspace reduction was performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.skillspace</code></td>
<td>
<p>Design matrix for skillspace reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Parameters <code class="reqn">\delta</code> for skill class representation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covbeta</code></td>
<td>
<p>Standard errors of <code class="reqn">\delta</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rrum.params</code></td>
<td>
<p>Parameters in the parametrization of the reduced RUM model
if <code>rule="RRUM"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.stat</code></td>
<td>
<p>Group statistics (sample sizes, group labels)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HOGDINA</code></td>
<td>
<p>The used value of <code>HOGDINA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mono.constr</code></td>
<td>
<p>Monotonicity constraint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regularization</code></td>
<td>
<p>Logical indicating whether regularization is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_lam</code></td>
<td>
<p>Regularization parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numb_bound_mono</code></td>
<td>
<p>Number of items with parameters at boundary of
monotonicity constraints</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numb_regular_pars</code></td>
<td>
<p>Number of regularized item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta_regularized</code></td>
<td>
<p>List indicating which item parameters
are regularized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd_algorithm</code></td>
<td>
<p>Logical indicating whether coordinate descent algorithm is
used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd_steps</code></td>
<td>
<p>Number of steps for each parameter in coordinate descent algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Used simulation seed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.attr</code></td>
<td>
<p>Attribute parameters <code class="reqn">a_k</code> in case of <code>HOGDINA&gt;=0</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.attr</code></td>
<td>
<p>Attribute parameters <code class="reqn">b_k</code> in case of <code>HOGDINA&gt;=0</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr.rf</code></td>
<td>
<p>Attribute response functions. This matrix contains all
<code class="reqn">a_k</code> and <code class="reqn">b_k</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>Logical indicating whether convergence was achieved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>Optimization parameters used in estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable</code></td>
<td>
<p>Parameter table for <code>gdina</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polychor</code></td>
<td>
<p>Group-wise matrices with polychoric correlations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequential</code></td>
<td>
<p>Logical indicating whether a sequential GDINA model
is applied for polytomous item responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further values</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The function <code>din</code> does not allow for multiple group estimation.
Use this <code>gdina</code> function instead and choose the appropriate <code>rule="DINA"</code>
as an argument.
</p>
<p>Standard error calculation in analyses which use sample weights or
designmatrix for delta parameters (<code>delta.designmatrix!=NULL</code>) is not yet
correctly implemented. Please use replication methods instead.
</p>


<h3>References</h3>

<p>Berlinet, A. F., &amp; Roland, C. (2012).
Acceleration of the EM algorithm: P-EM versus epsilon algorithm.
<em>Computational Statistics &amp; Data Analysis, 56</em>(12), 4122-4137.
</p>
<p>Chen, J., &amp; de la Torre, J. (2013).
A general cognitive diagnosis model for expert-defined polytomous attributes.
<em>Applied Psychological Measurement, 37</em>, 419-437.
</p>
<p>Chen, J., &amp; de la Torre, J. (2018). Introducing the general polytomous diagnosis
modeling framework.
<em>Frontiers in Psychology | Quantitative Psychology and Measurement, 9</em>(1474).
</p>
<p>de la Torre, J., &amp; Douglas, J. A. (2004). Higher-order latent trait models
for cognitive diagnosis. <em>Psychometrika, 69</em>, 333-353.
</p>
<p>de la Torre, J. (2011). The generalized DINA model framework.
<em>Psychometrika, 76</em>, 179-199.
</p>
<p>Hong, C. Y., Chang, Y. W., &amp; Tsai, R. C. (2016). Estimation of generalized DINA
model with order restrictions. <em>Journal of Classification, 33</em>(3), 460-484.
</p>
<p>Huo, Y., de la Torre, J. (2014). Estimating a cognitive diagnostic model for
multiple strategies via the EM algorithm.
<em>Applied Psychological Measurement, 38</em>, 464-485.
</p>
<p>Kuo, B.-C., Chen, C.-H., &amp; de la Torre, J. (2018).
A cognitive diagnosis model for identifying coexisting skills and misconceptions.
<em>Applied Psychological Measurement, 42</em>(3), 179-191.
</p>
<p>Ma, W., &amp; de la Torre, J. (2016).
A sequential cognitive diagnosis model for polytomous responses.
<em>British Journal of Mathematical and Statistical Psychology, 69</em>(3),
253-275.
</p>
<p>Nash, J. C. (2014). <em>Nonlinear parameter optimization using <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> tools</em>.
West Sussex: Wiley.
</p>
<p>Rupp, A. A., &amp; Templin, J. (2008). Unique characteristics of
diagnostic classification models: A comprehensive review of the current
state-of-the-art. <em>Measurement: Interdisciplinary Research and
Perspectives, 6</em>, 219-262.
</p>
<p>Shen, X., Pan, W., &amp; Zhu, Y. (2012). Likelihood-based selection and sharp
parameter estimation.
<em>Journal of the American Statistical Association, 107</em>, 223-232.
</p>
<p>Tutz, G. (1997). Sequential models for ordered responses.
In W. van der Linden &amp; R. K. Hambleton.
<em>Handbook of modern item response theory</em> (pp. 139-152).
New York: Springer.
</p>
<p>Xu, G., &amp; Shang, Z. (2018). Identifying latent structures in
restricted latent class models.
<em>Journal of the American Statistical Association, 523</em>, 1284-1295.
</p>
<p>Xu, X., &amp; von Davier, M. (2008). <em>Fitting the structured general diagnostic
model to NAEP data</em>. ETS Research Report ETS RR-08-27. Princeton, ETS.
</p>
<p>Zeng, L., &amp; Xie, J. (2014). Group variable selection via
SCAD-<code class="reqn">L_2</code>. <em>Statistics, 48</em>, 49-66.
</p>
<p>Zhang, C.-H. (2010). Nearly unbiased variable selection under minimax concave
penalty. <em>Annals of Statistics, 38</em>, 894-942.
</p>


<h3>See Also</h3>

<p>See also the <code>din</code> function (for DINA and DINO estimation).
</p>
<p>For assessment of model fit see <code>modelfit.cor.din</code> and
<code>anova.gdina</code>.
</p>
<p>See <code>itemfit.sx2</code> for item fit statistics.
</p>
<p>See <code>sim.gdina</code> for simulating the GDINA model.
</p>
<p>See <code>gdina.wald</code> for a Wald test for testing the DINA and ACDM
rules at the item-level.
</p>
<p>See <code>gdina.dif</code> for assessing differential item
functioning.
</p>
<p>See <code>discrim.index</code> for computing discrimination indices.
</p>
<p>See the <code>GDINA::GDINA</code> function in the
<span class="pkg">GDINA</span> package for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Simulated DINA data | different condensation rules
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dina
Q &lt;- sim.qmatrix

#***
# Model 1: estimation of the GDINA model (identity link)
mod1 &lt;- CDM::gdina( data=dat,  q.matrix=Q)
summary(mod1)
plot(mod1) # apply plot function

## Not run: 
# Model 1a: estimate model with different simulation seed
mod1a &lt;- CDM::gdina( data=dat,  q.matrix=Q, seed=9089)
summary(mod1a)

# Model 1b: estimate model with some fixed delta parameters
delta.fixed &lt;- as.list( rep(NA,9) )        # List for parameters of 9 items
delta.fixed[[2]] &lt;- c( 0, .15, .15, .45 )
delta.fixed[[6]] &lt;- c( .25, .25 )
mod1b &lt;- CDM::gdina( data=dat,  q.matrix=Q, delta.fixed=delta.fixed)
summary(mod1b)

# Model 1c: fix all delta parameters to previously fitted model
mod1c &lt;- CDM::gdina( data=dat,  q.matrix=Q, delta.fixed=mod1$delta)
summary(mod1c)

# Model 1d: estimate GDINA model with GDINA package
mod1d &lt;- GDINA::GDINA( dat=dat, Q=Q, model="GDINA" )
summary(mod1d)
# extract item parameters
GDINA::itemparm(mod1d)
GDINA::itemparm(mod1d, what="delta")
# compare likelihood
logLik(mod1)
logLik(mod1d)

#***
# Model 2: estimation of the DINA model with gdina function
mod2 &lt;- CDM::gdina( data=dat,  q.matrix=Q, rule="DINA")
summary(mod2)
plot(mod2)

#***
# Model 2b: compare results with din function
mod2b &lt;- CDM::din( data=dat,  q.matrix=Q, rule="DINA")
summary(mod2b)

# Model 2: estimation of the DINO model with gdina function
mod3 &lt;- CDM::gdina( data=dat,  q.matrix=Q, rule="DINO")
summary(mod3)

#***
# Model 4: DINA model with logit link
mod4 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="DINA", linkfct="logit" )
summary(mod4)

#***
# Model 5: DINA model log link
mod5 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="DINA", linkfct="log")
summary(mod5)

#***
# Model 6: RRUM model
mod6 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="RRUM")
summary(mod6)

#***
# Model 7: Higher order GDINA model
mod7 &lt;- CDM::gdina( data=dat, q.matrix=Q, HOGDINA=1)
summary(mod7)

#***
# Model 8: GDINA model with independent attributes
mod8 &lt;- CDM::gdina( data=dat, q.matrix=Q, HOGDINA=0)
summary(mod8)

#***
# Model 9: Estimating the GDINA model with monotonicity constraints
mod9 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="GDINA",
              mono.constr=TRUE, linkfct="logit")
summary(mod9)

#***
# Model 10: Estimating the ACDM model with SCAD penalty and regularization
#           parameter of .05
mod10 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="ACDM",
                linkfct="logit", regular_type="scad", regular_lam=.05 )
summary(mod10)

#***
# Model 11: Estimation of GDINA model with prior distributions

# N(0,10^2) prior for item intercepts
prior_intercepts &lt;- c(0,10)
# N(0,1^2) prior for item slopes
prior_slopes &lt;- c(0,1)
# estimate model
mod11 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="GDINA",
              prior_intercepts=prior_intercepts, prior_slopes=prior_slopes)
summary(mod11)

#############################################################################
# EXAMPLE 2: Simulated DINO data
#    additive cognitive diagnosis model with different link functions
#############################################################################

data(sim.dino, package="CDM")
data(sim.matrix, package="CDM")

dat &lt;- sim.dino
Q &lt;- sim.qmatrix

#***
# Model 1: additive cognitive diagnosis model (ACDM; identity link)
mod1 &lt;- CDM::gdina( data=dat, q.matrix=Q,  rule="ACDM")
summary(mod1)

#***
# Model 2: ACDM logit link
mod2 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="ACDM", linkfct="logit")
summary(mod2)

#***
# Model 3: ACDM log link
mod3 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="ACDM", linkfct="log")
summary(mod3)

#***
# Model 4: Different condensation rules per item
I &lt;- 9      # number of items
rule &lt;- rep( "GDINA", I )
rule[1] &lt;- "DINO"   # 1st item: DINO model
rule[7] &lt;- "GDINA2" # 7th item: GDINA model with first- and second-order interactions
rule[8] &lt;- "ACDM"   # 8ht item: additive CDM
rule[9] &lt;- "DINA"   # 9th item: DINA model
mod4 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule=rule )
summary(mod4)

#############################################################################
# EXAMPLE 3: Model with user-specified design matrices
#############################################################################

data(sim.dino, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dino
Q &lt;- sim.qmatrix

# do a preliminary analysis and modify obtained design matrices
mod0 &lt;- CDM::gdina( data=dat,  q.matrix=Q,  maxit=1)

# extract default design matrices
Mj &lt;- mod0$Mj
Mj.user &lt;- Mj   # these user defined design matrices are modified.
#~~~  For the second item, the following model should hold
#     X1 ~ V2 + V2*V3
mj &lt;- Mj[[2]][[1]]
mj.lab &lt;- Mj[[2]][[2]]
mj &lt;- mj[,-3]
mj.lab &lt;- mj.lab[-3]
Mj.user[[2]] &lt;- list( mj, mj.lab )
#    [[1]]
#        [,1] [,2] [,3]
#    [1,]    1    0    0
#    [2,]    1    1    0
#    [3,]    1    0    0
#    [4,]    1    1    1
#    [[2]]
#    [1] "0"   "1"   "1-2"
#~~~  For the eight item an equality constraint should hold
#     X8 ~ a*V2 + a*V3 + V2*V3
mj &lt;- Mj[[8]][[1]]
mj.lab &lt;- Mj[[8]][[2]]
mj[,2] &lt;- mj[,2] + mj[,3]
mj &lt;- mj[,-3]
mj.lab &lt;- c("0", "1=2", "1-2" )
Mj.user[[8]] &lt;- list( mj, mj.lab )
Mj.user[[8]]
  ##   [[1]]
  ##        [,1] [,2] [,3]
  ##   [1,]    1    0    0
  ##   [2,]    1    1    0
  ##   [3,]    1    1    0
  ##   [4,]    1    2    1
  ##
  ##   [[2]]
  ##   [1] "0"   "1=2" "1-2"
mod &lt;- CDM::gdina( data=dat,  q.matrix=Q,
                    Mj=Mj.user,  maxit=200 )
summary(mod)

#############################################################################
# EXAMPLE 4: Design matrix for delta parameters
#############################################################################

data(sim.dino, package="CDM")
data(sim.qmatrix, package="CDM")

#~~~ estimate an initial model
mod0 &lt;- CDM::gdina( data=dat,  q.matrix=Q, rule="ACDM", maxit=1)
# extract coefficients
c0 &lt;- mod0$coef
I &lt;- 9  # number of items
delta.designmatrix &lt;- matrix( 0, nrow=nrow(c0), ncol=nrow(c0) )
diag( delta.designmatrix) &lt;- 1
# set intercept of item 1 and item 3 equal to each other
delta.designmatrix[ 7, 1 ] &lt;- 1 ; delta.designmatrix[,7] &lt;- 0
# set loading of V1 of item1 and item 3 equal
delta.designmatrix[ 8, 2 ] &lt;- 1 ; delta.designmatrix[,8] &lt;- 0
delta.designmatrix &lt;- delta.designmatrix[, -c(7:8) ]
                # exclude original parameters with indices 7 and 8

#***
# Model 1: ACDM with designmatrix
mod1 &lt;- CDM::gdina( data=dat,  q.matrix=Q,  rule="ACDM",
            delta.designmatrix=delta.designmatrix )
summary(mod1)

#***
# Model 2: Same model, but with logit link instead of identity link function
mod2 &lt;- CDM::gdina( data=dat,  q.matrix=Q,  rule="ACDM",
            delta.designmatrix=delta.designmatrix, linkfct="logit")
summary(mod2)

#############################################################################
# EXAMPLE 5: Multiple group estimation
#############################################################################

# simulate data
set.seed(9279)
N1 &lt;- 200 ; N2 &lt;- 100   # group sizes
I &lt;- 10                 # number of items
q.matrix &lt;- matrix(0,I,2)   # create Q-matrix
q.matrix[1:7,1] &lt;- 1 ; q.matrix[ 5:10,2] &lt;- 1
# simulate first group
dat1 &lt;- CDM::sim.din(N1, q.matrix=q.matrix, mean=c(0,0) )$dat
# simulate second group
dat2 &lt;- CDM::sim.din(N2, q.matrix=q.matrix, mean=c(-.3, -.7) )$dat
# merge data
dat &lt;- rbind( dat1, dat2 )
# group indicator
group &lt;- c( rep(1,N1), rep(2,N2) )

# estimate GDINA model with multiple groups assuming invariant item parameters
mod1 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group)
summary(mod1)

# estimate DINA model with multiple groups assuming invariant item parameters
mod2 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix, group=group, rule="DINA")
summary(mod2)

# estimate GDINA model with noninvariant item parameters
mod3 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group, invariance=FALSE)
summary(mod3)

# estimate GDINA model with some invariant item parameters (I001, I006, I008)
mod4 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group,
            invariance=c("I001", "I006","I008") )

#--- model comparison
IRT.compareModels(mod1,mod2,mod3,mod4)

# estimate GDINA model with non-invariant item parameters except for the
# items I001, I006, I008
mod5 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group,
            invariance=setdiff( colnames(dat), c("I001", "I006","I008") ) )

#############################################################################
# EXAMPLE 6: User specified reduced skill space
#############################################################################

#   Some correlations between attributes should be set to zero.
q.matrix &lt;- expand.grid( c(0,1), c(0,1), c(0,1), c(0,1) )
colnames(q.matrix) &lt;- colnames( paste("Attr", 1:4,sep=""))
q.matrix &lt;- q.matrix[ -1, ]
Sigma &lt;- matrix( .5, nrow=4, ncol=4 )
diag(Sigma) &lt;- 1
Sigma[3,2] &lt;- Sigma[2,3] &lt;- 0 # set correlation of attribute A2 and A3 to zero
dat &lt;- CDM::sim.din( N=1000, q.matrix=q.matrix, Sigma=Sigma)$dat

#~~~ Step 1: initial estimation
mod1a &lt;- CDM::gdina( data=dat, q.matrix=q.matrix, maxit=1, rule="DINA")
# estimate also "full" model
mod1 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix, rule="DINA")

#~~~ Step 2: modify designmatrix for reduced skillspace
Z.skillspace &lt;- data.frame( mod1a$Z.skillspace )
# set correlations of A2/A4 and A3/A4 to zero
vars &lt;- c("A2_A3","A2_A4")
for (vv in vars){ Z.skillspace[,vv] &lt;- NULL }

#~~~ Step 3: estimate model with reduced skillspace
mod2 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,
              Z.skillspace=Z.skillspace, rule="DINA")

#~~~ eliminate all covariances
Z.skillspace &lt;- data.frame( mod1$Z.skillspace )
colnames(Z.skillspace)
Z.skillspace &lt;- Z.skillspace[, -grep( "_", colnames(Z.skillspace),fixed=TRUE)]
colnames(Z.skillspace)

mod3 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,
               Z.skillspace=Z.skillspace, rule="DINA")
summary(mod1)
summary(mod2)
summary(mod3)

#############################################################################
# EXAMPLE 7: Polytomous GDINA model (Chen &amp; de la Torre, 2013)
#############################################################################

data(data.pgdina, package="CDM")

dat &lt;- data.pgdina$dat
q.matrix &lt;- data.pgdina$q.matrix

# pGDINA model with "DINA rule"
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA")
summary(mod1)
# no reduced skill space
mod1a &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA",reduced.skillspace=FALSE)
summary(mod1)

# pGDINA model with "GDINA rule"
mod2 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="GDINA")
summary(mod2)

#############################################################################
# EXAMPLE 8: Fraction subtraction data: DINA and HO-DINA model
#############################################################################

data(fraction.subtraction.data, package="CDM")
data(fraction.subtraction.qmatrix, package="CDM")

dat &lt;- fraction.subtraction.data
Q &lt;- fraction.subtraction.qmatrix

# Model 1: DINA model
mod1 &lt;- CDM::gdina( dat, q.matrix=Q, rule="DINA")
summary(mod1)

# Model 2: HO-DINA model
mod2 &lt;- CDM::gdina( dat, q.matrix=Q, HOGDINA=1, rule="DINA")
summary(mod2)

#############################################################################
# EXAMPLE 9: Skill space approximation data.jang
#############################################################################

data(data.jang, package="CDM")

data &lt;- data.jang$data
q.matrix &lt;- data.jang$q.matrix

#*** Model 1: Reduced RUM model
mod1 &lt;- CDM::gdina( data, q.matrix, rule="RRUM", conv.crit=.001, maxit=500 )

#*** Model 2: Reduced RUM model with skill space approximation
# use 300 instead of 2^9=512 skill classes
skillspace &lt;- CDM::skillspace.approximation( L=300, K=ncol(q.matrix) )
mod2 &lt;- CDM::gdina( data, q.matrix, rule="RRUM", conv.crit=.001,
            skillclasses=skillspace )
  ##   &gt; logLik(mod1)
  ##   'log Lik.' -30318.08 (df=153)
  ##   &gt; logLik(mod2)
  ##   'log Lik.' -30326.52 (df=153)

#############################################################################
# EXAMPLE 10: CDM with a linear hierarchy
#############################################################################
# This model is equivalent to a unidimensional IRT model with an ordered
# ordinal latent trait and is actually a probabilistic Guttman model.
set.seed(789)

# define 3 competency levels
alpha &lt;- scan()
   0 0 0   1 0 0   1 1 0   1 1 1

# define skill class distribution
K &lt;- 3
skillspace &lt;- alpha &lt;- matrix( alpha, K + 1,  K, byrow=TRUE )
alpha &lt;- alpha[ rep(  1:4,  c(300,300,200,200) ), ]
# P(000)=P(100)=.3, P(110)=P(111)=.2
# define Q-matrix
Q &lt;- scan()
    1 0 0   1 1 0   1 1 1

Q &lt;- matrix( Q, nrow=K,  ncol=K, byrow=TRUE )
Q &lt;- Q[ rep(1:K, each=4 ), ]
colnames(skillspace) &lt;- colnames(Q) &lt;- paste0("A",1:K)
I &lt;- nrow(Q)

# define guessing and slipping parameters
guess &lt;- stats::runif( I, 0, .3 )
slip &lt;- stats::runif( I, 0, .2 )
# simulate data
dat &lt;- CDM::sim.din( q.matrix=Q, alpha=alpha, slip=slip, guess=guess )$dat

#*** Model 1: DINA model with linear hierarchy
mod1 &lt;- CDM::din( dat, q.matrix=Q, rule="DINA",  skillclasses=skillspace )
summary(mod1)

#*** Model 2: pGDINA model with 3 levels
#    The multidimensional CDM with a linear hierarchy is a unidimensional
#    polytomous GDINA model.
Q2 &lt;- matrix( rowSums(Q), nrow=I, ncol=1 )
mod2 &lt;- CDM::gdina( dat, q.matrix=Q2, rule="DINA" )
summary(mod2)

#*** Model 3: estimate probabilistic Guttman model in sirt
#    Proctor, C. H. (1970). A probabilistic formulation and statistical
#    analysis for Guttman scaling. Psychometrika, 35, 73-78.
library(sirt)
mod3 &lt;- sirt::prob.guttman( dat, itemlevel=Q2[,1] )
summary(mod3)
# -&gt; The three models result in nearly equivalent fit.

#############################################################################
# EXAMPLE 11: Sequential GDINA model (Ma &amp; de la Torre, 2016)
#############################################################################

data(data.cdm04, package="CDM")

#** attach dataset
dat &lt;- data.cdm04$data    # polytomous item responses
q.matrix1 &lt;- data.cdm04$q.matrix1
q.matrix2 &lt;- data.cdm04$q.matrix2

#-- DINA model with first Q-matrix
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix1, rule="DINA")
summary(mod1)
#-- DINA model with second Q-matrix
mod2 &lt;- CDM::gdina( dat, q.matrix=q.matrix2, rule="DINA")
#-- GDINA model
mod3 &lt;- CDM::gdina( dat, q.matrix=q.matrix2, rule="GDINA")

#** model comparison
IRT.compareModels(mod1,mod2,mod3)

#############################################################################
# EXAMPLE 12: Simulataneous modeling of skills and misconceptions (Kuo et al., 2018)
#############################################################################

data(data.cdm08, package="CDM")
dat &lt;- data.cdm08$data
q.matrix &lt;- data.cdm08$q.matrix

#*** estimate model
mod &lt;- CDM::gdina( dat0, q.matrix, rule="SISM", bugs=colnames(q.matrix)[5:7] )
summary(mod)

#############################################################################
# EXAMPLE 13: Regularized estimation in GDINA model data.dtmr
#############################################################################

data(data.dtmr, package="CDM")
dat &lt;- data.dtmr$data
q.matrix &lt;- data.dtmr$q.matrix

#***** LASSO regularization with lambda parameter of .02
mod1 &lt;- CDM::gdina(dat, q.matrix=q.matrix, rule="GDINA", regular_lam=.02,
                  regular_type="lasso")
summary(mod1)
mod$delta_regularized

#***** using starting values from previuos estimation
delta.init &lt;- mod1$delta
attr.prob.init &lt;- mod1$attr.prob
mod2 &lt;- CDM::gdina(dat, q.matrix=q.matrix, rule="GDINA", regular_lam=.02, regular_type="lasso",
                delta.init=delta.init, attr.prob.init=attr.prob.init)
summary(mod2)

#***** final estimation fixing regularized estimates to zero and estimate all other
#***** item parameters unregularized
regular_weights &lt;- mod2$delta_regularized
delta.init &lt;- mod2$delta
attr.prob.init &lt;- mod2$attr.prob

mod3 &lt;- CDM::gdina(dat, q.matrix=q.matrix, rule="GDINA", regular_lam=1E5, regular_type="lasso",
                delta.init=delta.init, attr.prob.init=attr.prob.init,
                regular_weights=regular_weights)
summary(mod3)

## End(Not run)
</code></pre>


</div>