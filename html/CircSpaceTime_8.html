<div class="container">

<table style="width: 100%;"><tr>
<td>ProjKrigSp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kriging using projected normal model.</h2>

<h3>Description</h3>

<p><code>ProjKrigSp</code> function computes the spatial prediction
for circular spatial data using samples from the posterior distribution
of the spatial projected normal
</p>


<h3>Usage</h3>

<pre><code class="language-R">ProjKrigSp(ProjSp_out, coords_obs, coords_nobs, x_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ProjSp_out</code></td>
<td>
<p>the function takes the output of <code>ProjSp</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords_obs</code></td>
<td>
<p>coordinates of observed locations (in UTM)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords_nobs</code></td>
<td>
<p>coordinates of unobserved locations (in UTM)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_obs</code></td>
<td>
<p>observed values in <code class="reqn">[0,2\pi)</code>.
If they are not in <code class="reqn">[0,2\pi)</code>, the function will transform
the data in the right interval</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of 3 elements
</p>

<dl>
<dt><code>M_out</code></dt>
<dd>
<p>the mean of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSp</p>
</dd>
<dt><code>V_out</code></dt>
<dd>
<p>the variance of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSp</p>
</dd>
<dt><code>Prev_out</code></dt>
<dd>
<p>the posterior predicted  values at the unobserved locations.</p>
</dd>
</dl>
<h3>References</h3>

<p>F. Wang, A. E.   Gelfand,
"Modeling space and space-time directional data using projected Gaussian processes",
Journal of the American Statistical Association,109 (2014), 1565-1580
</p>
<p>G. Mastrantonio, G. Jona Lasinio, A. E. Gelfand,
"Spatio-temporal circular models with non-separable covariance structure",
TEST 25 (2016), 331-350 https://doi.org/10.1007/s11749-015-0458-y
</p>


<h3>See Also</h3>

<p><code>ProjSp</code> for spatial sampling from
Projected Normal ,
<code>WrapSp</code> for spatial sampling from
Wrapped Normal and <code>WrapKrigSp</code> for
spatial interpolation under the wrapped model
</p>
<p>Other spatial interpolations: <code>WrapKrigSp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(CircSpaceTime)
## auxiliary function
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
 d &lt;- if (is.matrix(varcov))
   ncol(varcov)
 else 1
 z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
 y &lt;- t(mean + t(z))
 return(y)
}

####
# Simulation using exponential  spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
tau     &lt;- 0.2
sigma2  &lt;- 1
alpha   &lt;- c(0.5,0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n),
           kronecker(SIGMA, matrix(c( sigma2,sqrt(sigma2)*tau,sqrt(sigma2)*tau,1 ) ,nrow=2 )))
theta &lt;- c()
for(i in 1:n) {
 theta[i] &lt;- atan2(Y[(i-1)*2+2],Y[(i-1)*2+1])
}
theta &lt;- theta %% (2*pi) #to be sure to have values in (0,2pi)

hist(theta)
rose_diag(theta)

val &lt;- sample(1:n,round(n*0.1))

################some useful quantities
rho.min &lt;- 3/max(Dist)
rho.max &lt;- rho.min+0.5

set.seed(100)

mod &lt;- ProjSp(
 x       = theta[-val],
 coords    = coords[-val,],
 start   = list("alpha"      = c(0.92, 0.18, 0.56, -0.35),
                "rho"     = c(0.51,0.15),
                "tau"     = c(0.46, 0.66),
                "sigma2"    = c(0.27, 0.3),
                "r"       = abs(rnorm(  length(theta))  )),
 priors   = list("rho"      = c(rho.min,rho.max),
                 "tau"      = c(-1,1),
                 "sigma2"    = c(10,3),
                 "alpha_mu" = c(0, 0),
                 "alpha_sigma" = diag(10,2)
 )  ,
 sd_prop   = list("sigma2" = 0.1, "tau" = 0.1, "rho" = 0.1,
                  "sdr" = sample(.05,length(theta), replace = TRUE)),
 iter    = 10000,
 BurninThin    = c(burnin = 7000, thin = 10),
 accept_ratio = 0.234,
 adapt_param = c(start = 130000, end = 120000, exp = 0.5),#no adaptation
 corr_fun = "exponential",
 kappa_matern = .5,
 n_chains = 2 ,
 parallel = TRUE ,
 n_cores = 2
)
# If you don't want to install/use DoParallel
# please set parallel = FALSE. Keep in mind that it can be substantially slower
# How much it takes?

check &lt;-  ConvCheck(mod)
check$Rhat #close to 1 we have convergence

#### graphical check
par(mfrow=c(3,2))
coda::traceplot(check$mcmc)

par(mfrow=c(1,1))

# move to prediction once convergence is achieved
Krig &lt;- ProjKrigSp(
 ProjSp_out = mod,
 coords_obs =  coords[-val,],
 coords_nobs =  coords[val,],
 x_obs = theta[-val]
)

# The quality of prediction can be checked using APEcirc and CRPScirc
ape  &lt;- APEcirc(theta[val],Krig$Prev_out)
crps &lt;- CRPScirc(theta[val],Krig$Prev_out)
</code></pre>


</div>