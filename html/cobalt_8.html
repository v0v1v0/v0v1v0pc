<div class="container">

<table style="width: 100%;"><tr>
<td>bal.tab</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Display Balance Statistics in a Table</h2>

<h3>Description</h3>

<p>Generates balance statistics on covariates in relation to an observed treatment variable. It is a generic function that dispatches to the method corresponding to the class of the first argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bal.tab(x, ...)

## # Arguments common across all input types:
## bal.tab(x,
##         stats,
##         int = FALSE,
##         poly = 1,
##         distance = NULL,
##         addl = NULL,
##         data = NULL,
##         continuous,
##         binary,
##         s.d.denom,
##         thresholds = NULL,
##         weights = NULL,
##         cluster = NULL,
##         imp = NULL,
##         pairwise = TRUE,
##         s.weights = NULL,
##         abs = FALSE,
##         subset = NULL,
##         quick = TRUE,
##         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an input object on which to assess balance. Can be the output of a call to a balancing function in another package or a formula or data frame. Input to this argument will determine which <code>bal.tab()</code> method is used. Each input type has its own documentation page, which is linked in the See Also section below. Some input types require or allow additional arguments to be specified. For inputs with no dedicated method, the default method will be dispatched. See Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See display options for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code>stats</code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code>set.cobalt.options()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code>set.cobalt.options()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code>col_w_smd()</code> for allowable options. If weights are supplied, each set of weights should have a corresponding entry to <code>s.d.denom</code>. Abbreviations allowed. If left blank and weights, subclasses, or matching strata are supplied, <code>bal.tab()</code> will figure out which one is best based on the <code>estimand</code>, if given (for ATT, <code>"treated"</code>; for ATC, <code>"control"</code>; otherwise <code>"pooled"</code>) and other clues if not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code>get.w()</code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code>class-bal.tab.cluster</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code>class-bal.tab.imp</code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code>bal.tab.multi()</code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>bal.tab()</code> performs various calculations on the the data objects given. This page details the arguments and calculations that are used across <code>bal.tab()</code> methods.
</p>


<h4>With Binary Point Treatments</h4>

<p>Balance statistics can be requested with the <code>stats</code> argument. The default balance statistic for mean differences for continuous variables is the standardized mean difference, which is the difference in the means divided by a measure of spread (i.e., a d-type effect size measure). This is the default because it puts the mean differences on the same scale for comparison with each other and with a given threshold. For binary variables, the default balance statistic is the raw difference in proportion. Although standardized differences in proportion can be computed, raw differences in proportion for binary variables are already on the same scale, and computing the standardized difference in proportion can obscure the true difference in proportion by dividing the difference in proportion by a number that is itself a function of the observed proportions.
</p>
<p>Standardized mean differences are calculated using <code>col_w_smd()</code> as follows: the numerator is the mean of the treated group minus the mean of the control group, and the denominator is a measure of spread calculated in accordance with the argument to <code>s.d.denom</code> or the default of the specific method used. Common approaches in the literature include using the standard deviation of the treated group or using the "pooled" standard deviation (i.e., the square root of the mean of the group variances) in calculating standardized mean differences. The computed spread <code>bal.tab()</code> uses is always that of the full, unadjusted sample (i.e., before matching, weighting, or subclassification), as recommended by Stuart (2010).
</p>
<p>Prior to computation, all variables are checked for variable type, which allows users to differentiate balance statistic calculations based on type using the arguments to <code>continuous</code> and <code>binary</code>. First, if a given covariate is numeric and has only 2 levels, it is converted into a binary (0,1) variable. If 0 is a value in the original variable, it retains its value and the other value is converted to 1; otherwise, the lower value is converted to 0 and the other to 1. Next, if the covariate is not numeric or logical (i.e., is a character or factor variable), it will be split into new binary variables, named with the original variable and the value, separated by an underscore. Otherwise, the covariate will be used as is and treated as a continuous variable.
</p>
<p>When weighting or matching are used, an "effective sample size" is calculated for each group using the following formula: <code class="reqn">(\sum w)^2 / \sum w^2</code>. The effective sample size is "approximately the number of observations from a simple random sample that yields an estimate with sampling variation equal to the sampling variation obtained with the weighted comparison observations" (Ridgeway et al., 2016). The calculated number tends to underestimate the true effective sample size of the weighted samples. The number depends on the variability of the weights, so sometimes trimming units with large weights can actually increase the effective sample size, even though units are being down-weighted. When matching is used, an additional "unweighted" sample size will be displayed indicating the total number of units contributing to the weighted sample.
</p>
<p>When subclassification is used, the balance tables for each subclass stored in <code style="white-space: pre;">⁠$Subclass.Balance⁠</code> use values calculated as described above. For the aggregate balance table stored in <code style="white-space: pre;">⁠$Balance.Across.Subclass⁠</code>, the values of each statistic are computed as a weighted average of the statistic across subclasses, weighted by the proportion of units in each subclass. See <code>class-bal.tab.subclass</code> for more details.
</p>



<h4>With Continuous Point Treatments</h4>

<p>When continuous treatment variables are considered, the balance statistic calculated is the Pearson correlation between the covariate and treatment. The correlation after adjustment is computed using <code>col_w_cov()</code> as the weighted covariance between the covariate and treatment divided by the product of the standard deviations of the unweighted covariate and treatment, in an analogous way to how how the weighted standardized mean difference uses an unweighted measure of spread in its denominator, with the purpose of avoiding the analogous paradox (i.e., where the covariance decreases but is accompanied by a change in the standard deviations, thereby distorting the actual resulting balance computed using the weighted standard deviations). This can sometimes yield correlations greater than 1 in absolute value; these usually indicate degenerate cases anyway.
</p>



<h4>With Multi-Category Point Treatments</h4>

<p>For information on using <code>bal.tab()</code> with multi-category treatments, see <code>class-bal.tab.multi</code>. Essentially, <code>bal.tab()</code> compares pairs of treatment groups in a standard way.
</p>



<h4>With Longitudinal Treatments</h4>

<p>For information on using <code>bal.tab()</code> with longitudinal treatments, see <code>class-bal.tab.msm</code> and <code>vignette("longitudinal-treat")</code>. Essentially, <code>bal.tab()</code> summarizes balance at each time point and summarizes across time points.
</p>



<h4>With Clustered or Multiply Imputed Data</h4>

<p>For information on using <code>bal.tab()</code> with clustered data, see <code>class-bal.tab.cluster</code>. For information on using <code>bal.tab()</code> with multiply imputed data, see <code>class-bal.tab.imp</code>.
</p>



<h4><code>quick</code></h4>

<p>Calculations can take some time, especially when there are many variables, interactions, or clusters. When certain values are not printed, by default they are not computed. In particular, summary tables are not computed when their display has not been requested. This can speed up the overall production of the output when these values are not to be used later. However, when they are to be used later, such as when output is to be further examined with <code>print()</code> or is to be used in some other way after the original call to <code>bal.tab()</code>, it may be useful to compute them even if they are not to be printed initially. To do so, users can set <code>quick = FALSE</code>, which will cause <code>bal.tab()</code> to calculate all values and components it can. Note that <code>love.plot()</code> is fully functional even when <code>quick = TRUE</code> and values are requested that are otherwise not computed in <code>bal.tab()</code> with <code>quick = TRUE</code>.
</p>



<h4>Missing Data</h4>

<p>If there is missing data in the covariates (i.e., <code>NA</code>s in the covariates provided to <code>bal.tab()</code>), a few additional things happen. A warning will appear mentioning that missing values were present in the data set. The computed balance summaries will be for the variables ignoring the missing values. New variables will be created representing missingness indicators for each variable, named <code style="white-space: pre;">⁠var: &lt;NA&gt;⁠</code> (with <code>var</code> replaced by the actual name of the variable). If <code>int = TRUE</code>, balance for the pairwise interactions between the missingness indicators will also be computed. These variables are treated like regular variables once created.
</p>



<h3>Value</h3>

<p>An object of class <code>"bal.tab"</code>. The use of continuous treatments, subclasses, clusters, and/or imputations will also cause the object to inherit other classes. The class <code>"bal.tab"</code> has its own <code>print()</code> method (<code>print.bal.tab()</code>), which formats the output nicely and in accordance with print-related options given in the call to <code>bal.tab()</code>, and which can be called with its own options.
</p>
<p>For scenarios with binary point treatments and no subclasses, imputations, or clusters, the following are the elements of the <code>bal.tab</code> object:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Balance</code></td>
<td>
<p>A data frame containing balance information for each covariate. Balance contains the following columns, with additional columns present when other balance statistics are requested, and some columns omitted when not requested:
</p>

<ul>
<li>
<p><code>Type</code>: Whether the covariate is binary, continuous, or a measure of distance (e.g., the propensity score).
</p>
</li>
<li>
<p><code>M.0.Un</code>: The mean of the control group prior to adjusting.
</p>
</li>
<li>
<p><code>SD.0.Un</code>: The standard deviation of the control group prior to adjusting.
</p>
</li>
<li>
<p><code>M.1.Un</code>: The mean of the treated group prior to adjusting.
</p>
</li>
<li>
<p><code>SD.1.Un</code>: The standard deviation of the treated group prior to adjusting.
</p>
</li>
<li>
<p><code>Diff.Un</code>: The (standardized) difference in means between the two groups prior to adjusting. See the <code>binary</code> and <code>continuous</code> arguments on the <code>bal.tab</code> method pages to determine whether standardized or raw mean differences are being reported. By default, the standardized mean difference is displayed for continuous variables and the raw mean difference (difference in proportion) is displayed for binary variables.
</p>
</li>
<li>
<p><code>M.0.Adj</code>: The mean of the control group after adjusting.
</p>
</li>
<li>
<p><code>SD.0.Adj</code>: The standard deviation of the control group after adjusting.
</p>
</li>
<li>
<p><code>M.1.Adj</code>: The mean of the treated group after adjusting.
</p>
</li>
<li>
<p><code>SD.1.Adj</code>: The standard deviation of the treated group after adjusting.
</p>
</li>
<li>
<p><code>Diff.Adj</code>: The (standardized) difference in means between the two groups after adjusting. See the <code>binary</code> and <code>continuous</code> arguments on the <code>bal.tab</code> method pages to determine whether standardized or raw mean differences are being reported. By default, the standardized mean difference is displayed for continuous variables and the raw mean difference (difference in proportion) is displayed for binary variables.
</p>
</li>
<li>
<p><code>M.Threshold</code>: Whether or not the calculated mean difference after adjusting exceeds or is within the threshold given by <code>thresholds</code>.  If a threshold for mean differences is not specified, this column will be <code>NA</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Balanced.Means</code></td>
<td>
<p>If a threshold on mean differences is specified, a table tallying the number of variables that exceed or are within the threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Max.Imbalance.Means</code></td>
<td>
<p>If a threshold on mean differences is specified, a table displaying the variable with the greatest absolute mean difference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Observations</code></td>
<td>
<p>A table displaying the sample sizes before and after adjusting. Often the effective sample size (ESS) will be displayed. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The original function call, if adjustment was performed by a function in another package.</p>
</td>
</tr>
</table>
<p>If the treatment is continuous, instead of producing mean differences, <code>bal.tab()</code> will produce correlations between the covariates and the treatment. The default corresponding entries in the output will be <code>"Corr.Un"</code>, "<code style="white-space: pre;">⁠Corr.Adj"⁠</code>, and <code>"R.Threshold"</code> (and accordingly for the balance tally and maximum imbalance tables).
</p>
<p>If multiple weights are supplied, <code>"Adj"</code> in <code>Balance</code> will be replaced by the provided names of the sets of weights, and extra columns will be added for each set of weights. Additional columns and rows for other items in the output will be created as well.
</p>
<p>For <code>bal.tab</code> output with subclassification, see <code>class-bal.tab.subclass</code>.
</p>


<h3>References</h3>

<p>Ridgeway, G., McCaffrey, D., Morral, A., Burgette, L., &amp; Griffin, B. A. (2016). Toolkit for Weighting and Analysis of Nonequivalent Groups: A tutorial for the twang package. R vignette. RAND.
</p>
<p>Stuart, E. A. (2010). Matching Methods for Causal Inference: A Review and a Look Forward. Statistical Science, 25(1), 1-21. <a href="https://doi.org/10.1214/09-STS313">doi:10.1214/09-STS313</a>
</p>


<h3>See Also</h3>

<p>For information on the use of <code>bal.tab()</code> with specific types of objects, use the following links:
</p>

<ul>
<li> <p><code>bal.tab.matchit()</code> for the method for objects returned by <span class="pkg">MatchIt</span>.
</p>
</li>
<li> <p><code>bal.tab.weightit()</code> for the method for <code>weightit</code> and <code>weightitMSM</code> objects returned by <span class="pkg">WeightIt</span>.
</p>
</li>
<li> <p><code>bal.tab.ps()</code> for the method for <code>ps</code>, <code>mnps</code>, and <code>iptw</code> objects returned by <span class="pkg">twang</span> and for <code>ps.cont</code> objects returned by <span class="pkg">twangContinuous</span>.
</p>
</li>
<li> <p><code>bal.tab.Match()</code> for the method for objects returned by <span class="pkg">Matching</span>.
</p>
</li>
<li> <p><code>bal.tab.optmatch()</code> for the method for objects returned by <span class="pkg">optmatch</span>.
</p>
</li>
<li> <p><code>bal.tab.cem.match()</code> for the method for objects returned by <span class="pkg">cem</span>.
</p>
</li>
<li> <p><code>bal.tab.CBPS()</code> for the method for objects returned by <span class="pkg">CBPS</span>.
</p>
</li>
<li> <p><code>bal.tab.ebalance()</code> for the method for objects returned by <span class="pkg">ebal</span>.
</p>
</li>
<li> <p><code>bal.tab.designmatch()</code> for the method for objects returned by <span class="pkg">designmatch</span>.
</p>
</li>
<li> <p><code>bal.tab.mimids()</code> for the method for objects returned by <span class="pkg">MatchThem</span>.
</p>
</li>
<li> <p><code>bal.tab.sbwcau()</code> for the method for objects returned by <span class="pkg">sbw</span>.
</p>
</li>
<li> <p><code>bal.tab.formula()</code> and <code>bal.tab.data.frame()</code> for the methods for <code>formula</code> and data frame interfaces when the user has covariate values and weights (including matching weights) or subclasses or wants to evaluate balance on an unconditioned data set. For data that corresponds to a longitudinal treatment (i.e., to be analyzed with a marginal structural model), see <code>bal.tab.time.list()</code>.
</p>
</li>
</ul>
<p>See <code>vignette("faq")</code> for answers to frequently asked questions about <code>bal.tab()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## See individual pages above for examples with
## different inputs, or see `vignette("cobalt")`
</code></pre>


</div>