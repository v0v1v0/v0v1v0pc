<div class="container">

<table style="width: 100%;"><tr>
<td>CKT.kernel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of conditional Kendall's tau using kernel smoothing</h2>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
For this, a kernel-based estimator is used, as described in
(Derumigny, &amp; Fermanian (2019)).
</p>


<h3>Usage</h3>

<pre><code class="language-R">CKT.kernel(
  X1 = NULL,
  X2 = NULL,
  Z = NULL,
  newZ,
  h,
  kernel.name = "Epa",
  methodCV = "Kfolds",
  Kfolds = 5,
  nPairs = 10 * length(observedX1),
  typeEstCKT = "wdm",
  progressBar = TRUE,
  observedX1 = NULL,
  observedX2 = NULL,
  observedZ = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p>a vector of n observations of the first variable
(or a 1-column matrix)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>a vector of n observations of the second variable
(or a 1-column matrix)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>a vector of n observations of the conditioning variable,
or a matrix with n rows of observations of the conditioning vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newZ</code></td>
<td>
<p>the new data of observations of Z at which
the conditional Kendall's tau should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>the bandwidth used for kernel smoothing.
If this is a vector, then cross-validation is used following the method
given by argument <code>methodCV</code> to choose the best bandwidth
before doing the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.name</code></td>
<td>
<p>name of the kernel used for smoothing.
Possible choices are <code>"Gaussian"</code> (Gaussian kernel)
and <code>"Epa"</code> (Epanechnikov kernel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methodCV</code></td>
<td>
<p>method used for the cross-validation.
Possible choices are <code>"leave-one-out"</code> and <code>"Kfolds"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kfolds</code></td>
<td>
<p>number of subsamples used,
if <code>methodCV = "Kfolds"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nPairs</code></td>
<td>
<p>number of pairs used in the cross-validation criteria,
if <code>methodCV = "leave-one-out"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.
Possible choices are </p>

<ul>
<li> <p><code>1</code> and <code>3</code> produced biased estimators.
<code>2</code> does not attain the full range <code class="reqn">[-1,1]</code>.
Therefore these 3 choices are not recommended for applications on real data.
</p>
</li>
<li> <p><code>4</code> is an improved version of <code>1,2,3</code> that has less bias
and attains the full range <code class="reqn">[-1,1]</code>.
</p>
</li>
<li> <p><code>"wdm"</code> is the default version and produces the same results
as <code>4</code> when they are no ties in the data.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressBar</code></td>
<td>
<p>control the display of progress bars.
Possible choices are: </p>

<ul>
<li> <p><code>0</code> no progress bar is displayed
</p>
</li>
<li> <p><code>1</code> a general progress bar is displayed
</p>
</li>
<li> <p><code>2</code> and larger values:
a general progress bar is displayed, and additionally,
a progressbar for each value of <code>h</code> is displayed
to show the progress of the computation.
This only applies when the bandwidth is chosen by cross-validation
(i.e. when <code>h</code> is a vector).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observedX1, observedX2, observedZ</code></td>
<td>
<p>old parameter names for <code>X1</code>,
<code>X2</code>, <code>Z</code>. Support for this will be removed at a later version.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Choice of the bandwidth <code>h</code></strong>.
The choice of the bandwidth must be done carefully.
In the univariate case, the default kernel (Epanechnikov kernel) has a support
on <code class="reqn">[-1,1]</code>, so for a bandwidth <code>h</code>, estimation of conditional Kendall's
tau at <code class="reqn">Z=z</code> will only use points for which <code class="reqn">Z_i \in [z \pm h]</code>.
As usual in nonparametric estimation, <code>h</code> should not be too small
(to avoid having a too large variance) and should not be large
(to avoid having a too large bias).
</p>
<p>We recommend that for each <code class="reqn">z</code> for which the conditional Kendall's tau
<code class="reqn">\tau_{X_1, X_2 | Z=z}</code> is estimated, the set
<code class="reqn">\{i: Z_i \in [z \pm h] \}</code>
should contain at least 20 points and not more than 30% of the points of
the whole dataset.
Note that for a consistent estimation, as the sample size <code class="reqn">n</code> tends
to the infinity, <code>h</code> should tend to <code class="reqn">0</code> while the size of the set
<code class="reqn">\{i: Z_i \in [z \pm h]\}</code> should also tend to the infinity.
Indeed the conditioning points should be closer and closer to the point of interest <code class="reqn">z</code>
(small <code>h</code>) and more and more numerous (<code>h</code> tending to 0 slowly enough).
</p>
<p>In the multivariate case, similar recommendations can be made.
Because of the curse of dimensionality, a larger sample will be necessary to
reach the same level of precision as in the univariate case.
</p>


<h3>Value</h3>

<p>a list with two components
</p>

<ul>
<li> <p><code>estimatedCKT</code> the vector of size <code>NROW(newZ)</code>
containing the values of the estimated conditional Kendall's tau.
</p>
</li>
<li> <p><code>finalh</code> the bandwidth <code>h</code> that was finally used
for kernel smoothing (either the one specified by the user
or the one chosen by cross-validation if multiple bandwidths were given.)
</p>
</li>
</ul>
<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
On kernel-based estimation of conditional Kendallâ€™s tau:
finite-distance bounds and asymptotic behavior.
Dependence Modeling, 7(1), 292-321.
<a href="https://doi.org/10.1515/demo-2019-0016">doi:10.1515/demo-2019-0016</a>
</p>


<h3>See Also</h3>

<p><code>CKT.estimate</code> for other estimators
of conditional Kendall's tau.
<code>CKTmatrix.kernel</code> for a generalization of this function
when the conditioned vector is of dimension <code>d</code>
instead of dimension <code>2</code> here.
</p>
<p>See <code>CKT.hCV.l1out</code> for manual selection of the bandwidth <code>h</code>
by leave-one-out or K-folds cross-validation.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
estimatedCKT_kernel &lt;- CKT.kernel(
   X1 = X1, X2 = X2, Z = Z,
   newZ = newZ, h = 0.1, kernel.name = "Epa")$estimatedCKT

# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col = "black",
     type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_kernel, col = "red")

</code></pre>


</div>