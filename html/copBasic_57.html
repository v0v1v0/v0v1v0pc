<div class="container">

<table style="width: 100%;"><tr>
<td>GHcop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Gumbel–Hougaard Extreme Value Copula</h2>

<h3>Description</h3>

<p><em>SYMMETRIC GUMBEL-HOUGAARD</em>—The <em>Gumbel–Hougaard copula</em> (Nelsen, 2006, pp. 118 and 164) is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\Theta}(u,v) = \mathbf{GH}(u,v) = \mathrm{exp}\{-[(-\log u)^\Theta+(-\log v)^\Theta]^{1/\Theta}\}\mbox{,}</code>
</p>

<p>where <code class="reqn">\Theta \in [1 , \infty)</code>. The copula here is a <em>bivariate extreme value copula</em> (<code class="reqn">BEV</code>). The parameter <code class="reqn">\Theta</code> is readily estimated using a <em>Kendall Tau</em> (say a sample version <code class="reqn">\hat\tau</code>) where the <code class="reqn">\tau</code> of the copula (<code class="reqn">\tau_\mathbf{C}</code>) is defined as
</p>
<p style="text-align: center;"><code class="reqn">\tau_\mathbf{C} = \frac{\Theta - 1}{\Theta} \rightarrow \Theta = \frac{1}{1-\tau}\mbox{.}</code>
</p>

<p>The copula is readily extended into <code class="reqn">d</code> dimensions by
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{\Theta}(u,v) = \mathrm{exp}\{-[(-\log u_1)^\Theta+\cdots+(-\log u_d)^\Theta]^{1/\Theta}\}\mbox{.}</code>
</p>

<p>However, such an implementation is not available in the <span class="pkg">copBasic</span> package.
</p>
<p>Every Gumbel–Hougaard copula is a <em>multivariate extreme value</em> (<code class="reqn">MEV</code>) copula, and hence useful in analysis of extreme value distributions. The Gumbel–Hougaard copula is the <em>only</em> Archimedean <code class="reqn">MEV</code> (Salvadori <em>et al.</em>, 2007, p. 192). The Gumbel–Hougaard copula has respective <em>lower-</em> and <em>upper-tail dependency</em> parameters of <code class="reqn">\lambda^L = 0</code> and <code class="reqn">\lambda^U = 2 - 2^{1/\Theta}</code>, respectively. Nelsen (2006, p. 96) shows that <code class="reqn">\mathbf{C}^r_\theta(u^{1/r}, v^{1/r}) = \mathbf{C}_\theta(u,v)</code> so that every Gumbel–Hougaard copula has a property known as <em>max-stable</em>. A <em>dependence measure</em> uniquely defined for <code class="reqn">BEV</code> copulas is shown under <code>rhobevCOP</code>.
</p>
<p>A comparison through simulation between Gumbel–Hougaard implementations by the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> packages <span class="pkg">acopula</span>, <span class="pkg">copBasic</span>, <span class="pkg">copula</span>, and <span class="pkg">Gumbel</span> is shown in the <b>Examples</b> section. At least three divergent techniques for random variate generation are used amongst those packages. The simulations also use <span class="pkg">copBasic</span>-style random variate generation  (conditional simulation) using an analytical-numerical hybrid solution to conditional inverse described in the <span class="pkg">Note</span> section.
</p>
<p><em>TWO-PARAMETER GUMBEL–HOUGAARD</em>—A <em>permutation symmetric</em> (<code>isCOP.permsym</code>) but almost certainly <em>radial asymmetric</em> (<code>isCOP.radsym</code>) version of the copula is readily constructed (Brahimi <em>et al.</em>, 2015) into a two-parameter version:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}(u,v; \beta_1, \beta_2) =
\biggl[
\biggl(\bigl(u^{-\beta_2} -1\bigr)^{\beta_1} +
       \bigl(v^{-\beta_2} -1\bigr)^{\beta_1}
\biggr)^{1/\beta_1} + 1
\biggr]^{-1/\beta_2}\mbox{,}</code>
</p>

<p>where <code class="reqn">\beta_1 \ge 1</code> and <code class="reqn">\beta_2 &gt; 0</code>. Both parameters controls the general level of association, whereas parameter <code class="reqn">\beta_2</code> can be thought of as controlling left-tail dependency (<code>taildepCOP</code>, <code class="reqn">\lambda^{[U\mid L]}_{(\beta_1, \beta_2)}</code>; <em>e.g.</em>
<code class="reqn">\lambda^U_{(1.5; \beta_2)} = 0.413</code> for all <code class="reqn">\beta_2</code> but
<code class="reqn">\lambda^L_{(1.5; 0.2)} = 0.811</code> and
<code class="reqn">\lambda^L_{(1.5; 2.2)} = 0.099</code>. Brahimi <em>et al.</em> (2015) report a <em>Spearman Rho</em> (<code>rhoCOP</code>) for a <code class="reqn">\mathbf{GH}_{(1.5, 0.2)}(u,v)</code> is 0.5, which is readily confirmed in <span class="pkg">copBasic</span> by the function call <code>rhoCOP(cop=GHcop, para=c(1.5,0.2))</code>. The two-parameter <code class="reqn">\mathbf{GH}</code> is triggered if the length of the <code>para</code> argument is exactly 2.
</p>
<p><em>ASYMMETRIC GUMBEL–HOUGAARD</em>—An asymmetric version of the copula is readily constructed (Joe, 2014, p. 185–186) into a three-parameter version with <em>Marshall–Olkin</em> copulas on the boundaries:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}(u,v; \Theta, \pi_2, \pi_3) = \mathrm{exp}[-\mathcal{A}(-\log u, -\log v; \Theta, \pi_2, \pi_3)]\mbox{,}</code>
</p>

<p>where <code class="reqn">\Theta \ge 1</code> as before, <code class="reqn">0 \le \pi_2,  \pi_3 \le 1</code>, and
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{A}(x, y; \Theta, \pi_2, \pi_3) = [(\pi_2 x)^\Theta + (\pi_3 y)^\Theta]^{1/\Theta} + (1-\pi_2)x + (1-\pi_3)y\mbox{.}</code>
</p>

<p>The asymmetric <code class="reqn">\mathbf{GH}</code> is triggered if the length of the <code>para</code> argument is exactly 3. The <code>GHcop</code> function provides no mechanism for estimation of the parameters for the asymmetric version. Reviewing simulations, the bounds on the <code class="reqn">\pi</code> parameters in Joe (2014, p. 185) “[<code class="reqn">0 \le \pi_2 &lt; \pi_3 \le 1</code>]” might be incorrect—by Joe back referencing to Joe (2014, eq. 4.35, p. 183) the <code class="reqn">\pi</code>-limits as stated for <span class="pkg">copBasic</span> are shown. An algorithm for parameter estimation for the asymmetric <code class="reqn">\mathbf{GH}</code> using two different measures of <em>bivariate skewness</em> as well as an arbitrary <em>measure of association</em> is shown in section <b>Details</b> in <code>joeskewCOP</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GHcop(u, v, para=NULL, tau=NULL, tau.big=0.985, cor=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>A vector (single element or triplet) of parameters—the <code class="reqn">\Theta</code> parameter of the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Kendall Tau <code class="reqn">\tau</code> from which to estimate the parameter <code class="reqn">\Theta</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.big</code></td>
<td>
<p>The largest value for <code class="reqn">\tau_\mathbf{C}</code> prior to switching to the <code class="reqn">\mathbf{M}</code> copula applicable to the the symmetric version of this copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>A <span class="pkg">copBasic</span> syntax for “the correlation coefficient” suitable for the copula—a synonym for <code>tau</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Numerical experiments seem to indicate for <code class="reqn">\tau_\mathbf{C} &gt; 0.985</code> that failures in the numerical partial derivatives in <code>derCOP</code> and <code>derCOP2</code> result—a <code class="reqn">\tau_\mathbf{C}</code> this large is indeed <em>large</em>. As <code class="reqn">\Theta \rightarrow \infty</code> the Gumbel–Hougaard copula becomes the <em>Fréchet–Hoeffding upper-bound copula</em> <code class="reqn">\mathbf{M}</code> (see <code>M</code>). A <code class="reqn">\tau_\mathbf{C} \approx 0.985</code> yields <code class="reqn">\Theta \approx 66 + 2/3</code>, then for <code class="reqn">\Theta &gt; 1/(1-\tau_\mathbf{C})</code> flips over to the <code class="reqn">\mathbf{M}</code> copula with a warning issued.
</p>


<h3>Value</h3>

<p>Value(s) for the copula are returned using the <code class="reqn">\Theta</code> as set by argument <code>para</code>. Alternative returned values are possible: (1) If <code>para=NULL</code> and <code>tau</code> is set, then <code class="reqn">\tau_\mathbf{C} \rightarrow \Theta</code> and an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> is returned. (2) If <code>para=NULL</code> and <code>tau=NULL</code>, then an attempt to estimate <code class="reqn">\Theta</code> from the <code>u</code> and <code>v</code> is made by <code class="reqn">\mathrm{cor}(u,v)_\tau \rightarrow \tau_\mathbf{C} \rightarrow \Theta</code> by either trigger using <code>cor(u,v, method="kendall")</code> in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, and an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> is returned. The possibly returned <code>list</code> has the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>The computed <code class="reqn">\Theta</code> from the given bivariate data in <code>para</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The sample estimate of <code class="reqn">\tau</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p><em>SYMMETRIC GUMBEL–HOUGAARD</em>—A function for the derivative of the copula (Joe, 2014, p. 172) given <code class="reqn">u</code> is
</p>
<pre>
  "GHcop.derCOP" &lt;- function(u, v, para=NULL, ...) {
     x &lt;- -log(u); y &lt;- -log(v)
     A &lt;- exp(-(x^para + y^para)^(1/para)) * (1 + (y/x)^para)^(1/para - 1)
     return(A/u)
  }
</pre>
<p>that can be tested by the following
</p>
<pre>
  Theta &lt;- 1/(1-.15) # a Kendall Tau of 0.15
  GHcop.derCOP(     0.5, 0.75, para=Theta) # 0.7787597
  derCOP(cop=GHcop, 0.5, 0.75, para=Theta) # 0.7787597
  # The next two nearly return same value but conversion to GRVs
  # (Gumbel Reduced Variates) to magnify the numerical differences.
  # The GHcop.derCOP is expected to be the more accurate of the two.
  lmomco::prob2grv(GHcop.derCOP(     0.5, 0.9999999, para=Theta)) # 18.83349
  lmomco::prob2grv(derCOP(cop=GHcop, 0.5, 0.9999999, para=Theta)) # 18.71497
  lmomco::prob2grv(derCOP(cop=GHcop, 0.5, 0.9999999, para=Theta,
                                   delu=.Machine$double.eps^.25)) # 18.83341
</pre>
<p>where the last numerical approximation shows that tighter tolerance is needed. A function for the inverse of the derivative (Joe, 2014, p. 172) given <code class="reqn">u</code> by an analytical-numerical hybrid is
</p>
<pre>
  "GHcop.derCOPinv" &lt;- function(u,t, para=NULL, verbose=FALSE,
                                     tol=.Machine$double.eps, ...) {
    if(length(u) &gt; 1) warning("only the first value of u will be used")
    if(length(t) &gt; 1) warning("only the first value of t will be used")
    if(is.null(para)) { warning("para can not be NULL"); return(NA) }
    u &lt;- u[1]; t &lt;- t[1]; rt &lt;- NULL
    x &lt;- -log(u); A &lt;- (x + (para - 1)*log(x) - log(t))
    hz &lt;- function(z) { z + (para - 1)*log(z) - A }
    zmax &lt;- x; i &lt;- 0; hofz.lo &lt;- hz(zmax)
    if(sign(hofz.lo) != -1) warning("sign for h(z) is not negative!")
    while(1) {
       i &lt;- i + 1
       if(i &gt; 100) {
          warning("maximum iterations looking for zmax reached"); break
       }
       # increment zmax by 1/2 log cycle, sign(hofz.lo) should be negative!
       if(sign(hz(zmax &lt;- zmax + 1/2)) != sign(hofz.lo)) break
    }
    try(rt &lt;- uniroot(hz, c(x, zmax), tol=tol, ...), silent=FALSE)
    if(verbose) print(rt)
    if(is.null(rt)) {
       warning("NULL on the inversion of the GH copula derivative")
       return(NA)
    }
    zo &lt;- rt$root
    y &lt;- (zo^para - x^para)^(1/para)
    names(y) &lt;- NULL
    return(exp(-y))
  }
</pre>
<p>that can be tested by the following, which also shows how to increase the tolerance on the numerical implementation
</p>
<pre>
  u &lt;- 0.999; p &lt;- 0.999
  GHcop.derCOPinv(     u, p, para=1.56) # 0.999977
  derCOPinv(cop=GHcop, u, p, para=1.56) # 1 (unity), needs tighter tolerance
  derCOPinv(cop=GHcop, u, p, para=1.56, tol=.Machine$double.eps/10) # 0.999977
</pre>
<p><em>ASYMMETRIC GUMBEL–HOUGAARD</em>—Set <code class="reqn">\tau_\mathbf{C} = 0.35</code> then for a symmetric and then reflection on the 1:1 line of the asymmetric Gumbel–Hougaard copula and compute the primary parameter <code class="reqn">\Theta</code>, and lastly, compute three bivariate <code class="reqn">\nu_\mathbf{C}</code> skewnesses (<code>nuskewCOP</code>):
</p>
<pre>
  Theta1 &lt;- uniroot(function(t) {
                0.35 - tauCOP(cop=GHcop, para=c(t)) },           c(1,10))$root
  Theta2 &lt;- uniroot(function(t) { # asymmetric
                0.35 - tauCOP(cop=GHcop, para=c(t, 0.6, 0.9)) }, c(1,30))$root
  Theta3 &lt;- uniroot(function(t) { # asymmetric reflection on 1:1
                0.35 - tauCOP(cop=GHcop, para=c(t, 0.9, 0.6)) }, c(1,30))$root
  # Theta1 = 1.538462   and   Theta2 = Theta3 = 2.132856
  # Three "skews" based on a combination of U, V, and C(u,v) [nuskew()]
  nuskewCOP(cop=GHcop,   1.538462) # zero bivariate skewness
  nuskewCOP(cop=GHcop, c(2.132856, 0.6, 0.9)) #  0.008245653
  nuskewCOP(cop=GHcop, c(2.132856, 0.9, 0.6)) # -0.008245653
</pre>
<p>So, we see, holding <code class="reqn">\tau_\mathbf{C}</code> constant, that the <code class="reqn">\mathbf{GH}</code> has a <code class="reqn">\nu_{\mathbf{GH}(1.538)} = 0</code> but the asymmetric case <code class="reqn">\nu_{\mathbf{GH}(2.133, 0.6, 0.9)} = 0.0082</code> and <code class="reqn">\nu_{\mathbf{GH}(2.133, 0.9, 0.6)} = -0.0082</code> where the change in sign represents reflection about the 1:1 line. Finally, compute <em>L-coskew</em> by large simulation and the adjective “bow” representing the direction of bowing or curvature of the principle copula density.
</p>
<pre>
  # Because the Tau's are all similar, there is nothing to learn from the
  # L-correlation, let us inspect the L-coskew instead:
  coT3.1&lt;-lmomco::lcomoms2(simCOP(n=8000, cop=GHcop, para=c(Theta1      )))$T3
  coT3.2&lt;-lmomco::lcomoms2(simCOP(n=8000, cop=GHcop, para=c(Theta2,.6,.9)))$T3
  coT3.3&lt;-lmomco::lcomoms2(simCOP(n=8000, cop=GHcop, para=c(Theta3,.9,.6)))$T3
  # The simulations for Theta1 have no curvature about the diagonal.
  # The simulations for Theta2 have curvature towards the upper left.
  # The simulations for Theta3 have curvature towards the lower right.
  message("# L-coskews: ",round(coT3.1[1,2],digits=4),"(symmetric) ",
                          round(coT3.2[1,2],digits=4),"(asym.--bow UL) ",
                          round(coT3.3[1,2],digits=4),"(asym.--bow UL)")
  message("# L-coskews: ",round(coT3.1[2,1],digits=4),"(symmetric) ",
                          round(coT3.2[2,1],digits=4),"(asym.--bow LR) ",
                          round(coT3.3[2,1],digits=4),"(asym.--bow LR)")
  # L-coskews: 0.0533(symmetric) 0.1055(asym.--bow UL) 0.0021(asym.--bow UL)
  # L-coskews: 0.0679(symmetric) 0.0112(asym.--bow LR) 0.1154(asym.--bow LR)
</pre>
<p>Thus, the <em>L-comoments</em> (Asquith, 2011) using their sample values measure something fundamental about the bivariate association between the three copulas choosen. The L-coskews for the symmetrical case are about equal and are
</p>
<p style="text-align: center;"><code class="reqn">\tau^{\mathbf{GH}(\Theta_1)}_{3[12]} \approx \tau^{\mathbf{GH}(\Theta_1)}_{3[21]} \rightarrow (0.0533 + 0.0679)/2 = 0.0606\mbox{,}</code>
</p>

<p>whereas the L-coskew for the curvature to the upper left are
</p>
<p style="text-align: center;"><code class="reqn">\tau^{\mathbf{GH}(\Theta_2, 0.6, 0.9)}_{3[12]} = 0.1055\mbox{\ and\ } \tau^{\mathbf{GH}(\Theta_2, 0.6, 0.9)}_{3[12]} = 0.0112\mbox{,}</code>
</p>

<p>whereas the L-coskew for the curvature to the lower right are
</p>
<p style="text-align: center;"><code class="reqn">\tau^{\mathbf{GH}(\Theta_3, 0.9, 0.6)}_{3[12]} = 0.0021\mbox{\ and\ } \tau^{\mathbf{GH}(\Theta_3, 0.6, 0.9)}_{3[12]} = 0.1154\mbox{.}</code>
</p>

<p>Thus, the <code class="reqn">\pi_2</code> and <code class="reqn">\pi_3</code> parameters as choosen add about (<code class="reqn">(0.1154+0.1055)/2 - 0.0606 \rightarrow</code> <code class="reqn">0.1105 - 0.0606 = 0.05</code>) L-coskew units to the bivariate distribution.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Asquith, W.H., 2011, Distributional analysis with L-moment statistics using the R environment for statistical computing: Createspace Independent Publishing Platform, ISBN 978–146350841–8.
</p>
<p>Brahimi, B., Chebana, F., and Necir, A., 2015, Copula representation of bivariate L-moments—A new estimation method for multiparameter two-dimensional copula models: Statistics, v. 49, no. 3, pp. 497–521.
</p>
<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>
<p>Salvadori, G., De Michele, C., Kottegoda, N.T., and Rosso, R., 2007, Extremes in Nature—An approach using copulas: Springer, 289 p.
</p>
<p>Zhang, L., and Singh, V.P., 2007, Gumbel–Hougaard copula for trivariate rainfall frequency analysis: Journal Hydrologic Engineering, v. 12, Special issue—Copulas in Hydrology, pp. 409–419.
</p>


<h3>See Also</h3>

<p><code>M</code>, <code>GLcop</code>, <code>HRcop</code>, <code>tEVcop</code>, <code>rhobevCOP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Theta    &lt;- 2.2 # Let us see if numerical and analytical tail deps are the same.
del.lamU &lt;- abs( taildepCOP(cop=GHcop, para=Theta)$lambdaU - (2-2^(1/Theta)) )
as.logical(del.lamU &lt; 1E-6) # TRUE
## Not run: 
# The simulations match Joe (2014, p. 72) for Gumbel-Hougaard
n &lt;- 600; nsim &lt;- 1000; set.seed(946) # see for reproducibility
SM &lt;- sapply(1:nsim, function(i) { rs &lt;- semicorCOP(cop=GHcop, para=1.35, n=n)
                                 c(rs$botleft.semicor, rs$topright.semicor) })
RhoM     &lt;- round(mean(SM[1,]),          digits=3)
RhoP     &lt;- round(mean(SM[2,]),          digits=3)
SE.RhoM  &lt;- round(  sd(SM[1,]),          digits=3)
SE.RhoP  &lt;- round(  sd(SM[2,]),          digits=3)
SE.RhoMP &lt;- round(  sd(SM[2,] - SM[1,]), digits=3)
# Semi-correlations (sRho) and standard errors (SEs)
message("# sRho[-]=", RhoM, " (SE[-]=", SE.RhoM, ") Joe(p.72)=0.132 (SE[-]=0.08)")
message("# sRho[+]=", RhoP, " (SE[+]=", SE.RhoP, ") Joe(p.72)=0.415 (SE[+]=0.07)")
message("# SE(sRho[-] - sRho[+])=", SE.RhoMP, " Joe(p.72) SE=0.10")
# sRho[-]=0.134 (SE[-]=0.076) Joe(p.72)=0.132 (SE[-]=0.08)
# sRho[+]=0.407 (SE[+]=0.074) Joe(p.72)=0.415 (SE[+]=0.07)
# SE(sRho[-] - sRho[+])=0.107 Joe(p.72) SE=0.10
# Joe (2014, p. 72) reports the values 0.132, 0.415, 0.08, 0.07, 0.10, respectively.
## End(Not run)

## Not run: 
file &lt;- "Lcomom_study_of_GHcopPLACKETTcop.txt"
x &lt;- data.frame(tau=NA, trho=NA, srho=NA, PLtheta=NA, PLT2=NA, PLT3=NA, PLT4=NA,
                                          GHtheta=NA, GHT2=NA, GHT3=NA, GHT4=NA )
write.table(x, file=file, row.names=FALSE, quote=FALSE)
n &lt;- 250 # Make a large number for very long CPU run but seems stable
for(tau in seq(0,0.98, by=0.005)) {
   thetag &lt;- GHcop(u=NULL, v=NULL, tau=tau)$para
   trho   &lt;- rhoCOP(cop=GHcop, para=thetag)
   GH     &lt;- simCOP(n=n, cop=GHcop, para=thetag, points=FALSE, ploton=FALSE)
   srho   &lt;- cor(GH$U, GH$V, method="spearman")
   thetap &lt;- PLACKETTpar(rho=trho)
   PL     &lt;- simCOP(n=n, cop=PLACKETTcop, para=thetap, points=FALSE, ploton=FALSE)
   GHl    &lt;- lmomco::lcomoms2(GH, nmom=4); PLl &lt;- lmomco::lcomoms2(PL, nmom=4)
   x &lt;- data.frame(tau=tau, trho=trho, srho=srho,
                   GHtheta=thetag, PLtheta=thetap,
                   GHT2=mean(c(GHl$T2[1,2], GHl$T2[2,1])),
                   GHT3=mean(c(GHl$T3[1,2], GHl$T3[2,1])),
                   GHT4=mean(c(GHl$T4[1,2], GHl$T4[2,1])),
                   PLT2=mean(c(PLl$T2[1,2], PLl$T2[2,1])),
                   PLT3=mean(c(PLl$T3[1,2], PLl$T3[2,1])),
                   PLT4=mean(c(PLl$T4[1,2], PLl$T4[2,1])) )
   write.table(x, file=file, row.names=FALSE, col.names=FALSE, append=TRUE)
}

# After a processing run with very large "n", then meaningful results exist.
D &lt;- read.table(file, header=TRUE); D &lt;- D[complete.cases(D),]
plot(D$tau, D$GHT3, ylim=c(-0.08,0.08), type="n",
     xlab="KENDALL TAU", ylab="L-COSKEW OR NEGATED L-COKURTOSIS")
points(D$tau,  D$GHT3, col=2);             points(D$tau,  D$PLT3, col=1)
points(D$tau, -D$GHT4, col=4, pch=2);      points(D$tau, -D$PLT4, col=1, pch=2)
LM3 &lt;- lm(D$GHT3~I(D$tau^1)+I(D$tau^2)+I(D$tau^4)-1)
LM4 &lt;- lm(D$GHT4~I(D$tau^1)+I(D$tau^2)+I(D$tau^4)-1)
LM3c &lt;- LM3$coe; LM4c &lt;- LM4$coe
Tau &lt;- seq(0,1, by=.01); abline(0,0, lty=2, col=3)
lines(Tau,   0 + LM3c[1]*Tau^1 + LM3c[2]*Tau^2 + LM3c[3]*Tau^4,  col=4, lwd=3)
lines(Tau, -(0 + LM4c[1]*Tau^1 + LM4c[2]*Tau^2 + LM4c[3]*Tau^4), col=2, lwd=3) #
## End(Not run)

## Not run: 
# Let us compare the conditional simulation method of copBasic by numerics and by the
# above analytical solution for the Gumbel-Hougaard copula to two methods implemented
# by package gumbel, a presumed Archimedean technique by package acopula, and an
# Archimedean technique by package copula. Setting seeds by each "method" below does
# not appear diagnostic because of the differences in which the simulations are made.
nsim &lt;- 10000; kn &lt;- "kendall" #  The theoretical KENDALL TAU is (1.5-1)/1.5 = 1/3
# Simulate by conditional simulation using numerical derivative and then inversion
A &lt;- cor(copBasic::simCOP(nsim, cop=GHcop, para=1.5, graphics=FALSE), method=kn)[1,2]
U &lt;- runif(nsim) # GHcop.derCOPinv() comes from earlier in this documentation.
V &lt;- sapply(1:nsim, function(i) { GHcop.derCOPinv(U[i], runif(1), para=1.5) })
# Simulate by conditional simulation using exact analytical solution
B &lt;- cor(U, y=V, method=kn);  rm(U, V)
# Simulate by the "common frailty" technique
C &lt;- cor(gumbel::rgumbel(nsim, 1.5, dim=2, method=1), method=kn)[1,2]
# Simulate by "K function" (Is the K function method, Archimedean?)
D &lt;- cor(gumbel::rgumbel(nsim, 1.5, dim=2, method=2), method=kn)[1,2]
# Simulate by an Archimedean implementation (presumably)
E &lt;- cor(acopula::rCopula(nsim, pars=1.5), method=kn)[1,2]
# Simulate by an Archimedean implementation
G &lt;- cor(copula::rCopula(nsim, copula::gumbelCopula(1.5)), method=kn)[1,2]
K &lt;- round(c(A, B, C, D, E, G), digits=5); rm(A, B, C, D, E, G, kn); tx &lt;- ", "
message("Kendall Tau: ", K[1], tx, K[2], tx, K[3], tx, K[4], tx, K[5], tx, K[6])
# Kendall Tau: 0.32909, 0.32474, 0.33060, 0.32805, 0.32874, 0.33986 -- run 1
# Kendall Tau: 0.33357, 0.32748, 0.33563, 0.32913, 0.32732, 0.32416 -- run 2
# Kendall Tau: 0.34311, 0.33415, 0.33815, 0.33224, 0.32961, 0.33008 -- run 3
# Kendall Tau: 0.32830, 0.33573, 0.32756, 0.33401, 0.33567, 0.33182 -- nsim=50000!
# All solutions are near 1/3 and it is unknown without further study which of the
# six methods would result in the least bias and (or) sampling variability.
## End(Not run)
</code></pre>


</div>