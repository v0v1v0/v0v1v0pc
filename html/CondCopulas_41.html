<div class="container">

<table style="width: 100%;"><tr>
<td>conv_treeCKT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Converting to matrix of indicators / matrix of conditional Kendall's tau</h2>

<h3>Description</h3>

<p>The function <code>treeCKT2matrixInd</code>
takes as input a binary tree that has been returned
by the function <code>bCond.treeCKT</code>.
Since this tree describes a partition of the conditioning space,
it can be interesting to get, for a given dataset, the matrix
</p>
<p style="text-align: center;"><code class="reqn">1\{ X_{i,J} \in A_{j,J} \},</code>
</p>

<p>where each <code class="reqn">A_{j,J}</code> corresponds to a conditioning subset.
This is the so-called <code>matrixInd</code>.
Finally, it can be interesting to get the matrix of
</p>


<h3>Usage</h3>

<pre><code class="language-R">treeCKT2matrixInd(estimatedTree, newDataXJ = NULL)

matrixInd2matrixCKT(matrixInd, newDataXI)

treeCKT2matrixCKT(estimatedTree, newDataXI = NULL, newDataXJ = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>estimatedTree</code></td>
<td>
<p>the tree that has been estimated before,
for example by <code>bCond.treeCKT</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newDataXJ</code></td>
<td>
<p>this is a matrix of size <code>N * |J|</code>
where <code>|J|</code> is the number of conditional variables used in the tree.
By default this is <code>NULL</code> meaning that
we return the matrix for the original data
(that was used to compute the <code>estimatedTree</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrixInd</code></td>
<td>
<p>a matrix of indexes of size (n, N.boxes) describing
for each observation i to which box ( = event) it belongs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newDataXI</code></td>
<td>
<p>this is a matrix of size <code>N * |I|</code>
where <code>|I|</code> is the number of conditioned variables.
By default this is <code>NULL</code> meaning that
we return the matrix for the original data
used to compute the <code>estimatedTree</code></p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li>
<p> The function <code>treeCKT2matrixInd</code> returns
a matrix of size <code>N * m</code> which component <code>[i,j]</code>
is </p>
<p style="text-align: center;"><code class="reqn">1\{ X_{i,J} \in A_{j,J} \}</code>
</p>
<p>.
</p>
</li>
<li>
<p> The function <code>matrixInd2matrixCKT</code> and <code>treeCKT2matrixCKT</code> return
a matrix of size <code>|I| * (|I|-1) * m</code> where each component corresponds
to a conditional Kendall's tau between a pair of conditional variables
conditionally to the conditioned variables in one of the boxes
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>bCond.treeCKT</code> for the construction of such a binary tree.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n = 200
XJ = MASS::mvrnorm(n = n, mu = c(3,3), Sigma = rbind(c(1, 0.2), c(0.2, 1)))
XI = matrix(nrow = n, ncol = 2)
high_XJ1 = which(XJ[,1] &gt; 4)
XI[high_XJ1, ]  = MASS::mvrnorm(n = length(high_XJ1), mu = c(10,10),
                                Sigma = rbind(c(1, 0.8), c(0.8, 1)))
XI[-high_XJ1, ] = MASS::mvrnorm(n = n - length(high_XJ1), mu = c(8,8),
                                Sigma = rbind(c(1, -0.2), c(-0.2, 1)))

result = bCond.treeCKT(XI = XI, XJ = XJ, minSize = 10, verbose = 2)

treeCKT2matrixInd(result)

matrixInd2matrixCKT(treeCKT2matrixInd(result), newDataXI = XI)

treeCKT2matrixCKT(result)

</code></pre>


</div>