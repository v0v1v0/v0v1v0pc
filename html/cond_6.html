<div class="container">

<table style="width: 100%;"><tr>
<td>cond.glm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Approximate Conditional Inference for Logistic and Loglinear Models
</h2>

<h3>Description</h3>

<p>Performs approximate conditional inference on a scalar parameter of 
interest in logistic and loglinear models.  The output is stored in
an object of class <code>cond</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'glm'
cond(object, offset, formula = NULL, family = NULL, 
         data = sys.frame(sys.parent()), pts = 20, 
         n = max(100, 2*pts), tms = 0.6, from = NULL, to = NULL, 
         control = glm.control(...), trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>a <code>glm</code> object.  Families supported are binomial and Poisson
with canonical link function.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>

<p>the covariate occurring in the model formula whose coefficient
represents the parameter of interest.  May be numerical or a 
two-level factor.  In case of a two-level factor, it must be 
coded by contrasts and not appear as two dummy variables in the 
model.  Can also be a call to a mathematical function (such as 
<code>exp</code>, <code>sin</code>, ...) or to  a mathematical operator 
(<code>^</code>, <code>/</code>, ...) applied to a numerical variable.
The call must always agree with the label used to identify the
corresponding parameter in the <code>glm</code> object passed through 
the <code>object</code> argument or defined by <code>formula</code> and 
<code>family</code>.  Beware that the label includes the identity 
function <code>I()</code> if an  arithmetic operator was used.  Other 
function types (e.g. <code>factor</code>) and interactions are not 
admitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>a formula expression (only if no <code>glm</code> object is defined).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>a <code>family</code> object defining the variance function (only if no
<code>glm</code> object is defined).  Families supported are binomial 
and Poisson with canonical link function. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame in which to interpret the variables 
occurring in the formula (only if no <code>glm</code> object is 
defined).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pts</code></td>
<td>

<p>number of output points (minimum 10) that are calculated exactly.
The default is 20. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>approximate number of output points (minimum 50) produced by the
spline interpolation.  The default is the maximum between 100 and 
twice <code>pts</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tms</code></td>
<td>

<p>defines the range <abbr><span class="acronym">MLE</span></abbr> +/- <code>tms</code> * <abbr><span class="acronym">s.e.</span></abbr> 
where cubic spline interpolation is replaced by polynomial 
interpolation.  The default is 0.6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>

<p>starting value of the sequence that contains the values of the 
parameter of interest for which output points are calculated 
exactly.  The default is <abbr><span class="acronym">MLE</span></abbr> - 3.5 * <abbr><span class="acronym">s.e.</span></abbr>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>

<p>ending value of the sequence that contains the values of the 
parameter of interest for which output points are calculated 
exactly.  The default is <abbr><span class="acronym">MLE</span></abbr> +  3.5 * <abbr><span class="acronym">s.e.</span></abbr>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>a list of iteration and algorithmic constants that controls the 
<abbr><span class="acronym">GLM</span></abbr> fit.  See \ <code>glm.control</code> for their 
names and default values.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>if <code>TRUE</code>, iteration numbers will be printed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments, such as <code>subset</code> etc., used by the 
<code>glm</code> fitting routine if the <code>glm</code> object 
is defined through <code>formula</code> and <code>family</code>.  See 
<code>glm</code> for their definition and use.  The
arguments <code>weights</code>, <code>offset</code> and <code>contrasts</code> are 
not admitted.  The returned value is an object of class <code>cond</code>; 
see <code>cond.object</code> for details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a method for the generic function <code>cond</code> for 
class <code>glm</code>.  It can be invoked by calling <code>cond</code> 
for an object of the appropriate class, or directly by calling 
<code>cond.glm</code> regardless of the class of the object.  
<code>cond.glm</code> has also to be used if the <code>glm</code> object is not
provided throught the <code>object</code> argument but specified by 
<code>formula</code> and <code>family</code>.
</p>
<p>The function <code>cond.glm</code> implements several small sample 
asymptotic methods for approximate conditional inference in 
logistic and loglinear models.  Approximations for both the 
conditional log likelihood function and conditional tail area 
probabilities are available (see <code>cond.object</code> for 
details).  Attention is restricted to a scalar parameter of 
interest.  The associated covariate can be either numerical or 
a two-level factor. 
</p>
<p>Approximate conditional inference is performed by either updating a
fitted generalized linear model or defining the model formula and 
family.  All approximations are calculated exactly for <code>pts</code> 
equally spaced points ranging from <code>from</code> to <code>to</code>.  A 
cubic spline interpolation is used to extend them over the whole 
interval of interest, except for the range of values defined by 
<abbr><span class="acronym">MLE</span></abbr> +/- <code>tms</code> * <abbr><span class="acronym">s.e.</span></abbr> where the spline 
interpolation is replaced by a higher order polynomial 
interpolation.  This is done in order to avoid numerical 
instabilities which are likely to occur for values of the parameter 
of interest close to the <abbr><span class="acronym">MLE</span></abbr>.  Results are stored in an 
object of class <code>cond</code>.  Method functions like <code>print</code>, 
<code>summary</code> and <code>plot</code> can be used to examine the output or 
represent it graphically.  Components can be extracted using 
<code>coef</code>, <code>formula</code> and <code>family</code>.
</p>
<p>Main references for the methods considered are the papers by 
<cite>Pierce and Peters (1992)</cite> and <cite>Davison (1988)</cite>.  More 
details on the implementation are given in <cite>Brazzale (1999, 
2000)</cite>.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>cond</code>; see 
<code>cond.object</code> for details.
</p>


<h3>Note</h3>

<p>In rare occasions, <code>cond.glm</code> dumps because of non-convergence
of the function <code>glm</code> which is used to refit the model for a 
fixed value of the parameter of interest.  This happens for instance
if this value is too extreme.  The arguments <code>from</code> and 
<code>to</code> may then be used to limit the default range of 
<abbr><span class="acronym">MLE</span></abbr> +/- 3.5 * <abbr><span class="acronym">s.e.</span></abbr>  A further possibility is to
fine-tuning the constants (number of iterations, convergence 
threshold) that control the <abbr><span class="acronym">GLM</span></abbr> fit through the 
<code>control</code> argument. 
</p>
<p><code>cond.glm</code> may also dump if the estimate of the parameter of 
interest is large (tipically &gt; 400) in absolute value.  This may be
avoided by reparametrizing the model.
</p>
<p>The output of <code>cond.glm</code> may be unreliable if part of the data
have a degenerate distribution.  For example take the fungal 
infections treatment data contained in the <code>fungal</code> data
frame.  Of the five <code class="reqn">2\times 2</code> contingency tables, two 
(the first and the third) are degenerate.  As they make no 
contribution to the exact conditional likelihood, they should be 
omitted from the approximate conditional fit.  
</p>


<h3>References</h3>

<p>Brazzale, A. R. (1999) Approximate conditional inference for 
logistic and loglinear models.  <em>J. Comput. Graph. Statist.</em>, 
<b>8</b>, 1999, 653–661.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>
<p>Davison, A. C. (1988) Approximate conditional inference in 
generalized linear models.  <em>J. R. Statist. Soc.</em> B, <b>50</b>,
445–461.
</p>
<p>Pierce, D. A. and Peters, D. (1992) Practical use of higher order 
asymptotics for multiparameter exponential families (with 
Discussion).  <em>J. R. Statist. Soc.</em> B, <b>54</b>, 701–737.
</p>


<h3>See Also</h3>

<p><code>cond.object</code>, <code>summary.cond</code>, 
<code>plot.cond</code>, <code>glm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Crying Babies Data
data(babies)
babies.glm &lt;- glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                  family = binomial, data = babies)
babies.cond &lt;- cond(object = babies.glm, offset = lullyes)
babies.cond
##
## If one wishes to avoid the generalized linear model fit:
babies.cond &lt;- cond.glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                        family = binomial, data = babies, offset = lullyes)
babies.cond

## Urine Data 
## (function call as offset variable) 
data(urine)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + log(calc), 
                 family = binomial, data = urine)
labels(coef(urine.glm))
urine.cond &lt;- cond(urine.glm, log(calc))
##
## (large estimate of regression coefficient)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.glm &lt;- glm(r ~ I(gravity * 100) + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.cond &lt;- cond(urine.glm, I(gravity * 100))

## Fungal Infections Treatment Data (numerical instabilities around the
##                                   MLE)
## (full data analysis)
data(fungal)
fungal.glm &lt;- glm(cbind(success, failure) ~ center + group - 1, 
                  family = binomial, data = fungal, 
                  control = glm.control(maxit = 50, epsilon = 1e-005))
fungal.cond &lt;- cond(fungal.glm, groupT)
plot(fungal.cond, which = 2)
## (partial data analysis)
fungal.glm &lt;- glm(cbind(success, failure) ~ center + group - 1, 
                  family = binomial, data = fungal, subset = -c(1,2,5,6), 
                  control = glm.control(maxit = 50, epsilon = 1e-005))
fungal.cond &lt;- cond(fungal.glm, groupT)
plot(fungal.cond, which = 2)
## (Tables 1 and 3 are omitted).
</code></pre>


</div>