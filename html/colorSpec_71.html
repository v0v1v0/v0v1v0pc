<div class="container">

<table style="width: 100%;"><tr>
<td>invert</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>estimate spectra from responses, effectively inverting the operator from spectrum to response</h2>

<h3>Description</h3>

<p>Given a light responder (e.g. an eye or a camera),
two light spectra that produce the same response from the responder
are called <em>metamers</em> for that responder.
Similarly, given a material responder (e.g. a scanner),
two reflectance spectra that produce the same response from the responder
are called <em>metamers</em> for that responder.
</p>
<p>For a given responder and response, 
there are typically infinitely many <em>metamers</em>.
The set of all of them is often called the <em>metameric suite</em>.
The goal of the function <code>invert()</code> is to calculate a "good" metamer
in the "suite".
<cite>Koenderink</cite> calls this topic <em>inverse colorimetry</em>.
In the case that the estimated spectrum is a reflectance spectrum,
the topic is often called <em>reflectance estimation</em> or <em>reflectance recovery</em>,
see <cite>Bianco</cite>.
</p>
<p>The <em>centroid method</em>, which is the default and the featured method
in this package, computes the centroid of the set of all the metamers (if any).
The centroid is computed in an infinite-dimensional context 
and is expounded further in
<cite>Davis</cite>.
</p>
<p>The <em>Hawkyard method</em>, see <cite>Hawkyard</cite> and <cite>Bianco</cite>,
has been around a long time.
The centroid and Hawkyard methods have similarities,
e.g. both are low-dimensional with the number of variables equal to
the number of responses (usually 3).
The Hawkyard method is very fast, but has a key problem, see below.
</p>
<p>The <em>Transformed Least Slope Squared</em> (TLSS) method was developed
by Scott Burns, see <b>References</b>.
This is my name for it, not his.
What I call TLLS is actually is a combination of Burns' LHTSS and LLSS methods;
the one that <code>invert()</code> chooses depends on <code>type(x)</code>, see below.
Both of these are high-dimensional,
with the number of variables equal to #(responses) + #(wavelengths).
</p>
<p>The first argument to <code>invert()</code> is the responder <code>x</code>,
and the second is the matrix <code>response</code> of responses (e.g. XYZs or RGBs).
</p>
<p>The goal is to return a "good" spectrum for each response so that:
</p>

<table><tr>
<td style="text-align: center;">
<code>product( invert(x,response), x )</code> <code class="reqn">~\cong~</code> <code>response</code>
</td>
</tr></table>
<p>The error is returned as column <code>estim.precis</code>, see below.
</p>
<p>First consider the case where <code>x</code> has type <code>type='responsivity.material'</code>.
The goal is to compute a reflectance spectra.
All the methods will fail if the response is on the object-color boundary
(an <em>optimal color</em>) or outside the boundary.
They <em>may</em> also fail if the response is inside the object-color
solid (the <em>Rösch Farbkörper</em>) and very close to the boundary.
<br>
The centroid method solves a non-linear system that contains a 
<em>Langevin-function-based</em> squashing function, see <cite>Davis</cite> for details.
When successful it always returns a feasible spectrum
with small <code>estim.precis</code>.
<br>
The Hawkyard method is linear and very fast,
but in raw form it may return a non-feasible reflectance spectrum.
In this case <code>invert()</code> simply clamps to the interval [0,1] and so
<code>estim.precis</code> can be large.
<br>
The TLSS method solves a non-linear system that contains
the squashing function <code class="reqn">(\tanh(z) + 1)/2</code>, see <cite>Burns</cite> for details.
When successful it always returns a feasible spectrum
with small <code>estim.precis</code>.
</p>
<p>Now consider the case where <code>x</code> has <code>type='responsivity.light'</code>.
The goal is to compute the spectrum of a light source.
All the methods will fail if chromaticity of the response is on the boundary
of the inverted-U (assuming <code>x</code> models the human eye) or outside the boundary.
They <em>may</em> also fail if the response is inside the inverted-U
and very close to the boundary.
<br>
The centroid method works on a relatively small range of chromaticities;
it will fail if the response is too far from the response to Illuminant E.
See <cite>Davis</cite> for the details.
When successful it always returns an everywhere positive spectrum
with small <code>estim.precis</code>.
This method has the desirable property that if the response is multiplied by
a positive number, the computed spectrum is multiplied by that same number.
<br>
The Hawkyard method does not work in this case.
<br>
The TLSS method solves a non-linear system that contains
the squashing function <code class="reqn">\exp(z)</code>, see <cite>Burns</cite> for the details.
When successful it always returns an everywhere positive spectrum
with small <code>estim.precis</code>.
This method succeeds on a larger set of chromaticities than the centroid method.
It also has the desirable scaling multiplication property mentioned above.
</p>
<p>The centroid and Hawkyard methods have an equalization option,
which is controlled by the argument <code>alpha</code>
and is enabled by default, see below.
When enabled, if the response comes from a constant spectrum
(a perfectly neutral gray material, or a multiple of Illuminant E),
then the computed spectrum is that same constant spectrum (up to numerical precision).
I call this the <em>neutral-exact property</em>.
Equalization is a complicated mechanism, for details see <cite>Davis</cite>.
For the TLSS method, the neutral-exact property is intrinsic,
and <code>alpha</code> is ignored.
<br>
NOTE:
If the responder has only one output channel (e.g. a monochrome camera)
and equalization is enabled,
then <em>all</em> responses are inverted to a constant spectrum.
This may or may not be desirable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'colorSpec'
invert( x, response, method='centroid', alpha=1 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type(x)</code> = 
<code>'responsivity.material'</code> or <code>'responsivity.light'</code> and M responsivities.
The wavelengths must be regular (equidistant).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p> a numeric NxM matrix, or a numeric vector that can be converted
to such matrix, by row. The N responses are contained in the rows.
The <code>rownames(response)</code> are copied to the output <code>specnames</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>either <code>'centroid'</code> or <code>'Hawkyard'</code> or <code>'TLSS'</code>.  
<code>'Hawkyard'</code> is only valid when 
<code>type(x)</code> is <code>'responsivity.material'</code>.
Matching is partial and case-insensitive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a vector of M weighting coefficients, 
or a single number that is replicated to length M. 
When <code>method='centroid'</code>, <code>alpha</code> is used for <em>equalizing</em> 
the responsivities, which is recommended.
For <code>alpha</code> to be valid, the linear combination of the M responsitivies,
with coefficients <code>alpha</code>, must be positive.
To disable equalization (not recommended) and use the original responsivities, 
set <code>alpha=NULL</code>. 
Similarly, when <code>method='Hawkyard'</code>, <code>alpha</code> is used for equalizing 
the responsivities, which is also recommended.
When <code>method='TLSS'</code>, <code>alpha</code> is ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>method='centroid'</code> the function calls the non-linear root-finder 
<code>rootSolve::multiroot()</code>,
which is general purpose and "full Newton".

</p>
<p>For <code>method='Hawkyard'</code> the function solves a linear system by
inverting a small matrix (#[responses] x #[responses]).
The spectra are then clamped to [0,1].
</p>
<p>For <code>method='TLSS'</code> the function solves a constrained least-squares problem
using Lagrange multipliers.
A critical point is found using a "full Newton" iteration.
The original MATLAB code is posted at <cite>Burns</cite>,
and was  ported from MATLAB to R with only trivial changes.
When computing a reflectance spectrum, the Hawkyard method is used for the
initial guess, after little extra clamping.
This improved guess cuts the number of iterations substantially, 
and the extra computation time is negligible.
</p>


<h3>Value</h3>

<p>If <code>type(x)='responsivity.material'</code> it returns a <b>colorSpec</b> object
with <code>type</code> = <code>'material'</code> (<code>quantity</code> = <code>'reflectance'</code>).
</p>
<p>If <code>type(x)='responsivity.light'</code> it returns a <b>colorSpec</b> object
with <code>type</code> = <code>'light'</code>
(<code>quantity</code>=<code>'energy'</code> or <code>quantity</code>=<code>'photons'</code>
depending on <code>quantity(x)</code>).
</p>
<p>In either case, the returned object has <code>organization</code> = <code>'df.row'</code> 
and the <code>extradata</code> is a <code>data.frame</code> with these columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>the input matrix of desired responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estim.precis</code></td>
<td>
<p>the difference between the desired response and actual response.  It   is the mean of the absolute value of the differences.
See <code>rootSolve::multiroot()</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.msec</code></td>
<td>
<p>the time to compute the spectrum, in msec. 
When <code>method='Hawkyard'</code>, all N spectra are computed at once, 
so all N spectra are assigned the same mean time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iters</code></td>
<td>
<p>the number of iterations that were required to find the relevant root. 
This is not present when <code>method='Hawkyard'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clamped</code></td>
<td>
<p>a logical indicating whether the reflectance was clamped to [0,1]. This is present only  when <code>method='Hawkyard'</code>.</p>
</td>
</tr>
</table>
<p>If a response could not be estimated, 
the row contains <code>NA</code> in appropriate columns,
and a warning is issued.<br></p>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>Known Issues</h3>

<p>If <code>type(x)='responsivity.light'</code> the centroid method may fail
(not converge) if the response is too far from that of Illuminant E.
</p>


<h3>References</h3>

<p>Davis, Glenn.
A Centroid for Sections of a Cube in a Function Space, with Application to Colorimetry.
<a href="https://arxiv.org/abs/1811.00990">https://arxiv.org/abs/1811.00990</a>.
[math.FA].
2018.
</p>
<p>Bianco, Simone.
Reflectance spectra recovery from tristimulus values by adaptive estimation with metameric shape correction.
vol. 27, no 8.
<em>Journal of the Optical Society of America A</em>.
pages 1868-1877.
2010
<a href="https://opg.optica.org/josaa/abstract.cfm?uri=josaa-27-8-1868">https://opg.optica.org/josaa/abstract.cfm?uri=josaa-27-8-1868</a>.
</p>
<p>Burns, Scott A. 
Generating Reflectance Curves from sRGB Triplets.
<a href="http://scottburns.us/reflectance-curves-from-srgb/">http://scottburns.us/reflectance-curves-from-srgb/</a>.
</p>
<p>Hawkyard, C. J.
Synthetic reflectance curves by additive mixing.
<em>Journal of the Society of Dyers and Colourists</em>.
vol. 109. no. 10.
Blackwell Publishing Ltd.
pp. 323-329.
1993.
</p>
<p>Koenderink, J.J.
Color for the Sciences.
MIT Press.
2010.
</p>


<h3>See Also</h3>

<p><code>type()</code>,
<code>quantity()</code>,
<code>organization()</code>,
<code>specnames()</code>,
<code>product()</code>,
<code>extradata()</code>,
<code>rootSolve::multiroot()</code>,
vignette <a href="../doc/inversion.pdf"><b>Estimating a Spectrum from its Response</b></a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">wave = 400:700
E.eye = product( illuminantE(1,wave), "material", xyz1931.1nm, wavelength=wave )
path = system.file( 'extdata/targets/CC_Avg30_spectrum_CGATS.txt', package='colorSpec' )
MacbethCC = readSpectra( path, wavelength=wave )
XYZ = product( MacbethCC, E.eye, wavelength=wave )
est.eq   = invert( E.eye, XYZ, method='centroid', alpha=1 )
extra   = extradata(est.eq)
range(extra$estim.precis)       # prints   0.000000e+00 3.191741e-08
</code></pre>


</div>