<div class="container">

<table style="width: 100%;"><tr>
<td>mb.splsdrcox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MB.sPLS-DRCOX</h2>

<h3>Description</h3>

<p>The MB.sPLS-DRCOX function conducts a multi-block sparse partial least squares deviant residuals
Cox (MB.sPLS-DRCOX) using a dynamic variable selection approach. This analysis is particularly
suited for high-dimensional datasets where the goal is to identify the relationship between
explanatory variables and survival outcomes. The function outputs a model of class "Coxmos" with
an attribute labeled "MB.sPLS-DRCOX".
</p>


<h3>Usage</h3>

<pre><code class="language-R">mb.splsdrcox(
  X,
  Y,
  n.comp = 4,
  vector = NULL,
  MIN_NVAR = 10,
  MAX_NVAR = 10000,
  n.cut_points = 5,
  EVAL_METHOD = "AUC",
  x.center = TRUE,
  x.scale = FALSE,
  remove_near_zero_variance = TRUE,
  remove_zero_variance = TRUE,
  toKeep.zv = NULL,
  remove_non_significant = TRUE,
  alpha = 0.05,
  MIN_AUC_INCREASE = 0.01,
  pred.method = "cenROC",
  max.iter = 200,
  times = NULL,
  max_time_points = 15,
  MIN_EPV = 5,
  returnData = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix or data.frame. Explanatory variables. Qualitative variables must be
transform into binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric matrix or data.frame. Response variables. Object must have two columns named as
"time" and "event". For event column, accepted values are: 0/1 or FALSE/TRUE for censored and
event observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.comp</code></td>
<td>
<p>Numeric. Number of latent components to compute for the (s)PLS model (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vector</code></td>
<td>
<p>Numeric vector. Used for computing best number of variables. As many values as
components have to be provided. If vector = NULL, an automatic detection is perform (default: NULL). If
vector is a list, must be named as the names of X param followed by the number of variables to select.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_NVAR</code></td>
<td>
<p>Numeric. Minimum range size for computing cut points to select the best number of
variables to use (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MAX_NVAR</code></td>
<td>
<p>Numeric. Maximum range size for computing cut points to select the best number of
variables to use (default: 1000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cut_points</code></td>
<td>
<p>Numeric. Number of cut points for searching the optimal number of variables.
If only two cut points are selected, minimum and maximum size are used. For MB approaches as many
as n.cut_points^n.blocks models will be computed as minimum (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EVAL_METHOD</code></td>
<td>
<p>Character. If EVAL_METHOD = "AUC", AUC metric will be use to compute the best
number of variables. In other case, c-index metric will be used (default: "AUC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.center</code></td>
<td>
<p>Logical. If x.center = TRUE, X matrix is centered to zero means (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.scale</code></td>
<td>
<p>Logical. If x.scale = TRUE, X matrix is scaled to unit variances (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_near_zero_variance</code></td>
<td>
<p>Logical. If remove_near_zero_variance = TRUE, near zero variance
variables will be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_zero_variance</code></td>
<td>
<p>Logical. If remove_zero_variance = TRUE, zero variance variables will
be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toKeep.zv</code></td>
<td>
<p>Character vector. Name of variables in X to not be deleted by (near) zero variance
filtering (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant</code></td>
<td>
<p>Logical. If remove_non_significant = TRUE, non-significant
variables/components in final cox model will be removed until all variables are significant by
forward selection (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Numerical values are regarded as significant if they fall below the
threshold (default: 0.05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC_INCREASE</code></td>
<td>
<p>Numeric. Minimum improvement between different cross validation models to
continue evaluating higher values in the multiple tested parameters. If it is not reached for next
'MIN_COMP_TO_CHECK' models and the minimum 'MIN_AUC' value is reached, the evaluation stops
(default: 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.method</code></td>
<td>
<p>Character. AUC evaluation algorithm method for evaluate the model performance.
Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C",
"smoothROCtime_I" (default: "cenROC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Numeric. Maximum number of iterations for PLS convergence (default: 200).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of
'max_time_points' points will be selected equally distributed (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time_points</code></td>
<td>
<p>Numeric. Maximum number of time points to use for evaluating the model
(default: 15).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_EPV</code></td>
<td>
<p>Numeric. Minimum number of Events Per Variable (EPV) you want reach for the final
cox model. Used to restrict the number of variables/components can be computed in final cox models.
If the minimum is not meet, the model cannot be computed (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnData</code></td>
<td>
<p>Logical. Return original and normalized X and Y matrices (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The MB.sPLS-DRCOX methodology is designed to handle multi-block datasets, where each block
represents a set of related variables. By employing a sparse partial least squares approach,
the function efficiently selects relevant variables from each block, ensuring that the final
model is both interpretable and predictive. The Cox proportional hazards model is then applied to
the selected variables to assess their association with survival outcomes.
</p>
<p>The function offers flexibility in terms of parameter tuning. For instance, users can specify the
number of latent components to compute, the range of variables to consider for optimal selection,
and the evaluation metric (either AUC or c-index). Additionally, data preprocessing options are
available, such as centering and scaling of the explanatory variables, and removal of variables
with near-zero or zero variance.
</p>


<h3>Value</h3>

<p>Instance of class "Coxmos" and model "MB.sPLS-DRCOX". The class contains the following
elements:
<code>X</code>: List of normalized X data information.
</p>

<ul>
<li> <p><code>(data)</code>: normalized X matrix
</p>
</li>
<li> <p><code>(weightings)</code>: PLS weights
</p>
</li>
<li> <p><code>(weightings_norm)</code>: PLS normalize weights
</p>
</li>
<li> <p><code>(W.star)</code>: PLS W* vector
</p>
</li>
<li> <p><code>(scores)</code>: PLS scores/variates
</p>
</li>
<li> <p><code>(E)</code>: error matrices
</p>
</li>
<li> <p><code>(x.mean)</code>: mean values for X matrix
</p>
</li>
<li> <p><code>(x.sd)</code>: standard deviation for X matrix
</p>
</li>
</ul>
<p><code>Y</code>: List of normalized Y data information.
</p>

<ul>
<li> <p><code>(deviance_residuals)</code>: deviance residual vector used as Y matrix in the sPLS.
</p>
</li>
<li> <p><code>(dr.mean)</code>: mean values for deviance residuals Y matrix
</p>
</li>
<li> <p><code>(dr.sd)</code>: standard deviation for deviance residuals Y matrix'
</p>
</li>
<li> <p><code>(data)</code>: normalized X matrix
</p>
</li>
<li> <p><code>(y.mean)</code>: mean values for Y matrix
</p>
</li>
<li> <p><code>(y.sd)</code>: standard deviation for Y matrix'
</p>
</li>
</ul>
<p><code>survival_model</code>: List of survival model information.
</p>

<ul>
<li> <p><code>fit</code>: coxph object.
</p>
</li>
<li> <p><code>AIC</code>: AIC of cox model.
</p>
</li>
<li> <p><code>BIC</code>: BIC of cox model.
</p>
</li>
<li> <p><code>lp</code>: linear predictors for train data.
</p>
</li>
<li> <p><code>coef</code>: Coefficients for cox model.
</p>
</li>
<li> <p><code>YChapeau</code>: Y Chapeau residuals.
</p>
</li>
<li> <p><code>Yresidus</code>: Y residuals.
</p>
</li>
</ul>
<p><code>mb.model</code>: List of sPLS models computed for each block.
</p>
<p><code>n.comp</code>: Number of components selected.
</p>
<p><code>n.varX</code>: Number of variables selected for each block.
</p>
<p><code>call</code>: call function
</p>
<p><code>X_input</code>: X input matrix
</p>
<p><code>Y_input</code>: Y input matrix
</p>
<p><code>B.hat</code>: PLS beta matrix
</p>
<p><code>R2</code>: PLS R2
</p>
<p><code>SCR</code>: PLS SCR
</p>
<p><code>SCT</code>: PLS SCT
</p>
<p><code>nzv</code>: Variables removed by remove_near_zero_variance or remove_zero_variance.
</p>
<p><code>nz_coeffvar</code>: Variables removed by coefficient variation near zero.
</p>
<p><code>time</code>: time consumed for running the cox analysis.
</p>


<h3>Author(s)</h3>

<p>Pedro Salguero Garcia. Maintainer: pedsalga@upv.edu.es
</p>


<h3>References</h3>

<p>Rohart F, Gautier B, Singh A, Cao KAL (2017).
“mixOmics: An R package for ‘omics feature selection and multiple data integration.”
<em>PLoS Computational Biology</em>, <b>13</b>(11).
ISSN 15537358, <a href="https://pubmed.ncbi.nlm.nih.gov/29099853/">https://pubmed.ncbi.nlm.nih.gov/29099853/</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("X_multiomic")
data("Y_multiomic")
X &lt;- X_multiomic
X$mirna &lt;- X$mirna[,1:50]
X$proteomic &lt;- X$proteomic[,1:50]
Y &lt;- Y_multiomic
mb.splsdrcox(X, Y, n.comp = 2, vector = NULL, x.center = TRUE, x.scale = TRUE)

</code></pre>


</div>