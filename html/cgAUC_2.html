<div class="container">

<table style="width: 100%;"><tr>
<td>cgAUC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Calculate AUC when gold standard is continuous with large variables.</h2>

<h3>Description</h3>

<p>The cgAUC can calculate the AUC-type measure of Obuchowski(2006) when gold standard is continuous, and find the optimal linear combination of variables with respect to this measure.</p>


<h3>Usage</h3>

<pre><code class="language-R">cgAUC(x, z, h, delta = 1, auto = FALSE, tau = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>The potential variables. It is a matrix with column of values of a variables. It should be standardized in this application.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>

<p>The gold standard variable. It should be standardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>The parameter controls the window width of smoothing function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>The parameter be used in TGDM. The default value is one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto</code></td>
<td>

<p>Find the optimal delta in TGDN using cross-validation. If the auto is TRUE. The default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>The parameter used in TGDM. The default value is one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>

<p>Scaling data when scale = 1, no scaling data when scale = 0. The default value is 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In this package, we use the TGDM to find the optimal linear combination of variables in order to maximize the AUC-type measure. Before using this function, all of variables, including gold standard variable, should be standardized first. Below are parameters used in the algorithm:</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Rev</code></td>
<td>
<p>When Rev = 0 means l * 1; otherwise, l * -1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>The estimate of coefficients for the optimal linear combination of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.sh.h.p</code></td>
<td>
<p>The estimate of the theta of Chang(2012) for the optimal linear combination of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.sh.h.p.var</code></td>
<td>
<p>The estimate of variance for the theta of Chang(2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cntin.ri</code></td>
<td>
<p>The estimate of the theta of Chang(2012) for each single vaiable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.h.p</code></td>
<td>
<p>The estimate of the theta of Obuchowski(2006) for the optimal linear combination of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.h.p.var</code></td>
<td>
<p>The estimate of variance for the theta of Obuchowski(2006).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dscrt.ri</code></td>
<td>
<p>The estimate of the theta of Obuchowski(2006) for each single vaiable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The value of delta.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br>
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481–493.<br>
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261–3278.<br>
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br></p>


<h3>Examples</h3>

<pre><code class="language-R">##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

# n = 100; p = 5;
# r.x = matrix(rnorm(n * p), , p) # raw data
# r.z = r.x[ ,1] + rnorm(n) # gold standard
# x = scale(r.x) # standardized of raw data
# z = scale(r.z) # standardized of gold standard
# h = n^(-1 / 2)
# t1 = cgAUC(r.x, r.z, h, delta = 1, auto = FALSE, tau = 1, scale = 1) # the delta be constant
# t1
# t2 = cgAUC(r.x, r.z, h, delta = 1, auto = TRUE, tau = 1, scale = 1) # the delta be variable
# t2

## The function is currently defined as
function (x, z, h, delta = 1, auto = FALSE, tau = 1)
{
	x = scale(x)
	z = scale(z)
	conv = FALSE
	n = dim(x)[1]
	p = dim(x)[2]
	cntin.ri = dscrt.ri = rep(0, p)
	id = diag(p)
	for (i in 1:p) {
		dscrt.ri[i] = dscrt(x, z, id[i, ])$theta.h.p
		cntin.ri[i] = cntin(x, z, id[i, ], h)$theta.sh.h.p
	}
	beta.i = ifelse(cntin.ri &gt; 0.5, 1, -1)
	dscrt.ri = ifelse(dscrt.ri &gt; 0.5, dscrt.ri, (1 - dscrt.ri))
	cntin.ri = ifelse(cntin.ri &gt; 0.5, cntin.ri, (1 - cntin.ri))
	y = x * matrix(beta.i, n, p, byrow = TRUE)
	max.x = which(cntin.ri == max(cntin.ri))
	theta.sh.h.p = 0
	l = id[max.x, ]
	while (conv == FALSE) {
		d.l = d.theta.sh.h.p(y, z, l, h)
		max.d.l = max(d.l)
		ind.d.l = ifelse(d.l &gt;= (tau * max.d.l), 1, 0) * d.l
		if (auto == TRUE) {
			delta = optimal.delta(y, z, l, h, ind.d.l)
		}
		l = l + delta * ind.d.l
		l = l/max(l)
		theta.temp = cntin(y, z, l, h)$theta.sh.h.p
		ifelse(abs(theta.temp - theta.sh.h.p) &lt; 1e-04, conv &lt;- TRUE, conv &lt;- FALSE)
		theta.sh.h.p = theta.temp
	}
	optimal.dscrt = dscrt(y, z, l)
	theta.sh.h.p.var = cntin(y, z, l, h)$var
	l = l * beta.i
	return(list(l = l, theta.sh.h.p = theta.sh.h.p, theta.sh.h.p.var = theta.sh.h.p.var,
				cntin.ri = cntin.ri, theta.h.p = optimal.dscrt$theta.h.p,
				theta.h.p.var = optimal.dscrt$var, dscrt.ri = dscrt.ri,
				delta = delta))
}
## The function is currently defined as
function (x, z, h, delta = 1, auto = FALSE, tau = 1) 
{
    x = scale(x)
    z = scale(z)
    conv = FALSE
    n = dim(x)[1]
    p = dim(x)[2]
    cntin.ri = dscrt.ri = rep(0, p)
    id = diag(p)
    for (i in 1:p) {
        dscrt.ri[i] = dscrt(x, z, id[i, ])$theta.h.p
        cntin.ri[i] = cntin(x, z, id[i, ], h)$theta.sh.h.p
    }
    beta.i = ifelse(cntin.ri &gt; 0.5, 1, -1)
    dscrt.ri = ifelse(dscrt.ri &gt; 0.5, dscrt.ri, (1 - dscrt.ri))
    cntin.ri = ifelse(cntin.ri &gt; 0.5, cntin.ri, (1 - cntin.ri))
    y = x * matrix(beta.i, n, p, byrow = TRUE)
    max.x = which(cntin.ri == max(cntin.ri))
    theta.sh.h.p = 0
    l = id[max.x, ]
    while (conv == FALSE) {
        d.l = d.theta.sh.h.p(y, z, l, h)
        max.d.l = max(d.l)
        ind.d.l = ifelse(d.l &gt;= (tau * max.d.l), 1, 0) * d.l
        if (auto == TRUE) {
            delta = optimal.delta(y, z, l, h, ind.d.l)
        }
        l = l + delta * ind.d.l
        l = l/max(l)
        theta.temp = cntin(y, z, l, h)$theta.sh.h.p
        ifelse(abs(theta.temp - theta.sh.h.p) &lt; 1e-04, conv &lt;- TRUE, 
            conv &lt;- FALSE)
        theta.sh.h.p = theta.temp
    }
    optimal.dscrt = dscrt(y, z, l)
    theta.sh.h.p.var = cntin(y, z, l, h)$var
    l = l * beta.i
    return(list(l = l, theta.sh.h.p = theta.sh.h.p, theta.sh.h.p.var = theta.sh.h.p.var, 
        cntin.ri = cntin.ri, theta.h.p = optimal.dscrt$theta.h.p, 
        theta.h.p.var = optimal.dscrt$var, dscrt.ri = dscrt.ri, 
        delta = delta))
  }
</code></pre>


</div>