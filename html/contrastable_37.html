<div class="container">

<table style="width: 100%;"><tr>
<td>cumulative_split_code</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cumulative split contrasts</h2>

<h3>Description</h3>

<p>Contrast coding scheme that repeatedly dichotomizes the factor levels.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cumulative_split_code(n)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>This scheme is similar to Helmert contrasts, but instead of comparing one
level to the accumulated mean of all previous levels, each comparison with
this scheme splits the levels into two groups: those below and including
the current level, and those above the current level. Conceptually this is
similar to continuation ratio logits used in ordinal models. For example,
with a four level factor with levels A, B, C, and D, the comparisons would
be:
</p>

<ul>
<li>
<p> A vs. BCD
</p>
</li>
<li>
<p> AB vs. CD
</p>
</li>
<li>
<p> ABC vs. D
</p>
</li>
</ul>
<p>In other words, each comparison splits the levels into two groups.
Each of these comparisons uses the cumulative mean of all the levels in
each group. The intercept is the grand mean.
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

set.seed(111)
mydf &lt;- data.frame(
  grp = rep(c("a", "b", "c", "d"), each = 2000),
  val = c(
    rnorm(200, 2, 1),
    rnorm(200, 5, 1),
    rnorm(200, 7.5, 1),
    rnorm(200, 15, 1)
  )
) |&gt;
  set_contrasts(grp ~ cumulative_split_code |
    c("a-rest", "ab-rest", "abc-rest"))

lm(val ~ grp, data = mydf)

</code></pre>


</div>