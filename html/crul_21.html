<div class="container">

<table style="width: 100%;"><tr>
<td>Paginator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Paginator client</h2>

<h3>Description</h3>

<p>A client to help you paginate
</p>


<h3>Details</h3>

<p>See <code>HttpClient()</code> for information on parameters
</p>


<h3>Value</h3>

<p>a list, with objects of class <code>HttpResponse()</code>.
Responses are returned in the order they are passed in.
</p>


<h3>R6 classes</h3>

<p>This is an R6 class from the package <span class="pkg">R6</span>. Find out more
about R6 at <a href="https://r6.r-lib.org/">https://r6.r-lib.org/</a>. After creating an instance of an R6
class (e.g., <code>x &lt;- HttpClient$new(url = "https://hb.opencpu.org")</code>) you can
access values and methods on the object <code>x</code>.
</p>


<h3>Methods to paginate</h3>

<p>Supported now:
</p>

<ul>
<li> <p><code>limit_offset</code>: the most common way (in my experience), so is the default.
This method involves setting how many records and what record to start at
for each request. We send these query parameters for you.
</p>
</li>
<li> <p><code>page_perpage</code>: set the page to fetch and (optionally) how many records
to get per page
</p>
</li>
</ul>
<p>Supported later, hopefully:
</p>

<ul>
<li> <p><code>link_headers</code>: link headers are URLS for the next/previous/last
request given in the response header from the server. This is relatively
uncommon, though is recommended by JSONAPI and is implemented by a
well known API (GitHub).
</p>
</li>
<li> <p><code>cursor</code>: this works by a single string given back in each response, to
be passed in the subsequent response, and so on until no more records
remain. This is common in Solr
</p>
</li>
</ul>
<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>http_req</code></dt>
<dd>
<p>an object of class <code>HttpClient</code></p>
</dd>
<dt><code>by</code></dt>
<dd>
<p>(character) how to paginate. Only 'limit_offset' supported
for now. In the future will support 'link_headers' and 'cursor'.
See Details.</p>
</dd>
<dt><code>chunk</code></dt>
<dd>
<p>(numeric/integer) the number by which to chunk
requests, e.g., 10 would be be each request gets 10 records.
number is passed through <code>format()</code> to prevent larger numbers
from being scientifically formatted</p>
</dd>
<dt><code>limit_param</code></dt>
<dd>
<p>(character) the name of the limit parameter.
Default: limit</p>
</dd>
<dt><code>offset_param</code></dt>
<dd>
<p>(character) the name of the offset parameter.
Default: offset</p>
</dd>
<dt><code>limit</code></dt>
<dd>
<p>(numeric/integer) the maximum records wanted.
number is passed through <code>format()</code> to prevent larger numbers
from being scientifically formatted</p>
</dd>
<dt><code>page_param</code></dt>
<dd>
<p>(character) the name of the page parameter.
Default: NULL</p>
</dd>
<dt><code>per_page_param</code></dt>
<dd>
<p>(character) the name of the per page parameter.
Default: NULL</p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>(logical) print a progress bar, using utils::txtProgressBar.
Default: <code>FALSE</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Paginator-print"><code>Paginator$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-new"><code>Paginator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-get"><code>Paginator$get()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-post"><code>Paginator$post()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-put"><code>Paginator$put()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-patch"><code>Paginator$patch()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-delete"><code>Paginator$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-head"><code>Paginator$head()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-responses"><code>Paginator$responses()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-status_code"><code>Paginator$status_code()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-status"><code>Paginator$status()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-parse"><code>Paginator$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-content"><code>Paginator$content()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-times"><code>Paginator$times()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-url_fetch"><code>Paginator$url_fetch()</code></a>
</p>
</li>
<li> <p><a href="#method-Paginator-clone"><code>Paginator$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Paginator-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>print method for <code>Paginator</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>self</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>ignored</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Paginator-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>Paginator</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$new(
  client,
  by = "limit_offset",
  limit_param = NULL,
  offset_param = NULL,
  limit = NULL,
  chunk = NULL,
  page_param = NULL,
  per_page_param = NULL,
  progress = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>client</code></dt>
<dd>
<p>an object of class <code>HttpClient</code>, from a call to HttpClient</p>
</dd>
<dt><code>by</code></dt>
<dd>
<p>(character) how to paginate. Only 'limit_offset' supported for
now. In the future will support 'link_headers' and 'cursor'. See Details.</p>
</dd>
<dt><code>limit_param</code></dt>
<dd>
<p>(character) the name of the limit parameter.
Default: limit</p>
</dd>
<dt><code>offset_param</code></dt>
<dd>
<p>(character) the name of the offset parameter.
Default: offset</p>
</dd>
<dt><code>limit</code></dt>
<dd>
<p>(numeric/integer) the maximum records wanted</p>
</dd>
<dt><code>chunk</code></dt>
<dd>
<p>(numeric/integer) the number by which to chunk requests,
e.g., 10 would be be each request gets 10 records</p>
</dd>
<dt><code>page_param</code></dt>
<dd>
<p>(character) the name of the page parameter.</p>
</dd>
<dt><code>per_page_param</code></dt>
<dd>
<p>(character) the name of the per page parameter.</p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>(logical) print a progress bar, using utils::txtProgressBar.
Default: <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>Paginator</code> object
</p>


<hr>
<a id="method-Paginator-get"></a>



<h4>Method <code>get()</code>
</h4>

<p>make a paginated GET request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$get(path = NULL, query = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Paginator-post"></a>



<h4>Method <code>post()</code>
</h4>

<p>make a paginated POST request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$post(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Paginator-put"></a>



<h4>Method <code>put()</code>
</h4>

<p>make a paginated PUT request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$put(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Paginator-patch"></a>



<h4>Method <code>patch()</code>
</h4>

<p>make a paginated PATCH request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$patch(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Paginator-delete"></a>



<h4>Method <code>delete()</code>
</h4>

<p>make a paginated DELETE request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$delete(
  path = NULL,
  query = list(),
  body = NULL,
  encode = "multipart",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
<dt><code>body</code></dt>
<dd>
<p>body as an R list</p>
</dd>
<dt><code>encode</code></dt>
<dd>
<p>one of form, multipart, json, or raw</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Paginator-head"></a>



<h4>Method <code>head()</code>
</h4>

<p>make a paginated HEAD request
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$head(path = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>For <code>retry</code>, the options to be passed on to the method
implementing the requested verb, including curl options. Otherwise,
curl options, only those in the acceptable set from <code>curl::curl_options()</code>
except the following: httpget, httppost, post, postfields, postfieldsize,
and customrequest</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>not sure if this makes any sense or not yet
</p>


<hr>
<a id="method-Paginator-responses"></a>



<h4>Method <code>responses()</code>
</h4>

<p>list responses
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$responses()</pre></div>



<h5>Returns</h5>

<p>a list of <code>HttpResponse</code> objects, empty list before requests made
</p>


<hr>
<a id="method-Paginator-status_code"></a>



<h4>Method <code>status_code()</code>
</h4>

<p>Get HTTP status codes for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$status_code()</pre></div>



<h5>Returns</h5>

<p>numeric vector, empty numeric vector before requests made
</p>


<hr>
<a id="method-Paginator-status"></a>



<h4>Method <code>status()</code>
</h4>

<p>List HTTP status objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$status()</pre></div>



<h5>Returns</h5>

<p>a list of <code>http_code</code> objects, empty list before requests made
</p>


<hr>
<a id="method-Paginator-parse"></a>



<h4>Method <code>parse()</code>
</h4>

<p>parse content
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$parse(encoding = "UTF-8")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encoding</code></dt>
<dd>
<p>(character) the encoding to use in parsing.
default:"UTF-8"</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>character vector, empty character vector before
requests made
</p>


<hr>
<a id="method-Paginator-content"></a>



<h4>Method <code>content()</code>
</h4>

<p>Get raw content for each response
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$content()</pre></div>



<h5>Returns</h5>

<p>raw list, empty list before requests made
</p>


<hr>
<a id="method-Paginator-times"></a>



<h4>Method <code>times()</code>
</h4>

<p>curl request times
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$times()</pre></div>



<h5>Returns</h5>

<p>list of named numeric vectors, empty list before requests made
</p>


<hr>
<a id="method-Paginator-url_fetch"></a>



<h4>Method <code>url_fetch()</code>
</h4>

<p>get the URL that would be sent (i.e., before executing
the request) the only things that change the URL are path and query
parameters; body and any curl options don't change the URL
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$url_fetch(path = NULL, query = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>URL path, appended to the base URL</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p>query terms, as a named list. any numeric values are
passed through <code>format()</code> to prevent larger numbers from being
scientifically formatted</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>URLs (character)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
cli &lt;- HttpClient$new(url = "https://api.crossref.org")
cc &lt;- Paginator$new(client = cli, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10)
cc$url_fetch('works')
cc$url_fetch('works', query = list(query = "NSF"))
}
</pre>
</div>


<hr>
<a id="method-Paginator-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Paginator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
if (interactive()) {
# limit/offset approach
con &lt;- HttpClient$new(url = "https://api.crossref.org")
cc &lt;- Paginator$new(client = con, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10)
cc
cc$get('works')
cc
cc$responses()
cc$status()
cc$status_code()
cc$times()
# cc$content()
cc$parse()
lapply(cc$parse(), jsonlite::fromJSON)

# page/per page approach (with no per_page param allowed)
conn &lt;- HttpClient$new(url = "https://discuss.ropensci.org")
cc &lt;- Paginator$new(client = conn, by = "page_perpage",
 page_param = "page", per_page_param = "per_page", limit = 90, chunk = 30)
cc
cc$get('c/usecases/l/latest.json')
cc$responses()
lapply(cc$parse(), jsonlite::fromJSON)

# page/per_page
conn &lt;- HttpClient$new('https://api.inaturalist.org')
cc &lt;- Paginator$new(conn, by = "page_perpage", page_param = "page",
 per_page_param = "per_page", limit = 90, chunk = 30)
cc
cc$get('v1/observations', query = list(taxon_name="Helianthus"))
cc$responses()
res &lt;- lapply(cc$parse(), jsonlite::fromJSON)
res[[1]]$total_results
vapply(res, "[[", 1L, "page")
vapply(res, "[[", 1L, "per_page")
vapply(res, function(w) NROW(w$results), 1L)
## another
ccc &lt;- Paginator$new(conn, by = "page_perpage", page_param = "page",
 per_page_param = "per_page", limit = 500, chunk = 30, progress = TRUE)
ccc
ccc$get('v1/observations', query = list(taxon_name="Helianthus"))
res2 &lt;- lapply(ccc$parse(), jsonlite::fromJSON)
vapply(res2, function(w) NROW(w$results), 1L)

# progress bar
(con &lt;- HttpClient$new(url = "https://api.crossref.org"))
cc &lt;- Paginator$new(client = con, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10,
   progress = TRUE)
cc
cc$get('works')
}
## End(Not run)

## ------------------------------------------------
## Method `Paginator$url_fetch`
## ------------------------------------------------

## Not run: 
cli &lt;- HttpClient$new(url = "https://api.crossref.org")
cc &lt;- Paginator$new(client = cli, limit_param = "rows",
   offset_param = "offset", limit = 50, chunk = 10)
cc$url_fetch('works')
cc$url_fetch('works', query = list(query = "NSF"))

## End(Not run)
</code></pre>


</div>