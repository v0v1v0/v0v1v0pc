<div class="container">

<table style="width: 100%;"><tr>
<td>genRandomClust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RANDOM CLUSTER GENERATION WITH SPECIFIED DEGREE OF SEPARATION</h2>

<h3>Description</h3>

<p>Generate cluster data sets with specified degree of separation. 
The separation between any cluster and its nearest neighboring cluster can be 
set to a specified value. The covariance matrices of clusters can have 
arbitrary diameters, shapes and orientations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">genRandomClust(numClust, 
               sepVal = 0.01, 
               numNonNoisy = 2, 
               numNoisy = 0, 
               numOutlier = 0, 
               numReplicate = 3, 
               fileName = "test",  
               clustszind = 2, 
               clustSizeEq = 50, 
               rangeN = c(50,200), 
               clustSizes = NULL, 
               covMethod = c("eigen", "onion", "c-vine", "unifcorrmat"), 
	       eigenvalue = NULL,
               rangeVar = c(1, 10), 
               lambdaLow = 1, 
               ratioLambda = 10,  
               alphad = 1,
               eta = 1,
               rotateind = TRUE, 
               iniProjDirMethod = c("SL", "naive"), 
               projDirMethod = c("newton", "fixedpoint"), 
               alpha = 0.05, 
               ITMAX = 20, 
               eps = 1.0e-10, 
               quiet = TRUE, 
               outputDatFlag = TRUE, 
               outputLogFlag = TRUE, 
               outputEmpirical = TRUE, 
               outputInfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>numClust</code></td>
<td>

<p>Number of clusters in a data set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepVal</code></td>
<td>

<p>Desired value of the separation index between a cluster
and its nearest neighboring cluster. Theoretically, <code>sepVal</code> can take 
values within the interval <code class="reqn">[-1, 1)</code> 
(In practice, we set <code>sepVal</code> in <code class="reqn">(-0.999, 0.999)</code>). 
The closer to <code class="reqn">1</code> <code>sepVal</code> is, the more separated clusters are.
The default value is <code class="reqn">0.01</code> which is the value of the separation index for
two univariate clusters generated from <code class="reqn">N(0, 1)</code> and <code class="reqn">N(0, A)</code>,
respectively,  where <code class="reqn">A=4</code>. 
<code>sepVal</code><code class="reqn">=0.01</code> indicates a close cluster structure. 
<code>sepVal</code><code class="reqn">=0.21 (A=6)</code> indicates a separated cluster structure. 
<code>sepVal</code><code class="reqn">=0.34 (A=8)</code> indicates a well-separated cluster.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numNonNoisy</code></td>
<td>

<p>Number of non-noisy variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numNoisy</code></td>
<td>

<p>Number of noisy variables.
The default values of <code>numNoisy</code> and <code>numOutlier</code> are <code class="reqn">0</code> so 
that we get <dfn>clean</dfn> data sets. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numOutlier</code></td>
<td>

<p>Number or ratio of outliers. If <code>numOutlier</code> is a positive integer, 
then <code>numOutlier</code> means the number of outliers. 
If <code>numOutlier</code> is a real number between <code class="reqn">(0, 1)</code>, then 
<code>numOutlier</code> means the ratio of outliers, i.e. the number of outliers 
is equal to <code>round</code>(<code>numOutlier</code><code class="reqn">*n_1</code>), where <code class="reqn">n_1</code> is 
the total number of non-outliers.  If <code>numOutlier</code> is a real number 
greater than <code class="reqn">1</code>, then <code>numOutlier</code> to rounded to an integer.
The default values of <code>numNoisy</code> and <code>numOutlier</code> are 
<code class="reqn">0</code> so that we get ‘clean’ data sets. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numReplicate</code></td>
<td>

<p>Number of data sets to be generated for the same cluster structure specified 
by the other arguments of the function <code>genRandomClust</code>.
The default value <code class="reqn">3</code> follows the design in Milligan (1985).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fileName</code></td>
<td>

<p>The first part of the names of data files that record the generated data sets 
and associated information, such as cluster membership of data points, labels 
of noisy variables, separation index matrix, projection directions, etc. 
(see details). The default value of <code>fileName</code> is ‘<span class="file">test</span>’.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustszind</code></td>
<td>

<p>Cluster size indicator.
<code>clustszind</code><code class="reqn">=1</code> indicates that all cluster have equal size. 
The size is specified by the argument <code>clustSizeEq</code>.
<code>clustszind</code><code class="reqn">=2</code> indicates that the cluster sizes are randomly 
generated from the range specified by the argument <code>rangeN</code>.
<code>clustszind</code><code class="reqn">=3</code> indicates that the cluster sizes are specified
via the vector <code>clustSizes</code>.
The default value is <code class="reqn">2</code> so that the generated clusters are more
realistic.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustSizeEq</code></td>
<td>

<p>Cluster size.
If the argument <code>clustszind</code><code class="reqn">=1</code>, then all clusters will have the 
equal number <code>clustSizeEq</code> of data points. The value of <code>clustSizeEq</code> 
should be large enough to get non-singular cluster covariance matrices. 
We recommend the <code>clustSizeEq</code> is at least <code class="reqn">10*p</code>, where <code class="reqn">p</code> 
is the total number of variables (including both non-noisy and noisy variables).
The default value <code class="reqn">100</code> is a reasonable cluster size.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rangeN</code></td>
<td>

<p>The range of cluster sizes.
If <code>clustszind</code><code class="reqn">=2</code>, then cluster sizes will be randomly generated 
from the range specified by <code>rangeN</code>. The lower bound of the number of 
clusters should be large enough to get non-singular cluster covariance 
matrices. We recommend the minimum cluster size is at least <code class="reqn">10*p</code>, where 
<code class="reqn">p</code> is the total number of variables (including both non-noisy and noisy 
variables).  The default range is <code class="reqn">[50, 200]</code> which
can produce reasonable variability of cluster sizes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustSizes</code></td>
<td>

<p>The sizes of clusters.
If <code>clustszind</code><code class="reqn">=3</code>, then cluster sizes will be specified via the 
vector <code>clustSizes</code>.  We recommend the minimum cluster size is at least 
<code class="reqn">10*p</code>, where <code class="reqn">p</code> is the total number of variables (including both 
non-noisy and noisy variables).
The user needs to specify the value of <code>clustSizes</code>. Therefore, we
set the default value of <code>clustSizes</code> as <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covMethod</code></td>
<td>

<p>Method to generate covariance matrices for clusters (see details).
The default method is 'eigen' so that the user can directly 
specify the range of the <dfn>diameters</dfn> of clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigenvalue</code></td>
<td>

<p>numeric. user-specified eigenvalues when <code>covMethod = "eigen"</code>. If <code>eigenvalue = NULL</code> and <code>covMethod = "eigen"</code>, then eigenvalues will be automatically generated.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rangeVar</code></td>
<td>

<p>Range for variances of a covariance matrix (see details).
The default range is <code class="reqn">[1, 10]</code> which can generate reasonable
variability of variances.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaLow</code></td>
<td>

<p>Lower bound of the eigenvalues of cluster covariance matrices. 
If the argument “covMethod="eigen"”, we need to generate eigenvalues for cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>lambdaLow</code> should be positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratioLambda</code></td>
<td>

<p>The ratio of the upper bound of the eigenvalues to the lower bound of the 
eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, we need to generate eigenvalues for
cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>ratioLambda</code> should be larger than <code class="reqn">1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphad</code></td>
<td>
<p>parameter for unifcorrmat method to generate random correlation matrix
<code>alphad=1</code> for uniform. <code>alphad</code> should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>parameter for “c-vine” and “onion” methods to generate random correlation matrix
<code>eta=1</code> for uniform. <code>eta</code> should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotateind</code></td>
<td>

<p>Rotation indicator.
<code>rotateind=TRUE</code> indicates randomly rotating data in non-noisy 
dimensions so that we may not detect the full cluster structure from 
pair-wise scatter plots of the variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iniProjDirMethod</code></td>
<td>

<p>Indicating the method to get initial projection direction when calculating
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br><code>iniProjDirMethod</code>=“SL”, the default, indicates the initial 
projection direction is the sample version of the SL's projection direction 
(Su and Liu, 1993, JASA)
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code><br><code>iniProjDirMethod</code>=“naive” indicates the initial projection 
direction is <code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projDirMethod</code></td>
<td>

<p>Indicating the method to get the optimal projection direction when calculating 
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br><code>projDirMethod</code>=“newton” indicates we use the modified
Newton-Raphson method to search the optimal projection direction 
(c.f. Qiu and Joe, 2006a). This requires the assumptions that both covariance 
matrices of the pair of clusters are positive-definite. If this assumption 
is violated, the “fixedpoint” method could be used. The 
“fixedpoint” method iteratively searches the optimal projection 
direction based on the first derivative of the separation index to the 
projection direction (c.f. Qiu and Joe, 2006b).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
We set <code>alpha</code><code class="reqn">=0.05</code> like we set
the significance level in hypothesis testing as <code class="reqn">0.05</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ITMAX</code></td>
<td>

<p>Maximum iteration allowed when iteratively calculating the
optimal projection direction.
The actual number of iterations is usually much less than the default value 20.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>Convergence threshold. A small positive number to check if a quantitiy <code class="reqn">q</code> 
is equal to zero.  If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> is equal 
to zero.  <code>eps</code> is used to check if an algorithm converges.
The default value is <code class="reqn">1.0e-10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputDatFlag</code></td>
<td>

<p>Indicates if data set should be output to file.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputLogFlag</code></td>
<td>

<p>Indicates if log info should be output to file.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputEmpirical</code></td>
<td>

<p>Indicates if empirical separation indices and projection directions should be 
calculated. This option is useful when generating clusters with sizes which 
are not large enough so that the sample covariance matrices may be singular.
Hence, by default, <code>outputEmpirical=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputInfo</code></td>
<td>

<p>Indicates if theoretical and empirical separation information data frames 
should be output to a file with format <code>[fileName]_info.log</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>genRandomClust</code> is an implementation of the random cluster 
generation method proposed in Qiu and Joe (2006a) which improve the cluster 
generation method proposed in Milligan (1985) so that the degree of separation 
between any cluster and its nearest neighboring cluster could be set to a 
specified value while the cluster covariance matrices can be arbitrary positive definite matrices, and so that clusters generated might not be visualized 
by pair-wise scatterplots of variables. The separation between a pair of 
clusters is measured by the separation index proposed in Qiu and Joe (2006b).
</p>
<p>The current version of the function <code>genRandomClust</code> implements two 
methods to generate covariance matrices for clusters. The first method, 
denoted by <code>eigen</code>, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots&gt;\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then uses columns of a randomly generated 
orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\dots, \lambda_p)*\boldsymbol{Q}^T</code>.
The second method, denoted as “unifcorrmax”, first generates a random 
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots, \sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>
<p>For each data set generated, the function <code>genRandomClust</code> outputs
four files: data file, log file, membership file, and noisy set file. 
All four files have the same format: <code>[fileName]_[i].[extension]</code>, 
where <code class="reqn">i</code> indicates the replicate number, and ‘<span class="file">extension</span>’ can be 
‘<span class="file">dat</span>’, ‘<span class="file">log</span>’, ‘<span class="file">mem</span>’, and ‘<span class="file">noisy</span>’. 
</p>
<p>The data file with file extension ‘<span class="file">dat</span>’ contains <code class="reqn">n+1</code> rows and 
<code class="reqn">p</code> columns, where <code class="reqn">n</code> is the number of data points and <code class="reqn">p</code> 
is the number of variables. The first row is the variable names. 
The log file with file extension ‘<span class="file">log</span>’ contains information such 
as cluster sizes, mean vectors, covariance matrices, projection directions, 
separation index matrices, etc. The membership file with file extension 
‘<span class="file">mem</span>’ contains <code class="reqn">n</code> rows and one column of cluster memberships for 
data points. The noisy set file with file extension ‘<span class="file">noisy</span>’ contains 
a row of labels of noisy variables.
</p>
<p>When generating clusters, population covariance matrices are all 
positive-definite. However sample covariance matrices might be 
semi-positive-definite due to small cluster sizes. In this case, the 
function <code>genRandomClust</code> will automatically use the 
“fixedpoint” method to search the optimal projection direction.
</p>
<p>The current version of the function <code>genPositiveDefMat</code> implements four 
methods to generate random covariance matrices. The first method, denoted by 
“eigen”, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots,\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then
uses columns of a randomly generated orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code> is then 
contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\ldots,\lambda_p)*\boldsymbol{Q}^T</code>.
</p>
<p>The remaining methods, denoted as “onion”, “c-vine”, and “unifcorrmat”
respectively, first generates a random 
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method mentioned and proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots,\sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>


<h3>Value</h3>

<p>The function outputs four data files for each data set (see details).
</p>
<p>This function also returns separation information data frames 
<code>infoFrameTheory</code> and <code>infoFrameData</code> based on population 
and empirical mean vectors and covariance matrices of clusters for all 
the data sets generated. Both <code>infoFrameTheory</code> and <code>infoFrameData</code> 
contain the following seven columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Column 1:</code></td>
<td>

<p>Labels of clusters (<code class="reqn">1, 2, \ldots, numClust</code>), where <code class="reqn">numClust</code> 
is the number of clusters for the data set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 2:</code></td>
<td>

<p>Labels of the corresponding nearest neighbors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 3:</code></td>
<td>

<p>Separation indices of the clusters to their nearest neighboring clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 4:</code></td>
<td>

<p>Labels of the corresponding farthest neighboring clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 5:</code></td>
<td>

<p>Separation indices of the clusters to their farthest neighbors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 6:</code></td>
<td>

<p>Median separation indices of the clusters to their neighbors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Column 7:</code></td>
<td>

<p>Data file names with format <code>[fileName]_[i]</code>, where <code class="reqn">i</code> indicates 
the replicate number.
</p>
</td>
</tr>
</table>
<p>The function also returns three lists: <code>datList</code>, <code>memList</code>, and <code>noisyList</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>datList:</code></td>
<td>

<p>a list of data matrices for generated data sets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memList:</code></td>
<td>

<p>a list of luster memberships for data points for generated data sets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noisyList:</code></td>
<td>

<p>a list of sets of noisy variables for generated data sets.
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function might be take a while to complete.</p>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br>
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177–2189.
</p>
<p>Milligan G. W. (1985) 
An Algorithm for Generating Artificial Test Clusters.
<em>Psychometrika</em> <b>50</b>, 123–127.
</p>
<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585–603.
</p>
<p>Su, J. Q. and Liu, J. S. (1993)
Linear Combinations of Multiple Diagnostic Markers.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 1350–1355.
</p>
<p>Ghosh, S., Henderson, S. G. (2003).
Behavior of the NORTA method for correlated random vector generation
as the dimension increases.
<em>ACM Transactions on Modeling and Computer Simulation (TOMACS)</em>,
<b>13(3)</b>, 276–294.
</p>
<p>Kurowicka and Cooke, 2006.
<em>Uncertainty Analysis with High Dimensional Dependence Modelling</em>,
Wiley, 2006.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
tmp1 &lt;- genRandomClust(
		       numClust = 7, 
		       sepVal = 0.3, 
		       numNonNoisy = 5,  
                       numNoisy = 3, 
		       numOutlier = 5, 
		       numReplicate = 2, 
		       fileName = "chk1")

## End(Not run)
## Not run: 
tmp2 &lt;- genRandomClust(
		       numClust = 7, 
		       sepVal = 0.3, 
		       numNonNoisy = 5,  
                       numNoisy = 3, 
		       numOutlier = 5, 
		       numReplicate = 2, 
                       covMethod = "unifcorrmat", 
		       fileName = "chk2")

## End(Not run)
## Not run: 
tmp3 &lt;- genRandomClust(
		       numClust = 2, 
		       sepVal = -0.1, 
		       numNonNoisy = 2,  
                       numNoisy = 6, 
		       numOutlier = 30, 
		       numReplicate = 1, 
                       clustszind = 1, 
		       clustSizeEq = 80, 
		       rangeVar = c(10, 20),
                       covMethod = "unifcorrmat", 
		       iniProjDirMethod = "naive",
                       projDirMethod = "fixedpoint", 
		       fileName = "chk3")

## End(Not run)

</code></pre>


</div>