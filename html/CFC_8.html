<div class="container">

<table style="width: 100%;"><tr>
<td>summary.cfc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Summarizing and plotting output of <code>cfc</code>
</h2>

<h3>Description</h3>

<p><code>summary</code> method for class <code>cfc</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cfc'
summary(object
  , f.reduce = function(x) x
  , pval = 0.05, ...)
## S3 method for class 'summary.cfc'
plot(x, which = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class "cfc", usually the result of a call to <code>cfc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.reduce</code></td>
<td>
<p>Function to be applied to each sub-array of <code>object$ci</code> (cumulative incidence) and <code>object$s</code> (survival probability).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval</code></td>
<td>
<p>Desired significance level for confidence intervals produced by <code>summary.cfc</code>. We essentially set the argument <code>probs</code> to <code>c(pval/2, 0.5, 1-pval/2)</code> when calling <code>quantile</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class "summary.cfc", usually the result of a call to <code>summary.cfc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Vector of integers, indicating which plot(s) must be produced: 1) cumulative incidence functions, one per cause. For each cause, median and credible bands are plotted vs. time-from-index. 2) (unadjusted) survival functions, one per cause. Similar to (1), median and credible bands are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to <code>f.reduce</code> (for <code>summary.cfc</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Recall that the survival probability and cumulative incidence arrays returned by <code>cfc</code> are three-dimensional, and their first two dimensions indicate 1) time points and 2) causes. <code>f.reduce</code> is expected to produce an array of a fixed length, when applied to each sub-array, <code>ci[i, j, ]</code> and <code>s[i, j, ]</code>. The end-result is two three-dimensional array, where the first two dimensions are identical to its input arrays. This 3D array is then passed to the <code>quantile</code> function to compute median and credible bands. There is a special case where <code>f.reduce</code> returns a scalar, rather than an array, when applied to each sub-array. In this case, quantile calculation is meaningless and we return simply these point estimates. In summary, the return object from <code>summary</code> is a list with elements: 1) <code>ci</code> (cumulative incidence), 2) <code>s</code> (survival), and 3) <code>quantiles</code>, a boolean flag indicating whether the cumulative incidence and survival arrays returned are quantiles or point estimates.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p><code>cfc</code>, <code>summary</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

library("BSGW") # used for Bayesian survival regression

data(bmt)
# splitting data into training and prediction sets
idx.train &lt;- sample(1:nrow(bmt), size = 0.7 * nrow(bmt))
idx.pred &lt;- setdiff(1:nrow(bmt), idx.train)
nobs.train &lt;- length(idx.train)
nobs.pred &lt;- length(idx.pred)

# prepare data and formula for Bayesian cause-specific survival regression
# using R package BSGW
out.prep &lt;- cfc.prepdata(Surv(time, cause) ~ platelet + age + tcell, bmt)
f1 &lt;- out.prep$formula.list[[1]]
f2 &lt;- out.prep$formula.list[[2]]
dat &lt;- out.prep$dat
tmax &lt;- out.prep$tmax

# estimating cause-specific models
# set nsmp to larger number in real-world applications
nsmp &lt;- 10
reg1 &lt;- bsgw(f1, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)
reg2 &lt;- bsgw(f2, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)

# defining survival function for this model
survfunc &lt;- function(t, args, n) {
  nobs &lt;- args$nobs; natt &lt;- args$natt; nsmp &lt;- args$nsmp
  alpha &lt;- args$alpha; beta &lt;- args$beta; X &lt;- args$X
  idx.smp &lt;- floor((n - 1) / nobs) + 1
  idx.obs &lt;- n - (idx.smp - 1) * nobs
  return (exp(- t ^ alpha[idx.smp] * 
                exp(sum(X[idx.obs, ] * beta[idx.smp, ]))));
}

# preparing function and argument lists
X.pred &lt;- as.matrix(cbind(1, bmt[idx.pred, c("platelet", "age", "tcell")]))
arg.1 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg1$smp$betas), beta = reg1$smp$beta, X = X.pred)
arg.2 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg2$smp$betas), beta = reg2$smp$beta, X = X.pred)
arg.list &lt;- list(arg.1, arg.2)
f.list &lt;- list(survfunc, survfunc)

# cause-specific competing-risk
# set rel.tol to smaller number in real-world applications
out.cfc &lt;- cfc(f.list, arg.list, nobs.pred * nsmp, tout, rel.tol = 1e-2)

# summarizing (and plotting) the results
# this function calculates the population-average CI and survival, one
# per each MCMC sample; therefore, the quantiles produced by the summary
# method, correspondingly, reflect our confidence in population-average values
my.f.reduce &lt;- function(x, nobs, nsmp) {
  return (colMeans(array(x, dim = c(nobs, nsmp))))
}
my.summ &lt;- summary(out.cfc, f.reduce = my.f.reduce, nobs = nobs.pred, nsmp = nsmp)


## End(Not run)
</code></pre>


</div>