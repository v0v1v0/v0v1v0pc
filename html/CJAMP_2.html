<div class="container">

<table style="width: 100%;"><tr>
<td>cjamp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>C-JAMP: Copula-based joint analysis of multiple phenotypes.</h2>

<h3>Description</h3>

<p>Functions to perform C-JAMP: <code>cjamp</code> fits a joint model of two
phenotypes conditional on one or multiple predictors; <code>cjamp_loop</code>
uses <code>cjamp</code> to fit the same copula model separately for a list of
multiple predictors, e.g. for a genetic association study.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cjamp(copula = "Clayton", Y1 = NULL, Y2 = NULL,
  predictors_Y1 = NULL, predictors_Y2 = NULL, scale_var = FALSE,
  optim_method = "BFGS", trace = 0, kkt2tol = 1e-16, SE_est = TRUE,
  pval_est = TRUE, n_iter_max = 10)

cjamp_loop(copula = "Clayton", Y1 = NULL, Y2 = NULL,
  predictors = NULL, covariates_Y1 = NULL, covariates_Y2 = NULL,
  scale_var = FALSE, optim_method = "BFGS", trace = 0,
  kkt2tol = 1e-16, SE_est = TRUE, pval_est = TRUE, n_iter_max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>copula</code></td>
<td>
<p>String indicating whether the joint model will be computed
under the Clayton (<code>"Clayton"</code>) or 2-parameter copula
(<code>"2param"</code>) model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y1</code></td>
<td>
<p>Numeric vector containing the first phenotype.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y2</code></td>
<td>
<p>Numeric vector containing the second phenotype.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictors_Y1</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y1</code>
in columns (for the <code>cjamp</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictors_Y2</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y2</code>
in columns (for the <code>cjamp</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_var</code></td>
<td>
<p>Logical. Indicating whether all predictors will be centered and
scaled before the analysis or not (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim_method</code></td>
<td>
<p>String passed to the <code>optimx</code>
function. It specifies the optimization method in the
<code>optimx</code> function that is used for
maximizing the log-likelihood function. Recommended is the
<code>"BFGS"</code> optimization method (default). For further
methods, see the description of the
<code>optimx</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Integer passed to the <code>optimx</code>
function. It specifies the tracing information on the progress
of the optimization. The value <code>2</code> gives full tracing,
default value <code>0</code> blocks all details. See also the <code>optimx</code>
documentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kkt2tol</code></td>
<td>
<p>Numeric. Passed to the <code>optimx</code>
function, default value is 1E-16. It specifies the tolerance for
the eigenvalue ratio in the Karush-Kuhn-Tucker (KKT) test for a positive definite
Hessian matrix. See also the <code>optimx</code>
documentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE_est</code></td>
<td>
<p>Logical indicator whether standard error estimates are
computed for the parameters using the inverse of the observed
information matrix (<code>TRUE</code>, default), or whether standard
error estimates are not computed (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval_est</code></td>
<td>
<p>Logical indicator whether p-values are computed from
hypothesis tests of the absence of effects of each predictor
on each phenotype in the marginal models (<code>TRUE</code>, default),
or whether p-values are not computed (<code>FALSE</code>). P-values
are obtained from large sample Wald-type tests based on the
maximum likelihood parameter estimates and the standard error
estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_iter_max</code></td>
<td>
<p>Integer indicating the maximum number of optimization attempts
of the log-likelihood function with different starting values,
if the optimization doesn't converge (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictors</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y1</code>
and <code>Y2</code> in columns for which estimates are returned
(for the <code>cjamp_loop</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates_Y1</code></td>
<td>
<p>Dataframe containing the covariates of <code>Y1</code>
in columns for which estimates are not returned
(for the <code>cjamp_loop</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates_Y2</code></td>
<td>
<p>Dataframe containing the covariates of <code>Y2</code>
in columns for which estimates are not returned
(for the <code>cjamp_loop</code> function).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both functions <code>cjamp</code> and <code>cjamp_loop</code> fit a joint copula model
of two phenotypes using the Clayton copula or 2-parameter copula, conditional on none
or multiple predictors and covariates in the marginal models. The <code>optimx</code>
function of the <code>optimx</code> package is used to maximize the log-likelihood (i.e. to minimize
the minus log-likelihood function <code>minusloglik</code>) to obtain
maximum likelihood coefficient estimates of all parameters.
For this, the BFGS optimization method is recommended. Standard error estimates
of the coefficient estimates can be obtained by using
the observed inverse information matrix. P-values from hypothesis tests of
the absence of effects of each predictor on each phenotype in the marginal
models can be obtained from large-sample Wald-type tests (see the vignette for details).
</p>
<p>It should be noted that <code>cjamp</code>, <code>cjamp_loop</code> and
<code>minusloglik</code>) assume quantitative predictors and use an
additive model, i.e. for categorical predictors with more than 2 levels,
dummy variables have to be created beforehand. Accordingly, if single
nucleotide variants (SNVs) are included as predictors, the computation is
based on an additive genetic model if SNVs are provided as 0-1-2 genotypes
and on a dominant model if SNVs are provided as 0-1 genotypes.
</p>
<p>The <code>cjamp</code> function returns point estimates of all parameters,
standard error estimates and p-values for all marginal parameters (i.e. all parameters
for <code>predictors_Y1</code>, <code>predictors_Y1</code>), the minus
log-likelihood value as well as information about the convergence. The
<code>cjamp_loop</code> function only returns point estimates, standard error
estimates, and p-values for the specified predictors <code>predictors</code> and not
the covariates <code>covariates_Y1</code> and <code>covariates_Y2</code>, in addition
to the minus log-likelihood value as well as convergence information.
</p>
<p>It is recommended that all variables are centered and scaled before the analysis,
which can be done through the <code>scale_var</code> parameter. Otherwise, if the scales
of the variables differ, it can lead to convergence problems of the optimization.
</p>


<h3>Value</h3>

<p>An object of class <code>cjamp</code>, for which the summary function
<code>summary.cjamp</code> is implemented. The output is a list
containing estimates of the copula parameters, marginal parameters, Kendall's
tau (as well as the upper and lower tail dependence <code class="reqn">\lambda_l,
        \lambda_u</code> if the 2-parameter copula model is fitted), the standard
error estimates of all parameters, p-values of hypothesis tests
of the marginal parameters (i.e. of the absence of predictor effects on the
phenotypes), the convergence code of the log-likelihood maximization
(from the <code>optimx</code>
function, where 0 indicates successful convergence), the KKT
conditions 1 and 2 of the convergence, and the maximum log-likelihood value.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Data generation
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 100)
phenodata &lt;- generate_phenodata_2_copula(genodata = genodata$SNV1,
                                         MAF_cutoff = 1, prop_causal = 1,
                                         tau = 0.2, b1 = 0.3, b2 = 0.3)
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                         genodata[, 1:3])

## Not run. When executing, the following takes about 2 minutes running time.
## Example 1: Analysis of multiple SNVs as predictors in one model
#cjamp(copula = "Clayton", Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#      predictors_Y1 = predictors, predictors_Y2 = predictors,
#      optim_method = "BFGS", trace = 0, kkt2tol = 1E-16, SE_est = TRUE,
#      pval_est = TRUE, n_iter_max = 10)
#cjamp(copula = "2param", Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#      predictors_Y1 = predictors, predictors_Y2 = predictors,
#      optim_method = "BFGS", trace = 0, kkt2tol = 1E-16, SE_est = TRUE,
#      pval_est = TRUE, n_iter_max = 10)
#
## Example 2: Analysis of multiple SNVs in separate models
#covariates &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
#predictors &lt;- genodata
#cjamp_loop(copula = "Clayton", Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#           predictors = predictors, covariates_Y1 = covariates,
#           covariates_Y2 = covariates, optim_method = "BFGS", trace = 0,
#           kkt2tol = 1E-16, SE_est = TRUE, pval_est = TRUE,
#           n_iter_max = 10)

</code></pre>


</div>