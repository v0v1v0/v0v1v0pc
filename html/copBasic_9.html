<div class="container">

<table style="width: 100%;"><tr>
<td>blomatrixCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Matrix of Blomqvist-like Betas of a Copula</h2>

<h3>Description</h3>

<p>Compute the <em>Blomqvist-like Betas matrix</em> <code class="reqn">\beta^\circ_\mathbf{C}</code>-matrix of a copula, which is defined at presumably strategic points within <code class="reqn">\mathcal{I}^2</code>, as (for <code>as.blomCOPss=FALSE</code> argument)
</p>
<p style="text-align: center;"><code class="reqn">\beta^\circ_\mathbf{C} = \frac{\mathbf{C}(u^\circ,v^\circ)}{\mathbf{\Pi}(1/2, 1/2)} - 1\mbox{,}</code>
</p>

<p>where the <code class="reqn">u^\circ</code> and <code class="reqn">v^\circ</code> are of two types of gridded locations in <code class="reqn">\mathcal{I}^2</code> space and if <code class="reqn">u^\circ = 1/2</code> and <code class="reqn">v^\circ = 1/2</code>, then central location of the matrix is <em>Blomqvist Beta</em> (<code>blomCOP</code>). The definition of <code class="reqn">\beta^\circ_\mathbf{C}</code> is such that the matrix is entirely zero for the <em>independence copula</em> (<code class="reqn">\mathbf{\Pi}(u,v)</code>) (<code>P</code>) when <code class="reqn">\mathbf{C}(u^\circ,v^\circ) = \mathbf{\Pi}(u,v)</code> at the medial location <code class="reqn">u,v=1/2</code>. Also, the definition here might be unique to the <span class="pkg">copBasic</span> package. The decile version (<code>blomatrixCOPdec</code>) of this function uses <code class="reqn">u^\circ \in (1, 5, 9) / 10</code> and <code class="reqn">v^\circ \in (1, 5, 9) / 10</code>. Whereas, the quartile version (<code>blomatrixCOPiqr</code>) of this function uses  <code class="reqn">u^\circ \in (25, 50, 75) / 100</code> and <code class="reqn">v^\circ \in (25, 50, 75)/100</code>. If <code>as.blomCOPss=TRUE</code> argument is set (<b>default operation</b>), then the coordinate locations in the matrix become the <code class="reqn">\beta^\diamond_\mathbf{C}</code> of <code>blomCOPss</code>. As a rule <code class="reqn">\beta^\circ_\mathbf{C} \ne \beta^\diamond_\mathbf{C}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">blomatrixCOPdec(cop=NULL, para=NULL, as.sample=FALSE, as.blomCOPss=TRUE,
                  ctype=c("weibull", "hazen", "1/n",
                          "bernstein", "checkerboard"), ...)
blomatrixCOPiqr(cop=NULL, para=NULL, as.sample=FALSE, as.blomCOPss=TRUE,
                  ctype=c("weibull", "hazen", "1/n",
                          "bernstein", "checkerboard"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.sample</code></td>
<td>
<p>A logical controlling whether an optional <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> in <code>para</code> is used to compute the  <code class="reqn">\hat\beta^\circ_\mathbf{C}</code>-matrix at which point the <code>ctype</code> argument will be passed to multiple calls of <code>EMPIRcop</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.blomCOPss</code></td>
<td>
<p>A logical to trigger <code>blomCOPss</code> for each of the <code class="reqn">(u,v)</code> locations where for the <code>blomCOPss</code> calls (<code class="reqn">\beta^\diamond_\mathbf{C}(\mathbf{u}, \mathbf{v})</code>): <code class="reqn">u \mapsto (u,u) \mapsto \mathbf{u}</code> and  <code class="reqn">v  \mapsto (v,v) \mapsto \mathbf{v}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctype</code></td>
<td>
<p>Argument of the same as <code>EMPIRcop</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copula.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The matrix for <code class="reqn">\beta^\circ_\mathbf{C}</code> is returned depending on whether the decile or quartile version has been called.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>See Also</h3>

<p><code>blomCOP</code>, <code>blomCOPss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">round(blomatrixCOPdec(cop=P), digits=8);     round(blomatrixCOPiqr(cop=P), digits=8)
#          U|V=0.10 U|V=0.50 U|V=0.90        #          U|V=0.25 U|V=0.50 U|V=0.75
# U|V=0.90        0        0        0        # U|V=0.75        0        0        0
# U|V=0.50        0        0        0        # U|V=0.50        0        0        0
# U|V=0.10        0        0        0        # U|V=0.25        0        0        0

round(blomatrixCOPdec(cop=PSP, as.blomCOPss=TRUE), digits=8)
#           U|V=0.10   U|V=0.50   U|V=0.90
# U|V=0.90 0.4736842  0.8181818  0.5153268
# U|V=0.50 0.8181818  0.3333333  0.6459330
# U|V=0.10 0.8901099  0.4736842  0.1708292

round(blomatrixCOPdec(cop=PSP, as.blomCOPss=FALSE), digits=8)
#            U|V=0.10   U|V=0.50  U|V=0.90
# U|V=0.90 0.09890110 0.81818182 4.2631579
# U|V=0.50 0.05263158 0.33333333 0.8181818
# U|V=0.10 0.01010101 0.05263158 0.0989011

## Not run: 
set.seed(1)
td &lt;- c(0.10, 0.50, 0.90)
UVn &lt;- simCOP(n=5000, cop=glueCOP, col=8,
          para=list(glue=0.4, cop1 =PLcop,           cop2=PLcop,
                             para1=PLpar(rho=-0.5), para2=PLpar(rho=+0.5)))
points(td, rep(td[3], 3), cex=2, lwd=2, pch=3, col="red")
points(td, rep(td[2], 3), cex=2, lwd=2, pch=3, col="red")
points(td, rep(td[1], 3), cex=2, lwd=2, pch=3, col="red")

print(blomatrixCOPdec(as.sample=TRUE, para=UVn, ctype="weibull"))
#             U|V=0.10 U|V=0.50 U|V=0.90
# U|V=0.90 -0.08222222   -0.580   -0.190
# U|V=0.50  0.30800000    0.112    0.264
# U|V=0.10  0.84000000    0.620    0.262

BMdn &lt;- blomatrixCOPdec(cop=glueCOP,
          para=list(glue=0.4,  cop1=PLcop,            cop2=PLcop,
                              para1=PLpar(rho=-0.5), para2=PLpar(rho=+0.5)))
print(round(BMdn, digits=8))
#             U|V=0.10   U|V=0.50   U|V=0.90
# U|V=0.90 -0.08110464 -0.5569028 -0.2053772
# U|V=0.50  0.33449815  0.1202744  0.2424668
# U|V=0.10  0.75217766  0.6013719  0.2424668 
## End(Not run)


## Not run: 
set.seed(1); nsim &lt;- 2000
para.pop &lt;- list( cop1=GHcop,             cop2=PLcop,  alpha=0.359,
                 para1=c(4.003, 1.099),  para2=0.882,   beta=0.292)
UVs &lt;- simCOP(nsim, cop=composite2COP, para=para.pop)
mtext("GIVEN THIS SAMPLE")
Rho &lt;- rhoCOP(as.sample=TRUE, para=UVs) # Spearman Rho
BMn &lt;- blomatrixCOPdec(as.sample=TRUE, para=UVs, ctype="weibull")

parafn &lt;- function(k) {
  c(exp(k[1])+1, exp(k[2]), exp(k[3]), pnorm(k[4]), pnorm(k[5]))
}
parafn_list &lt;- function(k) {
  k &lt;- parafn(k)
  list(cop1=GHcop, para1=c(k[1], k[2]), alpha=k[4],
       cop2=PLcop, para2=k[4],          beta=k[5])
}
BLOM_ofun &lt;- function(para, statmat=NULL, parafn=NULL, rho=NA) {
   para &lt;- parafn(para)
   new.para &lt;- list(cop1=GHcop, para1=para[1:2], alpha=para[4],
                    cop2=PLcop, para2=para[3],    beta=para[5])
   bm &lt;- blomatrixCOPdec(cop=composite2COP, para=new.para)
   err &lt;- sum((statmat - bm)^2) + (rhoCOP(cop=composite2COP, para=new.para) - rho)^2
   #print(c(para, err))
   return(err)
}

run1 &lt;- function(graphics=TRUE, nsim=0) {
  par.init &lt;- c(log(1), log(1), log(1), qnorm(0.5), qnorm(0.5))
  rt       &lt;- optim(par.init, BLOM_ofun, statmat=BMn, parafn=parafn, rho=Rho)
  para     &lt;- parafn(rt$par)
  para.fit &lt;- list(  cop1=GHcop,      cop2=PLcop,   alpha=para[4],
                    para1=para[1:2], para2=para[3],  beta=para[5])
  uv &lt;- simCOP(nsim, cop=composite2COP, para=para.fit, graphics=graphics, col=2)
  rmse &lt;- round(rmseCOP(uv[,1], uv[,2], ctype="weibull",
                        cop=composite2COP, para=para.fit), digits=8)
  if(graphics) mtext(paste0("RMSE(run1)=", rmse))
  return(list(rmse=rmse, para=para.fit))
}
system.time(RUN1 &lt;- run1(nsim=nsim))
par.init &lt;- c(log(RUN1$para$para1[1]), log(RUN1$para$para1[2]),
              log(RUN1$para$para2), qnorm(RUN1$para$alpha), qnorm(RUN1$para$beta))

RMSE_ofun &lt;- function(para, parafn=NULL) {
   para &lt;- parafn(para)
   new.para &lt;- list(cop1=GHcop, para1=para[1:2], alpha=para[4],
                    cop2=PLcop, para2=para[3],    beta=para[5])
   new.rmse &lt;- rmseCOP(UVs[,1], UVs[,2], cop=composite2COP, para=new.para)
   #print(c(para, new.rmse))
   return(new.rmse)
}
run2 &lt;- function(graphics=TRUE, nsim=0, par.init=NULL) {
  if(is.null(par.init)) {
    par.init &lt;- c(log(1), log(1), log(1), qnorm(0.5), qnorm(0.5))
  }
  rt       &lt;- optim(par.init, RMSE_ofun, parafn=parafn)
  para     &lt;- parafn(rt$par)
  para.fit &lt;- list(  cop1=GHcop,      cop2=PLcop,   alpha=para[4],
                    para1=para[1:2], para2=para[3],  beta=para[5])
  uv &lt;- simCOP(nsim, cop=composite2COP, para=para.fit, graphics=graphics, col=4)
  rmse &lt;- round(rmseCOP(uv[,1], uv[,2], ctype="weibull",
                        cop=composite2COP, para=para.fit), digits=8)
  if(graphics) mtext(paste0("RMSE(run2)=", rmse))
  return(list(rmse=rmse, para=para.fit))
}
system.time(RUN2.1 &lt;- run2(nsim=nsim, par.init=par.init))
system.time(RUN2.2 &lt;- run2(nsim=nsim, par.init=NULL    ))

GIVN &lt;- c(para.pop$alpha, para.pop$para1, para.pop$beta, para.pop$para2)
FIT1   &lt;- c(RUN1$para$alpha, RUN1$para$para1, RUN1$para$beta, RUN1$para$para2)
FIT1   &lt;- round(FIT1, digits=3)
FIT2.1 &lt;- c(RUN2.1$para$alpha, RUN2.1$para$para1, RUN2.1$para$beta, RUN2.1$para$para2)
FIT2.1 &lt;- round(FIT2.1, digits=3)
FIT2.2 &lt;- c(RUN2.2$para$alpha, RUN2.2$para$para1, RUN2.2$para$beta, RUN2.2$para$para2)
FIT2.2 &lt;- round(FIT2.2, digits=3)
nms    &lt;- c("what", "alpha", "para1_1", "para1_2", "beta", "para2")
GIVN   &lt;- c("given",   GIVN);  FIT2.1 &lt;- c("by_Blom1", FIT2.1)
FIT1   &lt;- c("by_RMSE", FIT1);  FIT2.2 &lt;- c("by_Blom2", FIT2.2)
names(GIVN)   &lt;- nms; names(FIT1)   &lt;- nms
names(FIT2.1) &lt;- nms; names(FIT2.2) &lt;- nms
RESL &lt;- cbind(data.frame(GIVN), data.frame(FIT1), data.frame(FIT2.1), data.frame(FIT2.2))
print(RESL) #
## End(Not run)
</code></pre>


</div>