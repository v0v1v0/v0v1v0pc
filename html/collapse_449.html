<div class="container">

<table style="width: 100%;"><tr>
<td>pivot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast and Easy Data Reshaping
</h2>

<h3>Description</h3>

<p><code>pivot()</code> is <em>collapse</em>'s data reshaping command. It combines longer-, wider-, and recast-pivoting functionality in a single parsimonious API. Notably, it can also accommodate variable labels.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pivot(data,               # Summary of Documentation:
      ids = NULL,         # identifier cols to preserve
      values = NULL,      # cols containing the data
      names = NULL,       # name(s) of new col(s) | col(s) containing names
      labels = NULL,      # name of new labels col | col(s) containing labels
      how = "longer",     # method: "longer"/"l", "wider"/"w" or "recast"/"r"
      na.rm = FALSE,      # remove rows missing 'values' in reshaped data
      factor = c("names", "labels"), # create new id col(s) as factor variable(s)?
      check.dups = FALSE, # detect duplicate 'ids'+'names' combinations

      # Only apply if how = "wider" or "recast"
      FUN = "last",       # aggregation function (internal or external)
      FUN.args = NULL,    # list of arguments passed to aggregation function
      nthreads = .op[["nthreads"]], # minor gains as grouping remains serial
      fill = NULL,        # value to insert for unbalanced data (default NA/NULL)
      drop = TRUE,        # drop unused levels (=columns) if 'names' is factor
      sort = FALSE,       # "ids": sort 'ids' and/or "names": alphabetic casting

      # Only applies if how = "wider" with multiple long columns ('values')
      transpose = FALSE   # "columns": applies t_list() before flattening, and/or
)                         # "names": sets names nami_colj. default: colj_nami
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame-like object (list of equal-length columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ids</code></td>
<td>
<p>identifier columns to keep. Specified using column names, indices, a logical vector or an identifier function e.g. <code>is_categorical</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>columns containing the data to be reshaped. Specified like <code>ids</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>names of columns to generate, or retrieve variable names from:
</p>

<table>
<tr>
<td style="text-align: left;">
<code> how </code>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
                 <code>"longer"</code>  </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> list of names for the variable and value column in the long format, respectively. If <code>NULL</code>, <code>list("variable", "value")</code> will be chosen. Alternatively, a named list length 1 or 2 can be provided using "variable"/"value" as keys e.g. <code>list(value = "data_col")</code>.   </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
                 <code> "wider"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> column(s) containing names of the new variables. Specified using a vector of column names, indices, a logical vector or selector function e.g. <code>is.character</code>. Multiple columns will be combined using <code>finteraction</code> with <code>"_"</code> as separator.  </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
                 <code> "recast"</code>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> (named) list with the following elements: [[1]]/[["from"]] - column(s) containing names of the new variables, specified as in <code>"wider"</code>; [[2]]/[["to"]] - name of the variable to generate containing old column names. If <code>NULL</code>, <code>list("variable", "variable")</code> will be chosen.   </td>
</tr>
<tr>
<td style="text-align: left;">
                 </td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>

<p>names of columns to generate, or retrieve variable labels from:
</p>

<table>
<tr>
<td style="text-align: left;">
<code> how </code>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
                 <code>"longer"</code>  </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> A string specifying the name of the column to store labels - retrieved from the data using <code>vlabels(values)</code>. <code>TRUE</code> will create a column named <code>"label"</code>. Alternatively, a (named) list with two elements: [[1]]/[["name"]] - the name of the labels column; [[2]]/[["new"]] - a (named) character vector of new labels for the 'variable', 'label' and 'value' columns in the long-format frame. See Examples.   </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
                 <code> "wider"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> column(s) containing labels of the new variables. Specified using a vector of column names, indices, a logical vector or selector function e.g. <code>is.character</code>. Multiple columns will be combined using <code>finteraction</code> with <code>" - "</code> as separator.  </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
                 <code> "recast"</code>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> (named) list with the following elements: [[1]]/[["from"]] - column(s) containing labels for the new variables, specified as in <code>"wider"</code>; [[2]]/[["to"]] - name of the variable to generate containing old labels; [[3]]/[["new"]] - a (named) character vector of new labels for the generated 'variable' and 'label' columns. If [[1]]/[["from"]] is not supplied, this can also include labels for new variables. Omitting one of the elements via a named list or setting it to <code>NULL</code> in a list of 3 will omit the corresponding operation i.e. either not saving existing labels or not assigning new ones.  </td>
</tr>
<tr>
<td style="text-align: left;">
                 </td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>how</code></td>
<td>

<p>character. The pivoting method: one of <code>"longer"</code>, <code>"wider"</code> or <code>"recast"</code>. These can be abbreviated by the first letter i.e. <code>"l"/"w"/"r"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>

<p>logical. <code>TRUE</code> will remove missing values such that in the reshaped data there is no row missing all data columns - selected through 'values'. For wide/recast pivots using internal <code>FUN</code>'s <code>"first"/"last"/"count"</code>, this also toggles skipping of missing values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>

<p>character. Whether to generate new 'names' and/or 'labels' columns as factor variables. This is generally recommended as factors are more memory efficient than character vectors and also faster in subsequent filtering and grouping. Internally, this argument is evaluated as <code>factor &lt;- c("names", "labels") %in% factor</code>, so passing anything other than <code>"names"</code> and/or <code>"labels"</code> will disable it.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.dups</code></td>
<td>

<p>logical. <code>TRUE</code> checks for duplicate 'ids'+'names' combinations, and, if 'labels' are specified, also for duplicate 'names'+'labels' combinations. The default <code>FALSE</code> implies that the algorithm just runs through the data, leading effectively to the <code>FUN</code> option to be executed (default last value). See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>

<p>function to aggregate values. At present, only a single function is allowed. Fast Statistical Functions receive vectorized execution. For maximum efficiency, a small set of internal functions is provided: <code>"first"</code>, <code>"last"</code>, <code>"count"</code>, <code>"sum"</code>, <code>"mean"</code>, <code>"min"</code>, or <code>"max"</code>. In options <code>"first"/"last"/"count"</code> setting <code>na.rm = TRUE</code> skips missing values. In options <code>"sum"/"mean"/"min"/"max"</code> missing values are always skipped (see Details why). The <code>fill</code> argument is ignored in <code>"count"/"sum"/"mean"/"min"/"max"</code> (<code>"count"/"sum"</code> force <code>fill = 0</code> else <code>NA</code> is used).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.args</code></td>
<td>

<p>(optional) list of arguments passed to <code>FUN</code> (if using an external function). Data-length arguments such as weight vectors are supported.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>

<p>integer. if <code>how = "wider"|"recast"</code>: number of threads to use with OpenMP (default <code>get_collapse("nthreads")</code>, initialized to 1). Only the distribution of values to columns with <code>how = "wider"|"recast"</code> is multithreaded here. Since grouping id columns on a long data frame is expensive and serial, the gains are minor. With <code>how = "long"</code>, multithreading does not make much sense as the most expensive operation is allocating the long results vectors. The rest is a couple of <code>memset()</code>'s in C to copy the values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>if <code>how = "wider"|"recast"</code>: value to insert for 'ids'-'names' combinations not present in the long format. <code>NULL</code> uses <code>NA</code> for atomic vectors and <code>NULL</code> for lists.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>

<p>logical. if <code>how = "wider"|"recast"</code> and 'names' is a single factor variable: <code>TRUE</code> will check for and drop unused levels in that factor, avoiding the generation of empty columns.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>

<p>if <code>how = "wider"|"recast"</code>: specifying <code>"ids"</code> applies ordered grouping on the id-columns, returning data sorted by ids. Specifying <code>"names"</code> sorts the names before casting (unless 'names' is a factor), yielding columns cast in alphabetic order. Both options can be passed as a character vector, or, alternatively, <code>TRUE</code> can be used to enable both.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transpose</code></td>
<td>

<p>if <code>how = "wider"|"recast"</code> and multiple columns are selected through 'values': specifying <code>"columns"</code> applies <code>t_list</code> to the result before flattening, resulting in a different column order. Specifying <code>"names"</code> generates names of the form nami_colj, instead of colj_nami. Both options can be passed as a character vector, or, alternatively, <code>TRUE</code> can be used to enable both.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Pivot wider essentially works as follows: compute <code>g_rows = group(ids)</code> and also <code>g_cols = group(names)</code> (using <code>group</code> if <code>sort = FALSE</code>). <code>g_rows</code> gives the row-numbers of the wider data frame and <code>g_cols</code> the column numbers.
</p>
<p>Then, a C function generates a wide data frame and runs through each long column ('values'), assigning each value to the corresponding row and column in the wide frame. In this process <code>FUN</code> is always applied. The default, <code>"last"</code>, does nothing at all, i.e., if there are duplicates, some values are overwritten. <code>"first"</code> works similarly just that the C-loop is executed the other way around. The other hard-coded options count, sum, average, or compare observations on the fly. Missing values are internally skipped for statistical functions as there is no way to distinguish an incoming <code>NA</code> from an initial <code>NA</code> - apart from counting occurrences using an internal structure of the same size as the result data frame which is costly and thus not implemented.
</p>
<p>When passing an R-function to <code>FUN</code>, the data is grouped using <code>g_full = group(list(g_rows, g_cols))</code>, aggregated by groups, and expanded again to full length using <code>TRA</code> before entering the reshaping algorithm. Thus, this is significantly more expensive than the optimized internal functions. With Fast Statistical Functions the aggregation is vectorized across groups, other functions are applied using <code>BY</code> - by far the slowest option.

</p>
<p>If <code>check.dups = TRUE</code>, a check of the form  <code>fnunique(list(g_rows, g_cols)) &lt; fnrow(data)</code> is run, and an informative warning is issued if duplicates are found.
</p>
<p>Recast pivoting works similarly. In long pivots <code>FUN</code> is ignored and the check simply amounts to <code>fnunique(ids) &lt; fnrow(data)</code>. 
</p>


<h3>Value</h3>

<p>A reshaped data frame with the same class and attributes (except for 'names'/'row-names') as the input frame.
</p>


<h3>Note</h3>

<p>Leaving either 'ids' or 'values' empty will assign all other columns (except for <code>"variable"</code> if <code>how = "wider"|"recast"</code>) to the non-specified argument. It is also possible to leave both empty, e.g. for complete melting if <code>how = "wider"</code> or data transposition if <code>how = "recast"</code> (similar to <code>data.table::transpose</code> but supporting multiple names columns and variable labels). See Examples.
</p>
<p><code>pivot</code> currently does not support concurrently melting/pivoting longer to multiple columns. See <code>data.table::melt</code> or <code>pivot_longer</code> from <em>tidyr</em> or <em>tidytable</em> for an efficient alternative with this feature. It is also possible to achieve this with just a little bit of programming. An example is provided below. 
</p>


<h3>See Also</h3>

<p><code>collap</code>, <code>vec</code>, <code>rowbind</code>, <code>unlist2d</code>, Data Frame Manipulation, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R"># -------------------------------- PIVOT LONGER ---------------------------------
# Simple Melting (Reshaping Long)
pivot(mtcars) |&gt; head()
pivot(iris, "Species") |&gt; head()
pivot(iris, values = 1:4) |&gt; head() # Same thing

# Using collapse's datasets
head(wlddev)
pivot(wlddev, 1:8, na.rm = TRUE) |&gt; head()
pivot(wlddev, c("iso3c", "year"), c("PCGDP", "LIFEEX"), na.rm = TRUE) |&gt; head()
head(GGDC10S)
pivot(GGDC10S, 1:5, names = list("Sectorcode", "Value"), na.rm = TRUE) |&gt; head()
# Can also set by name: variable and/or value. Note that 'value' here remains lowercase
pivot(GGDC10S, 1:5, names = list(variable = "Sectorcode"), na.rm = TRUE) |&gt; head()

# Melting including saving labels
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = TRUE) |&gt; head()
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = "description") |&gt; head()

# Also assigning new labels
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = list("description",
            c("Sector Code", "Sector Description", "Value"))) |&gt; namlab()

# Can leave out value column by providing named vector of labels
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = list("description",
          c(variable = "Sector Code", description = "Sector Description"))) |&gt; namlab()

# Now here is a nice example that is explicit and respects the dataset naming conventions
pivot(GGDC10S, ids = 1:5, na.rm = TRUE,
      names = list(variable = "Sectorcode",
                   value = "Value"),
      labels = list(name = "Sector",
                    new = c(Sectorcode = "GGDC10S Sector Code",
                            Sector = "Long Sector Description",
                            Value = "Employment or Value Added"))) |&gt;
  namlab(N = TRUE, Nd = TRUE, class = TRUE)

# Note that pivot() currently does not support melting to multiple columns
# But you can tackle the issue with a bit of programming:
wide &lt;- pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable",
              how = "wider", na.rm = TRUE)
head(wide)
library(magrittr)
wide %&gt;% {av(pivot(., 1:2, grep("_VA", names(.))), pivot(gvr(., "_EMP")))} |&gt; head()
wide %&gt;% {av(av(gv(., 1:2), rm_stub(gvr(., "_VA"), "_VA", pre = FALSE)) |&gt;
                   pivot(1:2, names = list("Sectorcode", "VA"), labels = "Sector"),
             EMP = vec(gvr(., "_EMP")))} |&gt; head()
rm(wide)

# -------------------------------- PIVOT WIDER ---------------------------------
iris_long &lt;- pivot(iris, "Species") # Getting a long frame
head(iris_long)
# If 'names'/'values' not supplied, searches for 'variable' and 'value' columns
pivot(iris_long, how = "wider")
# But here the records are not identified by 'Species': thus aggregation with last value:
pivot(iris_long, how = "wider", check = TRUE) # issues a warning
rm(iris_long)

# This works better, these two are inverse operations
wlddev |&gt; pivot(1:8) |&gt; pivot(how = "w") |&gt; head()
# ...but not perfect, we loose labels
namlab(wlddev)
wlddev |&gt; pivot(1:8) |&gt; pivot(how = "w") |&gt; namlab()
# But pivot() supports labels: these are perfect inverse operations
wlddev |&gt; pivot(1:8, labels = "label") |&gt; print(max = 50) |&gt; # Notice the "label" column
  pivot(how = "w", labels = "label") |&gt; namlab()

# If the data does not have 'variable'/'value' cols: need to specify 'names'/'values'
# Using a single column:
pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", how = "w") |&gt; head()
SUM_wide &lt;- pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", how = "w", na.rm = TRUE)
head(SUM_wide) # na.rm = TRUE here removes all new rows completely missing data
tail(SUM_wide) # But there may still be NA's, notice the NA in the final row
# We could use fill to set another value
pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", how = "w",
      na.rm = TRUE, fill = -9999) |&gt; tail()
# This will keep the label of "SUM", unless we supply a column with new labels
namlab(SUM_wide)
# Such a column is not available here, but we could use "Variable" twice
pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", "Variable", how = "w",
      na.rm = TRUE) |&gt; namlab()
# Alternatively, can of course relabel ex-post
SUM_wide |&gt; relabel(VA = "Value Added", EMP = "Employment") |&gt; namlab()
rm(SUM_wide)

# Multiple-column pivots
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE) |&gt; head()
# Here we may prefer a transposed column order
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE, transpose = "columns") |&gt; head()
# Can also flip the order of names (independently of columns)
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE, transpose = "names") |&gt; head()
# Can also enable both (complete transposition)
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE, transpose = TRUE) |&gt; head() # or tranpose = c("columns", "names")

# Finally, here is a nice, simple way to reshape the entire dataset.
pivot(GGDC10S, values = 6:16, names = "Variable", na.rm = TRUE, how = "w") |&gt;
  namlab(N = TRUE, Nd = TRUE, class = TRUE)

# -------------------------------- PIVOT RECAST ---------------------------------
# Look at the data again
head(GGDC10S)
# Let's stack the sectors and instead create variable columns
pivot(GGDC10S, .c(Country, Regioncode, Region, Year),
      names = list("Variable", "Sectorcode"), how = "r") |&gt; head()
# Same thing (a bit easier)
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"), how = "r") |&gt; head()
# Removing missing values
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"), how = "r",
      na.rm = TRUE) |&gt; head()
# Saving Labels
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"),
      labels = list(to = "Sector"), how = "r", na.rm = TRUE) |&gt; head()

# Supplying new labels for generated columns: as complete as it gets
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"),
      labels = list(to = "Sector",
                    new = c(Sectorcode = "GGDC10S Sector Code",
                            Sector = "Long Sector Description",
                            VA = "Value Added",
                            EMP = "Employment")), how = "r", na.rm = TRUE) |&gt;
  namlab(N = TRUE, Nd = TRUE, class = TRUE)

# Now another (slightly unconventional) use case here is data transposition
# Let's get the data for Botswana
BWA &lt;- GGDC10S |&gt; fsubset(Country == "BWA", Variable, Year, AGR:SUM)
head(BWA)
# By supplying no ids or values, we are simply requesting a transpose operation
pivot(BWA, names = list(from = c("Variable", "Year"), to = "Sectorcode"), how = "r")
# Same with labels
pivot(BWA, names = list(from = c("Variable", "Year"), to = "Sectorcode"),
      labels = list(to = "Sector"), how = "r")
# For simple cases, data.table::transpose() will be more efficient, but with multiple
# columns to generate names and/or variable labels to be saved/assigned, pivot() is handy
rm(BWA)
</code></pre>


</div>