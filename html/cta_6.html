<div class="container">

<table style="width: 100%;"><tr>
<td>ci.table</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test-Inversion CIs for Estimands in Contingency Tables</h2>

<h3>Description</h3>

<p>Constructs test-inversion approximate confidence intervals (CIs) for
estimands in contingency tables subject to equality constraints.
Test statistics include Wald-type statistics, and difference and
nested versions of power-divergence statistics. This program can also compute
test-inversion approximate confidence intervals for estimands in
contingency tables without additionally imposed equality constraints,
by setting the constraint function <code>h.fct = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ci.table(y, h.fct = 0, h.mean = FALSE, S.fct, S.mean = FALSE, S.P = FALSE,
         S.space.H0 = NULL, method = "all", cc = 0.95, pdlambda = 2/3,
         trans.g = NULL, trans.g.epsilon = 0, trans.g.inv = NULL,
         strata = rep(1, length(y)), fixed.strata = "all", delta = 0.5,
         max.iter = 50, tol = 1e-2, tol.psi = 1e-4, adj.epsilon = 0.03,
         iter.robust.max = 30, iter.robust.eff = 10, check.homog.tol = 1e-9,
         check.zero.order.homog.tol = 1e-9, max.mph.iter = 1000, step = 1,
         change.step.after = 0.25 * max.mph.iter, y.eps = 0, iter.orig = 5,
         norm.diff.conv = 1e-6, norm.score.conv = 1e-6,
         max.score.diff.iter = 10, h0.fct.deriv = NULL,
         S0.fct.deriv = NULL, trans.g.deriv = NULL, plot.CIs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.fct</code></td>
<td>
<p>The imposed equality constraint(s). Note that sampling constraints are not included in <code>h.fct</code>, and the imposed equality constraints should be non-redundant.
</p>
<p>If <code>h.mean = FALSE</code> (default), <code class="reqn">h(p)</code> should be the input, where <code class="reqn">p</code> is the vector of data model probabilities, or it can be called the vector of table probabilities; If <code>h.mean = TRUE</code>, <code class="reqn">h(m)</code> should be the input, where <code class="reqn">m</code> is the vector of expected table counts, i.e. <code class="reqn">m = E(Y)</code>. In the case of <code class="reqn">h(m)</code> being the input, the function <code class="reqn">h(\cdot)</code> should be <code class="reqn">Z</code> homogeneous, where <code class="reqn">Z</code> is the population matrix. For the definition of <code class="reqn">Z</code> homogeneity and the population matrix, see Lang (2004). Note that if there is no imposed equality constraint, we should input <code>h.fct = 0</code> (real number <code>0</code>). Please do not specify <code>h.fct</code> as a zero function in this case. On the contrary, if there is (are) imposed equality constraint(s), please specify <code>h.fct</code> as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function. Another important note is that if there are multiple imposed equality constraints, please use <code>rbind()</code>, not <code>c()</code>, to concatenate the imposed equality constraints into a column vector.
</p>
<p>By default, <code>h.fct = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.mean</code></td>
<td>
<p>Logical argument, <code>TRUE</code> or <code>FALSE</code>. If <code>h.mean = FALSE</code> (default), the input <code>h.fct</code> is treated as a function of <code class="reqn">p</code>; If <code>h.mean = TRUE</code>, the input <code>h.fct</code> is treated as a function of <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.fct</code></td>
<td>
<p>Parameter or estimand of interest. It should be an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, which returns a real number. i.e. <code class="reqn">S(\cdot)</code> is a real-valued function. If <code>S.mean = FALSE</code> and <code>S.P = FALSE</code> (default), <code class="reqn">S(p)</code> should be the input; If <code>S.mean = TRUE</code>, <code class="reqn">S(m)</code> should be the input; If <code>S.P = TRUE</code>, <code class="reqn">S(P)</code> should be the input, where <code class="reqn">P</code> is the vector of joint probabilities, or it can be called the vector of pre-data probabilities. In the case of <code class="reqn">S(m)</code> or <code class="reqn">S(P)</code> being the input, the function <code class="reqn">S(\cdot)</code> should be zero-order <code class="reqn">Z</code> homogeneous, then <code class="reqn">S(P)</code> is <code class="reqn">Z</code> estimable with <code class="reqn">S(P) = S(m)</code>. In addition, when we are in the process of computing test-inversion confidence intervals other than Wald intervals, we have to fit several models and obtain constrained MLEs of expected table counts. These models have equality constraints <code class="reqn">h_{0}^{*}(m) = 0</code>, where <code class="reqn">h_{0}^{*}(m) = (h_{0}'(m), S_{0}(m) - \psi, samp_{0}'(m))'</code>. Here <code class="reqn">h_{0}(m) = 0</code> is (are) the imposed equality constraint(s), written in terms of <code class="reqn">m</code>; <code class="reqn">S_{0}(m) - \psi = 0</code> means that the estimand of interest is equal to <code class="reqn">\psi</code>; <code class="reqn">samp_{0}(m) = 0</code> is (are) the sampling constraint(s), written in terms of <code class="reqn">m</code>. Restriction of <code class="reqn">S(m)</code> [or <code class="reqn">S(P)</code>] to zero-order <code class="reqn">Z</code> homogeneity guarantees the <code class="reqn">Z</code> homogeneity of <code class="reqn">h_{0}^{*}(m)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.mean, S.P</code></td>
<td>
<p>Logical argument, <code>TRUE</code> or <code>FALSE</code>. If <code>S.mean = FALSE</code> and <code>S.P = FALSE</code> (default), the input <code>S.fct</code> is treated as a function of <code class="reqn">p</code>; If <code>S.mean = TRUE</code>, the input <code>S.fct</code> is treated as a function of <code class="reqn">m</code>; If <code>S.P = TRUE</code>, the input <code>S.fct</code> is treated as a function of <code class="reqn">P</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e. subject to the imposed equality constraints along with sampling constraints. If <code>S.space.H0</code> is not specified or the input <code>S.space.H0 = NULL</code>, the restricted estimand space is treated as <code class="reqn">(-\infty, \infty)</code>, i.e. the whole real number line. If <code>S.space.H0</code> is specified, it can either be input as a vector of length of an even number, or be input in class <code>Intervals_full {intervals}</code>. As an example, if the restricted estimand space is <code class="reqn">(-\infty, -1] \cup [1, \infty)</code>, then the input <code>S.space.H0</code> could be <code>c(-Inf, -1, 1, Inf)</code>, or
<code>Intervals_full(matrix(c(-Inf, -1, 1, Inf), ncol = 2, byrow = TRUE), closed = matrix(c(FALSE, TRUE, TRUE, FALSE), ncol = 2, byrow = TRUE), type = "R")</code>. It is strongly recommended that <code>S.space.H0</code> be specified, as it will improve the accuracy and (possibly) speed in interval estimation. However, it is often difficult to have an idea of the restricted estimand space exactly. In this scenario, specification of one (or several) possibly larger interval(s) that cover(s) the exact restricted estimand space is also helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The test statistic(s) in constructing the test-inversion approximate confidence interval(s). There are eight different test statistics, and the user is allowed to choose any number of the test statistics out of the eight. The eight test statistics are listed as follows: <code>"Wald"</code>, <code>"trans.Wald"</code> (need specification of the transformation <code class="reqn">g</code>), <code>"diff.Xsq"</code>, <code>"nested.Xsq"</code>, <code>"diff.Gsq"</code> (same as <code>"PL"</code> or <code>"LR"</code>), <code>"nested.Gsq"</code>, <code>"diff.PD"</code>, <code>"nested.PD"</code> (need specification of the power-divergence index parameter <code class="reqn">\lambda</code>). If the input <code>method = "all"</code> (default), all test statistics will be employed to compute confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cc</code></td>
<td>
<p>Confidence coefficient, or the nominal level of the confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.g</code></td>
<td>
<p>The transformation <code class="reqn">g</code> used in the transformed Wald confidence interval. First, we construct a confidence interval for <code class="reqn">g(S(\cdot))</code>, then we back-transform, i.e. apply <code class="reqn">g^{-1}</code> to the endpoints in order to obtain a confidence interval for <code class="reqn">S(\cdot)</code>. There are several built-in options for the transformation: <code>"Fisher's z"</code>, <code>"log"</code>, <code>"-log"</code> (same as <code>"negative log"</code>), and <code>"[A, B]"</code>. <code>"[A, B]"</code> refers to the reparameterization trick as stated in the Discussion part of Lang (2008). The user is also allowed to input their own choice of <code>trans.g</code>. Ordinarily, the transformation <code class="reqn">g</code> should be a bijection. Ideally, <code class="reqn">g</code> should be smooth, strictly monotonically increasing, and "to parameterize away the boundary" (Lang, 2008).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.g.epsilon</code></td>
<td>
<p>The small <code class="reqn">\epsilon</code> adjustment included in the transformation <code class="reqn">g</code>. For example, the <code>"[A, B]"</code> transformation <code class="reqn">g</code> with the small <code class="reqn">\epsilon</code> is </p>
<p style="text-align: center;"><code class="reqn">g(x) = \log(x - A + \epsilon) - \log(B + \epsilon - x).</code>
</p>

<p>By default, <code>trans.g.epsilon = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.g.inv</code></td>
<td>
<p><code class="reqn">g^{-1}</code> function used in back-transformation step in construction of the transformed Wald confidence interval. If <code>trans.g</code> is any one of the built-in options, then <code>trans.g.inv</code> is automatically specified accordingly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership identifier. By default, <code>strata = rep(1, length(y))</code> refers to the single stratum (non-stratified) setting. As another example, <code>strata = c(1,1,2,2)</code> means that the first and second table cells belong to the first stratum, and the third and fourth table cells belong to the second stratum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has (have) fixed sample sizes. It can equal one of the keywords, <code>fixed.strata = "all"</code> or <code>fixed.strata = "none"</code>, or it can be a vector of stratum membership identifiers, e.g. <code>fixed.strata = c(1,3)</code> or <code>fixed.strata = c("pop1", "pop5")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical values within each sliding quadratic step. By default, <code>delta = 0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>One of the stopping criteria. It is the maximum number of iterations in the sliding quadratic root-finding algorithm for searching the two roots to the test-inversion equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>One of the stopping criteria. In solving for the roots to the test-inversion equation, if the test statistic for testing <code class="reqn">H_{0}(\psi): S_{0}(m) = \psi</code> vs. not <code class="reqn">H_{0}(\psi)</code> under the general hypothesis <code class="reqn">H_{0}: (h_{0}'(m), samp_{0}'(m))' = 0</code>, for a certain <code class="reqn">\psi</code>, is within <code>tol</code> of the critical value, then we stop the iterations, and this current <code class="reqn">\psi</code> is treated as one root. Note that since we are constructing approximate (contrary to exact) confidence intervals based on the asymptotic distribution under the null hypothesis, <code>tol</code> need not be too small.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.psi</code></td>
<td>
<p>One of the stopping criteria. In solving for the roots to the test-inversion equation, if the two <code class="reqn">\psi</code>'s that are in nearby iterates in the corresponding tests <code class="reqn">H_{0}(\psi)</code> vs. not <code class="reqn">H_{0}(\psi)</code> under the general hypothesis <code class="reqn">H_{0}</code>, are less than <code>tol.psi</code> apart in distance, then we stop the iterations, and the current <code class="reqn">\psi</code> is treated as one root. Note that we should specify <code>tol.psi</code> to be sufficiently small (compared with the size of the restricted estimand space) so that the iterations are to be terminated mainly because of closeness of the test statistic to the critical value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.epsilon, iter.robust.max, iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure. First, we attempt to construct confidence intervals based on the original data <code>y</code>, but an error might occur during this process. The reason for occurrence of the error might be the non-existence of the constrained MLE subject to <code class="reqn">H_{0}</code>, or it might be because of the fact that the <code class="reqn">\psi</code> in the hypothesis test <code class="reqn">H_{0}(\psi)</code> vs. not <code class="reqn">H_{0}(\psi)</code> is, on some scale, too far away from <code class="reqn">\widehat{\psi}</code> which is the constrained MLE of the estimand subject to <code class="reqn">H_{0}</code>, although this <code class="reqn">\psi</code> is still within the restricted estimand space. If an error, or non-convergence issue occurs, then the program will go through the robustifying procedure, with the goal of reporting a confidence interval anyway, even in the most extreme configuration and/or with the most "extreme" data.
</p>
<p>In the robustifying procedure, we adjust the original data <code>y</code> by adding <code>1 * adj.epsilon</code> to each original table count, and compute the confidence interval based on the adjusted data <code>y + 1 * adj.epsilon</code>. Note, however, that even the adjusted data may lead to non-convergence issue sometimes. We also adjust the original data by adding <code>2 * adj.epsilon</code>, <code class="reqn">\ldots</code>, <code>iter.robust.max * adj.epsilon</code>, and compute confidence intervals based on these adjusted data, respectively. For computing purposes, as soon as <code>iter.robust.eff</code> confidence intervals based on the adjusted data have been successfully computed, we will not proceed further into adjustment and interval estimation based on adjusted data. Now, by exploiting the property that </p>
<p style="text-align: center;"><code class="reqn">\lim_{\texttt{adj.epsilon} \rightarrow 0+} CI(y + \texttt{adj.epsilon}; H_{0}) = CI(y; H_{0}) ,</code>
</p>
<p> we extrapolate using a polynomial fit of degree at most three based on lower and upper endpoints of the confidence intervals on adjusted data. It is advised that
<code>adj.epsilon</code> should not exceed <code>0.1</code>, but it should not be too small. By default, <code>adj.epsilon = 0.03</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.homog.tol</code></td>
<td>
<p>Round-off tolerance for <code class="reqn">Z</code> homogeneity check. If the function <code class="reqn">h(\cdot)</code> with respect to <code class="reqn">m</code> is not <code class="reqn">Z</code> homogeneous, the algorithm will stop immediately and report an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.zero.order.homog.tol</code></td>
<td>
<p>Round-off tolerance for zero-order <code class="reqn">Z</code> homogeneity check. If the function <code class="reqn">S(\cdot)</code> with respect to <code class="reqn">m</code> or <code class="reqn">P</code> is not zero-order <code class="reqn">Z</code> homogeneous, the algorithm will stop immediately and report an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.mph.iter, step, change.step.after, y.eps, iter.orig, norm.diff.conv, norm.score.conv, max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h0.fct.deriv</code></td>
<td>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function object that computes analytic derivative of the transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>. In this algorithm, if the input function <code>h.fct</code> is a function of <code class="reqn">p</code>, then the algorithm automatically rewrites it into another function of <code class="reqn">m</code>: <code class="reqn">h(p) = h(Diag^{-1}(ZZ'm)m) = h_{0}(m)</code>. If the input function <code>h.fct</code> is a function of <code class="reqn">m</code>, then we let <code class="reqn">h_{0}(m) = h(m)</code>. <code>h0.fct.deriv</code>, if it is specified, equals <code class="reqn">\partial h_{0}'(m) / \partial m</code>. Note that if <code class="reqn">h_{0}(\cdot)</code> maps from <code class="reqn">R^p</code> to <code class="reqn">R^q</code>, i.e. there are <code class="reqn">q</code> constraints, then <code>h0.fct.deriv</code> returns a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix of partial derivatives. If <code>h0.fct.deriv</code> is not specified or <code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S0.fct.deriv</code></td>
<td>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>. In this algorithm, if the input function <code>S.fct</code> is a function of <code class="reqn">p</code>, then the algorithm automatically rewrites it into another function of <code class="reqn">m</code>: <code class="reqn">S(p) = S(Diag^{-1}(ZZ'm)m) = S_{0}(m)</code>. If the input function <code>S.fct</code> is a function of <code class="reqn">m</code>, then we let <code class="reqn">S_{0}(m) = S(m)</code>. If the input function <code>S.fct</code> is a function of <code class="reqn">P</code>, since <code class="reqn">S(\cdot)</code> is required to be zero-order <code class="reqn">Z</code> homogeneous, in which case <code class="reqn">S(P) = S(m)</code>, we let <code class="reqn">S_{0}(m) =
S(P)</code>. <code>S0.fct.deriv</code>, if it is specified, equals <code class="reqn">\partial S_{0}(m) / \partial m</code>. It is a column vector, whose length is the same as the length of <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.g.deriv</code></td>
<td>
<p>The derivative function of the transformation <code class="reqn">g</code>, i.e. <code class="reqn">d g(w) / d w</code>. If it is specified, it should be an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, even if the derivative function is a constant function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.CIs</code></td>
<td>
<p>Logical argument, <code>TRUE</code> or <code>FALSE</code>. If <code>plot.CIs = TRUE</code> (default), a visual display of the computed confidence interval(s) will be created. If <code>plot.CIs = FALSE</code>, no plots will be created.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>ci.table</code> returns a list, which includes the following objects:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>result.table</code></td>
<td>
<p>A table that displays lower and upper endpoints of the computed confidence interval(s). The length(s) of the confidence interval(s) is (are) reported in the last column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CIs</code></td>
<td>
<p>An object of class <code>Intervals_full</code> <code>{intervals}</code> that includes all of the computed confidence interval(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Shat</code></td>
<td>
<p>The constrained MLE of <code class="reqn">S(\cdot)</code> subject to <code class="reqn">H_{0}</code>. If there is an error or non-convergence issue during the process of fitting the model subject to <code class="reqn">H_{0}</code> by <code>mph.fit</code>, <code>Shat</code> is set to be <code>NA</code>; or if the constrained MLE does not exist, <code>Shat</code> is also set to be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ase.Shat</code></td>
<td>
<p>The asymptotic standard error, i.e. ase, of the constrained MLE of <code class="reqn">S(\cdot)</code> subject to <code class="reqn">H_{0}</code>. If there is an error or non-convergence issue during the process of fitting the model subject to <code class="reqn">H_{0}</code> by <code>mph.fit</code>, <code>ase.Shat</code> is set to be <code>NA</code>; or if the constrained MLE does not exist, <code>ase.Shat</code> is also set to be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>. It might be different from the input <code>S.space.H0</code>. If the input <code>S.space.H0</code> is the union of at least two disjoint intervals, then the output <code>S.space.H0</code> displays the particular interval in which <code>Shat</code>, the constrained MLE of <code class="reqn">S(\cdot)</code> subject to <code class="reqn">H_{0}</code>, lies. If the input <code>S.space.H0</code> is an interval, then the output <code>S.space.H0</code> is the same as the input. If <code>S.space.H0</code> is unspecified or <code>S.space.H0 = NULL</code> in the input, then the output <code>S.space.H0 = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cc</code></td>
<td>
<p>Confidence coefficient, or the nominal level of the confidence interval. It is the same as the <code>cc</code> in the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The test statistic(s) that is (are) actually used to construct the test-inversion approximate confidence interval(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic. It is the same as the <code>pdlambda</code> in the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warnings.collection</code></td>
<td>
<p>Includes all of the warning messages that occur during construction of the confidence
interval(s). They might be on evoking of the robustifying procedure: <code>"xxx.CI: Adjustment used. Not on original data.\n"</code>, or they might be on unsuccessful construction of the confidence interval(s): <code>"xxx.CI: NA.\n"</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Qiansheng Zhu</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340–383.
</p>
<p>Lang, J. B. (2008) Score and profile likelihood confidence intervals for contingency table parameters, <em>Statistics in Medicine</em>, <b>27</b>, 5975–5990.
</p>
<p>Zhu, Q. (2020) "On improved confidence intervals for parameters of discrete distributions." PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code>mph.fit</code>, <code>mph.summary</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Construct test-inversion CIs subject to equality constraints.

# I. Mice-Fungicide data: Innes et al. (1969) conducted an experiment
#    to test the possible carcinogenic effect of a fungicide Avadex on
#    four subgroups of mice. The data is reproduced as a 2-by-2-by-4
#    three-way contingency table. Within each of the four 2-by-2 two-way
#    sub-tables, there is one fixed stratum for the treated group, and
#    there is also one fixed stratum for the control group. Overall,
#    the data was collected under the product-multinomial sampling scheme.
#    We assume that the relative risks that correspond to the four 2-by-2
#    two-way sub-tables are the same, and we construct 95% test-inversion
#    confidence intervals for this common relative risk.
#
#    For a detailed description of the Mice-Fungicide data set, see
#    Gart (1971):
#    Gart, J. J. (1971) The comparison of proportions: a review of
#    significance tests, confidence intervals and adjustments for
#    stratification. Revue de l'Institut International de Statistique,
#    39(2), pp. 148-169.

obs.y &lt;- c(4, 12, 5, 74, 2, 14, 3, 84, 4, 14, 10, 80, 1, 14, 3, 79)

h.fct &lt;- function(p) {
  RR_1 &lt;- p[1] / p[3]
  RR_2 &lt;- p[5] / p[7]
  RR_3 &lt;- p[9] / p[11]
  RR_4 &lt;- p[13] / p[15]
  rbind(RR_1 - RR_2, RR_1 - RR_3, RR_1 - RR_4)
}

S.fct &lt;- function(p) {
  p[1] / p[3]
}

mice_result &lt;- ci.table(obs.y, h.fct = h.fct, S.fct = S.fct,
                        S.space.H0 = c(0, Inf), trans.g = "log",
                        strata = rep(seq(1, 8), each = 2))


# II. Suppose there is a 3-by-4-by-2 three-way contingency table which
#     cross-classifies three variables: X, Y, and Z. We assign scores
#     {1,2,3}, {1,2,3,4}, and {1,2} to the variables X, Y, and Z,
#     respectively. At each level of Z, there is a 3-by-4 two-way sub-table
#     for variables X and Y, and the 3-by-4 sub-table forms a fixed
#     stratum. We assume that the Pearson's correlation coefficient between
#     X and Y when Z = 1 is the same as that when Z = 2. The observed table
#     counts are (1,2,3,4,5,6,7,8,9,10,11,12) for the 3-by-4 sub-table when
#     Z = 1, and (13,14,15,16,17,18,19,20,21,22,23,24) for the 3-by-4 sub-
#     table when Z = 2. We construct a 95% profile likelihood confidence
#     interval for this common Pearson's correlation coefficient.

corr_freq_prob &lt;- function(freq, score.X, score.Y) {
  # Compute the Pearson's correlation coefficient based on the vector
  # of table (frequency) counts or the vector of underlying table
  # probabilities.
  # Note that the input freq is a vector.
  c &lt;- length(score.X)
  d &lt;- length(score.Y)
  freq &lt;- matrix(freq, nrow = c, ncol = d, byrow = TRUE)
  P &lt;- freq / sum(freq)
  P.row.sum &lt;- apply(P, 1, sum)
  P.column.sum &lt;- apply(P, 2, sum)
  EX &lt;- crossprod(score.X, P.row.sum)
  EY &lt;- crossprod(score.Y, P.column.sum)
  EXsq &lt;- crossprod(score.X^2, P.row.sum)
  EYsq &lt;- crossprod(score.Y^2, P.column.sum)
  sdX &lt;- sqrt(EXsq - EX^2)
  sdY &lt;- sqrt(EYsq - EY^2)
  EXY &lt;- 0
  for (i in seq(1, c)) {
    for (j in seq(1, d)) {
      EXY &lt;- EXY + score.X[i] * score.Y[j] * P[i, j]
    }
  }
  Cov.X.Y &lt;- EXY - EX * EY
  if (Cov.X.Y == 0) {
    corr &lt;- 0
  }
  else {
    corr &lt;- as.numeric(Cov.X.Y / (sdX * sdY))
  }
  corr
}

h.fct &lt;- function(p) {
  corr_1 &lt;- corr_freq_prob(p[seq(1, 12)], c(1, 2, 3), c(1, 2, 3, 4))
  corr_2 &lt;- corr_freq_prob(p[seq(13, 24)], c(1, 2, 3), c(1, 2, 3, 4))
  corr_1 - corr_2
}

S.fct &lt;- function(p) {
  corr_freq_prob(p[seq(1, 12)], c(1, 2, 3), c(1, 2, 3, 4))
}

corr_result &lt;- ci.table(y = seq(1, 24), h.fct = h.fct, S.fct = S.fct,
                        S.space.H0 = c(-1, 1), method = "LR",
                        trans.g = "Fisher's z", strata = rep(c(1, 2), each = 12),
                        plot.CIs = FALSE)


# III. Crying Baby data: Gordon and Foss (1966) conducted an experiment to
#      investigate the effect of rocking on the crying of full term babies.
#      The data set can be reproduced as a 2-by-2-by-18 three-way contingency
#      table. Within each of the eighteen 2-by-2 two-way sub-tables, there is
#      one fixed stratum for the experimental group and one fixed stratum for
#      the control group. Overall, the data was collected under the product-
#      multinomial sampling scheme. We assume common odds ratios among the
#      eighteen two-way sub-tables, and we construct 95% test-inversion
#      confidence intervals for this common odds ratio.
#
#      For a detailed description of the Crying Baby data set, see Cox (1966):
#      Cox, D. R. (1966) A simple example of a comparison involving quantal
#      data. Biometrika, 53(1-2), pp. 213-220.

obs.y &lt;- c(0,1,5,3,0,1,4,2,0,1,4,1,1,0,5,1,0,1,1,4,0,1,5,4,0,1,3,5,0,1,
           4,4,0,1,2,3,1,0,1,8,0,1,1,5,0,1,1,8,0,1,3,5,0,1,1,4,0,1,2,4,
           0,1,1,7,1,0,2,4,0,1,3,5)
strata &lt;- rep(seq(1, 36), each = 2)

h.fct &lt;- function(p) {
  OR_1 &lt;- p[1] * p[4] / (p[2] * p[3])
  OR_2 &lt;- p[5] * p[8] / (p[6] * p[7])
  OR_3 &lt;- p[9] * p[12] / (p[10] * p[11])
  OR_4 &lt;- p[13] * p[16] / (p[14] * p[15])
  OR_5 &lt;- p[17] * p[20] / (p[18] * p[19])
  OR_6 &lt;- p[21] * p[24] / (p[22] * p[23])
  OR_7 &lt;- p[25] * p[28] / (p[26] * p[27])
  OR_8 &lt;- p[29] * p[32] / (p[30] * p[31])
  OR_9 &lt;- p[33] * p[36] / (p[34] * p[35])
  OR_10 &lt;- p[37] * p[40] / (p[38] * p[39])
  OR_11 &lt;- p[41] * p[44] / (p[42] * p[43])
  OR_12 &lt;- p[45] * p[48] / (p[46] * p[47])
  OR_13 &lt;- p[49] * p[52] / (p[50] * p[51])
  OR_14 &lt;- p[53] * p[56] / (p[54] * p[55])
  OR_15 &lt;- p[57] * p[60] / (p[58] * p[59])
  OR_16 &lt;- p[61] * p[64] / (p[62] * p[63])
  OR_17 &lt;- p[65] * p[68] / (p[66] * p[67])
  OR_18 &lt;- p[69] * p[72] / (p[70] * p[71])
  rbind(OR_1 - OR_2, OR_1 - OR_3, OR_1 - OR_4, OR_1 - OR_5, OR_1 - OR_6,
        OR_1 - OR_7, OR_1 - OR_8, OR_1 - OR_9, OR_1 - OR_10, OR_1 - OR_11,
        OR_1 - OR_12, OR_1 - OR_13, OR_1 - OR_14, OR_1 - OR_15,
        OR_1 - OR_16, OR_1 - OR_17, OR_1 - OR_18)
}

S.fct &lt;- function(p) {
  p[1] * p[4] / (p[2] * p[3])
}

crying_baby_result &lt;- ci.table(obs.y, h.fct = h.fct, S.fct = S.fct,
                               S.space.H0 = c(0, Inf), trans.g = "log",
                               strata = strata, fixed.strata = "all",
                               y.eps = 0.4)


# IV. Homicide data: Radelet &amp; Pierce (1985) examined cases of 1017 homicide
#     defendants in Florida between 1973 and 1977. Both the police department
#     and prosecutors classified these cases into three mutually exclusive
#     categories: 1 = "No Felony", 2 = "Possible Felony", 3 = "Felony".
#     Three variables: police classification (P), court (i.e. prosecutors')
#     classification (C), and race of defendant/victim (R) are cross-
#     classified in a 3-by-3-by-4 three-way contingency table. The data
#     was collected based on independent Poisson sampling, and the strata
#     correspond to levels of the race combination (R).
#
#     For a detailed description of the Homicide data set, see Agresti (1984)
#     and Radelet &amp; Pierce (1985):
#     Agresti, A. (1984). Analysis of Ordinal Categorical Data. John Wiley &amp;
#     Sons.
#     Radelet, M. L., &amp; Pierce, G. L. (1985). Race and prosecutorial
#     discretion in homicide cases. Law &amp; Society Review, 19(4), pp. 587-622.
#
#     To measure agreement between police and court classifications, the four
#     estimands of interest are Cohen's unweighted kappa coefficients at four
#     levels of R, respectively. We construct 95% test-inversion confidence
#     intervals for the estimands subject to two sets of equality constraints,
#     respectively.
#     (1) WkW and BkB have the same unweighted kappa, and BkW and WkB have
#     the same unweighted kappa.
#     (2) A "row effects" model for the conditional R-C association:
#     log mu_{ijk} = lambda + lambda_{i}^{R} + lambda_{j}^{P} + lambda_{k}^{C} +
#           lambda_{ij}^{RP} + lambda_{jk}^{PC} + tau_{i}^{RC}(w_{k} - bar{w}),
#     where race effects {tau_{i}^{RC}} that sum to zero are introduced for an
#     R-C association. The variable C is viewed as being ordinal with integer
#     monotonic scores {w_{k}}={1,2,3}.

BkW_v &lt;- c(7, 1, 3, 0, 2, 6, 5, 5, 109)
WkW_v &lt;- c(236, 11, 26, 7, 2, 21, 25, 4, 101)
BkB_v &lt;- c(328, 6, 13, 7, 2, 3, 21, 1, 36)
WkB_v &lt;- c(14, 1, 0, 6, 1, 1, 1, 0, 5)
obs.y &lt;- c(BkW_v, WkW_v, BkB_v, WkB_v)

Unweighted.Kappa.BkW &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(1,9)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}
Unweighted.Kappa.WkW &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(10,18)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}
Unweighted.Kappa.BkB &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(19,27)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}
Unweighted.Kappa.WkB &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(28,36)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}

# Constraints (1)
library(vcd)
WkW.BkB_BkW.WkB_cons &lt;- function(p) {
  mat.BkW &lt;- matrix(p[seq(1,9)], nrow = 3, byrow = TRUE)
  mat.WkW &lt;- matrix(p[seq(10,18)], nrow = 3, byrow = TRUE)
  mat.BkB &lt;- matrix(p[seq(19,27)], nrow = 3, byrow = TRUE)
  mat.WkB &lt;- matrix(p[seq(28,36)], nrow = 3, byrow = TRUE)
  rbind(Kappa(mat.BkW)$Unweighted[1] - Kappa(mat.WkB)$Unweighted[1],
        Kappa(mat.WkW)$Unweighted[1] - Kappa(mat.BkB)$Unweighted[1])
}
homicide_kappa_same_fit &lt;- mph.fit(obs.y, h.fct = WkW.BkB_BkW.WkB_cons,
                                   strata = rep(c(1,2,3,4), each = 9),
                                   fixed.strata = "none")
homicide_kappa_same_fit$Gsq
pchisq(homicide_kappa_same_fit$Gsq, 2, lower.tail = FALSE)  # p-value

BkW_kappa_same &lt;- ci.table(obs.y, h.fct = WkW.BkB_BkW.WkB_cons,
                           S.fct = Unweighted.Kappa.BkW, S.space.H0 = c(0,1),
                           strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none", trans.g = "[A,B]")
WkW_kappa_same &lt;- ci.table(obs.y, h.fct = WkW.BkB_BkW.WkB_cons,
                           S.fct = Unweighted.Kappa.WkW, S.space.H0 = c(0,1),
                           strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none", trans.g = "[A,B]")

# Constraints (2)
X_cond_RC_v &lt;- c(1,1,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,-1,0,0,
                 1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,
                 1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,
                 1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,0,-1,0,0,
                 1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,
                 1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,
                 1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,
                 1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
                 1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,-1,0,
                 1,0,1,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,
                 1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,
                 1,0,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,-1,0,
                 1,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,
                 1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,
                 1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,
                 1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
                 1,0,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,-1,
                 1,0,0,1,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,
                 1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
                 1,0,0,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,-1,
                 1,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,
                 1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
                 1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,
                 1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                 1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,
                 1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,
                 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,
                 1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,
                 1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,
                 1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,
                 1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
                 1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1)
X_cond_RC_mat &lt;- matrix(X_cond_RC_v, ncol = 21, byrow = TRUE)

cond_RC_HLP_fit &lt;- mph.fit(obs.y, L.fct = "logm", L.mean = TRUE,
                           X = X_cond_RC_mat,
                           strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none")
mph.summary(cond_RC_HLP_fit)

library(MASS)
X_cond_RC_U &lt;- Null(X_cond_RC_mat)
cond_RC_MPH_fit &lt;- mph.fit(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                           h.mean = TRUE, strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none")
mph.summary(cond_RC_MPH_fit)

BkW_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.BkW,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")
WkW_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.WkW,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")
BkB_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.BkB,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")
WkB_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.WkB,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")



### Construct test-inversion CIs, without additionally imposed constraints.

# V. Binomial success rate parameter p.
#    Model: 0 = x &lt;- X | p ~ Bin(n = 5, p).
#    Goal: Compute approximate 90% CIs for the success probability p.

bin_p_result &lt;- ci.table(c(0, 5), h.fct = 0, S.fct = function(p) {p[1]},
                         S.space.H0 = c(0, 1), cc = 0.9, y.eps = 0.1)

#    Example 2.1 in Lang (2008).
#    Model: y = (39, 1) &lt;- Y ~ mult(40, p1, p2).
#    Goal: Compute approximate 95% CIs for the success probability p1.

bin_p_eg21_result &lt;- ci.table(c(39,1), h.fct = 0, S.fct = function(p) {p[1]},
                              S.space.H0 = c(0,1), trans.g = "[A,B]")


# VI. Conditional probability.
#     Model: y = (0, 39, 18, 11) &lt;- Y ~ mult(68, p1, p2, p3, p4)
#     Goal: Compute approximate 95% CIs for the conditional probability
#           p1 / (p1 + p2).

cond_prob_result &lt;- ci.table(c(0, 39, 18, 11), h.fct = 0,
                             S.fct = function(p) {p[1] / (p[1] + p[2])},
                             S.space.H0 = c(0, 1), y.eps = 0.1)

#     Model: y = (0, 39 // 18, 11) &lt;- Y ~ prod mult(39, p1, p2 // 29, p3, p4).
#     That is,
#     y &lt;- Y ~ MP(gamma, p | strata = c(1, 1, 2, 2), fixed = "all"),
#          where gamma = (39, 29)'.
#     Goal: Compute approximate 95% CIs for p1.

cond_prob_SS_result &lt;- ci.table(c(0, 39, 18, 11), h.fct = 0,
                                S.fct = function(p) {p[1]}, S.space.H0 = c(0, 1),
                                strata = c(1, 1, 2, 2), y.eps = 0.1)


# VII. Difference between conditional probabilities.
#      Model: y = (0, 39, 18, 11) &lt;- Y ~ mult(68, p1, p2, p3, p4)
#      Goal: Compute approximate 95% CIs for the difference between conditional
#            probabilities, p1 / (p1 + p2) - p3 / (p3 + p4).

diff_cond_prob_result &lt;- ci.table(c(0, 39, 18, 11), h.fct = 0,
                                  S.fct = function(p) {p[1]/(p[1]+p[2]) - p[3]/(p[3]+p[4])},
                                  S.space.H0 = c(-1, 1), trans.g = "[A,B]")


# VIII. Gamma variant.
#       Example 2.3 in Lang (2008).
#       Model: y = (25, 25, 12 // 0, 1, 3)
#                   ~ prod mult(62, p11, p12, p13 // 4, p21, p22, p23).
#       Goal: Compute approximate 95% CIs for the Gamma* parameter as
#             described in Lang (2008).

Gamma_variant_23 &lt;- function(p) {
  p &lt;- matrix(p, 2, 3, byrow = TRUE)
  P.case.gt.control &lt;- (p[2, 2] + p[2, 3]) * p[1, 1] + p[2, 3] * p[1, 2]
  P.case.lt.control &lt;- p[1, 2] * p[2, 1] + p[1, 3] * (p[2, 1] + p[2, 2])
  P.case.neq.control &lt;- P.case.gt.control + P.case.lt.control
  P.case.gt.control / P.case.neq.control
}
Gamma_variant_result &lt;- ci.table(c(25, 25, 12, 0, 1, 3), h.fct = 0,
                                 S.fct = Gamma_variant_23, S.space.H0 = c(0, 1),
                                 trans.g = "[A,B]", strata = c(1, 1, 1, 2, 2, 2))

### Alternative code...
gammastar.fct &lt;- function(p) {
  nr &lt;- nrow(p)
  nc &lt;- ncol(p)
  probC &lt;- 0
  probD &lt;- 0
  for (i in 1:(nr-1)) {
    for (j in 1:(nc-1)) {
      Aij &lt;- 0
      for (h in (i+1):nr) {
        for (k in (j+1):nc) {
          Aij &lt;- Aij + p[h, k]
        }
      }
      probC &lt;- probC + p[i, j] * Aij
    }
  }
  for (i in 1:(nr-1)) {
    for (j in 2:nc) {
      Aij &lt;- 0
      for (h in (i+1):nr) {
        for (k in 1:(j-1)) {
          Aij &lt;- Aij + p[h, k]
        }
      }
      probD &lt;- probD + p[i, j] * Aij
    }
  }
  probC / (probC + probD)
}

Gamma_variant_23_a &lt;- function(p) {
  p &lt;- matrix(p, 2, 3, byrow = TRUE)
  gammastar.fct(p)
}
Gamma_variant_a_result &lt;- ci.table(c(25, 25, 12, 0, 1, 3), h.fct = 0,
                                   S.fct = Gamma_variant_23_a,
                                   S.space.H0 = c(0, 1), trans.g = "[A,B]",
                                   strata = c(1, 1, 1, 2, 2, 2))


# IX. Global odds ratio.
#     Model: y = (25, 25, 12 // 0, 1, 3)
#                 ~ prod mult(62, p11, p12, p13 // 4, p21, p22, p23).
#     Goal: Compute approximate 95% CIs for the first global odds ratio.

global_odds_ratio_23_11 &lt;- function(p) {
  p &lt;- matrix(p, 2, 3, byrow = TRUE)
  p[1, 1] * (p[2, 2] + p[2, 3]) / (p[2, 1] * (p[1, 2] + p[1, 3]))
}
global_odds_ratio_result &lt;- ci.table(c(25, 25, 12, 0, 1, 3), h.fct = 0,
                                     S.fct = global_odds_ratio_23_11,
                                     S.space.H0 = c(0, Inf), trans.g = "log",
                                     strata = c(1, 1, 1, 2, 2, 2))


# X. Difference between product-multinomial probabilities.
#    Example 2.2 in Lang (2008).
#    Source (secondary): Agresti 2002:65
#    Early study of the death penalty in Florida (Radelet)
#    Victim Black...
#    White Defendant  0/9   received Death Penalty
#    Black Defendant  6/103 received Death Penalty
#
#    Model: y = (0, 9 // 6, 97) &lt;- Y ~ prod mult(9, p1, p2 // 103, p3, p4).
#    Goal: Compute approximate 95% CIs for the difference between
#          product-multinomial probabilities, p1 - p3.

diff_prod_mult_prob_result &lt;- ci.table(c(0, 9, 6, 97), h.fct = 0,
                                       S.fct = function(p) {p[1] - p[3]},
                                       S.space.H0 = c(-1, 1),
                                       trans.g = "Fisher's z",
                                       strata = c(1, 1, 2, 2))

### Alternative (artificial) data that is even more sparse...

diff_prod_mult_prob_a_result &lt;- ci.table(c(0, 9, 0, 97), h.fct = 0,
                                         S.fct = function(p) {p[1] - p[3]},
                                         S.space.H0 = c(-1, 1),
                                         trans.g = "Fisher's z",
                                         strata = c(1, 1, 2, 2), y.eps = 0.4)


# XI. Kappa coefficient.
#     Example 2.4 in Lang (2008).
#     Model: y = (4, 0, 0, 0, 1, 0, 0, 0, 15)
#              &lt;- Y ~ mult(20, p11, p12, ..., p33).
#     Goal: Compute approximate 95% CIs for the unweighted kappa coefficient.

Kappa_coeff_33 &lt;- function(p) {
  p &lt;- matrix(p, 3, 3, byrow = TRUE)
  s1 &lt;- p[1, 1] + p[2, 2] + p[3, 3]
  prow &lt;- apply(p, 1, sum)
  pcol &lt;- apply(p, 2, sum)
  s2 &lt;- prow[1] * pcol[1] + prow[2] * pcol[2] + prow[3] * pcol[3]
  (s1 - s2) / (1 - s2)
}
kappa_coeff_result &lt;- ci.table(c(4, 0, 0, 0, 1, 0, 0, 0, 15), h.fct = 0,
                               S.fct = Kappa_coeff_33, S.space.H0 = c(-1, 1))

</code></pre>


</div>