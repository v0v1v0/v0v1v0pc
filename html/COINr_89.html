<div class="container">

<table style="width: 100%;"><tr>
<td>Normalise.purse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create normalised data sets in a purse of coins</h2>

<h3>Description</h3>

<p>This creates normalised data sets for each coin in the purse. In most respects, this works in a similar way
to normalising on a coin, for which reason please see <code>Normalise.coin()</code> for most documentation. There is however
a special case in terms of operating on a purse of coins. This is because, when
dealing with time series data, it is often desirable to normalise over the whole panel data set at once
rather than independently for each time point. This makes the resulting index and aggregates comparable
over time. Here, the <code>global</code> argument controls whether to normalise each coin independently or to normalise
across all data at once. In other respects, this function behaves the same as <code>Normalise.coin()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'purse'
Normalise(
  x,
  dset,
  global_specs = NULL,
  indiv_specs = NULL,
  directions = NULL,
  global = TRUE,
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A purse object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dset</code></td>
<td>
<p>The data set to normalise in each coin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>global_specs</code></td>
<td>
<p>Default specifications</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indiv_specs</code></td>
<td>
<p>Individual specifications</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data set
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will be taken from the <code>iMeta</code> table in the coin, if available.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>global</code></td>
<td>
<p>Logical: if <code>TRUE</code>, normalisation is performed "globally" across all coins, by using e.g. the
max and min of each indicator in any coin. This effectively makes normalised scores comparable between coins
because they are all scaled using the same parameters. Otherwise if <code>FALSE</code>, coins are normalised individually.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to</code></td>
<td>
<p>Optional character string for naming the data set in each coin. Data will be written to
<code>.$Data[[write_to]]</code>. Default is <code>write_to == "Normalised"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The same specifications are passed to each coin in the purse. This means that each coin is normalised
using the same set of specifications and directions. If you need control over individual coins, you
will have to normalise coins individually.
</p>


<h3>Value</h3>

<p>An updated purse with new normalised data sets added at <code>.$Data$Normalised</code> in each coin
</p>


<h3>Examples</h3>

<pre><code class="language-R"># build example purse
purse &lt;- build_example_purse(up_to = "new_coin", quietly = TRUE)

# normalise raw data set
purse &lt;- Normalise(purse, dset = "Raw", global = TRUE)

</code></pre>


</div>