<div class="container">

<table style="width: 100%;"><tr>
<td>integral</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numerical Integration</h2>

<h3>Description</h3>

<p>Computes the integrals of <code>functions</code> or <code>characters</code> in arbitrary 
<a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">integral(
  f,
  bounds,
  params = list(),
  coordinates = "cartesian",
  relTol = 0.001,
  absTol = 1e-12,
  method = NULL,
  vectorize = NULL,
  drop = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p><code>list</code> containing the lower and upper bounds for each variable. If the two bounds coincide, or if a single number is specified, the corresponding variable is not integrated and its value is fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a character vector of scale factors for each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relTol</code></td>
<td>
<p>the maximum relative tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>absTol</code></td>
<td>
<p>the absolute tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method to use. One of <code>"mc"</code>, <code>"hcubature"</code>, <code>"pcubature"</code>, <code>"cuhre"</code>, <code>"divonne"</code>, <code>"suave"</code> or <code>"vegas"</code>. Methods other than <code>"mc"</code> (naive Monte Carlo) require the <span class="pkg">cubature</span> package to be installed (efficient integration in C). The defaul uses <code>"hcubature"</code> if <span class="pkg">cubature</span> is installed or <code>"mc"</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectorize</code></td>
<td>
<p><code>logical</code>. Use vectorization? If <code>TRUE</code>, it can significantly boost performance but <code>f</code> needs to handle the vector of inputs appropriately. The default uses <code>FALSE</code> if <code>f</code> is a <code>function</code>, <code>TRUE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>if <code>TRUE</code>, return the integral as a vector and not as an <code>array</code> for vector-valued functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>. Print on progress?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>cubintegrate</code>, when method <code>"hcubature"</code>, <code>"pcubature"</code>, <code>"cuhre"</code>, <code>"divonne"</code>, <code>"suave"</code> or <code>"vegas"</code> is used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function integrates seamlessly with <span class="pkg">cubature</span> for efficient 
numerical integration in C. If the package <span class="pkg">cubature</span> is not 
installed, the function implements a naive Monte Carlo integration by default.
For arbitrary orthogonal coordinates <code class="reqn">q_1\dots q_n</code> the integral is computed as:
</p>
<p style="text-align: center;"><code class="reqn">\int J\cdot f(q_1\dots q_n) dq_1\dots dq_n</code>
</p>

<p>where <code class="reqn">J=\prod_i h_i</code> is the Jacobian determinant of the transformation 
and is equal to the product of the scale factors <code class="reqn">h_1\dots h_n</code>.
</p>


<h3>Value</h3>

<p>list with components
</p>

<dl>
<dt>value</dt>
<dd>
<p>the final estimate of the integral.</p>
</dd>
<dt>error</dt>
<dd>
<p>estimate of the modulus of the absolute error.</p>
</dd>
<dt>cuba</dt>
<dd>
<p><span class="pkg">cubature</span> output when method <code>"hcubature"</code>, <code>"pcubature"</code>, <code>"cuhre"</code>, <code>"divonne"</code>, <code>"suave"</code> or <code>"vegas"</code> is used.</p>
</dd>
</dl>
<h3>References</h3>

<p>Guidotti E (2022). "calculus: High-Dimensional Numerical and Symbolic Calculus in R." Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other integrals: 
<code>ode()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### unidimensional integral
i &lt;- integral("sin(x)", bounds = list(x = c(0,pi)))
i$value

### multidimensional integral
f &lt;- function(x,y) x*y
i &lt;- integral(f, bounds = list(x = c(0,1), y = c(0,1)))
i$value

### vector-valued integrals
f &lt;- function(x,y) c(x, y, x*y)
i &lt;- integral(f, bounds = list(x = c(0,1), y = c(0,1)))
i$value

### tensor-valued integrals
f &lt;- function(x,y) array(c(x^2, x*y, x*y, y^2), dim = c(2,2))
i &lt;- integral(f, bounds = list(x = c(0,1), y = c(0,1)))
i$value

### area of a circle
i &lt;- integral(1, 
              bounds = list(r = c(0,1), theta = c(0,2*pi)), 
              coordinates = "polar")
i$value

### surface of a sphere
i &lt;- integral(1, 
              bounds = list(r = 1, theta = c(0,pi), phi = c(0,2*pi)), 
              coordinates = "spherical")
i$value

### volume of a sphere
i &lt;- integral(1, 
         bounds = list(r = c(0,1), theta = c(0,pi), phi = c(0,2*pi)), 
         coordinates = "spherical")
i$value

</code></pre>


</div>