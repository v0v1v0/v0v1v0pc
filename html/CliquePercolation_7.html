<div class="container">

<table style="width: 100%;"><tr>
<td>cpPermuteEntropy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confidence Intervals Of Entropy Based On Random Permutations Of Network</h2>

<h3>Description</h3>

<p>Function for determining confidence intervals of entropy values calculated for
community partition from clique percolation based on randomly permuted networks
of original network.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cpPermuteEntropy(
  W,
  cpThreshold.object,
  n = 100,
  interval = 0.95,
  CFinder = FALSE,
  ncores,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>A qgraph object or a symmetric matrix; see also qgraph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpThreshold.object</code></td>
<td>
<p>A cpThreshold object; see also cpThreshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of permutations (default is 100)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>requested confidence interval (larger than zero and smaller 1;
default is 0.95)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CFinder</code></td>
<td>
<p>logical indicating whether clique percolation for weighted networks
should be performed as in CFinder ; see also cpAlgorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Numeric.
Number of cores to use in computing results.
Defaults to <code>parallel::detectCores() / 2</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Numeric.
Set seed for reproducible results.
Defaults to <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function generates <code>n</code> random permutations of the network
specified in <code>W</code>. For each randomly permuted network, it runs <code>cpThreshold</code>
(see cpThreshold for more information) with <code>k</code> and <code>I</code> values
extracted from the cpThreshold object specified in <code>cpThreshold.object</code>.
Across permutations, the confidence intervals of the entropy values are determined
for each <code>k</code> separately.
</p>
<p>The confidence interval of the entropy values is determined separately for each <code>k</code>.
This is because larger <code>k</code> have to produce less communities on average,
which will decrease entropy. Comparing confidence intervals of smaller <code>k</code> to
those of larger <code>k</code> would therefore be disadvantageous for larger <code>k</code>.
</p>
<p>In the output, one can check the confidence intervals of each <code>k</code>. Moreover,
a data frame is produced that takes the cpThreshold object that was specified in
<code>cpThreshold.object</code> and removes all rows that do not exceed the upper bound of the
confidence interval of the respective <code>k</code>.
</p>


<h3>Value</h3>

<p>A list object with the following elements:
</p>

<dl>
<dt>Confidence.Interval</dt>
<dd>
<p>a data frame with lower and upper bound of
confidence interval for each <code>k</code></p>
</dd>
<dt>Extracted.Rows</dt>
<dd>
<p>rows extracted from <code>cpThreshold.object</code> that are
larger than the upper bound of the specified confidence interval for
each <code>k</code></p>
</dd>
<dt>Settings</dt>
<dd>
<p>user-specified settings</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example with fictitious data

# create qgraph object
W &lt;- matrix(c(0,1,1,1,0,0,0,0,
              0,0,1,1,0,0,0,0,
              0,0,0,0,0,0,0,0,
              0,0,0,0,1,1,1,0,
              0,0,0,0,0,1,1,0,
              0,0,0,0,0,0,1,0,
              0,0,0,0,0,0,0,1,
              0,0,0,0,0,0,0,0), nrow = 8, ncol = 8, byrow = TRUE)
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# create cpThreshold object
cpThreshold.object &lt;- cpThreshold(W = W, method = "unweighted", k.range = c(3,4),
                                  threshold = "entropy")

# run cpPermuteEntropy with 100 permutations and 95% confidence interval

results &lt;- cpPermuteEntropy(W = W, cpThreshold.object = cpThreshold.object,
                            n = 100, interval = 0.95, ncores = 1, seed = 4186)

# check results
results


## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# create cpThreshold object

threshold &lt;- cpThreshold(net, method = "weighted",
                         k.range = 3:4,
                         I.range = seq(0.1, 0.5, 0.01),
                         threshold = "entropy")

                          
# run cpPermuteEntropy with 50 permutations and 99% confidence interval

permute &lt;- cpPermuteEntropy(net, cpThreshold.object = threshold,
                            interval = 0.99, n = 50, ncores = 1, seed = 4186)

# check results
permute


</code></pre>


</div>