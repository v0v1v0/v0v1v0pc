<div class="container">

<table style="width: 100%;"><tr>
<td>detect.th</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple change-point detection in the cross-covariance structure
of multivariate high-dimensional time series using a thresholding
based procedure and, wherever possible, extraction of the component
time series where the changes occurred</h2>

<h3>Description</h3>

<p>This function detects multiple change-points in the cross-covariance
structure of a multivariate time series using a thresholding based procedure.
It also, wherever possible, returns the relevant, transformed
time series where each change-point was detected. See Details for a brief
explanation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">detect.th(
  X,
  approach = c("euclidean", "infinity"),
  th_max = 2.25,
  th_sum = 0.65,
  pointsgen = 10,
  scales = -1,
  preaverage_gen = FALSE,
  scal_gen = 3,
  min_dist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numerical matrix representing the multivariate time series,
with the columns representing its components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approach</code></td>
<td>
<p>A character string, which defines the metric to be used
in order to detect the change-points. If approach = “euclidean”, which
is also the default value, then the <code class="reqn">L_2</code> metric will be followed
for the detection. If approach = “infinity”, then the <code class="reqn">L_{\infty}</code>
metric will be used for the detection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>th_max</code></td>
<td>
<p>A positive real number with default value equal to 2.25. It is
used to define the threshold if the <code class="reqn">L_{\infty}</code> metric is chosen in
<code>approach</code> .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>th_sum</code></td>
<td>
<p>A positive real number with default value equal to 0.65. It is
used to define the threshold if the <code class="reqn">L_2</code> metric is chosen in
<code>approach</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pointsgen</code></td>
<td>
<p>A positive integer with default value equal to 10. It
defines the distance between two consecutive end- or start-points of
the right- or left-expanding intervals, respectively; see Details for
more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scales</code></td>
<td>
<p>Negative integers for wavelet scales, with a small negative
integer representing  a fine scale. The default value is equal to -1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preaverage_gen</code></td>
<td>
<p>A logical variable with default value equal to
<code>FALSE</code>. If <code>FALSE</code>, then pre-averaging the data is not
required. If <code>TRUE</code>, then we need to pre-average the data before
proceeding with the detection of the change-points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scal_gen</code></td>
<td>
<p>A positive integer number with default value equal to 3. It
is used to define the way we pre-average the given data sequence only if
<code>preaverage_gen = TRUE</code>. See the Details in <code>preaverage</code>
for more information on how we pre-average.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_dist</code></td>
<td>
<p>A positive integer number with default value equal to 1. It
is used in order to provide the minimum distance acceptable between
detected change-points if such restrictions apply.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The time series <code class="reqn">X_t</code> is of dimensionality <code class="reqn">p</code> and we are
looking for changes in the cross-covariance structure between the
different time series components
<code class="reqn">X_{t}^{(1)}, X_{t}^{(2)}, ..., X_{t}^{(p)}</code>. We first use a
wavelet-based approach for the various given scales in <code>scales</code>
in order to transform the given time series <code class="reqn">X_t</code> to a multiplicative
model <code class="reqn">Y_{t}^{(k)} = \sigma^{(k)}_t (Z_t^{(k)})^2; t=1,2,\ldots,T; k = 1,2,\ldots,d,</code>
where <code class="reqn">Z_t^{(k)}</code> is a sequence of standard normal random variables,
<code class="reqn">E(Y_t^{(k)}) = \sigma_t^{(k)}</code>, and <code class="reqn">d</code> is the new
dimensionality, which depends on the value given in <code>scales</code>.
The function has been extensively tested on fMRI data, hence, its parameters
have been tuned for this data type. The function might not work well in other
structures, such as time series that are negatively serially correlated.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;"> <code>changepoints</code> </td>
<td style="text-align: left;"> The locations of the detected change-points.
</td>
</tr>
<tr>
<td style="text-align: left;"> <code>no.of.cpts</code> </td>
<td style="text-align: left;"> The number of the detected change-points.
</td>
</tr>
<tr>
<td style="text-align: left;"> <code>time_series</code> </td>
<td style="text-align: left;"> A list with two components that indicates which combinations
</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> of time series are responsible for each change-point detected. See the outcome
</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> values <code>time_series_indicator</code> and <code>most_important</code> of the function
</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> <code>match.cpt.ts</code> for more information.
   </td>
</tr>
</table>
<p>If the minimum distance between the detected change-points is less than
the value given in <code>min_dist</code>, then only the number and the locations of
the “pruned” change-points are returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:anastasiou.andreas@ucy.ac.cy">anastasiou.andreas@ucy.ac.cy</a>
</p>


<h3>References</h3>

<p>“Cross-covariance isolate detect: a new change-point method
for estimating dynamic functional connectivity”, Anastasiou et al (2020),
preprint &lt;doi:10.1101/2020.12.20.423696&gt;.
</p>


<h3>See Also</h3>

<p><code>detect.ic</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  set.seed(111)
  A &lt;- matrix(rnorm(20*400), nrow = 400) ## No change-point
  M1 &lt;- detect.th(A, approach = 'euclidean', scales = -1)
  M2 &lt;- detect.th(A, approach = 'infinity', scales = -1)
  M1
  M2

  set.seed(111)
  num.nodes &lt;- 40 # number of nodes
  etaA.1    &lt;- 0.95
  etaA.2    &lt;- 0.05
  pcor1     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.1)
  pcor2     &lt;- GeneNet::ggm.simulate.pcor(num.nodes, etaA = etaA.2)

  n &lt;- 100
  data1 &lt;- GeneNet::ggm.simulate.data(n, pcor1)
  data2 &lt;- GeneNet::ggm.simulate.data(n, pcor2)

  X1 &lt;- rbind(data1, data2) ## change-point at 100
  N1 &lt;- detect.th(X1, approach = 'euclidean', scales = -1)
  N2 &lt;- detect.th(X1, approach = 'infinity', scales = -1)
  N1$changepoints
  N1$time_series
  N2$changepoints
  N2$time_series
</code></pre>


</div>