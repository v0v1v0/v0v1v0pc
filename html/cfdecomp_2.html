<div class="container">

<table style="width: 100%;"><tr>
<td>cfd.FUN</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Flexible Function Decomposition: decompose any function that returns a vector</h2>

<h3>Description</h3>

<p>Flexible Function Decomposition: decompose any function that returns a vector
</p>


<h3>Usage</h3>

<pre><code class="language-R">cfd.FUN(
  formula.y,
  formula.m,
  mediator,
  group,
  data,
  family.y = "binomial",
  family.m = "binomial",
  bs.size = 250,
  mc.size = 50,
  FUN.y = mean,
  alpha = 0.05,
  cluster.sample = FALSE,
  cluster.name = NA,
  cluster.mrows = FALSE,
  sample.resid.y = FALSE,
  sample.resid.m = FALSE,
  print.iteration = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula.y</code></td>
<td>
<p>the <code>formula</code> for the multivariable model (see <code>glm</code>) for the outcome Y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula.m</code></td>
<td>
<p>the <code>formula</code> for the multivariable model (see <code>glm</code>) for the mediator M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mediator</code></td>
<td>
<p>the column name of the mediator M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>column name of a factor variable containing the group identifier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family.y</code></td>
<td>
<p>a description of the error distribution to be used in the model, see <code>family</code> for details. For the outcome variable any member of the <code>glm</code> family can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family.m</code></td>
<td>
<p>a description of the error distribution to be used in the model, see <code>family</code> for details. For the mediator, currently <code>gaussian</code>, <code>binomial</code> and <code>poisson</code> are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs.size</code></td>
<td>
<p>the number of bootstrap iterations to be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.size</code></td>
<td>
<p>the number of Monte Carlo iterations to be performed (more = more MC error reduction).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.y</code></td>
<td>
<p>a function to compute the statistics which can be applied to all data subsets, this function should return a vector and should be ran on pred_y (simulated y values in the natural course or counterfactual) and optional additional columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the alpha level used to construct confidence intervals (0.05 = 95 percent confidence interval).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.sample</code></td>
<td>
<p>set to TRUE if data are clustered in the long format (i.e. multiple rows per individual or other cluster).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.name</code></td>
<td>
<p>the name (as a character) of the column containing the cluster identifiers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.mrows</code></td>
<td>
<p>for the mediator model, only allows 1 observation per mediator so that the mediator model is not weighted by number of observations. e.g. set to TRUE if the mediator is time constant in longitudinal analysis of long format data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.resid.y</code></td>
<td>
<p>sample.resid if the <code>outcome</code> is Gaussian, should the simulation sample from the residuals of the linear regression model of the outcome to approximate the empirical distribution of the outcome in the simulation (Monte Carlo integration) (if so, set to <code>TRUE</code>), or should it sample from a Gaussian distribution with the standard deviation of the outcome? If the true distribution of the continuous outcome is not very Gaussian, the former may be preferred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.resid.m</code></td>
<td>
<p>sample.resid if the <code>mediator</code> is Gaussian, should the simulation sample from the residuals of the linear regression model of the mediator to approximate the empirical distribution of the mediator in the simulation (Monte Carlo integration) (if so, set to <code>TRUE</code>), or should it sample from a Gaussian distribution with the standard deviation of the mediator? If the true distribution of the continuous mediator is not very Gaussian, the former may be preferred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.iteration</code></td>
<td>
<p>print the bootstrap iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or used by methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>out_nc_m</code> returns the mean level of the mediator under the natural course, which is a value that should be close to the empirically observed value of the mediator for each group. <code>out_nc_quantile</code> provides the <code>alpha/2</code> and <code>1-alpha/2</code> bootstrap quantiles for this mean (AKA bootstrap percentile confidence intervals). <code>out_nc_y</code> provides the output of the function fed into FUN.y for each bootstrap iteration, with <code>out_nc_quantile_y</code> providing the <code>alpha/2</code> and <code>1-alpha/2</code> bootstrap quantiles of that output. Similarly, <code>out_cf_m</code>, <code>out_cf_quantile_m</code>,<code>out_cf_y</code>, and <code>out_cf_quantile_y</code> provide the corresponding values for the counterfactual scenario where the mediators of the groups are equalized. <code>mediation</code> and <code>mediation_quantile</code> are not provided for this function, so should be calculated by the user based on the output. <code>mc_conv_info_m</code> and <code>mc_conv_info_y</code> provide information that can help determine the number of Monte Carlo and Bootstrap iterations needed to achieve stability. See the <code>Examples</code> for more information.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(100)
# the decomposition functions in our package are computationally intensive
# to make the example run quick, I perform it on a subsample (n=250) of the data:
cfd.example.sample &lt;- cfd.example.data[sample(250),]
# define some function (here one that calculates the mean from the data)
# such a function already exists, but this is to demonstrate how to do it for one that
# will be implemented in cfd.FUN:
mean.fun &lt;- function(data,yname) {
x &lt;- data
return(mean(x[,yname],na.rm=TRUE))
}
# test if the function works on normal data:
mean.fun(cfd.example.sample,yname="med.pois")
# then enter it into cfd.FUN and run:
mean.results &lt;- cfd.FUN(formula.y='out.gauss ~ SES + med.gauss + med.binom + age',
                          formula.m='med.gauss ~ SES + age',
                          mediator='med.gauss',
                          group='SES',
                          data=cfd.example.sample,
                          family.y='gaussian',
                          family.m='gaussian',
                          FUN.y=mean.fun,
                          bs.size=15,
                          mc.size=5,
                          alpha=0.05,
                          print.iteration=TRUE,
                          yname="pred_y")
# more advanced code demonstrating how to do this with a function that calculates
# the age-adjusted rate ratio and life expectancy will hopefully soon be available
# in a publication.
#' @import stats utils
</code></pre>


</div>