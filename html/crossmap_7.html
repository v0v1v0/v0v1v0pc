<div class="container">

<table style="width: 100%;"><tr>
<td>cross_join</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Crossing join</h2>

<h3>Description</h3>

<p>Adds columns from a set of data frames, creating all combinations of
their rows
</p>


<h3>Usage</h3>

<pre><code class="language-R">cross_join(..., copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Data frames or a list of data frames â€“ including
data frame extensions (e.g. tibbles) and lazy data
frames (e.g. from dbplyr or dtplyr).
<code>NULL</code> inputs are silently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>If inputs are not from the same data source, and copy is
<code>TRUE</code>, then they will be copied into the same src as the first input.
This allows you to join tables across srcs, but it is a potentially
expensive operation so you must opt into it.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of the same type as the first input.
The order of the rows and columns of the first input is preserved as much
as possible. The output has the following properties:
</p>

<ul>
<li>
<p> Rows from each input will be duplicated.
</p>
</li>
<li>
<p> Output columns include all columns from each input.
If columns have the same name, suffixes are added to disambiguate.
</p>
</li>
<li>
<p> Groups are taken from the first input.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>cross_list()</code> to find combinations of elements of vectors
and lists.
</p>


<h3>Examples</h3>

<pre><code class="language-R">fruits &lt;- dplyr::tibble(
  fruit = c("apple", "banana", "cantaloupe"),
  color = c("red", "yellow", "orange")
)

desserts &lt;- dplyr::tibble(
  dessert = c("cupcake", "muffin", "streudel"),
  makes   = c(8, 6, 1)
)

cross_join(fruits, desserts)
cross_join(list(fruits, desserts))
cross_join(rep(list(fruits), 3))
</code></pre>


</div>