<div class="container">

<table style="width: 100%;"><tr>
<td>Script-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Script class and elements</h2>

<h3>Description</h3>

<p>This package works with collections of expressions
or code blocks and such a sequence can be thought of as a script.
The <code>Script</code> class is a list of code elements.
Such objects are typically created via a call to
<code>readScript</code>.
They can be read from XML files, tangled Sweave output,
regular R source files and R source files that are annotated
to identify the general task of each code block.
This last type of script has its own class named
<code>AnnotatedScript</code> and the code elements are annotated with labels
such as dataInput, simulate, plot, model, eda and so on.
</p>
<p>Each element of a <code>Script</code> list represents code.
These are stored as objects of class <code>ScriptNode</code>.
A <code>ScriptNode</code> class has slots for the
<code>code</code>, the <code>taskType</code> indicating the high-level nature of
the code, and an <code>id</code> so we can easily refer to it.
</p>
<p>While our focus is on the code elements in a <code>Script</code>, we work
with meta-data about the code elements. We identify information such
as the input variables required by a code element, the variables it
assigns (the outputs) and so on.  This information is stored
in a <code>ScriptNodeInfo</code> object.
And a collection of such objects that parallels a script
is a <code>ScriptInfo</code> object.
</p>
<p>We can easily map a <code>Script</code> or a <code>ScriptNode</code>
to the corresponding meta-information via the coercion methods
<code>as(script, "ScriptInfo")</code> and  <code>as(node, "ScriptNodeInfo")</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects of class <code>Script</code> are created with
<code>readScript</code>.
</p>
<p>Objects of class <code>ScriptInfo</code> are created with
<code>getInputs</code> or <code>as(, "ScriptInfo")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>.Data</code>:</dt>
<dd>
<p>the elements of the list.</p>
</dd>
<dt>
<code>location</code>:</dt>
<dd>
<p>a character string that gives the file name
or URL of the code for this script.</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"list"</code>, from data part.
Class <code>"vector"</code>, by class "list", distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "Script", to = "ScriptInfo")</code>:
convert a <code>Script</code> to a <code>ScriptInfo</code> to access the meta-information</p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "ScriptNode", to =
	"ScriptNodeInfo")</code>: 
compute the meta-information from an individual code element.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p> Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code>readScript</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> f = system.file("samples", "results-multi.R", package = "CodeDepends")
 sc = readScript(f)
 info = as(sc, "ScriptInfo")
 info = getInputs(sc, basedir = dirname(f))

   # Providing our own handler for calls to source()
 sourceHandler = function(e, collector = NULL, basedir = ".", ...) {
     collector$string(e[[2]], , TRUE)
     collector$calls(as.character(e[[1]]))
 }
 h = CodeDepends:::inputCollector(source = sourceHandler)
 info = getInputs(sc, h, basedir = dirname(f))

## Not run: 
 u = url("http://www.omegahat.net/CodeDepends/formula.R")
 sc = readScript(u)
 as(sc, "ScriptInfo")

## End(Not run)
</code></pre>


</div>