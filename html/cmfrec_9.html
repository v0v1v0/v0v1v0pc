<div class="container">

<table style="width: 100%;"><tr>
<td>factors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate latent factors on new data</h2>

<h3>Description</h3>

<p>Determine latent factors for new user(s)/row(s), given either 'X' data
(a.k.a. "warm-start"), or 'U' data (a.k.a. "cold-start"), or both.
</p>
<p>If passing both types of data ('X' and 'U'), and the number of rows in them
differs, will be assumed that the shorter matrix has only missing values
for the unmatched entries in the other matrix.
</p>
<p>Note: this function will not perform any internal re-indexing for the data.
If the 'X' to which the data was fit was a 'data.frame', the numeration of the
items will be under 'model$info$item_mapping'. There is also a function
factors_single which will let the model do the appropriate reindexing.
</p>
<p>For example usage, see the main section fit_models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">factors(model, ...)

## S3 method for class 'CMF'
factors(
  model,
  X = NULL,
  U = NULL,
  U_bin = NULL,
  weight = NULL,
  output_bias = FALSE,
  nthreads = model$info$nthreads,
  ...
)

## S3 method for class 'CMF_implicit'
factors(model, X = NULL, U = NULL, nthreads = model$info$nthreads, ...)

## S3 method for class 'ContentBased'
factors(model, U, nthreads = model$info$nthreads, ...)

## S3 method for class 'OMF_explicit'
factors(
  model,
  X = NULL,
  U = NULL,
  weight = NULL,
  output_bias = FALSE,
  output_A = FALSE,
  exact = FALSE,
  nthreads = model$info$nthreads,
  ...
)

## S3 method for class 'OMF_implicit'
factors(
  model,
  X = NULL,
  U = NULL,
  output_A = FALSE,
  nthreads = model$info$nthreads,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A collective matrix factorization model from this package - see
fit_models for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>New 'X' data, with rows denoting new users.
Can be passed in the following formats:</p>

<ul>
<li>
<p> A sparse COO/triplets matrix, either from package
'Matrix' (class 'dgTMatrix'), or from package 'SparseM' (class 'matrix.coo').
</p>
</li>
<li>
<p> A sparse matrix in CSR format, either from package
'Matrix' (class 'dgRMatrix'), or from package 'SparseM' (class 'matrix.csr').
Passing the input as CSR is faster than COO as it will be converted internally.
</p>
</li>
<li>
<p> A sparse row vector from package 'Matrix' (class 'dsparseVector').
</p>
</li>
<li>
<p> A dense matrix from base R (class 'matrix'), with missing entries set as 'NA'/'NaN'.
</p>
</li>
<li>
<p> A dense row vector from base R (class 'numeric'), with missing entries set as 'NA'/'NaN'.
</p>
</li>
</ul>
<p>Dense 'X' data is not supported for 'CMF_implicit' or 'OMF_implicit'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>New 'U' data, with rows denoting new users.
Can be passed in the same formats as 'X', or additionally
as a 'data.frame', which will be internally converted to a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U_bin</code></td>
<td>
<p>New binary columns of 'U'. Must be passed as a dense matrix from
base R or as a 'data.frame'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>Associated observation weights for entries in 'X'. If passed, must
have the same shape as 'X' - that is, if 'X' is a sparse matrix, should be a
numeric vector with length equal to the non-missing elements (or a sparse matrix in
the same format, but will not make any checks on the indices), if 'X' is a dense
matrix, should also be a dense matrix with the same number of rows and columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_bias</code></td>
<td>
<p>Whether to also return the user bias determined by the model
given the data in 'X'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_A</code></td>
<td>
<p>Whether to return the raw 'A' factors (the free offset).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>(In the 'OMF_explicit' model)
Whether to calculate 'A' and 'Am' with the regularization applied
to 'A' instead of to 'Am' (if using the L-BFGS method, this is how the model
was fit). This is usually a slower procedure.
Only relevant when passing 'X' data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that, regardless of whether the model was fit with the L-BFGS or
ALS method with CG or Cholesky solver, the new factors will be determined through the
Cholesky method or through the precomputed matrices (e.g. a simple matrix-matrix multiply
for the 'ContentBased' model), unless passing 'U_bin' in which case they will be
determined through the same L-BFGS method with which the model was fit.
</p>


<h3>Value</h3>

<p>If passing 'output_bias=FALSE', 'output_A=FALSE', and for the
implicit-feedback models, will return a matrix with the obtained latent
factors for each row/user given the 'X' and/or 'U' data (number of rows is
'max(nrow(X), nrow(U), nrow(U_bin))').
If passing any of the above options,
will return a list with the following elements: </p>

<ul>
<li>
<p> 'factors': The obtained latent factors (a matrix).
</p>
</li>
<li>
<p> 'bias': (If passing 'output_bias=TRUE')
A vector with the obtained biases for each row/user.
</p>
</li>
<li>
<p> 'A': (If passing 'output_A=TRUE') The raw 'A' factors matrix
(which is added to the factors determined from user attributes in order to
obtain the factorization parameters).
</p>
</li>
</ul>
<h3>See Also</h3>

<p>factors_single
</p>


</div>