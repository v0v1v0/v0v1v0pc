<div class="container">

<table style="width: 100%;"><tr>
<td>zykloid.scaleA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Wrapper for <code>zykloid</code> which allows to scale and position
a cycloid by the radius A of the fixed circle and its midpoint
</h2>

<h3>Description</h3>

<p>While <code>zykloid</code> provides the basic functionality for
calculating cycloids, this functions allows to re-size a cycloid
by freely setting the radius on the fixed circle. In addition,
the cycloid can be re-positioned by locating the fix circle's
midpoint. See Figures 1 and 2 and <code>zykloid</code> for the
geometrical principles of cycloids.
</p>


<h3>Usage</h3>

<pre><code class="language-R">zykloid.scaleA(A, a, lambda, hypo = TRUE, Cx = 0, Cy = 0,
               RadiusA = 1, steps = 360, start = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>

<p>The Radius of the fixed circle before re-sizing. Must be an integer
Number &gt; 0. Together with <code class="reqn">a</code> (see below), <code class="reqn">A</code> is only
determining the cycloid's shape and number of peaks (see
<code>npeaks</code>), while its actual size is defined by the
argument <code class="reqn">RadiusA</code> (see below).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>

<p>The radius of the moving circle before re-sizing. Must be an
integer Number &gt; 0. Together with <code class="reqn">A</code>, <code class="reqn">a</code> only determines the
cycloid's shape and number of peaks (see <code>npeaks</code>),
while its actual size is defined via the argument <code class="reqn">RadiusA</code>
(see below).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>The distance of the tracepoint from the moving circle's (c<code class="reqn">mov</code>)
centre in relative units of its radius <code class="reqn">a</code>. <code class="reqn">lambda = 1</code>
means that the tracepoint is located on <code class="reqn">cmov</code>'s circumference.
For <code class="reqn">lambda &lt; 1</code>, the tracepoint is on <code class="reqn">cmov</code>'s area, e.g.
if <code class="reqn">lambda = 0.5</code>, it is halfway between <code class="reqn">cmov</code>'s centre
and its circumference. If <code class="reqn">lambda &gt; 1</code> the tracepoint is outside
<code class="reqn">cmov</code>'s area, you might imagine it being attached to a rod
which is attached to <code class="reqn">cmov</code> and originates from its centre.
E.g. <code class="reqn">lambda = 2</code> would mean that the tracepoint's distance
from cmov's centre equals <code class="reqn">2*a</code>. <code class="reqn">lambda = 0</code> produces a
circle because the tracepoint is identical with <code class="reqn">cmov</code>'s centre.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hypo</code></td>
<td>

<p>logical. If TRUE, the resulting figure is a hypocycloid (<code class="reqn">lambda = 1</code>)
or a hypotrochoid (<code class="reqn">lambda != 1</code>), because <code class="reqn">cmov</code> is rolling
along the inner side of the fixed circle (<code class="reqn">cfix</code>). If FALSE,
an epicycloid (<code class="reqn">lambda = 1</code>) or an epitrochoid <code class="reqn">lambda != 1</code>
is generated, as <code class="reqn">cmov</code> is rolling at the outside of <code class="reqn">cfix</code>'s
circumference.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cx</code></td>
<td>

<p>x-coordinate of the fixed circle's midpoint. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cy</code></td>
<td>

<p>y-coordinate of the fixed circle's midpoint. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RadiusA</code></td>
<td>

<p>The actual radius of the fixed circle. Default is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>

<p>positive integer. The number of steps per circuit of the moving
circle (<code class="reqn">cmov</code>) for which tracepoint positions are calculated.
The default, 360, means steps of 1 degree for the movement of
cmov. Analogously, steps = 720 would mean steps of 0.5 degrees.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>Start angle (radians) of the moving circle's (<code class="reqn">cmov</code>) centre
counterclockwise to the horizontal with the fixed circle's (<code class="reqn">cfix</code>)
centre as the pivot. The tracepoint will start at a peak.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><img src="../help/figures/Figure1.png" width="500" height="500" alt="Figure1.png"><img src="../help/figures/Figure2.png" width="500" height="500" alt="Figure2.png"></p>


<h3>Value</h3>

<p>A dataframe with the columns <code class="reqn">x</code> and <code class="reqn">y</code>. Each row represents a
tracepoint position. The positions are ordered along the trace
with the last and the first point being identical in order to
warrant a closed figure when plotting the data.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>See Also</h3>

<p><code>zykloid</code>,
<code>zykloid.scaleAa</code>, <code>zykloid.scaleP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Same hypotrochoid scaled to different radii of the fix circle
cycl1 &lt;- zykloid.scaleA(A = 7, a = 3, lambda = 2/3, RadiusA = 1.3)
cycl2 &lt;- zykloid.scaleA(A = 7, a = 3, lambda = 2/3, RadiusA = 1.0)
cycl3 &lt;- zykloid.scaleA(A = 7, a = 3, lambda = 2/3, RadiusA = 0.7)
plot (y ~ x, data = cycl1, asp = 1, col = "red", type = "l",
      main = "A = 7, a = 3, lambda = 2/3")
lines(y ~ x, data = cycl2, asp = 1, col = "green")
lines(y ~ x, data = cycl3, asp = 1, col = "blue")
legend("topleft", c("RadiusA = 1.3", "RadiusA = 1.0", "RadiusA = 0.7"),
       lty = rep("solid", 3), col = c("red", "green", "blue"), bty = "n")
       


# In this example, RadiusA depends on the cosine of the x-coordinate
# of the fixed circle's centre
op &lt;- par(mar = c(0,0,0,0), bg = "black")
ctrx &lt;- seq(-2*pi, 2*pi, pi/10)
ccol &lt;- rainbow(length(ctrx))
plot.new()
plot.window(asp = 1, xlim = c(-8, 8), ylim = c(-0.5, 0.5))
for(i in c(1:length(ctrx))) {
    zzz &lt;- zykloid.scaleA(A = 9, a = 7, hypo = TRUE, Cx = ctrx[i],
                          Cy = -ctrx[i], lambda = 0.9,
                          RadiusA = 1.5 + cos(ctrx[i]), start = -pi/4)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# Geometric degression of RadiusA makes a nice star
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-10, 10), ylim = c(-10, 10))
rad &lt;- 10
n &lt;- 60
ccol &lt;- heat.colors(n)
for(i in c(1:n)) {
    if (i/2 != floor(i/2)) { sstart = pi/2 }
    else                   { sstart = pi/4 }
    zzz &lt;- zykloid.scaleA(A = 4, a = 3, RadiusA = rad, lambda = 1,
                          start = sstart)
    lines(y ~ x, data = zzz, col = ccol[i])
    rad &lt;- rad * 0.9
} # for i
par(op)



# A windmill
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-1.4, 1.4), ylim = c(-1.4, 1.4))
rrad &lt;- sqrt(seq(0.1, 2, 0.1))
n    &lt;- length(rrad)
ccol &lt;- rainbow(n, start = 0, end = 0.3)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleA(A = 7, a = 3, RadiusA = rrad[i],
           hypo = TRUE, lambda = 1.1,
           start = pi/2 - (1*pi/7 - (i - 1) * 2*pi/(7 * n)))
    lines(y ~ x, data = zzz, col = ccol[n + 1 - i])
} # for i
par(op)



# Advanced Example: A series of cycloids with their centres
# located on a logarithmic spiral
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-50, 50), ylim = c(-50, 50))
a     &lt;- 1/32     # spiral's scaling constant
alpha &lt;- pi/20    # spiral's slope angle
sphi  &lt;- seq(0, 18 * pi, pi/25)   # series of angles for cycloid centres
rad  &lt;- a * exp(tan(alpha)*sphi)  # corresponding spiral radii
spx  &lt;- rad * cos(sphi)           # corresponding x-coordinates
spy  &lt;- rad *sin(sphi)            # corresponding y-coordinates
n    &lt;- length(sphi)
ccol &lt;- rainbow(n, start = 2/3, end = 1/2)
for (i in c(1:n)) {
     czc &lt;- zykloid.scaleA(A = 3, a = 1, lambda = 1.5,
            Cx = spx[i], Cy = spy[i],
            RadiusA = rad[i]/2.5, # cycloid radii depends on spiral radii
            start = pi + sphi[i]) # angle cycloid towards spiral centre
     lines(y ~ x, data = czc, col = ccol[i])
} # for i
par(op)


</code></pre>


</div>