<div class="container">

<table style="width: 100%;"><tr>
<td>getParents</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate the connectivity matrix of a causal graph</h2>

<h3>Description</h3>

<p>Estimates the connectivity matrix of a directed causal graph, 
using various possible methods. Supported methods at the moment are ARGES,
backShift, bivariateANM, bivariateCAM, CAM, FCI, FCI+, GES, GIES, hiddenICP, 
ICP, LINGAM, MMHC, rankARGES, rankFci, rankGES, rankGIES, rankPC, 
regression, RFCI and PC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getParents(
  X,
  environment = NULL,
  interventions = NULL,
  parentsOf = 1:ncol(X),
  method = c("arges", "backShift", "bivariateANM", "bivariateCAM", "CAM", "fci",
    "fciplus", "ges", "gies", "hiddenICP", "ICP", "LINGAM", "mmhc", "rankArges",
    "rankFci", "rankGes", "rankGies", "rankPc", "rfci", "pc", "regression")[12],
  alpha = 0.1,
  mode = c("raw", "parental", "ancestral")[1],
  variableSelMat = NULL,
  excludeTargetInterventions = TRUE,
  onlyObservationalData = FALSE,
  indexObservationalData = 1,
  returnAsList = FALSE,
  sparse = FALSE,
  directed = FALSE,
  pointConf = FALSE,
  setOptions = list(),
  assumeNoSelectionVars = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A <code class="reqn">(n</code> x <code class="reqn">p)</code>-data matrix with n observations of  <code class="reqn">p</code> variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>environment</code></td>
<td>
<p>An optional vector of length <code class="reqn">n</code>, where the entry for 
observation <code class="reqn">i</code> is an index for the environment in which observation <code class="reqn">i</code> took 
place (Simplest case: entries <code>1</code> for observational data and entries
<code>2</code> for interventional data of unspecified type. Encoding for observational
data can be changed with <code>indexObservationalData</code>). Is required for 
methods <code>ICP</code>, <code>hiddenICP</code> and <code>backShift</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interventions</code></td>
<td>
<p>A optional list of length <code class="reqn">n</code>. The entry for observation
<code class="reqn">i</code> is a numeric vector that specifies the variables on which interventions 
happened for observation <code class="reqn">i</code> (a scalar if an intervention happened on just 
one variable and <code>integer(0)</code> if no intervention occured for this 
observation). Is used for methods <code>gies</code>, <code>rankGies</code> and <code>CAM</code> and will 
generate the vector <code>environment</code> if the latter is set to <code>NULL</code>.
(However, this might generate too many different environments for some data 
sets, so a hand-picked vector <code>environment</code> is preferable). Is also used 
for <code>ICP</code> and <code>hiddenICP</code> to exclude interventions on the target 
variable of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parentsOf</code></td>
<td>
<p>The variables for which we would like to estimate the 
parents. Default are all variables. Currently only used with <code>mode = "raw"</code>. 
Speeds up computation for methods <code>bivariateANM</code>,
<code>bivariateCAM</code>, <code>ICP</code>, <code>hiddenICP</code> and <code>regression</code>; 
for other methods only affects output. Also see <code>variableSelMat</code> for possibly
speeding up computational time by restricting the set of potential parents
for a variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string that specfies the method to use. The methods 
<code>pc</code> (PC-algorithm), <code>LINGAM</code> (LINGAM), <code>arges</code> (Adaptively 
restricted greedy equivalence search), <code>ges</code> 
(Greedy equivalence search), <code>gies</code> (Greedy interventional equivalence 
search),  <code>fci</code> (Fast causal inference), <code>fciplus</code>  
and <code>rfci</code> (Really fast causal inference) are imported from the 
package "pcalg" and are documented there in more detail, including the 
additional options that can be supplied via <code>setOptions</code>. 
The "rank versions" of arges, fci, ges, gies and pc are based on [1]. The method 
<code>CAM</code> (Causal additive models) is documented in the package "CAM" and 
the methods <code>ICP</code> (Invariant causal prediction), <code>hiddenICP</code> 
(Invariant causal prediction with hidden variables) are from the package 
"InvariantCausalPrediction". The method <code>backShift</code> comes from the 
package "backShift". The method <code>mmhc</code> comes from the 
package "bnlearn". Finally, the methods <code>bivariateANM</code> and 
<code>bivariateCAM</code> are for now implemented internally but will hopefully 
be part of another package at some point in the near future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The level at which tests are done. This leads to confidence 
intervals for <code>ICP</code> and <code>hiddenICP</code> and is used internally for 
<code>pc</code>, <code>rankPc</code>, <code>mmhc</code>, <code>fci</code>, <code>rankFci</code>, <code>fciplus</code>
and <code>rfci</code>. For all other methods <code>alpha</code> is not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>Determines output type - can be "raw" or one of the queries "isParent", 
"isMaybeParent", "isNoParent", "isAncestor","isMaybeAncestor", "isNoAncestor".
If "raw", <code>getParents()</code> returns the connectivity matrix computed by the
specified method in sparse matrix format if <code>sparse</code> is set to <code>TRUE</code>; 
else in dense matrix format (or as list if <code>returnAsList = TRUE</code>). 
The options <code>directed</code> and  <code>pointConf</code> will be ignored for 
all modes except for "raw" if set to <code>TRUE</code>. The different mode types
are explained in the help for <code>getRanking</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variableSelMat</code></td>
<td>
<p>An optional logical matrix of dimension  <code class="reqn">(p</code> x <code class="reqn">p)</code>. An 
entry <code>TRUE</code> for entry <code class="reqn">(i,j)</code> says that variable <code class="reqn">i</code> should be considered 
as a potential parent for variable <code class="reqn">j</code> and vice versa for <code>FALSE</code>. If the 
default value of <code>NULL</code> is used, all variables will be considered, but 
this can be very slow, especially for methods <code>pc</code>, <code>ges</code>, 
<code>gies</code>, <code>rfci</code> and <code>CAM</code>. Ignored for methods <code>backShift</code>, 
<code>fciplus</code>, <code>LINGAM</code> and <code>CAM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>excludeTargetInterventions</code></td>
<td>
<p>When looking for parents of variable <code class="reqn">k</code> 
in <code class="reqn">1,...,p</code>, set to <code>TRUE</code> if observations where an intervention on 
variable <code class="reqn">k</code> occured should be excluded. Default is <code>TRUE</code>. Used
in  <code>ICP</code> and <code>hiddenICP</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyObservationalData</code></td>
<td>
<p>If set to <code>TRUE</code>, only observational data 
is used. It will take the index in <code>environment</code> specified by 
<code>indexObservationalData</code>. If <code>environment</code> is <code>NULL</code>, all 
observations are used. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indexObservationalData</code></td>
<td>
<p>Index in <code>environment</code> that encodes 
observational data. Default is <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnAsList</code></td>
<td>
<p>If set to <code>TRUE</code>, will return a list, where entry 
<code class="reqn">k</code> is a list containing the estimated parents of variable <code class="reqn">k</code>. 
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>returnAsList</code> is <code>FALSE</code>,
output matrix will be in sparse matrix format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>If <code>TRUE</code>, an edge will be returned if and only if an 
edge has been detected to be directed. I.e. entry will be set to 0 for entry 
<code class="reqn">(j,k)</code> if both <code class="reqn">j -&gt; k</code> and <code class="reqn">k -&gt; j</code> are estimated 
(<code>ICP</code>, <code>hiddenICP</code>, <code>regression</code>), if <code class="reqn">j -- k</code> is undirected 
(in case of CPDAGs) or if the edge type is not of type <code class="reqn">i --&gt; j</code> in case of 
PAGs. If <code>assumeNoSelectionVars = TRUE</code> the edge type <code class="reqn">i --o j</code> is also 
considered 'directed' for methods returning PAGs.  Default is <code>FALSE</code>. 
Only supported in mode "raw".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pointConf</code></td>
<td>
<p>If <code>TRUE</code>, numerical estimates will be returned if 
possible. For methods <code>ICP</code> and <code>hiddenICP</code>, these are the values 
in the individual confidence intervals (at chosen level <code>alpha</code>) that 
are closest to 0; for other methods these are point estimates. Some methods 
do not return numerical point estimates; for these the output will remain 
binary 0/1 (no-edge/edge). Default is <code>FALSE</code>. Only supported in mode "raw".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setOptions</code></td>
<td>
<p>A list that can take method-specific options; see the 
individual documentations of the methods for more options and their 
possible values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assumeNoSelectionVars</code></td>
<td>
<p>Set to <code>TRUE</code> is you want to assume the absence 
of selection variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Parameters to be passed to underlying method's function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If option <code>returnAsList</code> is <code>FALSE</code>, a sparse matrix, 
where a 0 entry in position (j,k) corresponds to an estimate of "no edge" 
<code>j</code> -&gt; <code>k</code>, while an entry 1 corresponds to an 
estimated egde. If option <code>pointConf</code> is <code>TRUE</code>, the 1 entries 
will be replaced by numerical values that are either point estimates of the 
causal coefficients or confidence bounds (see above). 
If option <code>returnAsList</code> is <code>TRUE</code>, a list will be returned. 
The k-th entry in the list is the numeric vector with the indices of the 
estimated parents of node <code>k</code>.
</p>


<h3>Author(s)</h3>

<p>Christina Heinze-Deml <a href="mailto:heinzedeml@stat.math.ethz.ch">heinzedeml@stat.math.ethz.ch</a>, 
Nicolai Meinshausen <a href="mailto:meinshausen@stat.math.ethz.ch">meinshausen@stat.math.ethz.ch</a>
</p>


<h3>References</h3>


<ol><li>
<p> Naftali Harris and Mathias Drton: PC Algorithm for Nonparanormal 
Graphical Models. J. Mach. Learn. Res. 14(1) 2013.
</p>
</li></ol>
<h3>See Also</h3>

<p><code>getParentsStable</code> for stability selection-based 
estimation of the causal graph.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## load the backShift package for data generation and plotting functionality
if(require(backShift) &amp; require(pcalg)){
  # Simulate data with connectivity matrix A with assumptions
  # 1) hidden variables present
  # 2) precise location of interventions is assumed unknown
  # 3) different environments can be distinguished
  
  ## simulate data
  myseed &lt;- 1
  
  # sample size n
  n &lt;- 10000
  
  # p=3 predictor variables and connectivity matrix A
  p &lt;- 3
  labels &lt;- c("1", "2", "3")
  A &lt;- diag(p)*0
  A[1,2] &lt;- 0.8
  A[2,3] &lt;- 0.8
  A[3,1] &lt;- -0.4
  
  # divide data in 10 different environments
  G &lt;- 10
  
  # simulate
  simResult &lt;- backShift::simulateInterventions(n, p, A, G, intervMultiplier = 3,
               noiseMult = 1, nonGauss = TRUE, hiddenVars = TRUE,
               knownInterventions = FALSE, fracVarInt = NULL, simulateObs = TRUE,
               seed = myseed)
  X &lt;- simResult$X
  environment &lt;- simResult$environment
  
  ## apply all  methods given in vector 'methods'
  ## (using all data pooled for pc/LINGAM/rfci/ges -- can be changed with option
  ## 'onlyObservationalData=TRUE')
  
  methods &lt;- c("backShift", "LINGAM") #c("pc", "rfci", "ges")
  
  # select whether you want to run stability selection
  stability &lt;- FALSE
  
  # arrange graphical output into a rectangular grid
  sq &lt;- ceiling(sqrt(length(methods)+1))
  par(mfrow=c(ceiling((length(methods)+1)/sq),sq))
  
  ## plot and print true graph
  cat("\n true graph is  ------  \n" )
  print(A)
  plotGraphEdgeAttr(A, plotStabSelec = FALSE, labels = labels, thres.point = 0,
   main = "TRUE GRAPH")
  
  ## loop over all methods and compute and print/plot estimate
  for (method in methods){
    cat("\n result for method", method,"  ------  \n" )
  
    if(!stability){
      # Option 1): use this estimator as a point estimate
      Ahat &lt;- getParents(X, environment, method=method, alpha=0.1, pointConf = TRUE)
    }else{
      # Option 2): use a stability selection based estimator
      # with expected number of false positives bounded by EV=2
      Ahat &lt;- getParentsStable(X, environment, EV=2, method=method, alpha=0.1)
    }
  
   # print and plot estimate (point estimate thresholded if numerical estimates
   # are returned)
    print(Ahat)
    if(!stability)
      plotGraphEdgeAttr(Ahat, plotStabSelec = FALSE, labels = labels,
       thres.point = 0.05,
       main=paste("POINT ESTIMATE FOR METHOD\n", toupper(method)))
    else
      plotGraphEdgeAttr(Ahat, plotStabSelec = TRUE, labels = labels,
       thres.point = 0, main = paste("STABILITY SELECTION
       ESTIMATE\n FOR METHOD", toupper(method)))
   }
}else{
    cat("\nThe packages 'backShift' and 'pcalg' are needed for the examples to
work. Please install them.")
}
 

 
</code></pre>


</div>