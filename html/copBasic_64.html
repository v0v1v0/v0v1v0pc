<div class="container">

<table style="width: 100%;"><tr>
<td>hoefCOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Hoeffding Phi of a Copula or Lp Distances (Independence, Radial Asymmetry, or Reflection Symmetry Forms)</h2>

<h3>Description</h3>

<p>Compute the measure of association known as the <em>Hoeffding Phi</em> <code class="reqn">\Phi_\mathbf{C}</code> of a copula from <em>independence</em> (<code class="reqn">uv = \mathbf{\Pi}</code>; <code>P</code>) according to Cherunbini <em>et al.</em> (2004, p. 164) by
</p>
<p style="text-align: center;"><code class="reqn">\Phi_\mathbf{C} = 3 \sqrt{10\int\!\!\int_{\mathcal{I}^2} \bigl(\mathbf{C}(u,v) - uv\bigr)^2\,\mathrm{d}u\mathrm{d}v}\mbox{,}</code>
</p>

<p>and Nelsen (2006, p. 210) shows this as (and absolute value notation by Nelsen helps in generalization)
</p>
<p style="text-align: center;"><code class="reqn">\Phi_\mathbf{C} = \biggl(90\int\!\!\int_{\mathcal{I}^2} |\mathbf{C}(u,v) - uv|^2\,\mathrm{d}u\mathrm{d}v\biggr)^{1/2}\mbox{,}</code>
</p>

<p>for which <code class="reqn">\Phi^2_\mathbf{C}</code> (the square of the quantity) is known as the <em>dependence index</em>. Gaißer <em>et al.</em> (2010, eq. 1) have <code class="reqn">\Phi^2_\mathbf{C}</code> as the <em>Hoeffding Phi-Square</em>, and their definition, when square-rooted, matches Nelsen's listing.
</p>
<p>A generalization (Nelsen, 2006) to <code class="reqn">L_p</code> distances from independence (<code class="reqn">uv = \mathbf{\Pi}</code>; <code>P</code>) through the <code>LpCOP</code> function is
</p>
<p style="text-align: center;"><code class="reqn">L_p \equiv \Phi_\mathbf{C}(p) = \biggl(k(p)\int\!\!\int_{\mathcal{I}^2} |\mathbf{C}(u,v) - uv|^p\,\mathrm{d}u\mathrm{d}v\biggr)^{1/p}\mbox{,}</code>
</p>

<p>for a <code class="reqn">p: 1 \le p \le \infty</code> and where <code class="reqn">k(p)</code> is a normalization constant such that <code class="reqn">\Phi_\mathbf{C}(p) = 1</code> when the copula <code class="reqn">\mathbf{C}</code> is <code class="reqn">\mathbf{M}</code> (see <code>M</code>) or <code class="reqn">\mathbf{W}</code> (see <code>W</code>). The <code class="reqn">k(p)</code> (bivariate definition only) for other powers is given (Nelsen, 2006, exer. 5.44, p. 213) in terms of the <em>complete gamma function</em> <code class="reqn">\Gamma(t)</code> by
</p>
<p style="text-align: center;"><code class="reqn">k(p) = \frac{\Gamma(2p+3)}{2[\Gamma(p + 1)]^2}\mbox{,}</code>
</p>

<p>which is implemented by the <code>hoefCOP</code> function. It is important to realize that the <code class="reqn">L_p</code> distances are all <em>symmetric nonparametric measures of dependence</em> (Nelsen, 2006, p. 210). These are symmetric because distance from independence is used as evident by “<code class="reqn">uv</code>” in the above definitions.
</p>
<p><em>Reflection/Radial and Permutation Asymmetry</em>—Asymmetric forms similar to the above distances exist. Joe (2014, p. 65) shows two measures of bivariate <em>reflection asymmetry</em> or <em>radial asymmetry</em> (term favored in <span class="pkg">copBasic</span>) as the distance between <code class="reqn">\mathbf{C}(u,v)</code> and the survival copula <code class="reqn">\hat{\mathbf{C}}(u,v)</code> (<code>surCOP</code>) measured by
</p>
<p style="text-align: center;"><code class="reqn">L_\infty^{\mathrm{radsym}} = \mathrm{sup}_{0\le u,v\le1}|\mathbf{C}(u,v) - \hat{\mathbf{C}}(u,v)|\mbox{,}</code>
</p>

<p>or its <code class="reqn">L_p^{\mathrm{radsym}}</code> counterpart
</p>
<p style="text-align: center;"><code class="reqn">L_p^{\mathrm{radsym}} = \biggl[\int\!\!\int_{\mathcal{I}^2} |\mathbf{C}(u,v) - \hat{\mathbf{C}}(u,v)|^p\,\mathrm{d}u\mathrm{d}v\biggr]^{1/p}\,\mathrm{with}\, p \ge 1\mbox{,}</code>
</p>

<p>where <code class="reqn">\hat{\mathbf{C}}(u,v) = u + v - 1 + \mathbf{C}(1-u, 1-v)</code> and again <code class="reqn">p: 1 \le p \le \infty</code>. Joe (2014) does not seem to discuss and normalization constants for these two radial asymmetry distances.
</p>
<p>Joe (2014, p. 66) offers analogous measures of bivariate <em>permutation asymmetry</em> (<code>isCOP.permsym</code>) (<code class="reqn">\mathbf{C}(u,v) \not= \mathbf{C}(v,u)</code>) defined as
</p>
<p style="text-align: center;"><code class="reqn">L_\infty^{\mathrm{permsym}} = \mathrm{sup}_{0\le u,v\le1}|\mathbf{C}(u,v) - \hat{\mathbf{C}}(v,u)|\mbox{,}</code>
</p>

<p>or its <code class="reqn">L_p^{\mathrm{permsym}}</code> counterpart
</p>
<p style="text-align: center;"><code class="reqn">L_p^{\mathrm{permsym}} = \biggl[\int\!\!\int_{\mathcal{I}^2} |\mathbf{C}(u,v) - \hat{\mathbf{C}}(v,u)|^p\,\mathrm{d}u\mathrm{d}v\biggr]^{1/p}\,\mathrm{with}\, p \ge 1\mbox{,}</code>
</p>

<p>where <code class="reqn">p: 1 \le p \le \infty</code>. Again, Joe (2014) does not seem to discuss and normalization constants for these two permutation symmetry distances. Joe (2014, p. 65) states that the “simplest one-parameter bivariate copula families [and] most of the commonly used two-parameter bivariate copula families are permutation symmetric.” The <code class="reqn">L_\infty^{\mathrm{permsym}}</code> (or rather a similar form) is implemented by <code>LzCOPpermsym</code> and demonstration made in that documentation.
</p>
<p>The asymmetrical <code class="reqn">L_\infty</code> and <code class="reqn">L_p</code> measures identified by Joe (2014, p. 66) are nonnegative with an upper bounds that depends on <code class="reqn">p</code>. The bound dependence on <code class="reqn">p</code> is caused by the lack of normalization constant <code class="reqn">k(p)</code>. In an earlier paragraph, Joe (2014) indicates an upper bounds of 1/3 for both (likely?) concerning <code class="reqn">L_\infty^{\mathrm{radsym}}</code> and <code class="reqn">L_\infty^{\mathrm{permsym}}</code>. Discussion of this 1/3 or rather the integer 3 is made within <code>LzCOPpermsym</code>.
</p>
<p>The numerical integrations for <code class="reqn">L_p^{\mathrm{radsym}}</code> and <code class="reqn">L_p^{\mathrm{permsym}}</code> can readily return zeros. Often inspection of the formula for the <code class="reqn">\mathbf{C}(u,v)</code> itself would be sufficient to judge whether symmetry exists and hence the distances are uniquely zero.
</p>
<p>Joe (2014, p. 66) completes the asymmetry discussion with three definitions of skewness of combinations of random variables <code class="reqn">U</code> and <code class="reqn">V</code>: Two definitions are in <code>uvlmoms</code> (for <code class="reqn">U + V - 1</code> and <code class="reqn">U - V</code>) and two are for <code class="reqn">V-U</code> (<code>nuskewCOP</code>) and <code class="reqn">U+V-1</code> (<code>nustarCOP</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">hoefCOP(     cop=NULL, para=NULL, p=2, as.sample=FALSE,
                                       sample.as.prob=TRUE,
                                       brute=FALSE, delta=0.002, ...)

LpCOP(       cop=NULL, para=NULL, p=2, brute=FALSE, delta=0.002, ...)
LpCOPradsym( cop=NULL, para=NULL, p=2, brute=FALSE, delta=0.002, ...)
LpCOPpermsym(cop=NULL, para=NULL, p=2, brute=FALSE, delta=0.002, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The value for <code class="reqn">p</code> as described above with a default to 2 to match the discussion of Nelsen (2006) and the <em>Hoeffding Phi</em> of Cherubini <em>et al.</em> (2004). Do not confuse <code class="reqn">p</code> with <code class="reqn">d</code> described in <b>Note</b>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.sample</code></td>
<td>
<p>A logical controlling whether an optional <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> in <code>para</code> is used to compute the <code class="reqn">\hat{\Phi}_\mathbf{C}</code> (see <b>Note</b>). If set to <code>-1</code>, then the message concerning CPU effort will be surpressed;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.as.prob</code></td>
<td>
<p>When <code>as.sample</code> triggered, what are the units incoming in <code>para</code>? If they are probabilities, the default is applicable. If they are not, then the columns are re-ranked and divided simply by <code class="reqn">1/n</code>—more sophisticated <em>empirical copula</em> probabilities are not used (<code>EMPIRcop</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brute</code></td>
<td>
<p>Should brute force be used instead of two nested <code>integrate()</code> functions in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> to perform the double integration;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The <code class="reqn">\mathrm{d}u</code> and <code class="reqn">\mathrm{d}v</code> for the brute force (<code>brute=TRUE</code>) integration; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The value for <code class="reqn">\Phi_\mathbf{C}(p)</code> is returned.
</p>


<h3>Note</h3>

<p>Concerning the distance from independence, when <code class="reqn">p = 1</code>, then the <em>Spearman Rho</em> (<code>rhoCOP</code>) of a copula is computed where is it seen in that documentation that the <code class="reqn">k_p(1) = 12</code>. The respective values of <code class="reqn">k(p)</code> for select integers <code class="reqn">p</code> are
</p>
<p style="text-align: center;"><code class="reqn">p \mapsto [1, 2, 3, 4, 5] \equiv k(p) \mapsto \{12, 90, 560, 3150, 16600\}\mbox{,}</code>
</p>

<p>and these values are hardwired into <code>hoefCOP</code> and <code>LpCOP</code>. The integers for <code class="reqn">k_p</code> ensures that the equality in the second line of the examples is <code>TRUE</code>, but the <code class="reqn">p</code> can be a noninteger as well. Nelsen (2006, p. 211) reports that when <code class="reqn">p = \infty</code> that <code class="reqn">L_\infty</code> is
</p>
<p style="text-align: center;"><code class="reqn">L_\infty \equiv \Phi_\mathbf{C}(\infty) = \Lambda_\mathbf{C} = 4\;\mathrm{sup}_{u,v \in \mathcal{I}}|\mathbf{C}(u,v) - uv|\mbox{.}</code>
</p>

<p>A sample <code class="reqn">\hat{\Phi}_\mathbf{C}</code> (square root of the <em>Hoeffding Phi-Square</em>) based on nonparametric estimation generalized for <code class="reqn">d</code> dimensions (<code class="reqn">d = 2</code> for bivariate) is presented by Gaißer <em>et al.</em> (2010, eq. 10) for estimated probabilities <code class="reqn">\hat{U}_{ij}</code> for the <code class="reqn">i</code>th dimension and <code class="reqn">j</code>th row (observation) for sample of size <code class="reqn">n</code>. Those authors suggest that the <code class="reqn">\hat{U}_{ij}</code> be estimated from the empirical copula:
</p>
<p style="text-align: center;"><code class="reqn">\hat\Phi_\mathbf{C} = \sqrt{h(d)[A + B]}\mbox{,}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">A = \biggl(\frac{1}{n}\biggr)^2\sum_{j=1}^n\sum_{k=1}^n\prod_{i=1}^d
                    \bigl[1 - \mathrm{max}\bigl(\hat{U}_{ij}, \hat{U}_{ik}\bigr)\bigr]\mbox{,}</code>
</p>

<p style="text-align: center;"><code class="reqn">B = \biggl(\frac{1}{3}\biggr)^d - \biggl(\frac{2}{n}\biggr)\biggl(\frac{1}{2}\biggr)^d
               \sum_{j=1}^n\prod_{i=1}^d  [1 - \hat{U}_{ij}^2]\mbox{.}</code>
</p>

<p>The normalization constant is a function of dimension and is
</p>
<p style="text-align: center;"><code class="reqn">h(d)^{-1} = \frac{2}{(d+1)(d+2)} - \biggl(\frac{1}{2}\biggr)^d\frac{d\,!}{\prod_{i=0}^d\bigl(i+(1/2)\bigr)}+\biggl(\frac{1}{3}\biggr)^d\mbox{.}</code>
</p>

<pre>
  set.seed(1); UV &lt;- simCOP(n=1000, cop=PSP)
  hoefCOP(cop=PSP)                                       # 0.4547656 (theo.)
  hoefCOP(para=UV, as.sample=TRUE)                       # 0.4892757
  set.seed(1); UV &lt;- simCOP(n=1000, cop=PSP, snv=TRUE) # std normal variates
  hoefCOP(para=UV, as.sample=TRUE, sample.as.prob=FALSE) # 0.4270324
</pre>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Cherubini, U., Luciano, E., and Vecchiato, W., 2004, Copula methods in finance: Hoboken, NJ, Wiley, 293 p.
</p>
<p>Gaißer, S., Ruppert, M., and Schmid, F., 2010, A multivariate version of Hoeffding's Phi-Square: Journal of Multivariate Analysis, v. 101, no. 10, pp. 2571–2586.
</p>
<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>blomCOP</code>, <code>footCOP</code>, <code>giniCOP</code>,
<code>rhoCOP</code>, <code>tauCOP</code>, <code>wolfCOP</code>,
<code>joeskewCOP</code>, <code>uvlmoms</code>,
<code>LzCOPpermsym</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Example (ii) Gaisser et al. (2010, p. 2574)
Theta &lt;- 0.66 # Phi^2 = Theta^2 ---&gt; Phi == Theta as shown
hoefCOP(cop=convex2COP, para=c(alpha=Theta, cop1=M, cop2=P)) # 0.6599886

rhoCOP(cop=PSP) == hoefCOP(cop=PSP, p=1) # TRUE
LpCOP(cop=PLACKETTcop, para=1.6, p=2.6)  # 0.1445137 (Fractional p)
## End(Not run)

## Not run: 
set.seed(938) # Phi(1.6; Plackett) = 0.1184489; L_1 = 0.1168737
UV &lt;- simCOP(cop=PLACKETTcop, para=1.6, n=2000, ploton=FALSE, points=FALSE)
hoefCOP(cop=PLACKETTcop, para=1.6, p=200)  # Large p near internal limits
L_1 &lt;- 4*max(abs(PLACKETTcop(UV$U, UV$V, para=1.6) - UV$U*UV$V)) # p is infty
# and finite n and arguably a sample-like statistic here, now on intuition try
# a more sample-like means
U &lt;- runif(10000); V &lt;- runif(10000)
L_2 &lt;- 4*max(abs(EMPIRcop(U, V, para=UV) - U*V)) # 0.1410254 (not close enough)
## End(Not run)

## Not run: 
para &lt;- list(alpha=0.15, beta=0.90, kappa=0.06, gamma=0.96,
             cop1=GHcop, cop2=PLACKETTcop, para1=5.5, para2=0.07)
LpCOPradsym( cop=composite2COP, para=para) # 0.02071164
LpCOPpermsym(cop=composite2COP, para=para) # 0.01540297
## End(Not run)

## Not run: 
"MOcop.formula" &lt;- function(u,v, para=para, ...) {
   alpha &lt;- para[1]; beta &lt;- para[2]; return(min(v*u^(1-alpha), u*v^(1-beta)))
}
"MOcop" &lt;- function(u,v, ...) { asCOP(u,v, f=MOcop.formula, ...) }
   LpCOPradsym( cop=MOcop, para=c(0.8, 0.5)) # 0.0261843
   LpCOPpermsym(cop=MOcop, para=c(0.8, 0.5)) # 0.0243912 
## End(Not run)
</code></pre>


</div>