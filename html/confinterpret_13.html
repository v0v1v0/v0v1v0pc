<div class="container">

<table style="width: 100%;"><tr>
<td>plot_interpretation_result_list</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting function for collection of interpretation_result objects</h2>

<h3>Description</h3>

<p>Produces a plot presenting a collection of
<code>interpretation_result</code>
objects on a single chart. If the <code>interpretation_result</code> objects are
named then the names will be used for labelling the relevant intervals on
the chart.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot_interpretation_result_list(x, extra_boundaries = NULL,
  estimates = NULL, boundary_values = TRUE, boundary_label_pos = "below",
  interpretation_label_pos = "right", x_axis_pos = "below",
  y_axis_pos = "none", inner_margin = c(-0.1, 0.05, -0.1, 0.05),
  edge_margin = c(0, 0.02, 0, 0.02), edge_type = "gradient",
  interval_type = "norm", y_scale = 0.75, interval_value_labels = TRUE,
  estimate_value_labels = TRUE, plot_estimate_marks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A list of <code>interpretation_result</code> objects, length at least 2. The
objects may optionally be named. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra_boundaries</code></td>
<td>
<p>Names optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimates</code></td>
<td>
<p>Estimate values that the intervals assessed in each
<code>interpretation_result</code> object relate to. If not specified, a default
of the central point between the two ends of each interval will be assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_values</code></td>
<td>
<p>A logical value indicating whether the values should be appended to
the boundaries' names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_label_pos</code></td>
<td>
<p>Where to put the boundary labels.
Options are <code>c("below", "above", "on top", "none")</code>.
If you are planning to plot values on the canvas and want the boundary
labels on top then you may want to choose "none" and make a call to
<code>label_ontop_boundaries()</code> after plotting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpretation_label_pos</code></td>
<td>
<p>Options are <code>c("right", "left", "none")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_axis_pos</code></td>
<td>
<p>Location of a numerical x axis.
Options are <code>c("none", "below", "above")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_axis_pos</code></td>
<td>
<p>Location of a numerical y axis. Default "none" will almost always be right.
Options are c<code>("none", "left", "right")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_margin</code></td>
<td>
<p>Numerical vector of the form <code>c(bottom, left, top, right)</code>, which
gives the amount of inner margin to be added, expressed as a proportion
of the plotted area. This is space designed to be past any plotted objects
but before the edging (defined separately via <code>edge_margin</code>).
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_margin</code></td>
<td>
<p>Numerical vector of the form <code>c(bottom, left, top, right)</code>, which gives
the amount of 'edge margin' to be added, expressed as a proportion of the
plotted width. This is the space designed to be occupied by plot edges
(e.g. a gradient fading out). Currently only implemented for left and
right; top and bottom values are ignored. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_type</code></td>
<td>
<p>What style of edge to draw at the sides of the plot. Currently supported
options are <code>"gradient"</code> (the default) and <code>"zigzag"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval_type</code></td>
<td>
<p>Set the way the interval is presented. Current options are
<code>c("norm", "unif")</code> for a normal distribution-based curve
and a box, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_scale</code></td>
<td>
<p>How tall the interval plots are to be drawn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval_value_labels</code></td>
<td>
<p>Logical value specifying whether interval value labels are to be added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate_value_labels</code></td>
<td>
<p>Logical value specifying whether estimate value labels are to be added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_estimate_marks</code></td>
<td>
<p>Whether to plot marks at the x location of the estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a single <code>interpretation_result</code> object a <code>plot()</code> method is
provided; see <code>plot.interpretation_result</code>.
</p>
<p>To be a valid group of <code>interpretation_result</code> objects, each of the
items in <code>x</code> must be a valid <code>interpretation_result</code>, and they
must all share some characteristics. Each of the component objects must have
been generated using the same <code>interpretation_set</code>, with the same
boundaries, and the <code>low_to_high</code> parameter must be the same. This
enables them to be meaningfully plotted on the same canvas.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Set up some intervals to test:
ci_stage_1 &lt;- matrix(c(0.023, 0.131), nrow = 1,
                     dimnames = list("estimate", c("2.5 %", "97.5 %")))
ci_stage_2 &lt;- matrix(c(-0.016, 0.096), nrow = 1,
                     dimnames = list("estimate", c("2.5 %", "97.5 %")))
# Conduct the interpretations:
interp_stage_1 &lt;-  interpret_noninferiority(ci_stage_1, actual_null = 0,
                                           ni_margin = 0.05,
                                           groups = c("Business as usual",
                                                      "New approach"))
interp_stage_2 &lt;-  interpret_noninferiority(ci_stage_2, actual_null = 0,
                                           ni_margin = 0.05,
                                           groups = c("Business as usual",
                                                      "New approach"))

# Assemble the list object:
interp_1_and_2 &lt;- list("Stage 1" = interp_stage_1,
                       "Stage 2" = interp_stage_2)
# Set a nice colour scheme
grDevices::palette(c("#FF671F99", "#F2A90099", "#0085CA99"))
plot_interpretation_result_list(interp_1_and_2,
                                boundary_label_pos = "on top")

</code></pre>


</div>