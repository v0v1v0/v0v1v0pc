<div class="container">

<table style="width: 100%;"><tr>
<td>OSA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal String Alignment (OSA) String/Sequence Comparator</h2>

<h3>Description</h3>

<p>The Optimal String Alignment (OSA) distance between two strings/sequences
<code class="reqn">x</code> and <code class="reqn">y</code> is the minimum cost of operations (insertions,
deletions, substitutions or transpositions) required to transform  <code class="reqn">x</code>
into <code class="reqn">y</code>, subject to the constraint that <em>no substring/subsequence is
edited more than once</em>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">OSA(
  deletion = 1,
  insertion = 1,
  substitution = 1,
  transposition = 1,
  normalize = FALSE,
  similarity = FALSE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>deletion</code></td>
<td>
<p>positive cost associated with deletion of a character
or sequence element. Defaults to unit cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>insertion</code></td>
<td>
<p>positive cost associated insertion of a character
or sequence element. Defaults to unit cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>substitution</code></td>
<td>
<p>positive cost associated with substitution of a
character or sequence element. Defaults to unit cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transposition</code></td>
<td>
<p>positive cost associated with transposing (swapping)
a pair of characters or sequence elements. Defaults to unit cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>a logical. If TRUE, distances are normalized to the
unit interval. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
instead of distances. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>An OSA similarity is returned if <code>similarity = TRUE</code>, which
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = \frac{w_d |x| + w_i |y| - \mathrm{dist}(x, y)}{2},</code>
</p>

<p>where <code class="reqn">|x|</code>, <code class="reqn">|y|</code> are the number of characters in <code class="reqn">x</code> and
<code class="reqn">y</code> respectively, <code class="reqn">dist</code> is the OSA distance, <code class="reqn">w_d</code>
is the cost of a deletion and <code class="reqn">w_i</code> is the cost of an insertion.
</p>
<p>Normalization of the OSA distance/similarity to the unit interval
is also supported by setting <code>normalize = TRUE</code>. The normalization approach
follows Yujian and Bo (2007), and ensures that the distance remains a metric
when the costs of insertion <code class="reqn">w_i</code> and deletion <code class="reqn">w_d</code> are equal.
The normalized distance <code class="reqn">\mathrm{dist}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}_n(x, y) = \frac{2 \mathrm{dist}(x, y)}{w_d |x| + w_i |y| + \mathrm{dist}(x, y)},</code>
</p>

<p>and the normalized similarity <code class="reqn">\mathrm{sim}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}_n(x, y) = 1 - \mathrm{dist}_n(x, y) = \frac{\mathrm{sim}(x, y)}{w_d |x| + w_i |y| - \mathrm{sim}(x, y)}.</code>
</p>



<h3>Value</h3>

<p>An <code>OSA</code> instance is returned, which is an S4 class inheriting from
<code>StringComparator</code>.
</p>


<h3>Note</h3>

<p>If the costs of deletion and insertion are equal, this comparator is
symmetric in <code class="reqn">x</code> and <code class="reqn">y</code>. The OSA distance is not a proper metric
as it does not satisfy the triangle inequality. The Damerau-Levenshtein
distance is closely related—it allows the same edit operations as OSA,
but removes the requirement that no substring can be edited more than once.
</p>


<h3>References</h3>

<p>Boytsov, L. (2011), "Indexing methods for approximate dictionary searching:
Comparative analysis", <em>ACM J. Exp. Algorithmics</em> <strong>16</strong>,
Article 1.1.
</p>
<p>Navarro, G. (2001), "A guided tour to approximate string matching",
<em>ACM Computing Surveys (CSUR)</em>, <strong>33</strong>(1), 31-88.
</p>
<p>Yujian, L. &amp; Bo, L. (2007), "A Normalized Levenshtein Distance Metric",
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>
<strong>29</strong>: 1091–1095.
</p>


<h3>See Also</h3>

<p>Other edit-based comparators include <code>Hamming</code>, <code>LCS</code>,
<code>Levenshtein</code> and <code>DamerauLevenshtein</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Compare strings with a transposition error
x &lt;- "plauge"; y &lt;- "plague"
OSA()(x, y) != Levenshtein()(x, y)

## Unlike Damerau-Levenshtein, OSA does not allow a substring to be 
## edited more than once
x &lt;- "ABC"; y &lt;- "CA"
OSA()(x, y) != DamerauLevenshtein()(x, y)

## Compare car names using normalized OSA similarity
data(mtcars)
cars &lt;- rownames(mtcars)
pairwise(OSA(similarity = TRUE, normalize=TRUE), cars)

</code></pre>


</div>