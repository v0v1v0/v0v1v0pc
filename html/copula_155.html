<div class="container">

<table style="width: 100%;"><tr>
<td>estim.misc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Various Estimators for (Nested) Archimedean Copulas</h2>

<h3>Description</h3>

<p>Various Estimators for (Nested) Archimedean Copulas, namely,
</p>

<dl>
<dt>ebeta</dt>
<dd>
<p>Method-of-moments-like estimator based on (a
multivariate version of) Blomqvist'sbeta.</p>
</dd>
<dt>edmle</dt>
<dd>
<p>Maximum likelihood estimator based on the diagonal of a
(nested) Archimedean copula.</p>
</dd>
<dt>etau</dt>
<dd>
<p>Method-of-moments-like estimators based on (bivariate)
Kendall's tau.</p>
</dd>
</dl>
<h3>Usage</h3>

<pre><code class="language-R">ebeta(u, cop, interval = initOpt(cop@copula@name), ...)
edmle(u, cop, interval = initOpt(cop@copula@name), warn=TRUE, ...)
 etau(u, cop, method = c("tau.mean", "theta.mean"), warn=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula, where <code class="reqn">n</code> denotes the
sample size and <code class="reqn">d</code> the dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p><code>outer_nacopula</code> to be estimated
(currently only Archimedean copulas are provided).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in Hofert et
al. (2013).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string specifying the method (only
for <code>etau</code>), which has to be one (or a unique abbreviation) of
</p>

<dl>
<dt><code>"tau.mean"</code></dt>
<dd>
<p>method-of-moments-like estimator based on
the average of pairwise sample versions of Kendall’s tau;</p>
</dd>
<dt><code>"theta.mean"</code></dt>
<dd>
<p>average of the method-of-moments-like
Kendall's tau estimators.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>logical indicating if warnings are printed:
</p>

<dl>
<dt><code>edmle()</code></dt>
<dd>
<p>for the family of <code>"Gumbel"</code> if the
diagonal maximum-likelihood estimator is smaller than 1.</p>
</dd>
<dt><code>etau()</code></dt>
<dd>
<p>for the family of <code>"AMH"</code> if tau is outside
<code class="reqn">[0, 1/3]</code> and in general if at least one of the computed
pairwise sample	versions of Kendall's tau is negative.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to
<code>corKendall</code> (for <code>etau</code>, but see ‘Details’),
to <code>optimize</code> (for <code>edmle</code>), or
to <code>safeUroot</code> (for <code>ebeta</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>ebeta</code>, the parameter is estimated with a
method-of-moments-like procedure such that the population version of
the multivariate Blomqvist's beta matches its sample version.
</p>
<p>Note that the copula diagonal is a distribution function and the
maximum of all components of a random vector following the copula is
distributed according to this distribution function.  For
<code>edmle</code>, the parameter is estimated via maximum-likelihood
estimation based on the diagonal.
</p>
<p>For <code>etau</code>, <code>corKendall(u, ...)</code> is used and if there
are no <code>NA</code>s in <code>u</code>, by default (if no additional
arguments are provided), <code>corKendall()</code> calls the <code class="reqn">O(n log(n))</code>
fast <code>cor.fk()</code> from package <a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a>
instead of the <code class="reqn">O(n^2)</code> <code>cor(*, method="kendall")</code>.
Conversely, when <code>u</code> has <code>NA</code>s, by default,
<code>corKendall(u, ...)</code> will use
<code>cor(u, method="kendall", use = "pairwise")</code> such that
<code>etau(u, *)</code> will work.
<br>
Furthermore, <code>method="tau.mean"</code> means that the average
of sample versions of Kendall's tau are computed first and then the
parameter is determined such that the population version of Kendall's
tau matches this average (if possible); the <code>method="theta.mean"</code>
stands for first computing all pairwise Kendall's tau estimators and
then returning the mean of these estimators.
</p>
<p>For more details, see Hofert et al. (2013).
</p>
<p>Note that these estimators should be used with care; see the
performance results in Hofert et al. (2013).  In particular,
<code>etau</code> should be used with the (default) method <code>"tau.mean"</code>
since <code>"theta.mean"</code> is both slower and more prone to errors.
</p>


<h3>Value</h3>


<dl>
<dt><code>ebeta</code></dt>
<dd>
<p>the return value of <code>safeUroot</code>
(that is, typically almost the same as the value of
<code>uniroot</code>) giving the Blomqvist beta estimator.</p>
</dd>
<dt><code>edmle</code></dt>
<dd>
<p><code>list</code> as returned by
<code>optimize</code>, including the diagonal maximum likelihood
estimator.</p>
</dd>
<dt><code>etau</code></dt>
<dd>
<p>method-of-moments-like estimator based on
Kendall's tau for the chosen method.</p>
</dd>
</dl>
<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25–63.
</p>


<h3>See Also</h3>

<p><code>corKendall()</code>.
</p>
<p>The more sophisticated estimators <code>emle</code> (Maximum Likelihood) and
<code>emde</code> (Minimum Distance). <code>enacopula</code>
(wrapper for different estimators).
</p>


<h3>Examples</h3>

<pre><code class="language-R">tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3 = 1.333..
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n, cop)

system.time(theta.hat.beta &lt;- ebeta(U, cop=cop))
theta.hat.beta$root

system.time(theta.hat.dmle &lt;- edmle(U, cop=cop))
theta.hat.dmle$minimum

system.time(theta.hat.etau &lt;- etau(U, cop=cop, method="tau.mean"))
theta.hat.etau

system.time(theta.hat.etau. &lt;- etau(U, cop=cop, method="theta.mean"))
theta.hat.etau.

## etau()  in the case of missing values (NA's)
## ------                 ---------------------
##' @title add Missing Values completely at random
##' @param x  matrix or vector
##' @param prob desired probability ("fraction") of missing values (\code{\link{NA}}s).
##' @return x[] with some (100*prob percent) entries replaced by \code{\link{NA}}s.
addNAs &lt;- function(x, prob) {
    np &lt;- length(x)
    x[sample.int(np, prob*np)] &lt;- NA
    x
}

## UM[] := U[] with 5% missing values
set.seed(7); UM &lt;- addNAs(U, p = 0.05)
mean(is.na(UM)) # 0.05
## This error if x has NA's was happening for  etau(UM, cop=cop)
## before copula version 0.999-17 (June 2017) :
try(eM &lt;- etau(UM, cop=cop, use = "everything"))
        #  --&gt; Error ... NA/NaN/Inf in foreign function call
## The new default:
eM0 &lt;- etau(UM, cop=cop, use = "pairwise")
eM1 &lt;- etau(UM, cop=cop, use = "complete")
##  use = "complete" is really equivalent to dropping all obs. with with missing values:
stopifnot(all.equal(eM1, etau(na.omit(UM), cop=cop), tol = 1e-15))
## but  use = "pairwise" ---&gt; cor(*, use = "pairwise") is much better:
rbind(etau.U = theta.hat.etau, etau.UM.pairwise = eM0, etau.UM.complete = eM1)
</code></pre>


</div>