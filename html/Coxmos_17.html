<div class="container">

<table style="width: 100%;"><tr>
<td>cv.splsdrcox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sPLS-DRCOX Cross-Validation</h2>

<h3>Description</h3>

<p>This function performs cross-validated sparse partial least squares DRCox (sPLS-DRCOX).
The function returns the optimal number of components and the optimal sparsity penalty value based
on cross-validation. The performance could be based on multiple metrics as Area Under the Curve
(AUC), Brier Score or C-Index. Furthermore, the user could establish more than one metric
simultaneously.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.splsdrcox(
  X,
  Y,
  max.ncomp = 8,
  penalty.list = seq(0.1, 0.9, 0.2),
  n_run = 3,
  k_folds = 10,
  x.center = TRUE,
  x.scale = FALSE,
  remove_near_zero_variance = TRUE,
  remove_zero_variance = TRUE,
  toKeep.zv = NULL,
  remove_variance_at_fold_level = FALSE,
  remove_non_significant_models = FALSE,
  remove_non_significant = FALSE,
  alpha = 0.05,
  w_AIC = 0,
  w_c.index = 0,
  w_AUC = 1,
  w_BRIER = 0,
  times = NULL,
  max_time_points = 15,
  MIN_AUC_INCREASE = 0.01,
  MIN_AUC = 0.8,
  MIN_COMP_TO_CHECK = 3,
  pred.attr = "mean",
  pred.method = "cenROC",
  fast_mode = FALSE,
  MIN_EPV = 5,
  return_models = FALSE,
  returnData = FALSE,
  PARALLEL = FALSE,
  verbose = FALSE,
  seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix or data.frame. Explanatory variables. Qualitative variables must be
transform into binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric matrix or data.frame. Response variables. Object must have two columns named as
"time" and "event". For event column, accepted values are: 0/1 or FALSE/TRUE for censored and
event observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.ncomp</code></td>
<td>
<p>Numeric. Maximum number of PLS components to compute for the cross validation
(default: 8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.list</code></td>
<td>
<p>Numeric vector. Vector of penalty values. Penalty for sPLS-DRCOX. If
penalty = 0 no penalty is applied, when penalty = 1 maximum penalty (no variables are selected)
based on 'plsRcox' penalty. Equal or greater than 1 cannot be selected (default: seq(0.1,0.9,0.2)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_run</code></td>
<td>
<p>Numeric. Number of runs for cross validation (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_folds</code></td>
<td>
<p>Numeric. Number of folds for cross validation (default: 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.center</code></td>
<td>
<p>Logical. If x.center = TRUE, X matrix is centered to zero means (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.scale</code></td>
<td>
<p>Logical. If x.scale = TRUE, X matrix is scaled to unit variances (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_near_zero_variance</code></td>
<td>
<p>Logical. If remove_near_zero_variance = TRUE, near zero variance
variables will be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_zero_variance</code></td>
<td>
<p>Logical. If remove_zero_variance = TRUE, zero variance variables will
be removed (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toKeep.zv</code></td>
<td>
<p>Character vector. Name of variables in X to not be deleted by (near) zero variance
filtering (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_variance_at_fold_level</code></td>
<td>
<p>Logical. If remove_variance_at_fold_level = TRUE, (near) zero
variance will be removed at fold level (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant_models</code></td>
<td>
<p>Logical. If remove_non_significant_models = TRUE,
non-significant models are removed before computing the evaluation. A non-significant model is a
model with at least one component/variable with a P-Value higher than the alpha cutoff.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_non_significant</code></td>
<td>
<p>Logical. If remove_non_significant = TRUE, non-significant
variables/components in final cox model will be removed until all variables are significant by
forward selection (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Numerical values are regarded as significant if they fall below the
threshold (default: 0.05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_AIC</code></td>
<td>
<p>Numeric. Weight for AIC evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_c.index</code></td>
<td>
<p>Numeric. Weight for C-Index evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_AUC</code></td>
<td>
<p>Numeric. Weight for AUC evaluator. All weights must sum 1 (default: 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_BRIER</code></td>
<td>
<p>Numeric. Weight for BRIER SCORE evaluator. All weights must sum 1 (default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of
'max_time_points' points will be selected equally distributed (default: NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time_points</code></td>
<td>
<p>Numeric. Maximum number of time points to use for evaluating the model
(default: 15).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC_INCREASE</code></td>
<td>
<p>Numeric. Minimum improvement between different cross validation models
to continue evaluating higher values in the multiple tested parameters. If it is not reached for
next 'MIN_COMP_TO_CHECK' models and the minimum 'MIN_AUC' value is reached, the evaluation stops
(default: 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_AUC</code></td>
<td>
<p>Numeric. Minimum AUC desire to reach cross-validation models. If the minimum is
reached, the evaluation could stop if the improvement does not reach an AUC higher than adding
the 'MIN_AUC_INCREASE' value (default: 0.8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_COMP_TO_CHECK</code></td>
<td>
<p>Numeric. Number of penalties/components to evaluate to check if the AUC
improves. If for the next 'MIN_COMP_TO_CHECK' the AUC is not better and the 'MIN_AUC' is meet,
the evaluation could stop (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.attr</code></td>
<td>
<p>Character. Way to evaluate the metric selected. Must be one of the following:
"mean" or "median" (default: "mean").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.method</code></td>
<td>
<p>Character. AUC evaluation algorithm method for evaluate the model performance.
Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C",
"smoothROCtime_I" (default: "cenROC").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast_mode</code></td>
<td>
<p>Logical. If fast_mode = TRUE, for each run, only one fold is evaluated
simultaneously. If fast_mode = FALSE, for each run, all linear predictors are computed for test
observations. Once all have their linear predictors, the evaluation is perform across all the
observations together (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MIN_EPV</code></td>
<td>
<p>Numeric. Minimum number of Events Per Variable (EPV) you want reach for the final
cox model. Used to restrict the number of variables/components can be computed in final cox models.
If the minimum is not meet, the model cannot be computed (default: 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_models</code></td>
<td>
<p>Logical. Return all models computed in cross validation (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnData</code></td>
<td>
<p>Logical. Return original and normalized X and Y matrices (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PARALLEL</code></td>
<td>
<p>Logical. Run the cross validation with multicore option. As many cores as your
total cores - 1 will be used. It could lead to higher RAM consumption (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Number. Seed value for performing runs/folds divisions (default: 123).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code style="white-space: pre;">⁠sPLS-DRCOX Cross-Validation⁠</code> function offers a robust approach to fine-tune the hyperparameters
of the sPLS-DRCOX model, ensuring optimal performance in survival analysis tasks. By systematically
evaluating different combinations of hyperparameters, this function identifies the best model
configuration that minimizes prediction error.
</p>
<p>Cross-validation is a crucial step in survival analysis, especially when dealing with
high-dimensional datasets. It provides an unbiased assessment of the model's generalization
capability, safeguarding against overfitting. This function employs a k-fold cross-validation
strategy, partitioning the data into multiple subsets (folds) and iteratively using each fold as
a test set while the remaining folds serve as training data.
</p>
<p>One of the primary strengths of this function is its flexibility. Users can specify a range of
values for the number of PLS components and the penalty parameter <code>penalty</code>. The function then
evaluates all possible combinations, returning the optimal configuration that yields the best
predictive performance.
</p>
<p>Additionally, the function offers advanced features like parallel processing for faster computation,
and the ability to return all models from the cross-validation process. This is particularly
useful for in-depth analysis and comparisons.
</p>
<p>The output provides comprehensive insights, including performance metrics for each fold, run, and
hyperparameter combination. Visualization plots like AIC, C-Index, Brier Score, and AUC plots
further aid in understanding the model's performance across different configurations.
</p>


<h3>Value</h3>

<p>Instance of class "Coxmos" and model "cv.sPLS-DRCOX".
<code>best_model_info</code>: A data.frame with the information for the best model.
<code>df_results_folds</code>: A data.frame with fold-level information.
<code>df_results_runs</code>: A data.frame with run-level information.
<code>df_results_comps</code>: A data.frame with component-level information (for cv.coxEN, EN.alpha
information).
</p>
<p><code>lst_models</code>: If return_models = TRUE, return a the list of all cross-validated models.
<code>pred.method</code>: AUC evaluation algorithm method for evaluate the model performance.
</p>
<p><code>opt.comp</code>: Optimal component selected by the best_model.
<code>opt.penalty</code>: Optimal penalty/penalty selected by the best_model.
<code>opt.nvar</code>: Optimal number of variables selected by the best_model.
</p>
<p><code>plot_AIC</code>: AIC plot by each hyper-parameter.
<code>plot_c_index</code>: C-Index plot by each hyper-parameter.
<code>plot_BRIER</code>: Brier Score plot by each hyper-parameter.
<code>plot_AUC</code>: AUC plot by each hyper-parameter.
</p>
<p><code>class</code>: Cross-Validated model class.
</p>
<p><code>lst_train_indexes</code>: List (of lists) of indexes for the observations used in each run/fold
for train the models.
<code>lst_test_indexes</code>: List (of lists) of indexes for the observations used in each run/fold
for test the models.
</p>
<p><code>time</code>: time consumed for running the cross-validated function.
</p>


<h3>Author(s)</h3>

<p>Pedro Salguero Garcia. Maintainer: pedsalga@upv.edu.es
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("X_proteomic")
data("Y_proteomic")
set.seed(123)
index_train &lt;- caret::createDataPartition(Y_proteomic$event, p = .5, list = FALSE, times = 1)
X_train &lt;- X_proteomic[index_train,1:50]
Y_train &lt;- Y_proteomic[index_train,]
cv.splsdrcox_model &lt;- cv.splsdrcox(X_train, Y_train, max.ncomp = 2, penalty.list = c(0.1),
n_run = 1, k_folds = 2, x.center = TRUE, x.scale = TRUE)
</code></pre>


</div>