<div class="container">

<table style="width: 100%;"><tr>
<td>cCopula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conditional Distributions and Their Inverses from Copulas</h2>

<h3>Description</h3>

<p>Compute the conditional distribution function
<code class="reqn">C(u_d\,|\,u_1,\dots, u_{d-1})</code>
of <code class="reqn">u_d</code> given <code class="reqn">u_1,\dots,u_{d-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
cCopula(u, copula, indices = 1:dim(copula), inverse = FALSE,
        log = FALSE, drop = FALSE, ...)

## Deprecated (use cCopula() instead):
rtrafo(u, copula, indices = 1:dim(copula), inverse = FALSE, log = FALSE)
cacopula(u, cop, n.MC = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>data <code>matrix</code> in <code class="reqn">[0,1]^(n, d)</code> of
<code class="reqn">U(0,1)^d</code> samples if <code>inverse = FALSE</code>
and (pseudo-/copula-)observations if <code>inverse = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copula, cop</code></td>
<td>
<p>copula, i.e., an object of class
<code>"Copula"</code> with specified parameters; currently,
the conditional distribution is only provided for Archimedean and
elliptical copulas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indices</code></td>
<td>
<p>vector of indices <code class="reqn">j</code> (in <code class="reqn">\{1,\dots,d\}</code>
(<code class="reqn">d =</code> copula dimension); unique; sorted in increasing order) for which
<code class="reqn">C_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code> (or, if
<code>inverse = TRUE</code>,
<code class="reqn">C^-_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>)
is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverse</code></td>
<td>
<p><code>logical</code> indicating whether the inverse
<code class="reqn">C^-_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>
is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.MC</code></td>
<td>
<p>integer Monte Carlo sample size; for Archimedean copulas only,
used if positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>a <code>logical</code> indicating whether the logarithmic
values are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a <code>logical</code> indicating whether a vector should
be returned (instead of a 1–row matrix) when <code>n</code> is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments (currently only used if
<code>inverse = TRUE</code> in which case they are passed on to the
underlying <code>uniroot()</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default and if fed with a sample of the corresponding copula,
<code>cCopula()</code> computes the Rosenblatt
transform; see Rosenblatt (1952).  The involved high-order derivatives
for Archimedean copulas were derived in Hofert et al. (2012).
</p>
<p><em>Sampling</em>, that is, random number generation,
can be achieved by using <code>inverse=TRUE</code>.  In this case,
the inverse Rosenblatt transformation is used, which, for sampling
purposes, is also known as <em>conditional distribution method</em>.
Note that, for Archimedean copulas not being Clayton, this can be slow
as it involves numerical root finding in each (but the first) component.
</p>


<h3>Value</h3>

<p>An <code class="reqn">(n, k)</code>-<code>matrix</code> (unless <code>n == 1</code> and
<code>drop</code> is true, where a <code class="reqn">k</code>-vector is returned) where <code class="reqn">k</code>
is the length of <code>indices</code>.  This matrix contains the conditional
copula function values
<code class="reqn">C_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>
or, if <code>inverse = TRUE</code>, their inverses
<code class="reqn">C^-_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>
for all <code class="reqn">j</code> in <code>indices</code>.
</p>


<h3>Note</h3>

<p>For some (but not all) families, this function also makes sense on the
boundaries (if the corresponding limits can be computed).
</p>


<h3>References</h3>

<p>Genest, C., Rémillard, B., and Beaudoin, D. (2009).
Goodness-of-fit tests for copulas: A review and a power study.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 199–213.
</p>
<p>Rosenblatt, M. (1952).
Remarks on a Multivariate Transformation,
<em>The Annals of Mathematical Statistics</em> <b>23</b>, 3, 470–472.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133–150.
</p>


<h3>See Also</h3>

<p><code>htrafo</code>; <code>acopula-families</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 1) Sampling from a conditional distribution of a Clayton copula given u_1

## Define the copula
tau &lt;- 0.5
theta &lt;- iTau(claytonCopula(), tau = tau)
d &lt;- 2
cc &lt;- claytonCopula(theta, dim = d)
n &lt;- 1000
set.seed(271)

## A small u_1
u1 &lt;- 0.05
U &lt;- cCopula(cbind(u1, runif(n)), copula = cc, inverse = TRUE)
plot(U[,2], ylab = quote(U[2]))

## A large u_1
u1 &lt;- 0.95
U &lt;- cCopula(cbind(u1, runif(n)), copula = cc, inverse = TRUE)
plot(U[,2], ylab = quote(U[2]))


## 2) Sample via conditional distribution method and then apply the
##    Rosenblatt transform
##    Note: We choose the numerically more involved (and thus slower)
##          Gumbel case here

## Define the copula
tau &lt;- 0.5
theta &lt;- iTau(gumbelCopula(), tau = tau)
d &lt;- 5
gc &lt;- gumbelCopula(theta, dim = d)
n &lt;- 200
set.seed(271)
U. &lt;- matrix(runif(n*d), ncol = d) # U(0,1)^d


## Transform to Gumbel sample via conditional distribution method
U &lt;- cCopula(U., copula = gc, inverse = TRUE) # slow for ACs except Clayton
splom2(U) # scatter-plot matrix copula sample

## Rosenblatt transform back to U(0,1)^d (as a check)
U. &lt;- cCopula(U, copula = gc)
splom2(U.) # U(0,1)^d again


## 3) cCopula() for elliptical copulas

tau &lt;- 0.5
theta &lt;- iTau(claytonCopula(), tau = tau)
d &lt;- 5
cc &lt;- claytonCopula(theta, dim = d)
set.seed(271)
n &lt;- 1000
U &lt;- rCopula(n, copula = cc)
X &lt;- qnorm(U) # X now follows a meta-Clayton model with N(0,1) marginals
U &lt;- pobs(X) # build pseudo-observations

fN &lt;- fitCopula(normalCopula(dim = d), data = U) # fit a Gauss copula
U.RN &lt;- cCopula(U, copula = fN@copula)
splom2(U.RN, cex = 0.2) # visible but not so clearly

f.t &lt;- fitCopula(tCopula(dim = d), U)
U.Rt &lt;- cCopula(U, copula = f.t@copula) # transform with a fitted t copula
splom2(U.Rt, cex = 0.2) # still visible but not so clear

## Inverse (and check consistency)
U.N &lt;- cCopula(U.RN, copula = fN @copula, inverse = TRUE)
U.t &lt;- cCopula(U.Rt, copula = f.t@copula, inverse = TRUE)

tol &lt;- 1e-14
stopifnot(
    all.equal(U, U.N),
    all.equal(U, U.t),
    all.equal(log(U.RN),
              cCopula(U, copula = fN @copula, log = TRUE), tolerance = tol),
    all.equal(log(U.Rt),
              cCopula(U, copula = f.t@copula, log = TRUE), tolerance = tol)
)

## 4) cCopula() for a more sophisticated mixture copula (bivariate case only!)

tau &lt;- 0.5
cc &lt;- claytonCopula(iTau(claytonCopula(), tau = tau)) # first mixture component
tc &lt;- tCopula(iTau(tCopula(), tau = tau), df = 3) # t_3 copula
tc90 &lt;- rotCopula(tc, flip = c(TRUE, FALSE)) # t copula rotated by 90 degrees
wts &lt;- c(1/2, 1/2) # mixture weights
mc &lt;- mixCopula(list(cc, tc90), w = wts) # mixture copula with one copula rotated

set.seed(271)
U &lt;- rCopula(n, copula = mc)
U. &lt;- cCopula(U, copula = mc) # Rosenblatt transform back to U(0,1)^2 (as a check)
plot(U., xlab = quote(U*"'"[1]), ylab = quote(U*"'"[2])) # check for uniformity
</code></pre>


</div>