<div class="container">

<table style="width: 100%;"><tr>
<td>deltaInverse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate inverse (dose-finding) intervals, using local inversion and the Delta method</h2>

<h3>Description</h3>

<p>Calculate left-bound to right-bound intervals for the dose point estimates, using local slopes at design points (places where observations exist) to invert the forward lower-upper bounds.
</p>


<h3>Usage</h3>

<pre><code class="language-R">deltaInverse(
  isotPoint,
  target = (1:3)/4,
  intfun = morrisCI,
  conf = 0.9,
  adaptiveCurve = FALSE,
  minslope = 0.01,
  slopeRefinement = TRUE,
  finegrid = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>isotPoint</code></td>
<td>
<p>The output of an estimation function such as <code>cirPAVA,doseFind</code>,  with the option <code>full=TRUE</code>. Should be at least a list of 3 <code>doseResponse</code> objects named <code>input, output, shrinkage</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>A vector of target response rate(s), for which the interval is needed. Default (since version 2.3.0) is the 3 quartiles (<code>(1:3) / 4</code>). If changed to <code>NULL</code>, interval will be returned for the <code class="reqn">y</code> values of <code>isotPoint$output</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intfun</code></td>
<td>
<p>the function to be used for initial (forward) interval estimation. Default <code>morrisCI</code> (see help on that function for additional options).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptiveCurve</code></td>
<td>
<p>logical, should the CIs be expanded by using a parabolic curve between estimation points rather than straight interpolation (default <code>FALSE</code>)? Recommended when adaptive design was used and <code>target</code> is not 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minslope</code></td>
<td>
<p>minimum local slope (subsequently normalized by the units dose spacing) considered positive, passed on to <code>slope</code>. Needed to avoid unrealistically broad intervals. Default 0.01.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slopeRefinement</code></td>
<td>
<p><strong>(new to 2.3.0)</strong> logical: whether to allow refinement of the slope estimate, including different slopes to the left and right of target. Default <code>TRUE</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finegrid</code></td>
<td>
<p>a numerical value used to guide how fine the grid of <code>x</code> values will be during slope estimation. Should be in (0,1) (preferably much less than 1). Default 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed on to <code>quickIsotone</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Delta method in this application boils down to dividing the distance to the forward (vertical) bounds, by the slope, to get the left/right interval width. Both forward intervals and slopes are calculated across a standard set of <code class="reqn">x</code> values, then interpolated at horizontal cross-sections determined by <code>target</code>. Slope estimates are performed by <code>slope</code>.
</p>
<p>Starting version 2.3.0, by default the slope estimate is different to the right and left of target. The intervals should now better accommodate the sharp slope changes that often happen with discrete dose-response datasets. Operationally, the intervals are first estimated via the single-slope approach described above. Then using a finer grid of <code class="reqn">x</code> values, weighted-average slopes to the right and left of the point estimate separately are calculated over the first-stage's half-intervals. The weights are hard-coded as quadratic (Epanechnikov).
</p>
<p>An alternative and much simpler interval method (dubbed "global") is hard-coded into <code>quickInverse</code>, and can be chosen from there as an option. But it is not recommended.
</p>


<h3>Value</h3>

<p>two-column matrix with the left and right bounds, respectively
</p>


<h3>See Also</h3>

<p><code>quickIsotone</code>,<code>quickInverse</code>,<code>isotInterval</code>,
<code>slope</code>; <code>DRshrink</code> for the shrinkage fix.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17), wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
quick1=quickIsotone(dat, adaptiveShrink = TRUE, target = 0.3)

# For inverse confidence intervals "the long way", 
#    we need a full CIR output object:
fwd1=cirPAVA(dat, full=TRUE, adaptiveShrink = TRUE, target = 0.3)
# Inverse intervals. 
# Note: 'target' specifies the y values at which the interval is calculated.
#       They are selected here based on the y range in which there are estimates.
yvals = c(seq(0.15, 0.3, 0.05), 0.33)
invDelta=deltaInverse(fwd1, target = yvals, adaptiveCurve = TRUE)
# We added the adaptiveCurve option because the experiment's target is off-center,
#     and inverse-interval coverage tends to be lacking w/o that option.

### Showing the data and the estimates
par(mar=c(3,3,4,1), mgp=c(2,.5,0), tcl=-0.25)
# Following command uses plot.doseResponse()
plot(dat, ylim=c(0.05,0.55), 
     las=1, xlim=c(0,6.5), main="Inverse-Estimation CIs") 

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(0,7,0.1), pweibull(seq(0,7,0.1), shape=1.1615, scale=8.4839), col=4, lwd=1.5)
abline(h=0.3, col=2, lwd=2, lty=3) ### The experiment's official target

# Forward CIs; the "global" inverse interval just draws horizontal lines between them
# To get these "global" intervals calculated for you at specific targets, choose 'delta=FALSE' 
#      when calling quickInverse()
lines(quick1$y, lwd=1.5, col='purple') 
lines(quick1$lower90conf,lty=2,col=3) 
lines(quick1$upper90conf,lty=2,col=3) 
# Note that only the upper forward bounds intersect the horizontal line at y=0.3.
#   Therefore, via the "global" approach there won't be a finite CI for the target estimate.

# Now, the default "local" inverse interval, which is finite for the range of estimated y values.
# In particular, it is finite (albeit very wide) for y=0.3.
lines(invDelta[,1], yvals, lty=2, lwd=2)
lines(invDelta[,2], yvals, lty=2, lwd=2)

legend('topleft', pch=c(NA,NA,'X',NA,NA), lty=c(1,1,NA,2,2), 
       col=c(4,'purple', 1,1,3), lwd=c(1.5,1.5,0,2,1),
       legend = c('True Curve', 'CIR Curve', 'Observations', 
                  'Local Interval (default)',
                  'Forward/Global Interval'), bty='n')

</code></pre>


</div>