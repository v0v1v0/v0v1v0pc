<div class="container">

<table style="width: 100%;"><tr>
<td>is.submodel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Identify correctness-preserving submodel relations
</h2>

<h3>Description</h3>

<p>The function <code>is.submodel</code> checks for each element of a vector of <code>cna</code> solution formulas whether it is a submodel of a specified target model <code>y</code>. If <code>y</code> is the true model in an inverse search (i.e. the ground truth), <code>is.submodel</code> identifies correct models in the <code>cna</code> output (see Baumgartner and Thiem 2020, Baumgartner and Ambuehl 2020).
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.submodel(x, y, strict = FALSE)
identical.model(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character vector of atomic and/or complex solution formulas (asf/csf). Must be of length 1 in <code>identical.model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Character string of length 1 specifying the target asf or csf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the elements of <code>x</code> only count as submodels of <code>y</code> if they are proper parts of <code>y</code> (i.e. not identical to <code>y</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To benchmark the reliability of a method of causal inference it must be tested to what degree the method recovers the true data generating structure <code class="reqn">\Delta</code> or proper substructures of <code class="reqn">\Delta</code> from data of varying quality. Reliability benchmarking is done in so-called <em>inverse searches</em>, which reverse the order of causal discovery as normally conducted in scientific practice. An inverse search comprises three steps: (1) a causal structure <code class="reqn">\Delta</code> is drawn/presupposed (as ground truth), (2) artificial data <code class="reqn">\delta</code> is simulated from <code class="reqn">\Delta</code>, possibly featuring various deficiencies (e.g. noise, fragmentation, measurement error etc.), and (3) <code class="reqn">\delta</code> is processed by the benchmarked method in order to check whether its output meets the tested reliability benchmark (e.g. whether the output is true of or identical to <code class="reqn">\Delta</code>). 
</p>
<p>The main purpose of <code>is.submodel</code> is to execute step (3) of an inverse search that is tailor-made to test the reliability of <code>cna</code> [with <code>randomConds</code> and <code>selectCases</code> designed for steps (1) and (2), respectively]. A solution formula <code>x</code> being a submodel of a target formula <code>y</code> means that all the causal claims entailed by <code>x</code> are true of <code>y</code>, which is the case if a causal interpretation of <code>x</code> entails conjunctive and disjunctive causal relevance relations that are all likewise entailed by a causal interpretation of <code>y</code>. More specifically, <code>x</code> is a submodel of <code>y</code> if, and only if, the following conditions are satisfied: (i) all factor values causally relevant according to <code>x</code> are also causally relevant according to <code>y</code>, (ii) all factor values contained in two different disjuncts in <code>x</code> are also contained in two different disjuncts in <code>y</code>, (iii) all factor values contained in the same conjunct in <code>x</code> are also contained in the same conjunct in <code>y</code>, and (iv) if <code>x</code> is a csf with more than one asf, (i) to (iii) are satisfied for all asfs in <code>x</code>. For more details see Baumgartner and Thiem (2020) or Baumgartner and Ambuehl (2020, online appendix).
</p>
<p><code>is.submodel</code> requires two inputs <code>x</code> and <code>y</code>, where <code>x</code> is a character vector of <code>cna</code> solution formulas (asf or csf) and <code>y</code> is one asf or csf (i.e. a character string of length 1), viz. the target structure or ground truth. The function returns <code>TRUE</code> for elements of <code>x</code> that are a submodel of <code>y</code> according to the definition of submodel-hood given in the previous paragraph. If <code>strict = TRUE</code>, <code>x</code> counts as a submodel of <code>y</code> only if <code>x</code> is a proper part of <code>y</code> (i.e. <code>x</code> is not identical to <code>y</code>).
</p>
<p>The function <code>identical.model</code> returns <code>TRUE</code> only if <code>x</code> (which must be of length 1) and <code>y</code> are identical. It can be used to test whether <code>y</code> is completely recovered in an inverse search.
</p>


<h3>Value</h3>

<p>Logical vector of the same length as <code>x</code>.</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2020. “Causal Modeling with Multi-Value and Fuzzy-Set Coincidence Analysis.” <em>Political Science Research and Methods</em>. 8:526–542.
</p>
<p>Baumgartner, Michael and Alrik Thiem. 2020. “Often Trusted But Never (Properly) Tested: Evaluating Qualitative Comparative Analysis”. <em>Sociological Methods &amp; Research</em> 49:279-311.
</p>


<h3>See Also</h3>

<p><code>randomConds</code>, <code>selectCases</code>, <code>cna</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Binary expressions
# ------------------
trueModel.1 &lt;- "(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)"
candidates.1 &lt;- c("(A + B &lt;-&gt; C)*(C + c*D &lt;-&gt; E)", "A + B &lt;-&gt; C", 
                 "(A &lt;-&gt;  C)*(C &lt;-&gt; E)", "C &lt;-&gt; E")
candidates.2 &lt;- c("(A*B + a*b &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", "A*b*D + a*B &lt;-&gt; C", 
                 "(A*b + a*B &lt;-&gt; C)*(C*A*D &lt;-&gt; E)", "D &lt;-&gt; C", 
                 "(A*b + a*B + E &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)")

is.submodel(candidates.1, trueModel.1)
is.submodel(candidates.2, trueModel.1)
is.submodel(c(candidates.1, candidates.2), trueModel.1)

is.submodel("C + b*A &lt;-&gt; D", "A*b + C &lt;-&gt; D")
is.submodel("C + b*A &lt;-&gt; D", "A*b + C &lt;-&gt; D", strict = TRUE)
identical.model("C + b*A &lt;-&gt; D", "A*b + C &lt;-&gt; D")

target.1 &lt;- "(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)"
testformula.1 &lt;- "(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)*(A + B &lt;-&gt; C)"
is.submodel(testformula.1, target.1)

# Multi-value expressions
# -----------------------
trueModel.2 &lt;- "(A=1*B=2 + B=3*A=2 &lt;-&gt; C=3)*(C=1 + D=3 &lt;-&gt; E=2)"
is.submodel("(A=1*B=2 + B=3 &lt;-&gt; C=3)*(D=3 &lt;-&gt; E=2)", trueModel.2)
is.submodel("(A=1*B=1 + B=3 &lt;-&gt; C=3)*(D=3 &lt;-&gt; E=2)", trueModel.2)
is.submodel(trueModel.2, trueModel.2)
is.submodel(trueModel.2, trueModel.2, strict = TRUE)

target.2 &lt;- "C=2*D=1*B=3 + A=1 &lt;-&gt; E=5"
testformula.2 &lt;- c("C=2 + D=1 &lt;-&gt; E=5","C=2 + D=1*B=3 &lt;-&gt; E=5","A=1+B=3*D=1*C=2 &lt;-&gt; E=5",
                "C=2 + D=1*B=3 + A=1 &lt;-&gt; E=5","C=2*B=3 + D=1 + B=3 + A=1 &lt;-&gt; E=5")
is.submodel(testformula.2, target.2)
identical.model(testformula.2[3], target.2)
identical.model(testformula.2[1], target.2)
</code></pre>


</div>