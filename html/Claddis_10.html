<div class="container">

<table style="width: 100%;"><tr>
<td>calculate_g</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate the maximum tree length, g, under parsimony</h2>

<h3>Description</h3>

<p>Given a costmatrix and set of tip states returns the longest possible tree length under maximum parsimony.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calculate_g(
  costmatrix,
  tip_states,
  polymorphism_behaviour = "polymorphism",
  uncertainty_behaviour = "uncertainty"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>costmatrix</code></td>
<td>
<p>An object of class <code>costMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tip_states</code></td>
<td>
<p>A character vector of tip states, with polymorphic states separated by <code>&amp;</code>, uncertainties by <code>/</code>, missing values as <code>NA</code>, and inapplicables as empty strings <code>""</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polymorphism_behaviour</code></td>
<td>
<p>One of either "missing", "uncertainty", "polymorphism", or "random". See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncertainty_behaviour</code></td>
<td>
<p>One of either "missing", "uncertainty", "polymorphism", or "random". See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The maximum cost a character could have on any tree under maximum parsimony, termed <em>g</em>, depends on both the individual state-to-state transition costs (captured by a costmatrix) and the sampled states (i.e., the <code>tip_states</code> input). In practice this is the maximum parsimony length on the star tree. This length cannot be exceeded by any other tree (Hoyal Cuthill and Lloyd, in review). Note: this is standard practice in phylogenetics software and is also how both PAUP* (Swofford 2003) and TNT (Goloboff et al. 2008; Goloboff and Catalano 2016) calculate maximum cost.
</p>
<p><b>Special cases</b>
</p>
<p>A number of special cases apply to calculating <em>g</em> and are discussed further below.
</p>
<p><em>Polymorphisms</em>
</p>
<p>Polymorphisms remain a complex problem in phylogenetics and here multiple options are provided to deal with them. These include: 1. <code>"missing"</code> - where they are simply replaced by a missing value (see below), 2. <code>"uncertainty"</code> - where they are treated as uncertainties instead (see below), 3. <code>"polymorphism"</code> - where they are treated as genuinely polymorphic, and 4. <code>"random"</code> - where one of the tip states is selected at random.
</p>
<p>Options 1, 2, and 4 can be seen as undercounting the true amount of evolution that has occurred. However, how to <em>correctly</em> count this amount is unclear. If option 3 is chosen then polymorphic states must be present in <code>costmatrix</code> and users should refer to the add_polymorphisms_to_costmatrix function for details on available options.
</p>
<p><em>Uncertainties</em>
</p>
<p>Uncertainties are much simpler to deal with than polymorphisms and a means to incorporate them into length counts was laid out in Swofford and Maddison (1992). Indeed, popular software such as PAUP* (Swofford 2003) and TNT (Goloboff et al. 2008; Goloboff and Catalano 2016) simply treat polymorphisms as uncertainties perhaps because of this. There is still a concern of undercounting evolutionary change for uncertainties in the maximum parsimony context as the cheapest possible state will in effect be used everytime, whereas future study that removes uncertainty may reveal s higher cost state to be the true value. As such the same options are offered for uncertainties as polymorphisms, including to treat them as polymorphisms although this should probably only be done where they were miscoded in the first place.
</p>
<p>Again, if using uncertainties as uncertainties, these must be included in the costmatrix and this can be done by using the add_uncertainties_to_costmatrix function.
</p>
<p><em>Missing values</em>
</p>
<p>In practice missing values (<code>NA</code>) may exist amongst <code>tip_states</code>. These are permitted, and in practice are mathematically and practically equivalent to a statement that a tip could be any state present in the costmatrix (i.e., a special case of an uncertainty where no state can be ruled out). However, it should be considered in interpretation that <em>g</em> will typically become smaller as the number of missing values increases.
</p>
<p><em>Inapplicable values</em>
</p>
<p>Inapplicable values (<code>""</code>) may also exist amongst <code>tip_states</code>. These are conceptually different to missing values as there is no possibility that they can ever be (re)coded. Currently these are treated exactly the same as missing values, but again the user should apply caution in interpreting <em>g</em> in such cases as again it will be smaller than otherwise identical characters with fewer inapplicable values.
</p>


<h3>Value</h3>

<p>A single value indicating the maximum length, <em>g</em>. Note: this is not modified by <code>costmatrix$weight</code>.
</p>


<h3>Author(s)</h3>

<p>Graeme T. Lloyd <a href="mailto:graemetlloyd@gmail.com">graemetlloyd@gmail.com</a> and Jen Hoyal Cuthill <a href="mailto:j.hoyal-cuthill@essex.ac.uk">j.hoyal-cuthill@essex.ac.uk</a>
</p>


<h3>References</h3>

<p>Goloboff, P. A. and Catalano, S. A., 2016. TNT version 1.5, including a full implementation of phylogenetic morphometrics/ <em>Cladistics</em>, <b>32</b>. 221-238
</p>
<p>Goloboff, P., Farris, J. and Nixon, K., 2008. TNT, a free program for phylogenetic analysis. <em>Cladistics</em>, <b>24</b>, 774-786.
</p>
<p>Hoyal Cuthill, J. F. and Lloyd, G. T., in press. Measuring homoplasy I: comprehensive measures of maximum and minimum cost under parsimony across discrete cost matrix character types. <em>Cladistics</em>, bold, .
</p>
<p>Swofford, D. L., 2003. <em>PAUP*. Phylogenetic Analysis Using Parsimony (*and Other Methods). Version 4</em>. Sinauer Associates, Sunderland, Massachusetts.
</p>
<p>Swofford, D. L. and Maddison, W. P., 1992. Parsimony, character-state reconstructions, and evolutionary inferences. In R. L. Mayden (ed.), <em>Systematics, Historical Ecology, and North American Freshwater Fishes</em>. Stanford University Press, Stanford. pp187-223.
</p>


<h3>See Also</h3>

<p>calculate_gmax
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Create a Type I character costmatrix:
constant_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state = 0,
  character_type = "unordered"
)

# Calculate g for the case of five state 0s:
calculate_g(
  costmatrix = constant_costmatrix,
  tip_states = c("0", "0", "0", "0", "0")
)

# Create a Type II character costmatrix:
binary_symmetric_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state = 1,
  character_type = "unordered"
)

# Calculate g for the case of two state 0s and three state 1s:
calculate_g(
  costmatrix = binary_symmetric_costmatrix,
  tip_states = c("0", "0", "1", "1", "1")
)

# Create a Type III character costmatrix:
unordered_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 2,
  character_type = "unordered"
)

# Calculate g for the case of two state 0s and three state 1s and two state 2s:
calculate_g(
  costmatrix = unordered_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2")
)

# Create a Type IV character costmatrix:
linear_ordered_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 2,
  character_type = "ordered"
)

# Calculate g for the case of two state 0s and three state 1s and two state 2s:
calculate_g(
  costmatrix = linear_ordered_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2")
)

# Create a Type V character costmatrix:
nonlinear_ordered_costmatrix &lt;- convert_adjacency_matrix_to_costmatrix(
  adjacency_matrix = matrix(
    data = c(
      0, 1, 0, 0,
      1, 0, 1, 1,
      0, 1, 0, 0,
      0, 1, 0, 0
    ),
    nrow = 4,
    dimnames = list(0:3, 0:3)
  )
)

# Calculate g for the case of two state 0s, three state 1s, two state 2s and one state 3:
calculate_g(
  costmatrix = nonlinear_ordered_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2", "3")
)

# Create a Type VI character costmatrix:
binary_irreversible_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 1,
  character_type = "irreversible"
)

# Calculate g for the case of two state 0s and three state 1s:
calculate_g(
  costmatrix = binary_irreversible_costmatrix,
  tip_states = c("0", "0", "1", "1", "1")
)

# Create a Type VII character costmatrix:
multistate_irreversible_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 2,
  character_type = "irreversible"
)

# Calculate g for the case of two state 0s and three state 1s and two state 2s:
calculate_g(
  costmatrix = multistate_irreversible_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2")
)

# Create a Type VIII character costmatrix:
binary_dollo_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 1,
  character_type = "dollo"
)

# Calculate g for the case of two state 0s and three state 1s:
calculate_g(
  costmatrix = binary_dollo_costmatrix,
  tip_states = c("0", "0", "1", "1", "1")
)

# Create a Type IX character costmatrix:
multistate_dollo_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 2,
  character_type = "dollo"
)

# Calculate g for the case of two state 0s and three state 1s and two state 2s:
calculate_g(
  costmatrix = multistate_dollo_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2")
)

# Create a Type X character costmatrix:
multistate_symmetric_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 5,
  character_type = "ordered"
)
multistate_symmetric_costmatrix$type &lt;- "custom"
multistate_symmetric_costmatrix$costmatrix &lt;- matrix(
  data = c(
    0, 1, 2, 3, 2, 3,
    1, 0, 3, 2, 1, 2,
    2, 3, 0, 3, 2, 1,
    3, 2, 3, 0, 1, 2,
    2, 1, 2, 1, 0, 1,
    3, 2, 1, 2, 1, 0
  ),
  nrow = multistate_symmetric_costmatrix$size,
  ncol = multistate_symmetric_costmatrix$size,
  byrow = TRUE,
  dimnames = list(
    multistate_symmetric_costmatrix$single_states,
    multistate_symmetric_costmatrix$single_states
  )
)

# Calculate g for the case of two state 0s, three state 1s, two state 2s,
# one state 3, three state 4s and two state 5s:
calculate_g(
  costmatrix = multistate_symmetric_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2", "3", "4", "4", "4", "5", "5")
)

# Create a Type XI character costmatrix:
binary_asymmetric_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 1,
  character_type = "ordered"
)
binary_asymmetric_costmatrix$type &lt;- "custom"
binary_asymmetric_costmatrix$costmatrix &lt;- matrix(
  data = c(
    0, 1,
    10, 0
  ),
  nrow = binary_asymmetric_costmatrix$size,
  ncol = binary_asymmetric_costmatrix$size,
  byrow = TRUE,
  dimnames = list(
    binary_asymmetric_costmatrix$single_states,
    binary_asymmetric_costmatrix$single_states
  )
)
binary_asymmetric_costmatrix$symmetry &lt;- "Asymmetric"

# Calculate g for the case of two state 0s and three state 1s:
calculate_g(
  costmatrix = binary_asymmetric_costmatrix,
  tip_states = c("0", "0", "1", "1", "1")
)

# Create a Type XII character costmatrix:
multistate_asymmetric_costmatrix &lt;- make_costmatrix(
  min_state = 0,
  max_state= 2,
  character_type = "ordered"
)
multistate_asymmetric_costmatrix$type &lt;- "custom"
multistate_asymmetric_costmatrix$costmatrix &lt;- matrix(
  data = c(
    0, 1, 1,
    1, 0, 1,
    10, 10, 0
  ),
  nrow = multistate_asymmetric_costmatrix$size,
  ncol = multistate_asymmetric_costmatrix$size,
  byrow = TRUE,
  dimnames = list(
    multistate_asymmetric_costmatrix$single_states,
    multistate_asymmetric_costmatrix$single_states
  )
)
multistate_asymmetric_costmatrix$symmetry &lt;- "Asymmetric"

# Calculate g for the case of two state 0s and three state 1s and two state 2s:
calculate_g(
  costmatrix = multistate_asymmetric_costmatrix,
  tip_states = c("0", "0", "1", "1", "1", "2", "2")
)

</code></pre>


</div>