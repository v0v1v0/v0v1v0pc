<div class="container">

<table style="width: 100%;"><tr>
<td>calc_riskRatio_gev</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute risk ratio and uncertainty based on generalized extreme value model fit to block maxima or minima</h2>

<h3>Description</h3>

<p>Compute risk ratio and uncertainty by fitting generalized extreme value model, designed specifically for climate data, to exceedance-only data, using the point process approach. The risk ratio is the ratio of the probability of exceedance of a pre-specified value under the model fit to the first dataset to the probability under the model fit to the second dataset. Default standard errors are based on the usual MLE asymptotics using a delta-method-based approximation, but standard errors based on the nonparametric bootstrap and on a likelihood ratio procedure can also be computed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calc_riskRatio_gev(
  returnValue,
  y1,
  y2,
  x1 = NULL,
  x2 = NULL,
  locationFun1 = NULL,
  locationFun2 = NULL,
  scaleFun1 = NULL,
  scaleFun2 = NULL,
  shapeFun1 = NULL,
  shapeFun2 = NULL,
  nReplicates1 = 1,
  nReplicates2 = 1,
  replicateIndex1 = NULL,
  replicateIndex2 = NULL,
  weights1 = NULL,
  weights2 = NULL,
  xNew1 = NULL,
  xNew2 = NULL,
  maxes = TRUE,
  scaling1 = 1,
  scaling2 = 1,
  ciLevel = 0.9,
  ciType,
  bootSE,
  bootControl = NULL,
  lrtControl = NULL,
  optimArgs = NULL,
  optimControl = NULL,
  initial1 = NULL,
  initial2 = NULL,
  logScale1 = NULL,
  logScale2 = NULL,
  getReturnCalcs = FALSE,
  getParams = FALSE,
  getFit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>returnValue</code></td>
<td>
<p>numeric value giving the value for which the risk ratio should be calculated, where the resulting period will be the average number of blocks until the value is exceeded and the probability the probability of exceeding the value in any single block.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y1</code></td>
<td>
<p>a numeric vector of observed maxima or minima values for the first dataset. See <code>Details</code> for how the values of <code>y1</code> should be ordered if there are multiple replicates and the values of <code>x1</code> are identical for all replicates. For better optimization performance, it is recommended that <code>y1</code> have magnitude around one (see <code>Details</code>), for which one can use <code>scaling1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y2</code></td>
<td>
<p>a numeric vector of observed maxima or minima values for the second dataset. Analogous to <code>y1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>a data frame, or object that can be converted to a data frame with columns corresponding to covariate/predictor/feature variables and each row containing the values of the variable for the corresponding observed maximum/minimum. The number of rows should either equal the length of <code>y1</code> or (if there is more than one replicate) it can optionally equal the number of observations in a single replicate, in which case the values will be assumed to be the same for all replicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>analogous to <code>x1</code> but for the second dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locationFun1</code></td>
<td>
<p>formula, vector of character strings, or indices describing a linear model (i.e., regression function) for the location parameter using columns from <code>x1</code> for the first dataset. <code>x1</code> must be supplied if this is anything other than NULL or ~1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locationFun2</code></td>
<td>
<p>formula, vector of character strings, or indices describing a linear model (i.e., regression function) for the location parameter using columns from <code>x2</code> for the second dataset. <code>x2</code> must be supplied if this is anything other than NULL or ~1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleFun1</code></td>
<td>
<p>formula, vector of character strings, or indices describing a linear model (i.e., regression function) for the (potentially transformed) scale parameter using columns from <code>x1</code> for the first dataset.  <code>x1</code> must be supplied if this is anything other than NULL or ~1. <code>logScale1</code> controls whether this determines the log of the scale or the scale directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleFun2</code></td>
<td>
<p>formula, vector of character strings, or indices describing a linear model (i.e., regression function) for the  (potentially transformed) scale parameter using columns from <code>x2</code> for the second dataset.  <code>x2</code> must be supplied if this is anything other than NULL or ~1. <code>logScale2</code> controls whether this determines the log of the scale or the scale directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shapeFun1</code></td>
<td>
<p>formula, vector of character strings, or indices describing a linear model (i.e., regression function) for the shape parameter using columns from <code>x1</code> for the first dataset.  <code>x1</code> must be supplied if this is anything other than NULL or ~1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shapeFun2</code></td>
<td>
<p>formula, vector of character strings, or indices describing a linear model (i.e., regression function) for the shape parameter using columns from <code>x2</code> for the first dataset.  <code>x2</code> must be supplied if this is anything other than NULL or ~1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nReplicates1</code></td>
<td>
<p>numeric value indicating the number of replicates for the first dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nReplicates2</code></td>
<td>
<p>numeric value indicating the number of replicates for the second dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replicateIndex1</code></td>
<td>
<p>numeric vector providing the index of the replicate corresponding to each element of <code>y1</code>. Used (and therefore required) only when using bootstrapping with the resampling by replicates based on the <code>by</code> element of <code>bootControl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replicateIndex2</code></td>
<td>
<p>numeric vector providing the index of the replicate corresponding to each element of <code>y2</code>. Analogous to <code>replicateIndex1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights1</code></td>
<td>
<p>a vector providing the weights for each observation in the first dataset. When there is only one replicate or the weights do not vary by replicate, a vector of length equal to the number of observations. When weights vary by replicate, this should be of equal length to <code>y</code>. Likelihood contribution of each observation is multiplied by the corresponding weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights2</code></td>
<td>
<p>a vector providing the weights for each observation in the second dataset. Analogous to <code>weights1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xNew1</code></td>
<td>
<p>object of the same form as <code>x1</code>, providing covariate/predictor/feature values for which one desires log risk ratios.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xNew2</code></td>
<td>
<p>object of the same form as <code>x2</code>, providing covariate/predictor/feature values for which log risk ratios are desired. Must provide the same number of covariate sets as <code>xNew1</code> as the risk ratio is based on contrasting return probabilities under <code>xNew1</code> and <code>xNew2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxes</code></td>
<td>
<p>logical indicating whether analysis is for block maxima (TRUE) or block minima (FALSE); in the latter case, the function works with the negative of the values, changing the sign of the resulting location parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling1</code></td>
<td>
<p>positive-valued scalar used to scale the data values of the first dataset for more robust optimization performance. When multiplied by the values, it should produce values with magnitude around 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling2</code></td>
<td>
<p>positive-valued scalar used to scale the data values of the second dataset for more robust optimization performance. When multiplied by the values, it should produce values with magnitude around 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ciLevel</code></td>
<td>
<p>statistical confidence level for confidence intervals; in repeated experimentation, this proportion of confidence intervals should contain the true risk ratio. Note that if only one endpoint of the resulting interval is used, for example the lower bound, then the effective confidence level increases by half of one minus <code>ciLevel</code>. For example, a two-sided 0.90 confidence interval corresponds to a one-sided 0.95 confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ciType</code></td>
<td>
<p>character vector indicating which type of confidence intervals to compute. See <code>Details</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootSE</code></td>
<td>
<p>logical indicating whether to use the bootstrap to estimate the standard error of the risk ratio</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootControl</code></td>
<td>
<p>a list of control parameters for the bootstrapping. See <code>Details</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lrtControl</code></td>
<td>
<p>list containing a single component, <code>bounds</code>, which sets the range inside which the algorithm searches for the endpoints of the likelihood ratio-based confidence interval. This avoids numerical issues with endpoints converging to zero and infinity. If an endpoint is not found within the interval, it is set to <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimArgs</code></td>
<td>
<p>a list with named components matching exactly any arguments that the user wishes to pass to <code>optim</code>. See <code>help(optim)</code> for details. Of particular note, <code>'method'</code> can be used to choose the optimization method used for maximizing the log-likelihood to fit the model and <code>'control=list(maxit=VALUE)'</code> for a user-chosen VALUE can be used to increase the number of iterations if the optimization is converging slowly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimControl</code></td>
<td>
<p>a list with named components matching exactly any elements that the user wishes to pass as the <code>control</code> list to R's <code>optim</code> function. See <code>help(optim)</code> for details. Primarily provided for the Python interface because <code>control</code> can also be passed as part of <code>optimArgs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial1</code></td>
<td>
<p>a list with components named <code>'location'</code>, <code>'scale'</code>, and <code>'shape'</code> providing initial parameter values for the first dataset, intended for use in speeding up or enabling optimization when the default initial values are resulting in failure of the optimization; note that use of <code>scaling1</code>, <code>logScale1</code> and <code>.normalizeX = TRUE</code> cause numerical changes in some of the parameters. For example with <code>logScale1 = TRUE</code>, initial value(s) for <code>'scale'</code> should be specified on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial2</code></td>
<td>
<p>a list with components named <code>'location'</code>, <code>'scale'</code>, and <code>'shape'</code> providing initial parameter values for the second dataset, intended for use in speeding up or enabling optimization when the default initial values are resulting in failure of the optimization; note that use of <code>scaling2</code>, <code>logScale2</code> and <code>.normalizeX = TRUE</code> cause numerical changes in some of the parameters. For example with <code>logScale2 = TRUE</code>, initial value(s) for <code>'scale'</code> should be specified on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logScale1</code></td>
<td>
<p>logical indicating whether optimization for the scale parameter should be done on the log scale for the first dataset. By default this is FALSE when the scale is not a function of covariates and TRUE when the scale is a function of covariates (to ensure the scale is positive regardless of the regression coefficients).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logScale2</code></td>
<td>
<p>logical indicating whether optimization for the scale parameter should be done on the log scale for the second dataset. By default this is FALSE when the scale is not a function of covariates and TRUE when the scale is a function of covariates (to ensure the scale is positive regardless of the regression coefficients).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getReturnCalcs</code></td>
<td>
<p>logical indicating whether to return the estimated return values/probabilities/periods from the fitted models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getParams</code></td>
<td>
<p>logical indicating whether to return the fitted parameter values and their standard errors for the fitted models; WARNING: parameter values for models with covariates for the scale parameter must interpreted based on the value of <code>logScale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getFit</code></td>
<td>
<p>logical indicating whether to return the full fitted models (potentially useful for model evaluation and for understanding optimization problems); note that estimated parameters in the fit object for nonstationary models will not generally match the MLE provided when <code>getParams</code> is <code>TRUE</code> because covariates are normalized before fitting and the fit object is based on the normalized covariates. Similarly, parameters will not match if <code>scaling</code> is not 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>fit_gev</code> for more details on fitting the block maxima model for each dataset, including details on blocking and replication. Also see <code>fit_gev</code> for information on the <code>bootControl</code> argument.
</p>
<p>Optimization failures:
</p>
<p>It is not uncommon for maximization of the log-likelihood to fail for extreme value models. Please see the help information for <code>fit_gev</code>. Also note that if the probability in the denominator of the risk ratio is near one, one may achieve better numerical performance by swapping the two datasets and computing the risk ratio for the probability under dataset 2 relative to the probability under dataset 1.
</p>
<p><code>ciType</code> can include one or more of the following: <code>'delta'</code>, <code>'lrt'</code>, <code>'boot_norm'</code>, <code>'boot_perc'</code>, <code>'boot_basic'</code>, <code>'boot_stud'</code>, <code>'boot_bca'</code>. <code>'delta'</code> uses the delta method to compute an asymptotic interval based on the standard error of the log risk ratio. <code>'lrt'</code> inverts a likelihood-ratio test. Bootstrap-based options are the normal-based interval using the bootstrap standard error (<code>'boot_norm'</code>), the percentile bootstrap (<code>'boot_perc'</code>), the basic bootstrap (<code>'boot_basic'</code>), the bootstrap-t (<code>'boot_stud'</code>), and the bootstrap BCA method (<code>'boot_bca'</code>). See Paciorek et al. for more details. 
</p>
<p>See <code>fit_pot</code> for information on the <code>bootControl</code> argument.
</p>


<h3>Value</h3>

<p>The primary outputs of this function are as follows: the log of the risk ratio and standard error of that log risk ratio (<code>logRiskRatio</code> and <code>se_logRiskRatio</code>) as well the risk ratio itself (<code>riskRatio</code>). The standard error is based on the usual MLE asymptotics using a delta-method-based approximation. If requested via <code>ciType</code>, confidence intervals will be returned, as discussed in <code>Details</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher J. Paciorek
</p>


<h3>References</h3>

<p>Paciorek, C.J., D.A. Stone, and M.F. Wehner. 2018. Quantifying uncertainty in the attribution of human influence on severe weather. Weather and Climate Extremes 20:69-80. arXiv preprint &lt;https://arxiv.org/abs/1706.03388&gt;.
</p>
<p>Jeon S., C.J. Paciorek, and M.F. Wehner. 2016. Quantile-based bias correction and uncertainty quantification of extreme event attribution statements. Weather and Climate Extremes 12: 24-32. &lt;DOI:10.1016/j.wace.2016.02.001&gt;. arXiv preprint: &lt;http://arxiv.org/abs/1602.04139&gt;.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Fort, package = 'extRemes')
FortMax &lt;- aggregate(Prec ~ year, data = Fort, max)
earlyYears &lt;- 1900:1929
lateYears &lt;- 1970:1999
earlyPeriod &lt;- which(FortMax$year %in% earlyYears)
latePeriod &lt;- which(FortMax$year %in% lateYears)
# contrast late period with early period, assuming a nonstationary fit
# within each time period and finding RR based on midpoint of each period
## Not run: 
out &lt;- calc_riskRatio_gev(returnValue = 3,
                   y1 = FortMax$Prec[earlyPeriod], y2 = FortMax$Prec[latePeriod],
                   x1 = data.frame(years = earlyYears), x2 = data.frame(years = lateYears),
                   locationFun1 = ~years, locationFun2 = ~years,
                   xNew1 = data.frame(years = mean(earlyYears)),
                   xNew2 = data.frame(years = mean(lateYears)))

## End(Not run)
</code></pre>


</div>