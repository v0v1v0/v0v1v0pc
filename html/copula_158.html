<div class="container">

<table style="width: 100%;"><tr>
<td>emde</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Minimum Distance Estimators for (Nested) Archimedean Copulas</h2>

<h3>Description</h3>

<p>Compute minimum distance estimators for (nested) Archimedean copulas.
</p>


<h3>Usage</h3>

<pre><code class="language-R">emde(u, cop,
     method=c("mde.chisq.CvM", "mde.chisq.KS",
              "mde.gamma.CvM", "mde.gamma.KS"),
     interval=initOpt(cop@copula@name),
     include.K = FALSE, repara = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula, where <code class="reqn">n</code> denotes the
sample size and <code class="reqn">d</code> the dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p><code>outer_nacopula</code> to be estimated
(currently only Archimedean copulas are provided).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a <code>character</code> string specifying the distance
method, which has to be one (or a unique abbreviation) of
</p>

<dl>
<dt><code>"mde.chisq.CvM"</code></dt>
<dd>
<p>map to an Erlang distribution and
using a chi-square distribution and Cramér-von Mises distance;</p>
</dd>
<dt><code>"mde.chisq.KS"</code></dt>
<dd>
<p>map to an Erlang distribution and
using a chi-square distribution and Kolmogorov-Smirnov distance;</p>
</dd>
<dt><code>"mde.gamma.CvM"</code></dt>
<dd>
<p>map to an Erlang distribution and
using a Erlang distribution and Cramér-von Mises distance;</p>
</dd>
<dt><code>"mde.gamma.KS"</code></dt>
<dd>
<p>map to an Erlang distribution and using
a Kolmogorov-Smirnov distance.</p>
</dd>
</dl>
<p>The four methods are described in Hofert et al. (2013); see also the
‘Details’ section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in
Hofert et al. (2013).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.K</code></td>
<td>
<p>logical indicating whether the last component, the
(possibly numerically challenging) Kendall distribution function
<code class="reqn">K</code>, is used (<code>include.K=TRUE</code>) or not.  Note that the default is
<code>FALSE</code> here, where it is <code>TRUE</code> in the underlying
<code>htrafo()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repara</code></td>
<td>
<p>logical indicating whether the distance function to be
optimized is reparametrized (the default); see the code for more
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>optimize()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>First, <code>htrafo</code> is applied to map the
<code class="reqn">n\times d</code>-matrix of given realizations to a
<code class="reqn">n\times d</code>-matrix or <code class="reqn">n\times (d-1)</code>-matrix, depending on whether the last
component is included (<code>include.K=TRUE</code>) or not.  Second, using
either the sum of squares of the standard normal quantile function
(<code>method="mde.chisq.CvM"</code> and
<code>method="mde.chisq.KS"</code>) or the sum of negative logarithms
(<code>method="mde.gamma.CvM"</code> and <code>method="mde.gamma.KS"</code>), a map to a
chi-square or an Erlang distribution is applied, respectively.  Finally, a
Cramér-von Mises (<code>method="mde.chisq.CvM"</code> and
<code>method="mde.gamma.CvM"</code>) or Kolmogorov-Smirnov
(<code>method="mde.chisq.KS"</code> and <code>method="mde.gamma.KS"</code>) distance is
applied.  This is repeated in an optimization until the copula parameter is
found such that this distance is minimized.
</p>
<p>Note that the same transformations as described above are applied for
goodness-of-fit testing; see the ‘See Also’ section).
</p>


<h3>Value</h3>

<p><code>list</code> as returned by <code>optimize</code>, including the
minimum distance estimator.
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25–63.
</p>
<p>Hering, C. and Hofert, M. (2014),
Goodness-of-fit tests for Archimedean copulas in high dimensions,
<em>Innovations in Quantitative Risk Management</em>.
</p>


<h3>See Also</h3>

<p><code>enacopula</code> (wrapper for different estimators),
<code>gofCopula</code> (wrapper for different goodness-of-fit tests),
<code>htrafo</code> (transformation to a multivariate uniform
distribution), and
<code>K</code> (Kendall distribution function).
</p>


<h3>Examples</h3>

<pre><code class="language-R">tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n, cop)

(meths &lt;- eval(formals(emde)$method)) # "mde.chisq.CvM", ...
fun &lt;- function(meth, u, cop, theta){
	run.time &lt;- system.time(val &lt;- emde(u, cop=cop, method=meth)$minimum)
	list(value=val, error=val-theta, utime.ms=1000*run.time[[1]])
}
(res &lt;- sapply(meths, fun, u=U, cop=cop, theta=theta))
</code></pre>


</div>