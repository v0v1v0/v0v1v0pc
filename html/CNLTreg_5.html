<div class="container">

<table style="width: 100%;"><tr>
<td>denoisepermCh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Denoises a signal using the complex-valued lifting transform and multivariate soft thresholding and heteroscedastic variance computation
</h2>

<h3>Description</h3>

<p>Denoises an input signal contaminated by noise. First the signal is decomposed using the complex-valued lifting
scheme (see <code>fwtnppermC</code>) using an order of point removal. A sliding window approach is then used
on these wavelet coefficients to estimate a local noise variance.
The resulting complex-valued wavelet
coefficients are then thresholded using a soft thresholding rule on the details' magnitude.
The transform is inverted and an estimate of the noisy signal is obtained.
</p>


<h3>Usage</h3>

<pre><code class="language-R">denoisepermCh(x, f, returnall = FALSE, verbose = FALSE, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of any length (not necessarily equally spaced) that gives the grid on which the signal is
observed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Vector of the same length as <code>x</code> that gives the signal values corresponding to the
<code>x</code>-locations. </p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Indicates whether useful messages should be printed to the console during the procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other arguments to be passed to <code>fwtnpperm</code> and <code>fwtnppermC</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>After the complex lifting transform is applied, the wavelet coeficients are divided into artificial levels.
The details from the lifting scheme have different variances, and will therefore be normalized
to have the same variance as the noise, by using the lifting matrix.  A sliding window is used to compute a local 'heteroscedastic' noise variance by taking the MAD of those normalized details falling into the window, see Nunes et al. (2006) for more details.  
Given the noise estimates for each observation,  the normalized details can then be thresholded and un-normalized.  The transform is then inverted to
give an estimate of the signal.
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>,
a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>fhat</code></td>
<td>
<p>Estimated signal after removing the noise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>This is the matrix associated to the modified lifting transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>al</code></td>
<td>
<p>List giving the split of points between the artificial levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>Estimated heteroscedastic standard deviation of the noise.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A, Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications. 
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br><br>
Nunes, M. A., Knight, M. I and Nason, G. P. (2006) Adaptive lifting for nonparametric regression.
<em>Stat. Comput.</em> <b>16</b> (2), 143–159.<br><br>
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1–16.
</p>


<h3>See Also</h3>

<p><code>denoisepermC</code>,
<code>fwtnppermC</code>,
<code>fwtnpperm</code>,
<code>heterovar</code>,
<code>mthreshC</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(MASS)	# where the motorcyle data lives

mcycleu&lt;-mcycle[which(duplicated(mcycle$times)=='FALSE'),]
time&lt;-mcycleu[,1]
accel&lt;-mcycleu[,2]

set.seed(200)
est1&lt;-denoisepermCh(time,accel)

</code></pre>


</div>