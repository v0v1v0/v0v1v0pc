<div class="container">

<table style="width: 100%;"><tr>
<td>VaR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Value-at-Risk (VaR)</h2>

<h3>Description</h3>

<p><code>VaR</code> computes the Value-at-Risk of the distribution specified by the
arguments. The meaning of the parameters is the same as in <code>ES</code>, including
the recycling rules.
</p>


<h3>Usage</h3>

<pre><code class="language-R">VaR(dist, p_loss = 0.05, ...)

VaR_qf(
  dist,
  p_loss = 0.05,
  ...,
  intercept = 0,
  slope = 1,
  tol = .Machine$double.eps^0.5,
  x
)

VaR_cdf(
  dist,
  p_loss = 0.05,
  ...,
  intercept = 0,
  slope = 1,
  tol = .Machine$double.eps^0.5,
  x
)

## Default S3 method:
VaR(
  dist,
  p_loss = 0.05,
  dist.type = "qf",
  ...,
  intercept = 0,
  slope = 1,
  tol = .Machine$double.eps^0.5,
  x
)

## S3 method for class 'numeric'
VaR(dist, p_loss = 0.05, ..., intercept = 0, slope = 1, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>specifies the distribution whose ES is computed, usually a function or a name
of a function computing quantiles, cdf, pdf, or a random number generator, see
Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_loss</code></td>
<td>
<p>level, default is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed on to <code>dist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept, slope</code></td>
<td>
<p>compute VaR for the linear transformation <code>intercept +
slope*X</code>, where <code>X</code> has distribution specified by <code>dist</code>, see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tollerance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>deprecated and will soon be removed. <code>x</code> was renamed to <code>p_loss</code>,
please use the latter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.type</code></td>
<td>
<p>a character string specifying what is computed by <code>dist</code>, such as
"qf" or "cdf".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>VaR</code> is S3 generic. The meaning of the parameters for its default method is the
same as in <code>ES</code>, including the recycling rules.
</p>
<p><code>VaR_qf</code> and <code>VaR_cdf</code> are streamlined, non-generic, variants for the common
case when the <code>"..."</code> parameters are scalar. The parameters <code>x</code>,
<code>intercept</code>, and <code>slope</code> can be vectors, as for <code>VaR</code>.
</p>
<p>Argument <code>dist</code> can also be a numeric vector. In that case the ES is computed,
effectively, for the empirical cumulative distribution function (ecdf) of the
vector. The ecdf is not created explicitly and the <code>quantile</code>
function is used instead for the computation of VaR. Arguments in <code>"..."</code> are
passed eventually to <code>quantile()</code> and can be used, for example, to select a
non-defult method for the computation of quantiles.
</p>
<p>In practice, we may need to compute VaR associated with data. The distribution comes
from fitting a model. In the simplest case, we fit a distribution to the data,
assuming that the sample is i.i.d. For example, a normal distribution <code class="reqn">N(\mu,
    \sigma^2)</code> can be fitted using the sample mean and sample variance as estimates of the
unknown parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code>, see section ‘Examples’. For
other common distributions there are specialised functions to fit their parameters and
if not, general optimisation routines can be used. More soffisticated models may be
used, even time series models such as GARCH and mixture autoregressive models.
</p>


<h3>Note</h3>

<p>We use the traditional definition of VaR as the negated lower quantile. For example,
if <code class="reqn">X</code> are returns on an asset, VAR<code class="reqn">{}_\alpha</code> = <code class="reqn">-q_\alpha</code>,
where <code class="reqn">q_\alpha</code> is the lower <code class="reqn">\alpha</code> quantile of <code class="reqn">X</code>.
Equivalently, VAR<code class="reqn">{}_\alpha</code> is equal to the lower <code class="reqn">1-\alpha</code>
quantile of <code class="reqn">-X</code>.
</p>


<h3>See Also</h3>

<p><code>ES</code> for ES,
</p>
<p><code>predict</code> for examples with fitted models
</p>


<h3>Examples</h3>

<pre><code class="language-R">cvar::VaR(qnorm, c(0.01, 0.05), dist.type = "qf")

## the following examples use these values, obtained by fitting a normal distribution to
## some data:
muA &lt;- 0.006408553
sigma2A &lt;- 0.0004018977

## with quantile function, giving the parameters directly in the call:
res1 &lt;- cvar::VaR(qnorm, 0.05, mean = muA, sd = sqrt(sigma2A))
res2 &lt;- cvar::VaR(qnorm, 0.05, intercept = muA, slope = sqrt(sigma2A))
abs((res2 - res1)) # 0, intercept/slope equivalent to mean/sd

## with quantile function, which already knows the parameters:
my_qnorm &lt;- function(p) qnorm(p, mean = muA, sd = sqrt(sigma2A))
res1_alt &lt;- cvar::VaR(my_qnorm, 0.05)
abs((res1_alt - res1))

## with cdf the precision depends on solving an equation
res1a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf", mean = muA, sd = sqrt(sigma2A))
res2a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf", intercept = muA, slope = sqrt(sigma2A))
abs((res1a - res2)) # 3.287939e-09
abs((res2a - res2)) # 5.331195e-11, intercept/slope better numerically

## as above, but increase the precision, this is probably excessive
res1b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   mean = muA, sd = sqrt(sigma2A), tol = .Machine$double.eps^0.75)
res2b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   intercept = muA, slope = sqrt(sigma2A), tol = .Machine$double.eps^0.75)
abs((res1b - res2)) # 6.938894e-18 # both within machine precision
abs((res2b - res2)) # 1.040834e-16

## relative precision is also good
abs((res1b - res2)/res2) # 2.6119e-16 # both within machine precision
abs((res2b - res2)/res2) # 3.91785e-15


## an extended example with vector args, if "PerformanceAnalytics" is present
if (requireNamespace("PerformanceAnalytics", quietly = TRUE)) withAutoprint({
    data(edhec, package = "PerformanceAnalytics")
    mu &lt;- apply(edhec, 2, mean)
    sigma2 &lt;- apply(edhec, 2, var)
    musigma2 &lt;- cbind(mu, sigma2)

    ## compute in 2 ways with cvar::VaR
    vAz1 &lt;- cvar::VaR(qnorm, 0.05, mean = mu, sd = sqrt(sigma2))
    vAz2 &lt;- cvar::VaR(qnorm, 0.05, intercept = mu, slope = sqrt(sigma2))

    vAz1a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                       mean = mu, sd = sqrt(sigma2))
    vAz2a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                       intercept = mu, slope = sqrt(sigma2))

    vAz1b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   mean = mu, sd = sqrt(sigma2),
                   tol = .Machine$double.eps^0.75)
    vAz2b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   intercept = mu, slope = sqrt(sigma2),
                   tol = .Machine$double.eps^0.75)

    ## analogous calc. with PerformanceAnalytics::VaR
    vPA &lt;- apply(musigma2, 1, function(x)
        PerformanceAnalytics::VaR(p = .95, method = "gaussian", invert = FALSE,
                                  mu = x[1], sigma = x[2], weights = 1))
    ## the results are numerically the same
    max(abs((vPA - vAz1))) # 5.551115e-17
    max(abs((vPA - vAz2))) #   ""

    max(abs((vPA - vAz1a))) # 3.287941e-09
    max(abs((vPA - vAz2a))) #  1.465251e-10, intercept/slope better

    max(abs((vPA - vAz1b))) # 4.374869e-13
    max(abs((vPA - vAz2b))) # 3.330669e-16
})

</code></pre>


</div>