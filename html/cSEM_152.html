<div class="container">

<table style="width: 100%;"><tr>
<td>testHausman</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regression-based Hausman test</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>


<h3>Usage</h3>

<pre><code class="language-R">testHausman(
 .object               = NULL,
 .eval_plan            = c("sequential", "multicore", "multisession"),
 .handle_inadmissibles = c("drop", "ignore", "replace"),
 .R                    = 499,
 .resample_method      = c("bootstrap", "jackknife"),
 .seed                 = NULL
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.object</code></td>
<td>
<p>An R object of class cSEMResults resulting from a call to <code>csem()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.eval_plan</code></td>
<td>
<p>Character string. The evaluation plan to use. One of
"<em>sequential</em>", "<em>multicore</em>", or "<em>multisession</em>". In the two latter cases
all available cores will be used. Defaults to "<em>sequential</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of "<em>drop</em>", "<em>ignore</em>", or "<em>replace</em>". If "<em>drop</em>", all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For "<em>ignore</em>" all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For "<em>replace</em>" resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to "<em>drop</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
"<em>none</em>", "<em>bootstrap</em>" or "<em>jackknife</em>". Defaults to "<em>none</em>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculates the regression-based Hausman test to be used to compare
OLS to 2SLS estimates or 2SLS to 3SLS estimates. See e.g., Wooldridge (2010)
(pages 131 f.) for details.
</p>
<p>The function is somewhat experimental. Only use if you know what you are doing.
</p>


<h3>References</h3>

<p>Wooldridge JM (2010).
<em>Econometric Analysis of Cross Section and Panel Data</em>, 2 edition.
MIT Press.
</p>


<h3>See Also</h3>

<p><code>csem()</code>, cSEMResults
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example from Dijkstra &amp; Hensler (2015)
## Prepartion (values are from p. 15-16 of the paper)
Lambda &lt;- t(kronecker(diag(6), c(0.7, 0.7, 0.7)))
Phi &lt;- matrix(c(1.0000, 0.5000, 0.5000, 0.5000, 0.0500, 0.4000, 
                0.5000, 1.0000, 0.5000, 0.5000, 0.5071, 0.6286,
                0.5000, 0.5000, 1.0000, 0.5000, 0.2929, 0.7714,
                0.5000, 0.5000, 0.5000, 1.0000, 0.2571, 0.6286,
                0.0500, 0.5071, 0.2929, 0.2571, 1.0000, sqrt(0.5),
                0.4000, 0.6286, 0.7714, 0.6286, sqrt(0.5), 1.0000), 
              ncol = 6)

## Create population indicator covariance matrix
Sigma &lt;- t(Lambda) %*% Phi %*% Lambda
diag(Sigma) &lt;- 1
dimnames(Sigma) &lt;- list(paste0("x", rep(1:6, each = 3), 1:3),
                        paste0("x", rep(1:6, each = 3), 1:3))

## Generate data
dat &lt;- MASS::mvrnorm(n = 500, mu = rep(0, 18), Sigma = Sigma, empirical = TRUE)
# empirical = TRUE to show that 2SLS is in fact able to recover the true population
# parameters.

## Model to estimate
model &lt;- "
## Structural model (nonrecurisve)
eta5 ~ eta6 + eta1 + eta2
eta6 ~ eta5 + eta3 + eta4

## Measurement model
eta1 =~ x11 + x12 + x13
eta2 =~ x21 + x22 + x23
eta3 =~ x31 + x32 + x33
eta4 =~ x41 + x42 + x43

eta5 =~ x51 + x52 + x53
eta6 =~ x61 + x62 + x63
"

library(cSEM)

## Estimate
res_ols &lt;- csem(dat, .model = model, .approach_paths = "OLS")
sum_res_ols &lt;- summarize(res_ols) 

# Note: For the example the model-implied indicator correlation is irrelevant
#       the warnings can be ignored.

res_2sls &lt;- csem(dat, .model = model, .approach_paths = "2SLS",
                 .instruments = list("eta5" = c('eta1','eta2','eta3','eta4'), 
                                     "eta6" = c('eta1','eta2','eta3','eta4')))
sum_res_2sls &lt;- summarize(res_2sls)
# Note that exogenous constructs are supplied as instruments for themselves!

## Test for endogeneity
test_ha &lt;- testHausman(res_2sls, .R = 200)
test_ha
</code></pre>


</div>