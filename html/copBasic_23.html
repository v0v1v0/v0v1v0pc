<div class="container">

<table style="width: 100%;"><tr>
<td>COP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Copula</h2>

<h3>Description</h3>

<p>Compute the <em>copula</em> or <em>joint distribution function</em> through a copula as shown by Nelsen (2006, p. 18) is the joint probability
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Pr}[U \le u, V \le v] = \mathbf{C}(u,v)\mbox{.}</code>
</p>

<p>The copula is an expression of the joint probability that both <code class="reqn">U \le u</code> and <code class="reqn">V \le v</code>.
</p>
<p>A copula is a type of <em>dependence function</em> that permits straightforward characterization of dependence from independence.  Joe (2014, p. 8) comments that “copula families are usually given as cdfs [cumulative distribution functions.]” A <em>radially symmetric</em> or <em>permutation symmetric copula</em> is one such that <code class="reqn">\mathbf{C}(u,v) = \mathbf{C}(v,u)</code> otherwise the copula is <em>asymmetric</em>.
</p>
<p>The copula <em>inversions</em> <code class="reqn">t = \mathbf{C}(u{=}U, v)</code> or <code class="reqn">t = \mathbf{C}(u, v{=}V)</code> for a given <code class="reqn">t</code> and <code class="reqn">U</code> or <code class="reqn">V</code> are provided by <code>COPinv</code> and <code>COPinv2</code>, respectively. A copula exists in the domain of the unit square (<code class="reqn">\mathcal{I}^2 = [0, 1]\times [0,1]</code>) and is a <em>grounded</em> function meaning that
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}(u,0) = 0 = \mathbf{C}(0,v) \mbox{\ and\ thus\ } \mathbf{C}(0,0) = 0\mbox{, }</code>
</p>

<p>and other properties of a copula are that
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}(u,1) = u \mbox{\ and\ } \mathbf{C}(1,v) = v\mbox{\ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{C}(1,1) = 1\mbox{.}</code>
</p>

<p>Copulas can be combined with each other (<code>convexCOP</code>, <code>convex2COP</code>, <code>composite1COP</code>, <br><code>composite2COP</code>, <code>composite3COP</code>, and <code>glueCOP</code>) to form more complex and sophisticated dependence structures. Also copula multiplication—a special product of two copulas—yields another copula (see <code>prod2COP</code>).
</p>
<p>Perhaps the one of the more useful features of this function is that in practical applications it can be used to take a copula formula and reflect or rotated it in fashions to attain association structures that the native definition of the copula can not acquire. The terminal demonstration in the <b>Examples</b> demonstrates this for the <em>Raftery copula</em> (<code>RFcop</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">COP(u, v, cop=NULL, para=NULL,
          reflect=c("cop", "surv", "acute", "grave",
                      "1",    "2",     "3",     "4"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">u</code> in the <code class="reqn">X</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Nonexceedance probability <code class="reqn">v</code> in the <code class="reqn">Y</code> direction;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function with vectorization as in <code>asCOP</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structures, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reflect</code></td>
<td>
<p>The reflection of the copula form (see <b>Note</b>) and the default <code>"cop"</code> or <code>"1"</code> is the usual copula definition (also see <code>simCOPmicro</code>). The numbered values correspond, respectively, to the named values; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copula.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value(s) for the copula are returned.
</p>


<h3>Note</h3>

<p><em>REFLECTIONS OF VARIABLES (ROTATIONS OF THE COPULA)</em>—The copula of <code class="reqn">(1-U, 1-V)</code> is the survival copula (<code class="reqn">\hat{\mathbf{C}}(u,v)</code>; <code>surCOP</code>) and is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Pr}[\,U &gt; u, V &gt; v\,] = \hat{\mathbf{C}}(u,v) = u + v - 1 + \mathbf{C}(1-u,1-v)\:\rightarrow\mbox{\ \code{"surv"},}</code>
</p>

<p>whereas, following the notation of Joe (2014, p. 271), the copula of <code class="reqn">(1-U, V)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Pr}[\,U &gt; u, V \le v\,] = \acute{\mathbf{C}}(u,v) = v - \mathbf{C}(1-u,v)\:\rightarrow\mbox{\ \code{"acute"}, and}</code>
</p>

<p>the copula of <code class="reqn">(U, 1-V)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Pr}[\,U \le u, V &gt; v\,] = \grave{\mathbf{C}}(u,v) = u - \mathbf{C}(u,1-v)\:\rightarrow\mbox{\ \code{"grave"}.}</code>
</p>

<p>Here it is useful to stress the probability aspects that change with the reflections, but this section ends with the reflections themselves being graphically highlighted. The <b>Examples</b> stress simple variations on the probability aspects.
</p>
<p>To clarify the seemingly clunky nomenclature—Joe (2014) does not provide “names” for <code class="reqn">\acute{\mathbf{C}}(u,v)</code> or <code class="reqn">\grave{\mathbf{C}}(u,v)</code>—the following guidance is informative:<br><code class="reqn">\mbox{}\quad\mbox{}</code>(1) <code>"surv"</code> or <code class="reqn">\hat{\mathbf{C}}(u,v)</code> is a reflection of <code class="reqn">U</code> and <code class="reqn">V</code> on the horizontal <em>and</em> vertical axes, respectively,<br><code class="reqn">\mbox{}\quad\mbox{}</code>(2) <code>"acute"</code> or <code class="reqn">\acute{\mathbf{C}}(u,v)</code> is a reflection of <code class="reqn">U</code> on the horizontal axis, and<br><code class="reqn">\mbox{}\quad\mbox{}</code>(3) <code>"grave"</code> or <code class="reqn">\grave{\mathbf{C}}(u,v)</code> is a reflection of <code class="reqn">V</code> on the verical axis.<br>
The names <code>"acute"</code> and <code>"grave"</code> match those used in the <b>Rd</b>-format math typesetting instructions. Users are directed to the documentation of <code>simCOPmicro</code> for further discussion because the <code>COP</code> function is expected to be an early entry point for new users interested in the <span class="pkg">copBasic</span> API.
</p>
<p>For the <span class="pkg">copBasic</span> package and in order to keep some logic brief and code accessible for teaching and applied circumstances, reflections of copulas using analogs to the <code>reflect</code> argument are only natively supported in the <code>COP</code> and <code>simCOPmicro</code> functions. The interfaces of <span class="pkg">copBasic</span> should already be flexible enough for users to adapt and (or) specially name reflections of copulas for deployment. A caveat is that some individual copula implementations might have some self-supporting infrastructure. The reflection can also be set within the <code>para</code> argument when it is a list (see <b>Examples</b>).
</p>
<p>An example is warranted. Although the Gumbel–Hougaard copula (<code>GHcop</code>) can be reflected by <code>COP</code> and <code>simCOPmicro</code> and testing is made in the <b>Note</b> section of <code>simCOPmicro</code>, it is suggested that a user generally requiring say a horizontal reflection <code>ru</code> (or vertical reflection <code>rv</code>) of the Gumbel–Hougaard copula write a function named perhaps <code>ruGHcop</code> (or <code>rvGHcop</code>).
</p>
<p>Such functions, consistent with the mathematics at the beginning of this <b>Note</b>, can be used throughout functions of <span class="pkg">copBasic</span> using the <code>cop</code> arguments. The author (Asquith) eschews implementing what is perceived as too much flexibility and overhead for the package to support the three reflection permutations universally across all copula functions of the package. This being said, <code>COP</code> can take an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> for the <code>para</code> argument for rotation/reflection:
</p>
<pre>
  set.seed(14)
  UV3 &lt;- simCOP(20, cop=COP, pch=16, col=3,
                para=list(cop=GLcop, para=pi+1, reflect="3"))
  set.seed(14)
  UV2 &lt;- simCOP(20, cop=COP, pch=16, col=4, ploton=FALSE,
                para=list(cop=GLcop, para=pi+1, reflect="2"))
  arrows(x0=UV3[,1], y0=UV3[,2], x=UV2[,1], y=UV2[,2])
</pre>
<p>and this type of interface is similar to <code>composite1COP</code> as the following rotation and then asymmetric construction shows:
</p>
<pre>
  UV &lt;- simCOP(1000, cop=composite1COP,
                     para=list(cop1=COP,
                               para1=c(cop=GHcop, para=pi+1, reflect="4"),
                               alpha=0.1, beta=0.3))
</pre>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>coCOP</code>, <code>duCOP</code>, <code>surCOP</code>, <code>surfuncCOP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">u &lt;- runif(1); v &lt;- runif(1)
COP(cop=W,u,v); COP(cop=P,u,v); COP(cop=M,u,v); COP(cop=PSP,u,v)

FF &lt;- 0.75 # 75th percentile, nonexceedance
GG &lt;- 0.20 # 25th percentile, nonexceedance
bF &lt;- 1 - FF; bG &lt;- 1 - GG     # exceedance
# What is the probability that both X and Y are less than
# 75th and 20th percentiles, respectively?
COP(cop=P, FF, GG)    # 0.15
# What is the probability that both X and Y are greater than
# 75th and 20th percentiles, respectively?
surCOP(cop=P, bF, bG) # 0.20
# What is the probability that either X or Y are less than
# the 75th and 20th percentiles, respectively?
duCOP(cop=P, FF, GG)  # 0.8
# What is the probability that either X or Y are greater than
# the 75th and 20th percentiles, respectively?
coCOP(cop=P, bF, bG)  # 0.85

# Repeat for the PSP copula:
# What is the probability that both X and Y are less than
# 75th and 20th percentiles, respectively?
COP(cop=PSP, FF, GG)    # 0.1875
# What is the probability that both X and Y are greater than
# 75th and 20th percentiles, respectively?
surCOP(cop=PSP, bF, bG) # 0.2375
# What is the probability that either X or Y are less than
# the 75th and 20th percentiles, respectively?
duCOP(cop=PSP, FF, GG)  # 0.7625
# What is the probability that either X or Y are greater than
# the 75th and 20th percentiles, respectively?
coCOP(cop=PSP, bF, bG)  # 0.8125
# Both of these summations equal unity
   COP(cop=PSP, FF, GG) + coCOP(cop=PSP, bF, bG) # 1
surCOP(cop=PSP, bF, bG) + duCOP(cop=PSP, FF, GG) # 1

FF &lt;- 0.99 # 99th percentile, nonexceedance
GG &lt;- 0.50 # 50th percentile, nonexceedance
bF &lt;- 1 - FF # nonexceedance
bG &lt;- 1 - GG # nonexceedance
# What is the probability that both X and Y are less than
# 99th and 50th percentiles, respectively?
COP(cop=P, FF, GG)    # 0.495
# What is the probability that both X and Y are greater than
# 99th and 50th percentiles, respectively?
surCOP(cop=P, bF, bG) # 0.005
# What is the probability that either X or Y are less than
# the 99th and 50th percentiles, respectively?
duCOP(cop=P, FF, GG)  # 0.995
# What is the probability that either X or Y are greater than
# the 99th and 50th percentiles, respectively?
coCOP(cop=P, bF, bG)  # 0.505

## Not run: 
# MAJOR EXAMPLE FOR QUICKLY MODIFYING INHERENT ASSOCIATION STRUCTURES
p &lt;- 0.5 # Reasonable strong positive association for the Raftery copula
"RFcop1" &lt;- function(u,v, para) COP(u,v, cop=RFcop, para=para, reflect="1")
"RFcop2" &lt;- function(u,v, para) COP(u,v, cop=RFcop, para=para, reflect="2")
"RFcop3" &lt;- function(u,v, para) COP(u,v, cop=RFcop, para=para, reflect="3")
"RFcop4" &lt;- function(u,v, para) COP(u,v, cop=RFcop, para=para, reflect="4")

d &lt;- 0.01 # Just to speed up the density plots a bit
densityCOPplot(RFcop1, para=p, contour.col=1, deluv=d) # the Raftery in the literature
densityCOPplot(RFcop2, para=p, contour.col=1, deluv=d, ploton=FALSE)
densityCOPplot(RFcop3, para=p, contour.col=1, deluv=d, ploton=FALSE)
densityCOPplot(RFcop4, para=p, contour.col=1, deluv=d, ploton=FALSE)
# Now some text into the converging tail to show the reflection used.
text(-2,-2, "reflect=1", col=2); text(+2,+2, "reflect=2", col=2)
text(+2,-2, "reflect=3", col=2); text(-2,+2, "reflect=4", col=2)

# To show how the reflection can be alternatively specified and avoid in this case
# making four Raftery functions, pass by a list para argument. Also, demonstrate
# that cop1 --&gt; cop and para1 --&gt; para are the same in use of the function. This
# provides some nomenclature parallel to the other compositing functions.
densityCOPplot(COP, para=list(reflect=1, cop1=RFcop, para=p ), deluv=d,
                          contour.col=1, drawlabels=FALSE)
densityCOPplot(COP, para=list(reflect=2, cop= RFcop, para1=p), deluv=d,
                          contour.col=2, drawlabels=FALSE, ploton=FALSE)
densityCOPplot(COP, para=list(reflect=3, cop1=RFcop, para1=p), deluv=d,
                          contour.col=3, drawlabels=FALSE, ploton=FALSE)
densityCOPplot(COP, para=list(reflect=4, cop= RFcop, para=p ), deluv=d,
                          contour.col=4, drawlabels=FALSE, ploton=FALSE) #
## End(Not run)

## Not run: 
# Similar example to previous, but COP() can handle the reflection within a
# parameter list ,and the reflect, being numeric here, is converted to
# character internally.
T12 &lt;- CLcop(tau=0.67)$para # Kendall Tau of 0.67
T12 &lt;- list(cop=CLcop, para=T12, reflect=2) # reflected to upper tail dependency
UV  &lt;- simCOP(n=1000, cop=COP, para=T12) # 
## End(Not run)
</code></pre>


</div>