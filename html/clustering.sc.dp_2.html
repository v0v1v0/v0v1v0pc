<div class="container">

<table style="width: 100%;"><tr>
<td>clustering.sc.dp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optimal Clustering Multidimensional Data with Sequential Constraint by Dynamic Programming
</h2>

<h3>Description</h3>

<p>Perform optimal clustering on multidimensional data with sequential constraint (i.e. only subsequent elements of the input may form a cluster).
</p>


<h3>Usage</h3>

<pre><code class="language-R">clustering.sc.dp(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a multi-dimensional array containing input data to be clustered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the number of clusters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The '<code>clustering.sc.dp</code>' algorithm (Szkaliczki, 2016) groups multidimensional data given by <code>x</code> into <code>k</code> clusters with sequential constraint by dynamic programming. It generalises the one-dimensional '<code>Ckmeans.1d.dp</code>' algorithm (Wang and Song, 2011) to multidimensional data. If only subsequent elements of the input data may form a cluster the algorithm guarantees the optimality of clustering â€“ the sum of squares of within-cluster distances (<var>withinss</var>) from each element to its corresponding cluster centre (mean) is always the minimum. The sequential constraint is typically required in clustering datastreams or items with time stamps such as video frames, GPS signals of vehicles or movement data of persons etc. The run time of the algorithm is <var>O</var>( <var>k</var> <var>d</var> <var>n</var>^2) where <var>k</var>, <var>d</var> and <var>n</var> gives the number of clusters, the dimensions of the elements and the number of elements, respectively. 
</p>


<h3>Value</h3>

<p>An object of class '<code>clustering.sc.dp</code>' which has a print method and is a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>a vector of cluster indices assigned to each element in <code>x</code>. Each cluster is indexed by an integer from 1 to <code>k</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>a matrix whose rows represent cluster centres</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinss</code></td>
<td>
<p>the within-cluster sum of squares for each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>a vector of the number of points in each cluster</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Tibor Szkaliczki <a href="mailto:szkaliczki.tibor@sztaki.hu">szkaliczki.tibor@sztaki.hu</a>
</p>


<h3>References</h3>

<p>Szkaliczki, T. (2016) "clustering.sc.dp: Optimal Clustering with Sequential Constraint by Using Dynamic Programming" &lt;doi: 10.32614/RJ-2016-022&gt;
Wang, H. and Song, M. (2011) "Ckmeans.1d.dp: optimal <var>k</var>-means clustering in one dimension by dynamic programming" &lt;doi: 10.32614/RJ-2011-015&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example: clustering data generated from a random walk
x&lt;-matrix(, nrow = 100, ncol = 2)
x[1,]&lt;-c(0,0)
for(i in 2:100) {
  x[i,1]&lt;-x[i-1,1] + rnorm(1,0,0.1)
  x[i,2]&lt;-x[i-1,2] + rnorm(1,0,0.1)
}
k&lt;-2
result&lt;-clustering.sc.dp(x,k)
plot(x, type = 'b', col = result$cluster)
points(result$centers, pch = 24, bg = (1:k))
</code></pre>


</div>