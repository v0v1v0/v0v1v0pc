<div class="container">

<table style="width: 100%;"><tr>
<td>pclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prototype-Based Partitioning</h2>

<h3>Description</h3>

<p>Obtain prototype-based partitions of objects by minimizing the criterion
<code class="reqn">\sum w_b u_{bj}^m d(x_b, p_j)^e</code>, the sum of the case-weighted and
membership-weighted <code class="reqn">e</code>-th powers of the dissimilarities between
the objects <code class="reqn">x_b</code> and the prototypes <code class="reqn">p_j</code>, for suitable
dissimilarities <code class="reqn">d</code> and exponents <code class="reqn">e</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pclust(x, k, family, m = 1, weights = 1, control = list())
pclust_family(D, C, init = NULL, description = NULL, e = 1,
              .modify = NULL, .subset = NULL)
pclust_object(prototypes, membership, cluster, family, m = 1,
              value, ..., classes = NULL, attributes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the object to be partitioned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>an integer giving the number of classes to be used in the
partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>an object of class <code>"pclust_family"</code> as generated
by <code>pclust_family</code>, containing the information about <code class="reqn">d</code>
and <code class="reqn">e</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a number not less than 1 controlling the softness of the
partition (as the “fuzzification parameter” of the fuzzy
<code class="reqn">c</code>-means algorithm).  The default value of 1 corresponds to
hard partitions obtained from a generalized <code class="reqn">k</code>-means problem;
values greater than one give partitions of increasing softness
obtained from a generalized fuzzy <code class="reqn">c</code>-means problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a numeric vector of non-negative case weights.
Recycled to the number of elements given by <code>x</code> if necessary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>a function for computing dissimilarities <code class="reqn">d</code> between
objects and prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>a ‘consensus’ function with formals <code>x</code>,
<code>weights</code> and <code>control</code> for computing a consensus
prototype <code class="reqn">p</code> minimizing <code class="reqn">\sum_b w_b d(x_b, p) ^ e</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>a function with formals <code>x</code> and <code>k</code> initializing
an object with <code class="reqn">k</code> prototypes from the object <code>x</code> to be
partitioned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>a character string describing the family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>a number giving the exponent <code class="reqn">e</code> of the criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.modify</code></td>
<td>
<p>a function with formals <code>x</code>, <code>i</code> and
<code>value</code> for modifying a single prototype,
or <code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.subset</code></td>
<td>
<p>a function with formals <code>x</code> and <code>i</code> for
subsetting prototypes,
or <code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prototypes</code></td>
<td>
<p>an object representing the prototypes of the
partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>an object of class <code>"cl_membership"</code>
with the membership values <code class="reqn">u_{bj}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>the class ids of the nearest hard partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>the value of the criterion to be minimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further elements to be included in the generated pclust
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>a character vector giving further classes to be given
to the generated pclust object in addition to <code>"pclust"</code>, or
<code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attributes</code></td>
<td>
<p>a list of attributes, or <code>NULL</code> (default).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code class="reqn">m = 1</code>, a generalization of the Lloyd-Forgy variant of the
<code class="reqn">k</code>-means algorithm is used, which iterates between reclassifying
objects to their closest prototypes (according to the dissimilarities
given by <code>D</code>), and computing new prototypes as the consensus for
the classes (using <code>C</code>).
</p>
<p>For <code class="reqn">m &gt; 1</code>, a generalization of the fuzzy <code class="reqn">c</code>-means recipe
(e.g., Bezdek (1981)) is used, which alternates between computing
optimal memberships for fixed prototypes, and computing new prototypes
as the suitably weighted consensus clusterings for the classes.
</p>
<p>This procedure is repeated until convergence occurs, or the maximal
number of iterations is reached.
</p>
<p>Currently, no local improvement heuristics are provided.
</p>
<p>It is possible to perform several runs of the procedure via control
arguments <code>nruns</code> or <code>start</code> (the default is to perform a
single run), in which case the first partition with the smallest
value of the criterion is returned.
</p>
<p>The dissimilarity and consensus functions as well as the exponent
<code class="reqn">e</code> are specified via <code>family</code>.  In principle, arbitrary
representations of objects to be partitioned and prototypes (which do
not necessarily have to be “of the same kind”) can be employed.
In addition to <code>D</code> and <code>C</code>, what is needed are means to
obtain an initial collection of <code class="reqn">k</code> prototypes (<code>init</code>), to
modify a single prototype (<code>.modify</code>), and subset the prototypes
(<code>.subset</code>).  By default, list and (currently, only dense) matrix
(with the usual convention that the rows correspond to the objects)
are supported.  Otherwise, the family has to provide the functions
needed. 
</p>
<p>Available control parameters are as follows.
</p>

<dl>
<dt><code>maxiter</code></dt>
<dd>
<p>an integer giving the maximal number of
iterations to be performed.
Defaults to 100.</p>
</dd>
<dt><code>nruns</code></dt>
<dd>
<p>an integer giving the number of runs to be
performed.
Defaults to 1.</p>
</dd> 
<dt><code>reltol</code></dt>
<dd>
<p>the relative convergence tolerance.
Defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
<dt><code>start</code></dt>
<dd>
<p>a list of prototype objects to be used as
starting values.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>a logical indicating whether to provide
some output on minimization progress.
Defaults to <code>getOption("verbose")</code>.</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>control parameters to be used in the consensus
function.</p>
</dd>
</dl>
<p>The fixed point approach employed is a heuristic which cannot be
guaranteed to find the global minimum, in particular if <code>C</code> is
not an exact minimizer.  Standard practice would recommend to use the
best solution found in “sufficiently many” replications of the
base algorithm.
</p>


<h3>Value</h3>

<p><code>pclust</code> returns the partition found as an object of class
<code>"pclust"</code> (as obtained by calling <code>pclust_object</code>) which in
addition to the <em>default</em> components contains <code>call</code> (the 
matched call) and a <code>converged</code> attribute indicating convergence
status (i.e., whether the maximal number of iterations was reached).
</p>
<p><code>pclust_family</code> returns an object of class
<code>"pclust_family"</code>, which is a list with components corresponding
to the formals of <code>pclust_family</code>.
</p>
<p><code>pclust_object</code> returns an object inheriting from class
<code>"pclust"</code>, which is a list with components corresponding
to the formals (up to and including <code>...</code>) of
<code>pclust_object</code>, and additional classes and attributes specified
by <code>classes</code> and <code>attributes</code>, respectively.
</p>


<h3>References</h3>

<p>J. C. Bezdek (1981).
<em>Pattern recognition with fuzzy objective function algorithms</em>.
New York: Plenum.
</p>


<h3>See Also</h3>

<p><code>kmeans</code>,
<code>cmeans</code>.
</p>


</div>