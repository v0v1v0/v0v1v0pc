<div class="container">

<table style="width: 100%;"><tr>
<td>eval_report_pairs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluation Report for Linked Pairs</h2>

<h3>Description</h3>

<p>Compute various evaluation measures for a set of <em>predicted</em>
coreferent (linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval_report_pairs(true_pairs, pred_pairs, num_pairs = NULL, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_pairs</code></td>
<td>
<p>the total number of coreferent and non-coreferent pairs,
excluding equivalent pairs with reversed ids. If not provided,
measures that depend on the number of true negatives will be returned
as <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>whether to treat the element pairs as orderedâ€”i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list containing the following measures:
</p>

<dl>
<dt>precision</dt>
<dd>
<p>see <code>precision_pairs</code></p>
</dd>
<dt>recall</dt>
<dd>
<p>see <code>recall_pairs</code></p>
</dd>
<dt>specificity</dt>
<dd>
<p>see <code>specificity_pairs</code></p>
</dd>
<dt>sensitivity</dt>
<dd>
<p>see <code>sensitivity_pairs</code></p>
</dd>
<dt>f1score</dt>
<dd>
<p>see <code>f_measure_pairs</code></p>
</dd>
<dt>accuracy</dt>
<dd>
<p>see <code>accuracy_pairs</code></p>
</dd>
<dt>balanced_accuracy</dt>
<dd>
<p>see <code>balanced_accuracy_pairs</code></p>
</dd>
<dt>fowlkes_mallows</dt>
<dd>
<p>see <code>fowlkes_mallows_pairs</code></p>
</dd>
</dl>
<h3>See Also</h3>

<p>The <code>contingency_table_pairs</code> function can be used to compute
the contingency table for entity resolution or record linkage problems.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example where pairs/edges are undirected
# ground truth is 3-clique
true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3))
# prediction misses one edge
pred_pairs &lt;- rbind(c(1,2), c(2,3))
# total number of pairs assuming 3 elements
num_pairs &lt;- 3 * (3 - 1) / 2
eval_report_pairs(true_pairs, pred_pairs, num_pairs)

### Example where pairs/edges are directed
# ground truth is a 3-star
true_pairs &lt;- rbind(c(2,1), c(3,1), c(4,1))
# prediction gets direction of one edge incorrect
pred_pairs &lt;- rbind(c(2,1), c(3,1), c(1,4))
# total number of pairs assuming 4 elements
num_pairs &lt;- 4 * 4
eval_report_pairs(true_pairs, pred_pairs, num_pairs, ordered = TRUE)

</code></pre>


</div>