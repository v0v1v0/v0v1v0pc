<div class="container">

<table style="width: 100%;"><tr>
<td>S.RAB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a spatial generalised linear model with anisotropic basis functions to data
for computationally efficient localised spatial smoothing, where the parameters 
are estimated by penalised maximum likelihood estimation with a ridge regression 
penalty.
</h2>

<h3>Description</h3>

<p>Fit a spatial generalised linear model to areal unit data, where the response
variable can be binomial, Gaussian or Poisson. The linear predictor is modelled 
by known covariates and a set of K anisotropic spatial basis functions. The basis
functions are constructed from the set of geodesic distances between all pairs of 
areal units and a vector of ancillary data V, and the latter should have a similar
spatial pattern to the residual (after covariate adjustment) spatial structure in 
the data on the linear predictor scale. Parameter estimtion is carried out via 
penalised maximum likelihood methods, and the basis function coefficients are
constrained by a ridge regression penalty to prevent overfitting. The glmnet 
package is used for parameter estimation. Missing (NA) values are allowed in the 
response, and predictions are made for these values. This model implements localised
spatial smoothing and allows for boundaries in the data surface using a 
computationally efficient approach. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">S.RAB(formula, family, data=NULL, trials=NULL, W, V, nlambda=100, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate is a vector of length K*1. The response can 
contain missing (NA) values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>One of either "binomial", "gaussian", or "poisson", which respectively 
specify a binomial likelihood model with a logistic link function, 
a Gaussian likelihood model with an identity link function, or a Poisson likelihood 
model with a log link function. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each area. Only used if family="binomial". 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>A non-negative K by K neighbourhood matrix (where K is the number of 
spatial units). Typically a binary specification is used, where the jkth 
element equals one if areas (j, k) are spatially close (e.g. share a common 
border) and is zero otherwise. The matrix can be non-binary, but each row must 
contain at least one non-zero entry.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>

<p>A vector of ancillary data of length K, which should have a similar spatial 
pattern to the residual (after covariate adjustment) spatial structure in 
the data on the linear predictor scale.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>

<p>The number of possible values to use for the penalty parameter lambda in the glmnet()
estimation function. Defaults to 100.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>beta.hat </code></td>
<td>
<p>The estimated regression parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2.hat </code></td>
<td>
<p>The estimated error variance in the Gaussian data likelihood 
model. If a Gaussian model is not specified it is NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.hat </code></td>
<td>
<p>The estimated ridge regression penalty parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I </code></td>
<td>
<p>The level of residual spatial autocorrelation as measured by
Moran's I statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values </code></td>
<td>
<p>The fitted values from the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals </code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are "response" (raw), 
and "pearson".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula </code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.string </code></td>
<td>
<p>A text string describing the model fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X </code></td>
<td>
<p>The design matrix of covariates and spatial basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model </code></td>
<td>
<p>The fitted model object from the glmnet() function.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Lee, D (2024). Computationally efficient localised spatial smoothing of disease 
rates using anisotropic basis functions and penalised regression fitting, 
Spatial Statistics, 59, 100796.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 	
	
#### Generate the spatial covariance structure
dists &lt;- as.numeric(distance[upper.tri(distance)])
dists.quant &lt;- quantile(dists, 0.05)
rho &lt;- log(0.75) / -dists.quant
Sigma &lt;- exp(-rho * distance)

#### Generate the boundaries
groups &lt;-rep(0, K) 
groups[Grid$Var2&gt;5] &lt;- 1

#### Generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
phi &lt;- mvrnorm(n=1, mu=rep(0,K), Sigma=0.1 * exp(-rho * distance))
logit &lt;- x1 +  x2 + phi + 0.4 * groups
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(100,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)

#### Generate the ancillary data
V &lt;- rnorm(n=K, mean=phi + 0.4*groups , sd=rep(0.05,K))

#### Run the RAB model
mod &lt;- S.RAB(formula=Y~x1+x2, family="binomial", data=NULL, trials=trials, W=W, 
        V=V, nlambda=50, verbose=TRUE)
</code></pre>


</div>