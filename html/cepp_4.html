<div class="container">

<table style="width: 100%;"><tr>
<td>caller</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to optimize the projection index</h2>

<h3>Description</h3>

<p>This function provides an alternative way to optimize the projection
index, by moving along a geodesic path.</p>


<h3>Usage</h3>

<pre><code class="language-R">caller(start, index, n, bases)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>The Starting Projection for the optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>The Projection Index function. Typically generated by a
call to the <code>pp</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of new bases to try at every stage of the
optimization. Needs to be an array of the same length as
<code>bases</code>. Typically, you either pass a constant vector, or you
use a vector with ascending entries, so that you can try more matrices
as the optimization proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bases</code></td>
<td>
<p>The number of new bases desired. Actual number generated
may be lesser if optimization stalls.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function provides an alternative way to optimize the projection
index. It moves the index along geodesic paths between randomly
generated nearby matrices, in hopes of uncovering peaks of the index
function. By experience, one can say that it can often reveal structure
missed by Simulated Annealing optimization.
</p>


<h3>Value</h3>

<p>A list of basis matrices, of length <code>bases</code> or shorter (if
the optimization stalls).</p>


<h3>Author(s)</h3>

<p>Mohit Dayal
</p>


<h3>See Also</h3>

<p>Colon</p>


</div>