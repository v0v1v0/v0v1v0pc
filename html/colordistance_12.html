<div class="container">

<table style="width: 100%;"><tr>
<td>getImageHist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a 3D histogram based on color distribution in an image</h2>

<h3>Description</h3>

<p>Computes a histogram in either RGB or HSV colorspace by sorting pixels into a
specified number of bins.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getImageHist(
  image,
  bins = 3,
  bin.avg = TRUE,
  defaultClusters = NULL,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  as.vec = FALSE,
  alpha.channel = TRUE,
  norm.pix = FALSE,
  plotting = TRUE,
  hsv = FALSE,
  title = "path",
  bounds = c(0, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>image</code></td>
<td>
<p>Path to a valid image (PNG or JPG) or a <code>loadImage</code>
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. Bins=3 will result in 3^3 = 27 bins; bins=c(2, 2, 3) will
result in 2*2*3=12 bins (2 red, 2 green, 3 blue), etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin.avg</code></td>
<td>
<p>Logical. Should the returned color clusters be the average of
the pixels in that bin (bin.avg=<code>TRUE</code>) or the center of the bin
(<code>FALSE</code>)? If a bin is empty, the center of the bin is returned as the
cluster color regardless.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defaultClusters</code></td>
<td>
<p>Optional dataframe of default color clusters to be
returned when a bin is empty. If <code>NULL</code>, the geometric centers of the
bins are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li>
<p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li>
<p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li>
<p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li>
<p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li>
</ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.vec</code></td>
<td>
<p>Logical. Should the bin sizes just be returned as a vector?
Much faster if only using <code>chisqDistance</code> for comparison metric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code>removeBackground</code> for more
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.pix</code></td>
<td>
<p>Logical. Should RGB or HSV cluster values be normalized using
<code>normalizeRGB</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotting</code></td>
<td>
<p>Logical. Should a histogram of the bin colors and sizes be
plotted?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hsv</code></td>
<td>
<p>Logical. Should HSV be used instead of RGB?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>String for what to title the plots if plotting is on; defaults
to the image name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Upper and lower limits for the channels; R reads in images with
intensities on a 0-1 scale, but 0-255 is common.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments passed to the <code>barplot</code> function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If you choose 2 bins for each color channel, then each of R, G, and
B will be divided into 2 bins each, for a total of 2^3 = 8 bins.
</p>
<p>Once all pixels have been binned, the function will return either the size of
each bin, either in number of pixels or fraction of total pixels, and the
color of each bin, either as the geometric center of the bin or as the
average color of all pixels assigned to it.
</p>
<p>For example, if you input an image of a red square and used 8 bins, all red
pixels (RGB triplet of [1, 0, 0]) would be assigned to the bin with R bounds
(0.5, 1], G bounds [0, 0.5) and B bounds [0, 0.5). The average color of the
bin would be [0.75, 0.25, 0.25], but the average color of the pixels assigned
to that bin would be [1, 0, 0]. The latter option is obviously more
informative, but takes longer (about 1.5-2x longer depending on the images).
</p>


<h3>Value</h3>

<p>A vector or dataframe (depending on whether <code>as.vec=T</code>) of bin
sizes and color values.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate HSV histogram for a single image
colordistance::getImageHist(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3), bins=c(8, 3, 3), hsv=TRUE, plotting=TRUE)

# generate RGB histogram
colordistance::getImageHist(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3), bins=2)
</code></pre>


</div>