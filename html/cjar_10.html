<div class="container">

<table style="width: 100%;"><tr>
<td>cja_freeform_table</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get a freeform table</h2>

<h3>Description</h3>

<p>Get a report analogous to a <strong>Freeform Table</strong> visualization in CJA Workspace. The function uses
the arguments to construct and execute a JSON-based query to the CJA API and then returns
the results as a data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cja_freeform_table(
  dataviewId = Sys.getenv("CJA_DATAVIEW_ID"),
  date_range = c(Sys.Date() - 30, Sys.Date() - 1),
  dimensions = c("page", "lasttouchchannel", "mobiledevicetype"),
  metrics = c("visits", "visitors"),
  top = c(5),
  page = 0,
  filterType = "breakdown",
  segmentId = NA,
  metricSort = "desc",
  include_unspecified = TRUE,
  search = NA,
  prettynames = FALSE,
  allowRemoteLoad = "default",
  useCache = TRUE,
  useResultsCache = FALSE,
  includeOberonXml = FALSE,
  includePlatformPredictiveObjects = FALSE,
  debug = FALSE,
  check_components = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dataviewId</code></td>
<td>
<p>CJA Data View ID (dv). If an environment variable called <code>CJA_DATAVIEW_ID</code> exists
in <code>.Renviron</code> or elsewhere and no <code>dataviewId</code> argument is provided, then the <code>CJA_DATAVIEW_ID</code> value will
be used. Use <code>cja_get_dataviews()</code> to get a list of available <code>dataviewId</code>. Required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>date_range</code></td>
<td>
<p>A length-2 vector with a start date and an end date.
<code>POSIXt</code> objects are sent as is, for fine control over the date range.
Numeric values are automatically converted to dates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimensions</code></td>
<td>
<p>A character vector of dimensions. There is currently a limit of 20 dimension
breakdowns. Each dimension value that gets broken down by another dimension requires an additional API
call, so the more dimensions that are included, the longer the function will take to return results.
This is how the CJA API works. Use <code>cja_get_dimensions()</code> to get a list of available
<code>dimensions</code> IDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>A character vector of metrics. Use <code>cja_get_metrics()</code> and <code>cja_get_calculatedmetrics()</code>
to get a list of available <code>metrics</code> IDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>top</code></td>
<td>
<p>The number of values to be pulled for each dimension. The default is 5 and the "top" is based on
the first <code>metric</code> value (along with <code>metricSort</code>). If there are multiple dimensions, then this argument can
either be a vector that includes the number of values to include at each level (each breakdown) or, if a single
value is used, then that will be the maximum number of values to return at each level. See the <strong>Details</strong> for
information on the unique handling of <code>daterange...</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>page</code></td>
<td>
<p>Used in combination with <code>top</code> to return the next page of results. Uses 0-based numbering (e.g.,
<code>top = 50000</code> and <code>page = 1</code> will return the top 50,000 items <em>starting at 50,001</em>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filterType</code></td>
<td>
<p>This is a placeholder argument for use as additional functionality is added to the package.
Currently, it defaults to <code>breakdown</code>, and that is the only supported value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segmentId</code></td>
<td>
<p>A single segment ID or a vector of multiple segment IDs to apply to the overall report.
If multiple <code>segmentId</code> values are included, the segments will be effectived ANDed together, just as if
multiple segments were added to the header of an Analysis Workspace panel. Use <code>cja_get_filters()</code>
to get a list of available <code>segmentId</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metricSort</code></td>
<td>
<p>Pre-sorts the table by metrics. Values are either <code>asc</code> (ascending) or <code>desc</code> (descending).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_unspecified</code></td>
<td>
<p>Whether or not to include <strong>Unspecified</strong> values in the results. This is the equivalent
of the <strong>Include Unspecified (None)</strong> checkbox in freeform tables in Analysis Workspace. This defaults to <code>TRUE</code>,
which includes <strong>Unspecified</strong> values in the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search</code></td>
<td>
<p>Criteria to filter the results by one or more dimensions. Searches are case-insenstive. Refer to
the <strong>Details</strong> for more information on constructing values for this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prettynames</code></td>
<td>
<p>A logical that determines whether the column names in the results use the API field name
(e.g., "mobiledevicetype", "pageviews") or the "pretty name" for the field (e.g., "Mobile Device Type",
"Page Views"). This applies to both dimensions and metrics. The default value is <code>FALSE</code>, which returns the
API field names. For custom eVars, props, and events, the non-pretty values are simply the variable number
(e.g., "evar2", "prop3", "event15"). If <code>TRUE</code>, undoes any efficiency gains
from setting <code>check_components</code> to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allowRemoteLoad</code></td>
<td>
<p>Controls if Oberon should remote load data. Default behavior is true with fallback to
false if remote data does not exist. The default is "default" but options include: "true", "false", or "default".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useCache</code></td>
<td>
<p>Use caching for faster requests (Use cached dimensions to speed up permission checks - This does
not do any report caching). TRUE (default) or FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useResultsCache</code></td>
<td>
<p>Use results caching for faster reporting times (This is a pass through to Oberon which manages
the Cache) FALSE (default) or TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeOberonXml</code></td>
<td>
<p>Controls if Oberon XML should be returned in the response - DEBUG ONLY. FALSE (default) or TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includePlatformPredictiveObjects</code></td>
<td>
<p>Controls if platform Predictive Objects should be returned in the response. Only available when using
Anomaly Detection or Forecasting- DEBUG ONLY. FALSE (default) or TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>Set to <code>TRUE</code> to publish the full JSON request(s) being sent to the API to the console when the
function is called. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_components</code></td>
<td>
<p>Logical, whether to check the validity of metrics and
dimensions before running the query. Defaults to <code>TRUE</code>, but causes
<code>cja_freeform_report</code> to request all dimensions and metrics from the API,
which may be inefficient if you're running many queries. If you have many
queries, it's more efficient to implement validity checking yourself on either
side of your queries.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is based on the <strong>Freeform Table</strong> visualization in Analysis Workspace. It is accessing
the same API call type that is used to generate those visualizations.
</p>


<h4>Dimension Ordering</h4>

<p>CJA only queries one dimension at a time, even though the results get returned in a single data
frame (or table in the case of Analysis Workspace). The more dimensions are included in the report–the more
breakdowns of the data–the more queries are required. As a result, the <em>order</em> of the dimensions <em>can</em>
have a dramatic impact on the total query time, even if the resulting data is essentially identical.
</p>
<p>One way to understand this is to consider how much dragging and dropping would be required to return the
data in Analysis Workspace <em>if you were not able to &lt;Shift&gt;-&lt;click&gt; to highlight multiple values before
dragging a new dimension to break down existing values</em>.
</p>
<p>Consider a scenario where you are pulling metrics for the last 30 days (<code>daterangeday</code>) for <strong>Mobile Device Type</strong>
(<code>mobiledevicetype</code>), which has 7 unique values. Setting <code>dimensions = c("daterangeday", "mobiledevicetype")</code>
would make one query to get the values of the 30 days included. The query would then run a separate query
for <em>each of those 30 days</em> to get the <code>mobiledevicetype</code> results for each day. So, this would be <strong>31 API calls</strong>.
</p>
<p>If, instead, the function was called with the <code>dimension</code> values reversed (<code>dimensions = c("mobiledevicetype", "daterangeday")</code>), then
the first query would return the 7 <code>mobiledevicetype</code> values, and then would run an additional query for each of
those <em>7 mobile device type values</em> to return the results for the 30 days within each device type. This would be only <strong>7 API calls</strong>.
</p>
<p>Strategically ordering dimensions–and then wrangling the resulting data set as needed–is one of the best
ways to improve query performance.
</p>



<h4>Date Handling</h4>

<p>Date handling has several special characteristics that are worth getting familiar with:
</p>

<ul>
<li>
<p> The API names for day, week, month, etc. are prepended with <code>daterange</code>, so daily data uses
<code>daterangeday</code>, weekly data uses <code>daterangeweek</code>, monthly data uses <code>daterangemonth</code>, etc.
</p>
</li>
<li>
<p> When setting the argument for <code>top</code>, if the first (or only) <code>dimension</code> value is a <code>daterange...</code> object,
then, if this argument is not explicitly specified <em>or</em> if it uses only a single value (e.g., <code>top = 10</code>),
the function will still return all of the values that fall in that date range. For instance, if the
<code>date_range</code> was set for a 30-day period and the first <code>dimension</code> value was <code>daterangeday</code>, <em>and</em> no value
is specified for <code>top</code>, rather than simply returning the first 5 dates in the range, all 30 days will be
returned. In the same scenario, if <code>top = 10</code> was set, then all 30 days would still be returned, and the
<code>10</code> would simply be applied to the additional dimensions.
</p>
</li>
<li>
<p> If you want to return all of the date/time values but then have specific control over the number of
values returned for each of the drilldown dimensions, then set <code>0</code> as the first value in the <code>top</code>
argument and then specify different numbers for each breakdown (e.g., <code>top = c(0, 3, 10)</code> would return
all of the date/time values for the specified <code>date_range</code>, the top 3 values for the second specified
<code>dimension</code>, and then the top 10 values for each of the next dimension's results).
</p>
</li>
<li>
<p> If you are using a <code>daterange...</code> value <em>not</em> as the first dimension, then simply using <code>0</code> at the
same level in the <code>top</code> argument specification will return all of the values for that date/time value.
</p>
</li>
</ul>
<h4>Search/Filtering</h4>

<p>There are powerful filtering abilities within the function. However, to support that power requires a
syntax that can feel a bit cumbersome for simple queries. <strong><em>Note:</em></strong> search filters are case-insensitive.
This is CJA API functionality and can not be specified otherwise in queries.
</p>
<p>The <code>search</code> argument takes a vector of search strings, with each value in the vector corresponding to
the <code>dimension</code> value that is at the same position. These search strings support a range of operators,
including <code>AND</code>, <code>OR</code>, <code>NOT</code>, <code>MATCH</code>, <code>CONTAINS</code>, <code>BEGINS-WITH</code>, and <code>ENDS-WITH</code>.
</p>
<p>The default for any search string is to use <code>CONTAINS</code>. Consider a query where
<code>dimensions = c("mobiledevicetype", "lasttouchchannel")</code>:
</p>

<ul>
<li> <p><code>search = "CONTAINS 'mobile'"</code> will return results where <code>mobiledevicetype</code> contains "mobile", so would return all rows for <strong>Mobile Phone</strong>.
</p>
</li>
<li>
<p> This could be shortened to <code>search = "'mobile'"</code> and would behave exactly the same, since <code>CONTAINS</code> is the default operator
</p>
</li>
<li> <p><code>search = c("CONTAINS 'mobile'", "CONTAINS 'search'")</code> will return results where <code>mobiledevicetype</code> contains "mobile" and, within those results, results where <code>lasttouchchannel</code> contains "search".
</p>
</li>
<li> <p><code>search = c("(CONTAINS 'mobile') OR (CONTAINS 'tablet')", "(MATCH 'paid search')")</code> will return results where <code>mobiledevicetype</code> contains "mobile" <em>or</em> "tablet" and, within those results, will only include results where <code>lasttouchchannel</code> exactly matches "paid search" (but is case-insensitive, so would return "Paid Search" values).
</p>
</li>
</ul>
<h3>Value</h3>

<p>A data frame with dimensions and metrics.
</p>


<h3>See Also</h3>

<p><code>cja_get_me()</code>, <code>cja_get_dataviews()</code>, <code>cja_get_filters()</code>,
<code>cja_get_dimensions()</code>, <code>cja_get_metrics()</code>
</p>
<p>Use <code>cja_get_me()</code> to get started.
</p>


</div>