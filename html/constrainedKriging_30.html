<div class="container">

<table style="width: 100%;"><tr>
<td>CKrige</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constrained, Covariance-matching Constrained and Universal Kriging</h2>

<h3>Description</h3>

<p>Function computes constrained, covariance-matching
constrained and universal (external drift) Kriging predictions for
points or blocks (of any shape) in a global neighbourhood and for
isotropic covariance models.</p>


<h3>Usage</h3>

<pre><code class="language-R">CKrige(formula, data, locations, object, ...)

## S4 method for signature 'formula,data.frame,formula,preCKrigePolygons'
CKrige(formula, 
  data, locations, object, method = 2, ex.out = FALSE, ncores = 1L, 
  fork = !identical(.Platform[["OS.type"]], "windows"))

## S4 method for signature 'formula,data.frame,formula,preCKrigePoints'
CKrige(formula, 
  data, locations, object, method = 2, ex.out = FALSE)
</code></pre>


<h3>Arguments</h3>

 <table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula for the linear regression model
of the spatial variable in the form <code>response ~ terms of
  covariates</code>, for ordinary Kriging use the formula<br><code>response ~
  1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame with the values of the covariates for the
observations.  The names of the covariates used in <code>formula</code>
must match the column names of <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locations</code></td>
<td>
<p>a one-sided <code>formula</code> that describes the
coordinates of the observations (e.g. <code>~ x+y</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>either an object of class
“<code>preCKrigePolygons</code>” for block Kriging or of class
“<code>preCKrigePoints</code>” for point Kriging as generated by the
<code>preCKrige</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to control the spatial
interpolation method and the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a numeric scalar to choose the Kriging approach:
<code>method = 1</code>: universal (external drift), <code>method = 2</code>:
constrained (default) and <code>method = 3</code>: covariance-matching
constrained Kriging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ex.out</code></td>
<td>
<p>a logical scalar.  If <code>ex.out</code> is set equal to
<code>TRUE</code> <code>CKrige</code> returns an extended output with additional
items, see <em>Value</em> for more information, by default
<code>ex.out = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer scalar with the number of CPUs to
use for parallel computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fork</code></td>
<td>
<p>a logical scalar to control whether parallel
computations are done by forking using <code>mclapply</code>
(non-windows OSes) or by socket clusters using
<code>parLapply</code> (windows OS).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>CKrige</code> function depends on a
<code>preCKrige</code> output object that contains the parameters of
the isotropic covariance model, the covariates of the prediction
targets and the variance-covariance matrices of the prediction
targets.</p>


<h3>Value</h3>

<p>If <code>ex.out = FALSE</code> then the function <code>CKrige</code>
returns an object of class “<code>SpatialPointsDataFrame</code>” or
“<code>SpatialPolygonsDataFrame</code>”.  The class of the argument
<code>object</code> of <code>CKrige</code><br> (“<code>preCKrigePoints</code>” or
“<code>preCKrigePolygons</code>”) determines whether a
<code>SpatialPointsDataFrame</code> or <code>SpatialPolygonsDataFrame</code>
is returned.
</p>
<p>Irrespective of the chosen Kriging method, the data frame in the
<code>data</code> slot of the returned object contains the columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>prediction</code></td>
<td>
<p>a numeric vector with the Kriging predictions by the
chosen method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction.se</code></td>
<td>
<p>a numeric vector with the root mean square
prediction errors (Kriging standard errors).</p>
</td>
</tr>
</table>
<p>For constrained Kriging (argument <code>method = 2</code>) the data frame
has 3 additional columns, see<br><code>constrainedKriging-package</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>P1</code></td>
<td>
<p>a numeric vector with
<code class="reqn">P_{1} = (\mathrm{Var}[Y(B_1)] -
  \mathrm{Var}[\mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}] )^{0.5}.
</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q1</code></td>
<td>
<p>a numeric vector with
<code class="reqn">Q_{1} = (\mathrm{Var}[\widehat{Y}_{\mathrm{UK}}(B_1)] - \mathrm{Var}[
  \mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}] )^{0.5}.
</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>a numeric vector with <code class="reqn">K = P_{1} / Q_{1}</code>.</p>
</td>
</tr>
</table>
<p>For covariance-matching constrained Kriging (argument <code>method =
3</code>) the data frame has also 3 additional columns, see
<code>constrainedKriging-package</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>P1.11</code></td>
<td>
<p>a numeric vector with first diagonal elements
(which correspond to the target blocks) of the matrices
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{P}_{1} = ( \mathrm{Cov}[\mathbf{Y}, \mathbf{Y}^{\prime}] -
    \mathrm{Cov}[\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}},
   (\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}})^{\prime}] )^{\frac{1}{2}}.
</code>
</p>

</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q1.11</code></td>
<td>
<p>a numeric vector with first diagonal elements of the matrices
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{Q}_{1} = (\mathrm{Cov}[\widehat{\mathbf{Y}}_{\mathrm{UK}},
  \widehat{\mathbf{Y}}_{\mathrm{UK}}^{\prime}] -
  \mathrm{Cov}[\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}},
  (\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}})^{\prime}])^{\frac{1}{2}}.
</code>
</p>

</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.11</code></td>
<td>
<p>a numeric vector with first diagonal elements of the matrices
of the matrices
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{K} = \mathbf{Q}_{1}^{-1}\mathbf{P_{1}}.
</code>
</p>

</td>
</tr>
</table>
<p>If the argument <code>ex.out = TRUE</code> is used and the argument
<code>method</code> is either equal to <code>1</code> (universal) or <code>2</code>
(constrained Kriging) then the function <code>CKrige</code> returns an
object either of class<br> “<code>CKrige.exout.polygons</code>” or
“<code>CKrige.exout.points</code>”, which are lists with the
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>either an object of class
“<code>SpatialPointsDataFrame</code>” or<br>
“<code>SpatialPolygonsDataFrame</code>” as described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>krig.method</code></td>
<td>
<p>a numeric scalar, number of the chosen Kriging
<code>method</code> (1, 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>a list with 2 components.  First component
<code>beta.coef</code> is the vector with the generalized least squares
estimates of the linear regression coefficients, and the second
component <code>cov.beta</code> contains the covariance matrix of the
generalized least squares estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sk.weights</code></td>
<td>
<p>a matrix with the simple Kriging weights.  The
<var>i</var>th column contains the simple Kriging weights for the <var>i</var>th
prediction target.




</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.Sigma</code></td>
<td>
<p>a matrix with the inverse covariance matrix
<code class="reqn">\boldsymbol{\Sigma}^{-1}</code> of the observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a numeric vector with the generalized least squares
residuals of the linear regression.</p>
</td>
</tr>
</table>
<p>If the argument <code>ex.out = TRUE</code> is used and the argument
<code>method</code> is either equal to <code>3</code> (covariance-matching
constrained kriging) then the function <code>CKrige</code> returns an object
either of class<br> “<code>CKrige.exout.polygons</code>” or
“<code>CKrige.exout.points</code>”, which are lists with the
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>either an object of class
“<code>SpatialPointsDataFrame</code>” or<br>
“<code>SpatialPolygonsDataFrame</code>” as described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>krig.method</code></td>
<td>
<p>a numeric scalar, number of the chosen Kriging
<code>method</code> (3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CMCK.par</code></td>
<td>
<p>a list of 3 lists with the following components:
</p>

<ul>
<li> <p><code>P1</code> a list of matrices <code class="reqn">\mathbf{P}_1</code> for all
point or polygon neighbourhood configurations (the first row and
columns correspond to the target points or blocks of the
configurations).
</p>
</li>
<li> <p><code>Q1</code> a list of matrices <code class="reqn">\mathbf{Q}_1</code> for all
point or polygon neighbourhood configurations  (the first row and
columns correspond to the target points or blocks of the
configurations).
</p>
</li>
<li> <p><code>K</code> a list of matrices <code class="reqn">\mathbf{K}</code> for all
polygon neighbourhood configurations  (the first row and
columns correspond to the target points or blocks of the
configurations).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>a list with 2 components.  First component
<code>beta.coef</code> is the vector with the generalized least squares
estimates of the linear regression coefficients, and the second
component <code>cov.beta</code> contains the covariance matrix of the
generalized least squares estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sk.weights</code></td>
<td>
<p>a list with the simple Kriging weights of all point
or polygon neighbourhood configurations (the first columns contain the
weights of the target points or blocks of the configurations).




</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.Sigma</code></td>
<td>
<p>a matrix with the inverse covariance matrix
<code class="reqn">\boldsymbol{\Sigma}^{-1}</code> of the observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a numeric vector with the generalized least squares
residuals of the linear regression.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p><code>print</code> and <code>summary</code> methods are available for  
<code>CKrige</code> output object of the classes
“<code>CKrige.exout.polygons</code>” and
“<code>CKrige.exout.points</code>”.</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>References</h3>

<p>Cressie, N. (2006) Block Kriging for Lognormal Spatial Processes.
<em>Mathematical Geology</em>, <b>38</b>, 413–443,
<a href="https://doi.org/10.1007/s11004-005-9022-8">doi:10.1007/s11004-005-9022-8</a>.
</p>
<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562–1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>.
</p>


<h3>See Also</h3>

 <p><code>preCKrige</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
### load meuse data
data(meuse, package = "sp")
data(meuse.grid, package = "sp")
data(meuse.blocks)

### convert data frame meuse.grid to SpatialPointsDataFrame
coordinates(meuse.grid) &lt;- ~ x+y

### plot blocks along with observation locations
plot(meuse.blocks)
points(y ~ x, meuse, cex = 0.5)


### example 1: lognormal constrained block Kriging
### cf. Hofer &amp; Papritz, 2011, pp. 1567

### compute the approximated block variance of each block in meuse.blocks
### without any neighbouring blocks (default, required for in universal
### and constrained Kriging) for an exponential covariance function without
### a measurement error, a nugget = 0.15 (micro scale white noise process),
### a partial sill variance = 0.15 and a scale parameter = 192.5
### approximation of block variance by pixels of size 75m x 75m
preCK_block &lt;- preCKrige(newdata = meuse.blocks, model = covmodel(modelname =
    "exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### block prediction by constrained Kriging on the log scale
### extended output required for backtransformation
CK_block &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_block, ex.out = TRUE)

### backtransformation of the CK predictions to original scale
### cf Hofer &amp; Papritz, 2011, eq. (14), p. 1567
### note that Var(\hat{Y}{B}) = Var(Y(B))!
beta &lt;- CK_block$parameter$beta.coef
M &lt;- meuse.blocks@data$M
var.blockmeans &lt;- unlist(preCK_block@covmat)
CK_block$object@data$Zn &lt;- exp(CK_block$object@data$prediction
  + 0.5*(0.2 + beta[2]^2 * M - var.blockmeans))

### upper limits U of the relative 95%  prediction intervals for CK
### U multiplied by the predictions CK_block$object@data$Zn gives
### the upper limits of the 95% prediction intervals
CK_block$object@data$U &lt;- exp(CK_block$object@data$prediction
    + 1.96 * CK_block$object@data$prediction.se) / CK_block$object@data$Zn

### plot the CK predictions of Zn and the upper limits of relative 95%
### prediction intervals by function spplot of sp package
### function ck.colors(n) creates a rainbow-like color vector
breaks &lt;- seq(0, 1850, by = 185)
spplot(CK_block$object, zcol = "Zn", at = breaks, col.regions = ck.colors(10),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CK predictions of Zn block means")

### plot of upper limits of the relative 95% prediction intervals
breaks &lt;- seq(1, 3.2, by = 0.2)
spplot(CK_block$object, zcol = "U", at = breaks, col.regions = ck.colors(11),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "Upper limits rel. prediction intervals CK predictions")



### example 2: lognormal covariance-matching constrained block Kriging

### define neighbours by using the poly2nb function of spdep package
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours_block &lt;- spdep::poly2nb(meuse.blocks)
class(neighbours_block)
### neighbours_block should be an object of class "list"
class(neighbours_block) &lt;- "list"

### compute the approximated block variance-covariance matrices of each
### polygon neighbourhood configuration (= target block plus its
### neighbours)
preCMCK_block &lt;- preCKrige(newdata = meuse.blocks, neighbours = neighbours_block,
  model = covmodel("exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### block prediction by covariance-matching constrained Kriging on log
### scale
CMCK_block &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCMCK_block, method = 3, ex.out = TRUE)

### backtransformation of the CK predictions to the original scale
### cf Hofer &amp; Papritz, 2011, eq. (14), p. 1567
beta &lt;- CMCK_block$parameter$beta.coef
M &lt;- meuse.blocks@data$M
var.blockmeans &lt;- sapply(preCMCK_block@covmat, function(x) x[1, 1])
CMCK_block$object@data$Zn &lt;- exp(CMCK_block$object@data$prediction
  + 0.5*(0.2 + beta[2]^2 * M - var.blockmeans))

### plot the CMCK predictions of Zn by function spplot of sp package
### function ck.colors(n) creates a rainbow-like color vector
breaks &lt;- seq(0, 1850, by = 185)
spplot(CMCK_block$object, zcol = "Zn", at = breaks, col.regions = ck.colors(10),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CMCK predictions of Zn block means")



### example 3: lognormal universal block Kriging
UK_block &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_block, method = 1, ex.out = TRUE)

### backtransformation of the CK predictions to the original scale
### cf Hofer &amp; Papritz, 2011, Appendix B, pp. 1568 - 1569
beta &lt;- UK_block$parameter$beta.coef
cov.beta &lt;- UK_block$parameter$cov.beta.coef
M &lt;- meuse.blocks@data$M
var.blockmeans &lt;- unlist(preCK_block@covmat)
SKw &lt;-  UK_block$sk.weights
X &lt;-  model.matrix(~sqrt(dist), meuse)
XB &lt;- model.matrix(~sqrt(dist), meuse.blocks)
c1 &lt;- 0.5 * (0.2 + beta[2]^2*M - var.blockmeans +
  UK_block$object@data$prediction.se^2)
c2 &lt;- rowSums((XB - t(SKw) %*% X) * (XB %*% cov.beta))
UK_block$object@data$Zn &lt;- exp(UK_block$object@data$prediction + c1 - c2)

### upper limits U of the relative 95%  prediction intervals for CK
### U multiplied by the predictions UK_block$object@data$Zn gives
### the upper limits of the 95% prediction intervals
UK_block$object@data$U &lt;- exp(UK_block$object@data$prediction
    + 1.96 * UK_block$object@data$prediction.se) / UK_block$object@data$Zn

### plot the UK predictions of Zn by function spplot of sp package
### function ck.colors(n) creates a rainbow-like color vector
breaks &lt;- seq(0, 1850, by = 185)
spplot(UK_block$object, zcol = "Zn", at = breaks, col.regions = ck.colors(10),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "UK predictions of Zn block means")

### plot of upper limits of the relative 95% prediction intervals
breaks &lt;- seq(1, 3.2, by = 0.2)
spplot(UK_block$object, zcol = "U", at = breaks, col.regions = ck.colors(11),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "Upper limits rel. prediction intervals UK predictions")



### example 4: constrained point Kriging
### generate point CK preCKrige object for locations in meuse.grid
preCK_point &lt;- preCKrige(newdata = meuse.grid, model = covmodel(modelname =
    "exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5))

### point prediction by constrained Kriging on the log scale
### no extended output required for backtransformation
CK_point &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_point)

### backtransformation of the CK predictions to the original scale
### cf. Cressie, 2006, eq. (20), p. 421
### note that Var(\hat{Y}{s_0}) = Var(Y(s_0))!
CK_point@data$Zn &lt;- exp(CK_point@data$prediction)

### convert results object to SpatialGridDataFrame
gridded(CK_point) &lt;- TRUE
fullgrid(CK_point) &lt;- TRUE

### plot the CK predictions of Zn by function spplot of sp package
breaks &lt;- seq(0, 2600, by = 185)
spplot(CK_point, zcol = "Zn", at = breaks, col.regions = ck.colors(20),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CK predictions of Zn point values")



### example 5: covariance-matching constrained point Kriging

### define 4 nearest neighbours to each grid location by using the
### knearneigh function of the spdep package
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours_point &lt;- spdep::knearneigh(meuse.grid, k = 4)
### convert matrix with neighbours indices to list
neighbours_point &lt;- apply(neighbours_point$nn, 1, FUN = function(x) x,
  simplify = FALSE)

### generate point CMCK preCKrige object for locations in meuse.grid
preCMCK_point &lt;- preCKrige(newdata = meuse.grid, neighbours = neighbours_point,
  model = covmodel(modelname = "exponential", mev = 0, nugget = 0.05,
    variance = 0.15, scale = 192.5))

### point prediction by covariance-matching constrained Kriging on the log
### scale
### no extended output required for backtransformation
CMCK_point &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCMCK_point, method = 3)

### backtransformation of the CMCK predictions to the original scale
### cf. Cressie, 2006, eq. (20), p. 421
### note that Var(\hat{Y}{s_0}) = Var(Y(s_0))!
CMCK_point@data$Zn &lt;- exp(CMCK_point@data$prediction)

### convert results object to SpatialGridDataFrame
gridded(CMCK_point) &lt;- TRUE
fullgrid(CMCK_point) &lt;- TRUE

### plot the CMCK predictions of Zn by function spplot of sp package
breaks &lt;- seq(0, 2600, by = 185)
spplot(CMCK_point, zcol = "Zn", at = breaks, col.regions = ck.colors(20),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CMCK predictions of Zn point values")



### example 6: universal point Kriging
UK_point &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_point, method = 1, ex.out = TRUE)

### backtransformation of the UK predictions to the original scale cf.
### Cressie, 2006, eq.  (20), p.  421 and Hofer &amp; Papritz, 2011, Appendix
### B, p.  1569
cov.beta &lt;- UK_point$parameter$cov.beta.coef
SKw &lt;- UK_point$sk.weights
X &lt;-  model.matrix(~sqrt(dist), meuse)
Xgrid &lt;- model.matrix(~sqrt(dist), meuse.grid)
### universal kriging variances
c1 &lt;- 0.5 * UK_point$object@data$prediction.se^2
### \psi^' x(s_0)
c2 &lt;- rowSums((Xgrid - t(SKw) %*% X) * (Xgrid %*% cov.beta))
UK_point$object@data$Zn &lt;- exp(UK_point$object@data$prediction + c1 - c2)

### convert results object to SpatialGridDataFrame
gridded(UK_point$object) &lt;- TRUE
fullgrid(UK_point$object) &lt;- TRUE

### plot the CMCK predictions of Zn by function spplot of sp package
breaks &lt;- seq(0, 2600, by = 185)
spplot(UK_point$object, zcol = "Zn", at = breaks, col.regions = ck.colors(20),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "UK predictions of Zn point values")


</code></pre>


</div>