<div class="container">

<table style="width: 100%;"><tr>
<td>basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate basis values</h2>

<h3>Description</h3>

<p>Calculate the basis value for a given data set. There are various functions
to calculate the basis values for different distributions.
The basis value is the lower one-sided tolerance bound of a certain
proportion of the population. For more information on tolerance bounds,
see Meeker, et. al. (2017).
For B-Basis, set the content of tolerance bound to <code class="reqn">p=0.90</code> and
the confidence level to <code class="reqn">conf=0.95</code>; for A-Basis, set <code class="reqn">p=0.99</code> and
<code class="reqn">conf=0.95</code>. While other tolerance bound
contents and confidence levels may be computed, they are infrequently
needed in practice.
</p>
<p>These functions also perform some automated diagnostic
tests of the data prior to calculating the basis values. These diagnostic
tests can be overridden if needed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">basis_normal(
  data = NULL,
  x,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  override = c()
)

basis_lognormal(
  data = NULL,
  x,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  override = c()
)

basis_weibull(
  data = NULL,
  x,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  override = c()
)

basis_pooled_cv(
  data = NULL,
  x,
  groups,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  modcv = FALSE,
  override = c()
)

basis_pooled_sd(
  data = NULL,
  x,
  groups,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  modcv = FALSE,
  override = c()
)

basis_hk_ext(
  data = NULL,
  x,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  method = c("optimum-order", "woodward-frawley"),
  override = c()
)

basis_nonpara_large_sample(
  data = NULL,
  x,
  batch = NULL,
  p = 0.9,
  conf = 0.95,
  override = c()
)

basis_anova(data = NULL, x, groups, p = 0.9, conf = 0.95, override = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the variable in the data.frame for which to find the basis value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch</code></td>
<td>
<p>the variable in the data.frame that contains the batches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the content of the tolerance bound. Should be 0.90 for B-Basis
and 0.99 for A-Basis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf</code></td>
<td>
<p>confidence level Should be 0.95 for both A- and B-Basis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>override</code></td>
<td>
<p>a list of names of diagnostic tests to override,
if desired. Specifying "all" will override all diagnostic
tests applicable to the current method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>the variable in the data.frame representing the groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modcv</code></td>
<td>
<p>a logical value indicating whether the modified CV approach
should be used. Only applicable to pooling methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method for Hanson–Koopmans nonparametric basis values.
should be "optimum-order" for B-Basis and "woodward-frawley"
for A-Basis.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>data</code> is an optional argument. If <code>data</code> is given, it should
be a
<code>data.frame</code> (or similar object). When <code>data</code> is specified, the
value of <code>x</code> is expected to be a variable within <code>data</code>. If
<code>data</code> is not specified, <code>x</code> must be a vector.
</p>
<p>When <code>modcv=TRUE</code> is set, which is only applicable to the
pooling methods,
the data is first modified according to the modified coefficient
of variation (CV)
rules. This modified data is then used when both calculating the
basis values and
also when performing the diagnostic tests. The modified CV approach
is a way of
adding extra variance to datasets with unexpectedly low variance.
</p>
<p><code>basis_normal</code> calculate the basis value by subtracting <code class="reqn">k</code> times
the standard deviation from the mean. <code class="reqn">k</code> is given by
the function <code>k_factor_normal()</code>. The equations in
Krishnamoorthy and Mathew (2008) are used.
<code>basis_normal</code> also
performs a diagnostic test for outliers (using
<code>maximum_normed_residual()</code>)
and a diagnostic test for normality (using
<code>anderson_darling_normal()</code>).
If the argument <code>batch</code> is given, this function also performs
a diagnostic test for outliers within
each batch (using <code>maximum_normed_residual()</code>)
and a diagnostic test for between batch variability (using
<code>ad_ksample()</code>). The argument <code>batch</code> is only used
for these diagnostic tests.
</p>
<p><code>basis_lognormal</code> calculates the basis value in the same way
that <code>basis_normal</code> does, except that the natural logarithm of the
data is taken.
</p>
<p><code>basis_lognormal</code> function also performs
a diagnostic test for outliers (using
<code>maximum_normed_residual()</code>)
and a diagnostic test for normality (using
<code>anderson_darling_lognormal()</code>).
If the argument <code>batch</code> is given, this function also performs
a diagnostic test for outliers within
each batch (using <code>maximum_normed_residual()</code>)
and a diagnostic test for between batch variability (using
<code>ad_ksample()</code>). The argument <code>batch</code> is only used
for these diagnostic tests.
</p>
<p><code>basis_weibull</code> calculates the basis value for data distributed
according to a Weibull distribution. The confidence level for the
content requested is calculated using the conditional method, as
described in Lawless (1982) Section 4.1.2b. This has good agreement
with tables published in CMH-17-1G. Results differ between this function
and STAT17 by approximately 0.5\
</p>
<p><code>basis_weibull</code> function also performs
a diagnostic test for outliers (using
<code>maximum_normed_residual()</code>)
and a diagnostic test for normality (using
<code>anderson_darling_weibull()</code>).
If the argument <code>batch</code> is given, this function also performs
a diagnostic test for outliers within
each batch (using <code>maximum_normed_residual()</code>)
and a diagnostic test for between batch variability (using
<code>ad_ksample()</code>). The argument <code>batch</code> is only used
for these diagnostic tests.
</p>
<p><code>basis_hk_ext</code> calculates the basis value using the Extended
Hanson–Koopmans method, as described in CMH-17-1G and Vangel (1994).
For nonparametric distributions, this function should be used for samples
up to n=28 for B-Basis and up to <code class="reqn">n=299</code> for A-Basis.
This method uses a pair of order statistics to determine the basis value.
CMH-17-1G suggests that for A-Basis, the first and last order statistic
is used: this is called the "woodward-frawley" method in this package,
after the paper in which this approach is described (as referenced
by Vangel (1994)). For B-Basis, another approach is used whereby the
first and <code>j-th</code> order statistic are used to calculate the basis value.
In this approach, the <code>j-th</code> order statistic is selected to minimize
the difference between the tolerance limit (assuming that the order
statistics are equal to the expected values from a standard normal
distribution) and the population quantile for a standard normal
distribution. This approach is described in Vangel (1994). This second
method (for use when calculating B-Basis values) is called
"optimum-order" in this package.
The results of <code>basis_hk_ext</code> have been
verified against example results from the program STAT-17. Agreement is
typically well within 0.2%.
</p>
<p>Note that the implementation of <code>hk_ext_z_j_opt</code> changed after <code>cmstatr</code>
version 0.8.0. This function is used internally by <code>basis_hk_ext</code>
when <code>method = "optimum-order"</code>. This implementation change may mean
that basis values computed using this method may change slightly
after version 0.8.0. However, both implementations seem to be equally
valid. See the included vignette
for a discussion of the differences between the implementation before
and after version 0.8.0, as well as the factors given in CMH-17-1G.
To access this vignette, run: <code>vignette("hk_ext", package = "cmstatr")</code>
</p>
<p><code>basis_hk_ext</code> also performs
a diagnostic test for outliers (using
<code>maximum_normed_residual()</code>)
and performs a pair of tests that the sample size and method selected
follow the guidance described above.
If the argument <code>batch</code> is given, this function also performs
a diagnostic test for outliers within
each batch (using <code>maximum_normed_residual()</code>)
and a diagnostic test for between batch variability (using
<code>ad_ksample()</code>). The argument <code>batch</code> is only used
for these diagnostic tests.
</p>
<p><code>basis_nonpara_large_sample</code> calculates the basis value
using the large sample method described in CMH-17-1G. This method uses
a sum of binomials to determine the rank of the ordered statistic
corresponding with the desired tolerance limit (basis value). Results
of this function have been verified against results of the STAT-17
program.
</p>
<p><code>basis_nonpara_large_sample</code> also performs
a diagnostic test for outliers (using
<code>maximum_normed_residual()</code>)
and performs a test that the sample size is sufficiently large.
If the argument <code>batch</code> is given, this function also performs
a diagnostic test for outliers within
each batch (using <code>maximum_normed_residual()</code>)
and a diagnostic test for between batch variability (using
<code>ad_ksample()</code>). The argument <code>batch</code> is only used
for these diagnostic tests.
</p>
<p><code>basis_anova</code> calculates basis values using the ANOVA method.
<code>x</code> specifies the data (normally strength) and <code>groups</code>
indicates the group corresponding to each observation. This method is
described in CMH-17-1G, but when the ratio of between-batch mean
square to the within-batch mean square is less than or equal
to one, the tolerance factor is calculated based on pooling the data
from all groups. This approach is recommended by Vangel (1992)
and by Krishnamoorthy and Mathew (2008), and is also implemented
by the software CMH17-STATS and STAT-17.
This function automatically performs a diagnostic
test for outliers within each group
(using <code>maximum_normed_residual()</code>) and a test for between
group variability (using <code>ad_ksample()</code>) as well as checking
that the data contains at least 5 groups.
This function has been verified against the results of the STAT-17 program.
</p>
<p><code>basis_pooled_sd</code> calculates basis values by pooling the data from
several groups together. <code>x</code> specifies the data (normally strength)
and <code>group</code> indicates the group corresponding to each observation.
This method is described in CMH-17-1G and matches the pooling method
implemented in ASAP 2008.
</p>
<p><code>basis_pooled_cv</code> calculates basis values by pooling the data from
several groups together. <code>x</code> specifies the data (normally strength)
and <code>group</code> indicates the group corresponding to each observation.
This method is described in CMH-17-1G.
</p>
<p><code>basis_pooled_sd</code> and <code>basis_pooled_cv</code> both automatically
perform a number of diagnostic tests. Using
<code>maximum_normed_residual()</code>, they check that there are no
outliers within each group and batch (provided that <code>batch</code> is
specified). They check the between batch variability using
<code>ad_ksample()</code>. They check that there are no outliers within
each group (pooling all batches) using
<code>maximum_normed_residual()</code>. They check for the normality
of the pooled data using <code>anderson_darling_normal()</code>.
<code>basis_pooled_sd</code> checks for equality of variance of all
data using <code>levene_test()</code> and <code>basis_pooled_cv</code>
checks for equality of variances of all data after transforming it
using <code>normalize_group_mean()</code>
using <code>levene_test()</code>.
</p>
<p>The object returned by these functions includes the named vector
<code>diagnostic_results</code>. This contains all of the diagnostic tests
performed. The name of each element of the vector corresponds with the
name of the diagnostic test. The contents of each element will be
"P" if the diagnostic test passed, "F" if the diagnostic test failed,
"O" if the diagnostic test was overridden and <code>NA</code> if the
diagnostic test was skipped (typically because an optional
argument was not supplied).
</p>
<p>The following list summarizes the diagnostic tests automatically
performed by each function.
</p>

<ul>
<li> <p><code>basis_normal</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_batch_variability</code>
</p>
</li>
<li> <p><code>outliers</code>
</p>
</li>
<li> <p><code>anderson_darling_normal</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_lognormal</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_batch_variability</code>
</p>
</li>
<li> <p><code>outliers</code>
</p>
</li>
<li> <p><code>anderson_darling_lognormal</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_weibull</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_batch_variability</code>
</p>
</li>
<li> <p><code>outliers</code>
</p>
</li>
<li> <p><code>anderson_darling_weibull</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_pooled_cv</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_group_variability</code>
</p>
</li>
<li> <p><code>outliers_within_group</code>
</p>
</li>
<li> <p><code>pooled_data_normal</code>
</p>
</li>
<li> <p><code>normalized_variance_equal</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_pooled_sd</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_group_variability</code>
</p>
</li>
<li> <p><code>outliers_within_group</code>
</p>
</li>
<li> <p><code>pooled_data_normal</code>
</p>
</li>
<li> <p><code>pooled_variance_equal</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_hk_ext</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_batch_variability</code>
</p>
</li>
<li> <p><code>outliers</code>
</p>
</li>
<li> <p><code>sample_size</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_nonpara_large_sample</code>
</p>

<ul>
<li> <p><code>outliers_within_batch</code>
</p>
</li>
<li> <p><code>between_batch_variability</code>
</p>
</li>
<li> <p><code>outliers</code>
</p>
</li>
<li> <p><code>sample_size</code>
</p>
</li>
</ul>
</li>
<li> <p><code>basis_anova</code>
</p>

<ul>
<li> <p><code>outliers_within_group</code>
</p>
</li>
<li> <p><code>equality_of_variance</code>
</p>
</li>
<li> <p><code>number_of_groups</code>
</p>
</li>
</ul>
</li>
</ul>
<h3>Value</h3>

<p>an object of class <code>basis</code>
This object has the following fields:
</p>

<ul>
<li> <p><code>call</code> the expression used to call this function
</p>
</li>
<li> <p><code>distribution</code> the distribution used (normal, etc.)
</p>
</li>
<li> <p><code>p</code> the value of <code class="reqn">p</code> supplied
</p>
</li>
<li> <p><code>conf</code> the value of <code class="reqn">conf</code> supplied
</p>
</li>
<li> <p><code>modcv</code> a logical value indicating whether the modified
CV approach was used. Only applicable to pooling methods.
</p>
</li>
<li> <p><code>data</code> a copy of the data used in the calculation
</p>
</li>
<li> <p><code>groups</code> a copy of the groups variable.
Only used for pooling and ANOVA methods.
</p>
</li>
<li> <p><code>batch</code> a copy of the batch data used for diagnostic tests
</p>
</li>
<li> <p><code>modcv_transformed_data</code> the data after the modified CV transformation
</p>
</li>
<li> <p><code>override</code> a vector of the names of diagnostic tests that
were overridden. <code>NULL</code> if none were overridden
</p>
</li>
<li> <p><code>diagnostic_results</code> a named character vector containing the
results of all the diagnostic tests. See the Details section for
additional information
</p>
</li>
<li> <p><code>diagnostic_failures</code> a vector containing any diagnostic tests
that produced failures
</p>
</li>
<li> <p><code>n</code> the number of observations
</p>
</li>
<li> <p><code>r</code> the number of groups, if a pooling method was used.
Otherwise it is NULL.
</p>
</li>
<li> <p><code>basis</code> the basis value computed. This is a number
except when pooling methods are used, in which case it is a data.frame.
</p>
</li>
</ul>
<h3>References</h3>

<p>J. F. Lawless, Statistical Models and Methods for Lifetime Data.
New York: John Wiley &amp; Sons, 1982.
</p>
<p>“Composite Materials Handbook, Volume 1. Polymer Matrix Composites
Guideline for Characterization of Structural Materials,” SAE International,
CMH-17-1G, Mar. 2012.
</p>
<p>M. Vangel, “One-Sided Nonparametric Tolerance Limits,”
Communications in Statistics - Simulation and Computation,
vol. 23, no. 4. pp. 1137–1154, 1994.
</p>
<p>K. Krishnamoorthy and T. Mathew, Statistical Tolerance Regions: Theory,
Applications, and Computation. Hoboken: John Wiley &amp; Sons, 2008.
</p>
<p>W. Meeker, G. Hahn, and L. Escobar, Statistical Intervals: A Guide
for Practitioners and Researchers, Second Edition.
Hoboken: John Wiley &amp; Sons, 2017.
</p>
<p>M. Vangel, “New Methods for One-Sided Tolerance Limits for a One-Way
Balanced Random-Effects ANOVA Model,” Technometrics, vol. 34, no. 2.
Taylor &amp; Francis, pp. 176–185, 1992.
</p>


<h3>See Also</h3>

<p><code>hk_ext_z_j_opt()</code>
</p>
<p><code>k_factor_normal()</code>
</p>
<p><code>transform_mod_cv()</code>
</p>
<p><code>maximum_normed_residual()</code>
</p>
<p><code>anderson_darling_normal()</code>
</p>
<p><code>anderson_darling_lognormal()</code>
</p>
<p><code>anderson_darling_weibull()</code>
</p>
<p><code>ad_ksample()</code>
</p>
<p><code>normalize_group_mean()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)

# A single-point basis value can be calculated as follows
# in this example, three failed diagnostic tests are
# overridden.

carbon.fabric %&gt;%
  filter(test == "FC") %&gt;%
  filter(condition == "RTD") %&gt;%
  basis_normal(strength, batch,
               override = c("outliers",
                            "outliers_within_batch",
                            "anderson_darling_normal"))

## Call:
## basis_normal(data = ., x = strength, batch = batch,
##     override = c("outliers", "outliers_within_batch",
##    "anderson_darling_normal"))
##
## Distribution:  Normal 	( n = 18 )
## The following diagnostic tests were overridden:
##     `outliers`,
##     `outliers_within_batch`,
##     `anderson_darling_normal`
## B-Basis:   ( p = 0.9 , conf = 0.95 )
## 76.94656

# A set of pooled basis values can also be calculated
# using the pooled standard deviation method, as follows.
# In this example, one failed diagnostic test is overridden.
carbon.fabric %&gt;%
  filter(test == "WT") %&gt;%
  basis_pooled_sd(strength, condition, batch,
                  override = c("outliers_within_batch"))

## Call:
## basis_pooled_sd(data = ., x = strength, groups = condition,
##                 batch = batch, override = c("outliers_within_batch"))
##
## Distribution:  Normal - Pooled Standard Deviation 	( n = 54, r = 3 )
## The following diagnostic tests were overridden:
##     `outliers_within_batch`
## B-Basis:   ( p = 0.9 , conf = 0.95 )
## CTD  127.6914
## ETW  125.0698
## RTD  132.1457

</code></pre>


</div>