<div class="container">

<table style="width: 100%;"><tr>
<td>simpA.NP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nonparametric testing of the simplifying assumption</h2>

<h3>Description</h3>

<p>This function tests the “simplifying assumption” that a conditional
copula </p>
<p style="text-align: center;"><code class="reqn">C_{1,2|3}(u_1, u_2 | X_3 = x_3)</code>
</p>
<p> does not depend on the
value of the conditioning variable <code class="reqn">x_3</code> in a nonparametric setting,
where the conditional copula is estimated by kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simpA.NP(
  X1,
  X2,
  X3,
  testStat,
  typeBoot = "bootNP",
  h,
  nBootstrap = 100,
  kernel.name = "Epanechnikov",
  truncVal = h,
  numericalInt = list(kind = "legendre", nGrid = 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p>vector of <code>n</code> observations of the first conditioned variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>vector of <code>n</code> observations of the second conditioned variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X3</code></td>
<td>
<p>vector of <code>n</code> observations  of the conditioning variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testStat</code></td>
<td>
<p>name of the test statistic to be used.
Possible values are
</p>

<ul>
<li> <p><code>T1_CvM_Cs3</code>: Equation (3) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (6) and the weight
<code class="reqn">w(u_1, u_2, u_3) = \hat{F}_1(u_1) \hat{F}_2(u_2) \hat{F}_3(u_3)</code>.
</p>
</li>
<li> <p><code>T1_CvM_Cs4</code>: Equation (3) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (7) and the weight
<code class="reqn">w(u_1, u_2, u_3) = \hat{F}_1(u_1) \hat{F}_2(u_2) \hat{F}_3(u_3)</code>.
</p>
</li>
<li> <p><code>T1_KS_Cs3</code>: Equation (4) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (6).
</p>
</li>
<li> <p><code>T1_KS_Cs4</code>: Equation (4) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (7).
</p>
</li>
<li> <p><code>tilde_T0_CvM</code>: Equation (10) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
<li> <p><code>tilde_T0_KS</code>: Equation (9) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
<li> <p><code>I_chi</code>: Equation (13) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
<li> <p><code>I_2n</code>: Equation (15) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeBoot</code></td>
<td>
<p>the type of bootstrap to be used
(see Derumigny and Fermanian, 2017, p.165).
Possible values are
</p>

<ul>
<li> <p><code>boot.NP</code>: usual (Efron's) non-parametric bootstrap
</p>
</li>
<li> <p><code>boot.pseudoInd</code>: pseudo-independent bootstrap
</p>
</li>
<li> <p><code>boot.pseudoInd.sameX3</code>: pseudo-independent bootstrap
without resampling on <code class="reqn">X_3</code>
</p>
</li>
<li> <p><code>boot.pseudoNP</code>: pseudo-non-parametric bootstrap
</p>
</li>
<li> <p><code>boot.cond</code>: conditional bootstrap
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>the bandwidth used for kernel smoothing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBootstrap</code></td>
<td>
<p>number of bootstrap replications</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.name</code></td>
<td>
<p>the name of the kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truncVal</code></td>
<td>
<p>the value of truncation for the integral,
i.e. the integrals are computed from <code>truncVal</code> to <code>1-truncVal</code>
instead of from 0 to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numericalInt</code></td>
<td>
<p>parameters to be given to
<code>statmod::gauss.quad</code>, including the number of
quadrature points and the type of interpolation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>true_stat</code>: the value of the test statistic
computed on the whole sample
</p>
</li>
<li> <p><code>vect_statB</code>: a vector of length <code>nBootstrap</code>
containing the bootstrapped test statistics.
</p>
</li>
<li> <p><code>p_val</code>: the p-value of the test.
</p>
</li>
</ul>
<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>


<h3>See Also</h3>

<p>Other tests of the simplifying assumption:
</p>

<ul>
<li> <p><code>simpA.param</code> in a (semi)parametric setting,
where the conditional copula belongs to a parametric family,
but the conditional margins are estimated arbitrarily through
kernel smoothing
</p>
</li>
<li> <p><code>simpA.kendallReg</code>: test based on the constancy of
conditional Kendall's tau
</p>
</li>
<li>
<p> the counterparts of these tests in the discrete conditioning setting:
<code>bCond.simpA.CKT</code>
(test based on conditional Kendall's tau)
<code>bCond.simpA.param</code>
(test assuming a parametric form for the conditional copula)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># We simulate from a conditional copula
set.seed(1)
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1], mean = Z)
X2 = qnorm(simCopula[,2], mean = - Z)

result &lt;- simpA.NP(
   X1 = X1, X2 = X2, X3 = Z,
   testStat = "I_chi", typeBoot = "boot.pseudoInd",
   h = 0.03, kernel.name = "Epanechnikov", nBootstrap = 10)

# In practice, it is recommended to use at least nBootstrap = 100
# with nBootstrap = 200 being a good choice.

print(result$p_val)

set.seed(1)
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.8
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1], mean = Z)
X2 = qnorm(simCopula[,2], mean = - Z)

result &lt;- simpA.NP(
   X1 = X1, X2 = X2, X3 = Z,
   testStat = "I_chi", typeBoot = "boot.pseudoInd",
   h = 0.08, kernel.name = "Epanechnikov", nBootstrap = 10)
print(result$p_val)

</code></pre>


</div>