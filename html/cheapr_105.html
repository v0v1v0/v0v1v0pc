<div class="container">

<table style="width: 100%;"><tr>
<td>factor_</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A cheaper version of <code>factor()</code> along with cheaper utilities</h2>

<h3>Description</h3>

<p>A fast version of <code>factor()</code> using the collapse package. <br></p>
<p>There are some additional utilities, most of which begin with the prefix
'levels_', such as
<code>as_factor()</code> which is an efficient way to coerce both vectors and factors,
<code>levels_factor()</code> which returns the levels of a factor, as a factor,
<code>levels_used()</code> which returns the used levels of a factor,
<code>levels_unused()</code> which returns the unused levels of a factor,
<code>levels_add_na()</code> which adds an explicit <code>NA</code> level,
<code>levels_drop_na()</code> which drops the <code>NA</code> level,
<code>levels_drop()</code> which drops unused factor levels,
and finally <code>levels_reorder()</code> which reorders the levels of <code>x</code>
based on <code>y</code> using the ordered median values of <code>y</code> for each level.
</p>


<h3>Usage</h3>

<pre><code class="language-R">factor_(
  x = integer(),
  levels = NULL,
  order = TRUE,
  na_exclude = TRUE,
  ordered = is.ordered(x)
)

as_factor(x)

levels_factor(x)

levels_used(x)

levels_unused(x)

used_levels(x)

unused_levels(x)

levels_add_na(x, name = NA, where = c("last", "first"))

levels_drop_na(x)

levels_drop(x)

levels_reorder(x, order_by, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>Optional factor levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Should factor levels be sorted? Default is <code>TRUE</code>.
It typically is faster to set this to <code>FALSE</code>, in which case the levels
are sorted by order of first appearance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_exclude</code></td>
<td>
<p>Should <code>NA</code> values be excluded from the factor levels?
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>Should the result be an ordered factor?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>Name of <code>NA</code> level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>where</code></td>
<td>
<p>Where should <code>NA</code> level be placed? Either first or last.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_by</code></td>
<td>
<p>A vector to order the levels of <code>x</code> by using the medians of
<code>order_by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>Should the reordered levels be in decreasing order?
Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This operates similarly to <code>collapse::qF()</code>. <br>
The main difference internally is that <code>collapse::funique()</code> is used
and therefore s3 methods can be written for it. <br>
Furthermore, for date-times <code>factor_</code> differs in that it differentiates
all instances in time whereas <code>factor</code> differentiates calendar times.
Using a daylight savings example where the clocks go back: <br><code>factor(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 4 levels whereas <br><code>factor_(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 5 levels.
</p>


<h3>Value</h3>

<p>A <code>factor</code> or <code>character</code> in the case of <code>levels_used</code> and <code>levels_unused</code>.
</p>


</div>