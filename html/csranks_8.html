<div class="container">

<table style="width: 100%;"><tr>
<td>irank_against</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute integer ranks in another reference vector</h2>

<h3>Description</h3>

<p>The method <code>irank</code> compares ranks using the same vector as reference.
<code>irank_against</code> returns integer ranks, that values from <code>x</code> would assume if (individually)
inserted into <code>v</code>. <code>frank_against</code> acts analogously, returning fractional ranks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">irank_against(x, v, omega = 0, increasing = FALSE, na.rm = FALSE)

frank_against(x, v, omega = 0, increasing = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric query vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>numeric reference vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>numeric value in [0,1], defining how ties in <code>x</code> (if any) are handled; default is <code>0</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>increasing</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), then large elements in <code>x</code> receive a small rank. Otherwise, large elements in <code>x</code> receive a large rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code>. Default: <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It's useful to think about <code>frank_against(x,v)</code> as a generalization of Empirical Cumulative
Distribution Function, created for <code>v</code> and evaluated for points in <code>x</code>.
<code>frank_agaist(x,v,increasing=TRUE,omega=1)</code> is identical
to <code>ecdf(v)(x)</code>.
</p>
<p><code>increasing</code> switches the inequality sign in ECDF definition from
<code class="reqn">F_V(t) = \hat P(V &lt;= t)</code> to <code class="reqn">\hat P(V &gt;= t)</code>.
</p>
<p><code>omega=0</code> introduces the strict inequality (<code class="reqn">\hat P(V &lt; t)</code> instead of <code class="reqn">\hat P(V &lt;= t)</code>).
Any <code>omega</code> in between is a weighted average of the cases <code>omega=1</code> and <code>omega=0</code>.
</p>
<p>Finally, <code>irank_against</code> is equal to <code>frank_against</code> multiplied by the <code>length(v)</code>.
</p>
<p>This particular choice of default parameters was made for compatibility with default parameters of
<code>irank</code> and <code>frank</code>. <code>irank(x)</code> is always equal to <code>irank_against(x,x)</code> and <code>frank(x)</code> is always equal to <code>frank_against(x,x)</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code> containing the integer (for <code>irank_against</code>) or fractional (for <code>frank_against</code>) ranks.
</p>


<h3>See Also</h3>

<p><code>irank()</code>, <code>ecdf()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">irank_against(1:10, c(4,4,4,3,1,10,7,7))
</code></pre>


</div>