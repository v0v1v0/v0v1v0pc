<div class="container">

<table style="width: 100%;"><tr>
<td>phi.fun.toy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to create or change hyperparameters</h2>

<h3>Description</h3>

<p>Function to create (<code>phi.fun.toy</code>) or modify
(<code>phi.change</code>) toy hyperparameters <code class="reqn">\phi</code>
in a form suitable for passing to the other functions in the library.
</p>
<p>The user should never make <code class="reqn">\phi</code> by hand; always use one of
these functions
</p>


<h3>Usage</h3>

<pre><code class="language-R">phi.fun.toy(rho, lambda, psi1, psi1.apriori, psi2, psi2.apriori,
  theta.apriori)
phi.change(phi.fun, old.phi = NULL, rho = NULL, lambda = NULL,
          psi1 = NULL, psi1.apriori=NULL,  psi1.apriori.mean=NULL,
          psi1.apriori.sigma=NULL, psi2 = NULL, psi2.apriori=NULL,
          psi2.apriori.mean=NULL,  psi2.apriori.sigma=NULL,
          theta.apriori=NULL, theta.apriori.mean=NULL,
          theta.apriori.sigma=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phi.fun</code></td>
<td>
<p>In <code>phi.change()</code>, the name of the function that 
creates the hyperparameters.  Use <code>phi.fun.toy()</code> for the toy
dataset
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>old.phi</code></td>
<td>
<p>In function <code>phi.change()</code>, the hyperparameter
object <code class="reqn">\phi</code> to be modified
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Correlation hyperparameter appearing in main equation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Noise hyperparameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi1</code></td>
<td>
<p>Roughness lengths hyperparameter for design matrix
<code>D1</code>.  Internal function <code>pdm.maker.psi1()</code> takes
<code>psi1</code> as an argument and returns <code>omega_x</code>,
<code>omega_t</code> and <code>sigma1squared</code>.
</p>
<p>Recall that <code class="reqn">\Omega_x</code> and <code class="reqn">Omega_t</code> are
arbitrary functions of <code class="reqn">\psi_1</code>.  In this case,
the values are <code>omega_x=psi1[1:2]</code>, <code>omega_t=psi1[3:4]</code>
and <code>sigma1squared=psi1[6]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi1.apriori</code></td>
<td>
<p>A priori PDF for <code class="reqn">\psi_1</code>.  In the form
of a two element list with first element (<code>mean</code>) the mean and
second element (<code>sigma</code>) the covariance matrix; distribution of
the logarithms is assumed to be multivariate normal.  In the toy
example, the mean is a vector of length six (the first five are
<code class="reqn">\psi_1</code> and the sixth is for
<code class="reqn">\sigma_1^2</code>), and the variance is the
corresponding six-by-six matrix.  Use function <code>prob.psi1()</code> to
calculate the apriori probability density for a particular value of
<code class="reqn">\psi_1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi1.apriori.mean</code></td>
<td>
<p>In function <code>phi.change.toy()</code>, use this
argument to change just the mean of <code>psi1</code> (and leave the value
of <code>sigma</code> unchanged)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi1.apriori.sigma</code></td>
<td>
<p>In function <code>phi.change.toy()</code>, use
this argument to change just the variance matrix  of <code>psi1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2</code></td>
<td>
<p>Roughness lengths hyperparameter for <code>D2</code>.
</p>
<p>Internal function <code>pdm.maker.psi2()</code> takes <code>psi2</code> as an
argument and returns <code>omegastar_x</code> and <code>sigma2squared</code>.
In <code>phi.fun.toy()</code>, the values are <code>omegastar_x=psi2[1:2]</code>
and <code>sigma2squared=psi2[3]</code>.
</p>
<p>NB: function <code>stage2()</code> optimizes more than just <code>psi2</code>.
It simultaneously optimizes <code>psi2</code> and <code>lambda</code> and
<code>rho</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2.apriori</code></td>
<td>
<p>A priori PDF for <code class="reqn">\psi_2</code> <strong>and</strong>
hyperparameters <code class="reqn">\rho</code> and <code class="reqn">\lambda</code> (in that
order). 
</p>
<p>As for <code>psi1.apriori</code>, this is in the form of a list with the
first element (<code>mean</code>) the mean and second element
(<code>sigma</code>) the covariance matrix; the logs are multivariate
normal.  In the toy example, the mean is a vector of length five.
The first and second elements of the mean are the apriori mean of
<code class="reqn">\rho</code> and <code class="reqn">\lambda</code> respectively; the third
and fourth elements are the apriori mean of <code class="reqn">\psi_2</code> (that
is, <code>x</code> and <code>y</code> respectively); and the fifth is the mean
of <code class="reqn">\sigma_2^2</code>.
</p>
<p>The second element of <code>phi.toy$psi2.apriori</code>, <code>sigma</code>, is
the corresponding four-by-four variance matrix.  Use function
<code>prob.psi2()</code> to calculate the apriori probability density of a
particular value of <code class="reqn">\psi_2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2.apriori.mean</code></td>
<td>
<p>In <code>phi.change.toy()</code>, use to change
just the mean of <code>psi2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2.apriori.sigma</code></td>
<td>
<p>In
<code>phi.change.toy()</code>, use to change just the variance matrix of
<code>psi2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.apriori</code></td>
<td>
<p>Apriori PDF for
<code class="reqn">\theta</code>.  As above, in the form of a list with elements
for the mean and covariance.  The distribution is multivariate
normal (NB: The distribution is multivariate normal and NOT
lognormal!  To be explicit: <code class="reqn">\log(\theta)</code> is
lognormally distributed).  Use function <code>prob.theta()</code> to
calculate the apriori probability density of a particular value of
<code class="reqn">\theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.apriori.mean</code></td>
<td>
<p>In <code>phi.change.toy()</code>, use to change
just the mean of <code>theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.apriori.sigma</code></td>
<td>
<p>In <code>phi.change.toy()</code>,
use to change just the variance matrix of <code>theta</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that this toy function contains within itself
<code>pdm.maker.toy()</code> which extracts <code>omega_x</code> and
<code>omega_t</code> and <code>sigma1squared</code> from <code>psi1</code>.
This will need to  be changed for real-world applications.
</p>
<p>Earlier versions of the package had <code>pdm.maker.toy()</code>
defined separately.
</p>


<h3>Value</h3>

<p>Returns a list of several elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Correlation hyperparameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Noise hyperparameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi1</code></td>
<td>
<p>Roughness lengths hyperparameter for <code>D1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi1.apriori</code></td>
<td>
<p>Apriori mean and variance matrix for <code>psi1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2</code></td>
<td>
<p>Roughness lengths hyperparameter for <code>D2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2.apriori</code></td>
<td>
<p>Apriori mean and variance matrix for <code>psi2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.apriori</code></td>
<td>
<p>Apriori mean and variance matrix for the
parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_x</code></td>
<td>
<p>Positive definite matrix for the lat/long part of
<code>D1</code>, whose diagonal is <code>psi1[1:2]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_t</code></td>
<td>
<p>Positive definite matrix for the code parameters theta,
whose diagonal is <code>psi1[3:5]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omegastar_x</code></td>
<td>
<p>Positive definite matrix for use in equation 13 of
the supplement; represents distances between rows of <code>D2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma1squared</code></td>
<td>
<p>variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2squared</code></td>
<td>
<p>variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_x.upper</code></td>
<td>
<p>Upper triangular Cholesky decomposition for <code>omega_x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_x.lower</code></td>
<td>
<p>Lower triangular Cholesky decomposition for <code>omega_x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_t.upper</code></td>
<td>
<p>Upper triangular Cholesky decomposition for <code>omega_t</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_t.lower</code></td>
<td>
<p>Lower triangular Cholesky decomposition for <code>omega_t</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Precalculated matrix for use in
<code>Edash.theta(...,fast.but.opaque=TRUE)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Precalculated matrix for use in
<code>Edash.theta(...,fast.but.opaque=TRUE)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>Precalculated scalar for use in
<code>ht.fun(...,fast.but.opaque=TRUE)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Precalculated scalarfor use in
<code>tt.fun()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.upper</code></td>
<td>
<p>Upper triangular Cholesky decomposition for <code>A</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.lower</code></td>
<td>
<p>Lower triangular Cholesky decomposition for <code>A</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001. <em>Bayesian
calibration of computer models</em>.  Journal of the Royal Statistical
Society B, 63(3) pp425-464
</p>
</li>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001.  <em>Supplementary details on
Bayesian calibration of computer models</em>, Internal report, University
of Sheffield.  Available at
<a href="http://www.tonyohagan.co.uk/academic/ps/calsup.ps">http://www.tonyohagan.co.uk/academic/ps/calsup.ps</a>
</p>
</li>
<li>
<p>R. K. S. Hankin 2005. <em>Introducing BACCO, an R bundle for
Bayesian analysis of computer code output</em>, Journal of Statistical
Software, 14(16)
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>toys</code>,
<code>H1.toy</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
phi.fun.toy(100,101,1:6,list(mean=rep(1,6),sigma=1+diag(6)),50:55,
list(mean=rep(0,4),sigma=0.1+diag(4)),
list(mean=0.1+(1:3),sigma=2.1+diag(3)))

phi.fun.toy(rho=1, lambda=1,
    psi1 = structure(c(1.1, 1.2, 1.3, 1.4, 1.5, 0.7),
            .Names = c("x", "y", "A","B", "C","s1sq")),
    psi1.apriori  = list(
             mean=rep(0,6), sigma=0.4+diag(6)),
             psi2=structure(c(2.1, 2.2), .Names = c("x","y")),
             psi2.apriori  = list(mean=rep(0,5),sigma=0.2+diag(5)),
             theta.apriori = list(mean=0.1+(1:3),sigma=2.1+diag(3))
)

data(toys)
phi.change(phi.fun=phi.fun.toy, old.phi = phi.toy, rho = 100)
phi.change(phi.fun=phi.fun.toy, old.phi = phi.toy,
     theta.apriori.sigma = 4*diag(3))

identical(phi.toy, phi.change(phi.fun=phi.fun.toy, old.phi=phi.toy))
</code></pre>


</div>