<div class="container">

<table style="width: 100%;"><tr>
<td>celltrackR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>celltrackR: Quantitative analysis of motion.</h2>

<h3>Description</h3>

<p>The CelltrackR package is designed for analyzing cell tracks acquired by
time-lapse microscopy (like those provided in the included datasets
<code>TCells</code>, <code>BCells</code> and <code>Neutrophils</code>).
But it can of course process any x-y-(z)-t data, and we hope that it may be useful
for other purposes as well.
</p>


<h3>Details</h3>

<p>For a complete list of functions, use <code>help( package="celltrackR" )</code>.
A handy cheat sheet is available in pdf. You can open it by calling
the function <code>cheatsheet</code>.
</p>


<h3>Data structure</h3>

<p>The basic data structure that most functions in this package operate on is a set of
<em>tracks</em>. A track is a list of spatial coordinates that are recorded at
<em>fixed</em> time intervals; the function <code>timeStep</code> can be used to check
for fluctuations of the recording intervals.
</p>
<p>We expect tracks to be stored in a matrix (or data frame, but this is discouraged
for efficiency reasons) whose first column denotes a time interval
(e.g. seconds elapsed since the beginning
of the experiment), and whose remaining columns denote a spatial coordinate. A set of
tracks is stored as a <code>list</code> with S3 class <code>tracks</code>. CelltrackR provides
some S3 methods for this class, which are explained in <code>tracks</code> as well as
<code>plot.tracks</code>, <code>sort.tracks</code> and <code>as.list.tracks</code>.
</p>


<h3>Track analysis in celltrackR</h3>

<p>A wide range of common track measures are included in the package. These are all functions
that take a single track as an input, and output one or several numbers.
For instance, the function <code>speed</code> estimates
the average instantaneous speed of the track by linear interpolation, and
<code>straightness</code> computes the start-to-end distance divided by the trajectory
length (a number between 0 and 1, where 1 indicates a perfectly straight track).
See <code>TrackMeasures</code> for an overview of measures that can be analyzed on tracks.
Also see <code>AngleAnalysis</code> for an overview of functions that can help detect
directional bias and tracking artefacts (see Beltman et al, 2009).
</p>
<p>CelltrackR is designed to support various flavors of track analysis that have been
suggested in the literature. The simplest kind is a <em>track-based</em> analysis, where
we compute a single statistic for each track in a dataset (Beltman et al, 2009). Because
track sets are lists, this is achieved simply by using <code>lapply</code> or
<code>sapply</code> together with the track measure (see Examples).
</p>
<p>In <em>step-based</em> analyses (Beltman et al, 2009), we
chop each track up into segments of the same length and then apply our measures to those
segments. This can help to avoid biases that arise from variations
in track length (which are always present in cell tracking experiments).
In CelltrackR, step-based analyses are performed by using the <code>subtracks</code>
function. Often we want to perform such step-based analyses for all possible subtrack
lengths simultaneously, and plot the result as a function of the subtrack length;
a famous example is the <em>mean square displacement plot</em>. This can be
achieved by using the <code>aggregate.tracks</code> function, which has options
to control which subtrack lengths are considered and whether overlapping subtracks are
considered.
</p>
<p>In a <em>staggered</em> <em>staggered</em> analysis (Mokhtari et al, 2013), we analyse all
subtracks (of any length) of a single track, and typically plot the result as a matrix.
This can reveal dynamic patterns along a single track,
e.g. turning behaviour or local slowdowns. Staggered analyses can be performed using the
<code>applyStaggered</code> function.
</p>


<h3>Simulating tracks in celltrackR</h3>

<p>Lastly, in addition to data analysis, the package contains some function to generate
cell tracks by simulation. This is useful to develop and benchmark track analysis
methodology (Textor et al, 2011), and for computational biology studies that try to
extrapolate the long-term consequences of observed cell migration behaviour. Alongside
a simple uncorrelated random walk (<code>brownianTrack</code>), this package implements
a simulation model proposed by Beauchemin et al (2007)
in the function <code>beaucheminTrack</code>. That model can also simulate
directionally biased motion.
</p>


<h3>Author(s)</h3>

<p>Johannes Textor, Katharina Dannenberg, Jeffrey Berry, Gerhard Burger, Inge Wortel
Maintainer: Johannes Textor &lt;johannes.textor@gmx.de&gt;
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789–798. doi:10.1038/nri2638
</p>
<p>Zeinab Mokhtari, Franziska Mech, Carolin Zitzmann, Mike Hasenberg, Matthias Gunzer
and Marc Thilo Figge (2013), Automated Characterization and
Parameter–Free Classification of Cell Tracks Based on Local Migration
Behavior. <em>PLoS ONE</em> <b>8</b>(12), e80808. doi:10.1371/journal.pone.0080808
</p>
<p>Johannes Textor, Antonio Peixoto, Sarah E. Henrickson, Mathieu
Sinn, Ulrich H. von Andrian and Juergen Westermann (2011),
Defining the Quantitative Limits of Intravital Two-Photon Lymphocyte Tracking.
<em>PNAS</em> <b>108</b>(30):12401–12406. doi:10.1073/pnas.1102288108
</p>
<p>Catherine Beauchemin, Narendra M. Dixit and Alan S. Perelson (2007), Characterizing
T cell movement within lymph nodes in the absence of antigen. <em>Journal of Immunology</em>
<b>178</b>(9), 5505-5512. doi:10.4049/jimmunol.178.9.5505
</p>


<h3>See Also</h3>

<p>The package vignettes, available from <code>browseVignettes( package="celltrackR" )</code>.
Make sure you have installed the package with option <code>build_vignettes = TRUE</code>, or
vignettes will not be visible. Also check out the package cheat sheet, which is available by
calling the function <code>cheatsheet</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  ## track-based speed comparison
  boxplot(sapply( Neutrophils, straightness ), sapply( BCells, straightness ))

  ## step-based turning angle comparison
  boxplot(sapply(subtracks(Neutrophils, 2), overallAngle),
    sapply(subtracks(BCells, 2), overallAngle))

 ## mean square displacement plot; a step-based displacement analysis for all step lengths
 plot(aggregate(TCells, squareDisplacement)[,"value"])

 ## 'staggered' analysis of displacement over whole track. Reveals that this track
 ## slows down near its beginning and near its end.
 filled.contour(applyStaggered(TCells[[4]], displacement, matrix=TRUE))

 ## a simple hierarchical clustering based on 2D asphericity

 ## tag track IDs so we can identify them later
 names(TCells) &lt;- paste0("T",names(TCells))
 names(BCells) &lt;- paste0("B",names(BCells))
 names(Neutrophils) &lt;- paste0("N",names(Neutrophils))
 ## project all tracks down to 2D
 cells &lt;-  projectDimensions(c(TCells,BCells,Neutrophils), c("x","y"))

 ## compute asphericity
 asph &lt;- lapply(cells, asphericity)

 ## plot clustering
 plot(hclust(dist(asph)))

</code></pre>


</div>