<div class="container">

<table style="width: 100%;"><tr>
<td>conf_intervals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confidence intervals</h2>

<h3>Description</h3>

<p>Calculates confidence intervals for individual parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">conf_intervals(
  object,
  which_pars = NULL,
  init = NULL,
  conf = 95,
  mult = 1.5,
  num = 10,
  type = c("vertical", "cholesky", "spectral", "none"),
  profile = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>"chandwich"</code> returned by
<code>adjust_loglik</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_pars</code></td>
<td>
<p>A vector specifying the (unfixed) parameters for which
confidence intervals are required.  Can be either a numeric vector,
specifying indices of the components of the <strong>full</strong> parameter
vector, or a character vector of parameter names, which must be a subset
of those supplied in <code>par_names</code> in the call to
<code>adjust_loglik</code> that produced <code>object</code>.
</p>
<p><code>which_pars</code> must not have any parameters in common with
<code>attr(object, "fixed_pars")</code>.  <code>which_pars</code> must not contain
all of the unfixed parameters, i.e. there is no point in profiling over
all the unfixed parameters.
</p>
<p>If missing, all parameters are included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A numeric vector of initial estimates of the values of the
parameters that are not fixed and are not in <code>which_pars</code>.
Should have length <code>attr(object, "p_current") - length(which_pars)</code>.
If <code>init</code> is <code>NULL</code> or is of the wrong length then the
relevant components from the MLE stored in <code>object</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf</code></td>
<td>
<p>A numeric scalar in (0, 100). Confidence level for the
intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mult</code></td>
<td>
<p>A numeric vector of length 1 or the same length as
<code>which_pars</code>.
The search for the profile loglikelihood-based confidence limits is
conducted over the corresponding symmetric confidence intervals
(based on approximate normal theory), extended
by a factor of the corresponding component of <code>mult</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num</code></td>
<td>
<p>A numeric scalar.  The number of values at which to evaluate the
profile loglikelihood either side of the MLE.  Increasing <code>num</code>
increases the accuracy of the confidence limits, but the code will take
longer to run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character scalar.  The argument <code>type</code> to the function
returned by <code>adjust_loglik</code>, that is, the type of adjustment
made to the independence loglikelihood function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profile</code></td>
<td>
<p>A logical scalar.  If <code>FALSE</code> then only intervals based
on approximate large sample normal theory, which are symmetric about the
MLE, are returned (in <code>sym_CI</code>) and <code>prof_CI</code> in the returned
object will contain <code>NA</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to <code>optim</code>.
These may include <code>gr</code>, <code>method</code>, <code>lower</code>, <code>upper</code>
or <code>control</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculates (profile, if necessary) likelihood-based confidence
intervals for individual parameters, and also provides symmetric intervals
based on a normal approximation to the sampling distribution of the
estimator.  See also the S3 confint method
<code>confint.chandwich</code>.
</p>


<h3>Value</h3>

<p>An object of class "confint", a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>conf</code></td>
<td>
<p>The argument <code>conf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>A numeric scalar.  For values inside the
confidence interval the profile loglikelihood lies above
<code>cutoff</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter_vals, prof_loglik_vals</code></td>
<td>
<p><code>2 * num + 1</code> by
<code>length(which_pars)</code> numeric matrices.
Column i of <code>parameter_vals</code> contains the profiled values of
parameter <code>which_par[i]</code>.  Column i of <code>prof_loglik_vals</code>
contains the corresponding values of the profile loglikelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sym_CI, prof_CI</code></td>
<td>
<p><code>length(which_pars)</code>
by 2 numeric matrices.  Row i of <code>sym_CI</code> (<code>prof_CI</code>)
contains the symmetric (profile loglikelihood-based) confidence
intervals for parameter <code>which_pars[i]</code>.</p>
</td>
</tr>
</table>
<p>  If a value in
<code>prof_CI</code> is <code>NA</code> then this means that the search for the
confidence limit did no extend far enough.  A remedy is to increase
the value of <code>mult</code>, or the relevant component of <code>mult</code>,
and perhaps also increase <code>num</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>max_loglik</code></td>
<td>
<p>The value of the adjusted loglikelihood
at its maximum, stored in <code>object$max_loglik</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The argument <code>type</code> supplied in the call
to <code>conf_intervals</code>, i.e. the type of loglikelihood adjustment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_pars</code></td>
<td>
<p>The argument <code>which_pars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>A character scalar. The name of the model,
stored in <code>attr(object, "name")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_current</code></td>
<td>
<p>The number of free parameters in the current model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_pars, fixed_at</code></td>
<td>
<p><code>attr(object, "fixed_pars")</code> and
<code>attr(object, "fixed_at")</code>, the arguments <code>fixed_pars</code> and
<code>fixed_at</code> to <code>adjust_loglik</code>, if these were
supplied.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>confint.chandwich</code> S3 confint method for objects
of class <code>"chandwich"</code> returned from <code>adjust_loglik</code>.
</p>
<p><code>adjust_loglik</code> to adjust a user-supplied
loglikelihood function.
</p>
<p><code>summary.chandwich</code> for maximum likelihood estimates
and unadjusted and adjusted standard errors.
</p>
<p><code>plot.chandwich</code> for plots of one-dimensional adjusted
loglikelihoods.
</p>
<p><code>conf_region</code> for a confidence region for
a pair of parameters.
</p>
<p><code>compare_models</code> to compare nested models using an
(adjusted) likelihood ratio test.
</p>
<p><code>plot.confint</code>, <code>print.confint</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># ------------------------- Binomial model, rats data ----------------------

# Contributions to the independence loglikelihood
binom_loglik &lt;- function(prob, data) {
  if (prob &lt; 0 || prob &gt; 1) {
    return(-Inf)
  }
  return(dbinom(data[, "y"], data[, "n"], prob, log = TRUE))
}
rat_res &lt;- adjust_loglik(loglik = binom_loglik, data = rats, par_names = "p")

# 95% likelihood-based confidence intervals, vertically adjusted
ci &lt;- conf_intervals(rat_res)
plot(ci)
# Unadjusted
conf_intervals(rat_res, type = "none")

# -------------------------- GEV model, owtemps data -----------------------
# ------------ following Section 5.2 of Chandler and Bate (2007) -----------

gev_loglik &lt;- function(pars, data) {
  o_pars &lt;- pars[c(1, 3, 5)] + pars[c(2, 4, 6)]
  w_pars &lt;- pars[c(1, 3, 5)] - pars[c(2, 4, 6)]
  if (isTRUE(o_pars[2] &lt;= 0 | w_pars[2] &lt;= 0)) return(-Inf)
  o_data &lt;- data[, "Oxford"]
  w_data &lt;- data[, "Worthing"]
  check &lt;- 1 + o_pars[3] * (o_data - o_pars[1]) / o_pars[2]
  if (isTRUE(any(check &lt;= 0))) return(-Inf)
  check &lt;- 1 + w_pars[3] * (w_data - w_pars[1]) / w_pars[2]
  if (isTRUE(any(check &lt;= 0))) return(-Inf)
  o_loglik &lt;- log_gev(o_data, o_pars[1], o_pars[2], o_pars[3])
  w_loglik &lt;- log_gev(w_data, w_pars[1], w_pars[2], w_pars[3])
  return(o_loglik + w_loglik)
}

# Initial estimates (method of moments for the Gumbel case)
sigma &lt;- as.numeric(sqrt(6 * diag(var(owtemps))) / pi)
mu &lt;- as.numeric(colMeans(owtemps) - 0.57722 * sigma)
init &lt;- c(mean(mu), -diff(mu) / 2, mean(sigma), -diff(sigma) / 2, 0, 0)

# Log-likelihood adjustment of the full model
par_names &lt;- c("mu[0]", "mu[1]", "sigma[0]", "sigma[1]", "xi[0]", "xi[1]")
large &lt;- adjust_loglik(gev_loglik, data = owtemps, init = init,
                       par_names = par_names)

# 95% likelihood-based confidence intervals, vertically adjusted
large_v &lt;- conf_intervals(large, which_pars = c("xi[0]", "xi[1]"))
large_v
plot(large_v)
plot(large_v, which_par = "xi[1]")

# Unadjusted
large_none &lt;- conf_intervals(large, which_pars = c("xi[0]", "xi[1]"),
                             type = "none")
large_none
plot(large_v, large_none)
plot(large_v, large_none, which_par = "xi[1]")


# --------- Misspecified Poisson model for negative binomial data ----------

# ... following Section 5.1 of the "Object-Oriented Computation of Sandwich
# Estimators" vignette of the sandwich package
# https://cran.r-project.org/web/packages/sandwich/vignettes/sandwich-OOP.pdf

# Simulate data
set.seed(123)
x &lt;- rnorm(250)
y &lt;- rnbinom(250, mu = exp(1 + x), size = 1)
# Fit misspecified Poisson model
fm_pois &lt;- glm(y ~ x + I(x^2), family = poisson)
summary(fm_pois)$coefficients

# Contributions to the independence loglikelihood
pois_glm_loglik &lt;- function(pars, y, x) {
  log_mu &lt;- pars[1] + pars[2] * x + pars[3] * x ^ 2
  return(dpois(y, lambda = exp(log_mu), log = TRUE))
}
pars &lt;- c("alpha", "beta", "gamma")
pois_quad &lt;- adjust_loglik(pois_glm_loglik, y = y, x = x, par_names = pars)
conf_intervals(pois_quad)
</code></pre>


</div>