<div class="container">

<table style="width: 100%;"><tr>
<td>Transition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Monitor Transitions in Cluster Solutions.</h2>

<h3>Description</h3>

<p>Model and trace the evolution of clusters evolving over time in cumulative
datasets. A typical call to <code>Transition()</code> function involves three essential pieces:
the data input <code>(listdata, listclus, overlap)</code>, choice of window <code>swSize</code>,
and the threshold parameters. The function either receive a list of datasets arriving at
time points <code>t_1, t_2, t_3, ..., t_n</code> respectively, list of clustering solutions
extracted from cumulative datasets at successive time points, or list of objects of class
<code>OverLap</code> (see <strong>Details</strong>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">Transition(
  listdata,
  swSize = 1,
  Overlap = NULL,
  listclus = NULL,
  typeind = 1,
  Survival_thrHold = 0.7,
  Split_thrHold = 0.3,
  location_thrHold = 0.3,
  density_thrHold = 0.3,
  k = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>listdata</code></td>
<td>
<p>List of numeric matrices containing datasets <code>d_1, d_2, ..., d_n</code>,
or a list of objects that can be coerced to such matrices, for instance, data frames.
Each element of the list contain dataset <code>d_i</code> evolving at corresponding time point
<code>t_i</code>. The number of clusters in each accumulative data matrix is specified by the
argument <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swSize</code></td>
<td>
<p>Integer value (1, length(listdata)) indicating size of the sliding window. As time goes
by, each window consist only objects that fall in the interval [t-swSize+1, t], while older objects
are discarded. The default value of <code>swSize = 1</code> indicate landmark window model, where objects over
the entire history are included i.e. [1, t]. Size of sliding window can only be provided if <code>listdata</code>
arguments is choosen. If there are total <code>n</code> time stamps and a window of size <code>swSize</code> is
selected then entire history would be devided into <code>n-swSize+2</code> window panes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Overlap</code></td>
<td>
<p>A list of objects as produced by the <code>Overlap()</code> method. The object contains a matrix of similarity
indices between clusters, and the summaries of clusters extracted at first and second clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listclus</code></td>
<td>
<p><code>listclus</code> is a list of nested lists containing clustering solutions <code class="reqn">\xi_1, \xi_2, ..., \xi_n</code> at
time points <code>{t1, t2,···, tn}</code> respectively, and having the same length as the number of time points. The <code>i^th</code>
element of <code>listclus</code> is a nested list that contain set of clusters as matrices at corresponding time point <code>t_i</code>
i.e. <code class="reqn">\xi_i = {X1, X2,···, Xki}</code>. For more details, <em>see</em> <strong>Examples</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeind</code></td>
<td>
<p>Type indicator. <code>typeind = 1</code> indicates that the raw data is provided in
<code>listdata</code> argument, <code>typeind = 2</code> indicates that the <code>OverLap</code> objects are provided,
whereas <code>typeind = 3</code> indicates that list of clusters are provided using <code>listclus</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Survival_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for survival of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Split_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for split of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>location_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for shift in location of survived clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for changes in density of Survived clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Numeric Vector of length <code>vector("numeric", length = n-swSize+2)</code>. In the case of landmark window, its length
is <code>n</code>, whereas in case of sliding window model its length is <code>n-swSize+2</code>, where <code>n</code> is the number of time points
and <code>swSize</code> is the size of the sliding window. This argument should only be provided if <code>listdata</code> argument is chosen.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>Transition()</code> function apply 'MONIC' algorithm presented by Spiliopoulou et.al (2006) to trace
changes in cluster solutions of dynamic data sets. The changes includes two types of transition i.e. External transition
and Internal transition. External Transition consist of 'Survive', 'Split', 'Merge', 'Disappeared' and 'newly emerged' candidates,
while Internal transition consist of changes in location and cohesion of the survived clusters. The <code>listdata</code> argument
allow user to import dynamic datasets as a list of matrices or data frames, where each element of the list is a matrix containing
data set at a single time point. Each dataset are clustered by 'kmeans' algorithm using default settings of <code>cclust()</code> function
from <code>flexclust</code> package. The number of clusters at each time stamp can be import by <code>k</code> argument of the function,
which is a vector of integers encompassing number of partitions in corresponding datasets of <code>listdata</code> argument. Once the datasets are
clustered, the 'Overlap' matrices in clustering at consecutive time stamps are calculated. The Overlap matrix is
calculated by using algorithm presented by Ntoutsi, I., et.al (2012). These 'Overlap' matrices are used to trace the
transitions occurred in cluster solutions.
Alternatively, the user can directly import list of 'Overlap' matrices between consecutive clustering. The Overlap
matrix can be calculated using <code>Overlap(obj, e1, e2)</code> method of the package, where 'obj' is the object of class
<code>OverLap</code> and e1, e2 are any clustering at time stamp i and j respectively.
As a third option user can provide list of clusters at each data point utilizing <code>listclus</code> argument. Each element
of the <code>listclus</code> is a nested list, which holds clusters at a single time stamp.
</p>


<h3>Value</h3>

<p>Returns A list of class <code>Monic</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Survive</code></td>
<td>
<p>Number of clusters survived.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Merged</code></td>
<td>
<p>Number of clusters merged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Split</code></td>
<td>
<p>Number of clusters split.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Died</code></td>
<td>
<p>Number of clusters disappeared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.Emerged</code></td>
<td>
<p>Number of newly emerged clusters, which are not upshot of any external transition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SurvivalCanx</code></td>
<td>
<p>A vector of integers indicating candidates from the first clustering
survived to the latter time stamp</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SurvivalCany</code></td>
<td>
<p>A vector of integers indicating candidates of second clustering, that
clinch the survival candidates from first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SplitCanx</code></td>
<td>
<p>A vector of integers indicating candidate(s) that split into various daughter clusters from
first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SplitCany</code></td>
<td>
<p>List of integer vector(s) designating candidates appeared, as a result of splits
from first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MergeCanx</code></td>
<td>
<p>List of integer vector(s) designating Candidates that spliced together to form
new clusters. Each element of the list gives candidates that merge together to form one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MergeCany</code></td>
<td>
<p>Vector of integers designating candidates that emerged, as a result of merger
of different candidates from first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EmergCan</code></td>
<td>
<p>Vector of integers contain Newly emerged candidates, which are not result of
any external transition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SurvivalRatio</code></td>
<td>
<p>The Ratio of survived clusters at second clustering to the total number
of clusters at first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AbsorptionRatio</code></td>
<td>
<p>Ratio of number of merged clusters to total number of clusters at first
clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>passforwardRatio</code></td>
<td>
<p>Sum of SurvivalRatio and AbsorptionRatio. This gives the ratio of
clusters that is also present at second clustering either in the form of survival or absorption.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Overlap</code></td>
<td>
<p>A numeric matrix containing overlap of the two clustering. The rows of matrix
indicate first clustering, while columns indicate second clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Centersx</code></td>
<td>
<p>A matrix of cluster centers from first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Centersx</code></td>
<td>
<p>A matrix of cluster centers from second clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rx</code></td>
<td>
<p>A numeric vector containing radius of each cluster from first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ry</code></td>
<td>
<p>A numeric vector containing radius of each cluster from second clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avgDisx</code></td>
<td>
<p>A numeric vector containing average distance of points in a cluster from its center in first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avgDisy</code></td>
<td>
<p>A numeric vector containing average distance of points in a cluster from its center in second clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ShiftLocCan</code></td>
<td>
<p>A vector of integers comprises of Survived candidates with shift in location.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NoShiftLocCan</code></td>
<td>
<p>A vector of integers comprises of Survived candidates with no shift in location.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MoreCompactCan</code></td>
<td>
<p>A Vector of integers comprises of Survived candidates, which becomes more compact.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MoreDiffuseCan</code></td>
<td>
<p>A Vector of integers comprises of Survived candidates, which becomes more diffuse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NoChangeCompactCan</code></td>
<td>
<p>A Vector of integers comprises of Survived candidates, with no changes in compactness.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Location.diff</code></td>
<td>
<p>A numeric vector containing Distance between the centers of survived clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Compactness.diff</code></td>
<td>
<p>A numeric vector containing Difference between compactness of survived clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cluster_Tracex</code></td>
<td>
<p>A vector containing result of each cluster from first clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cluster_Tracey</code></td>
<td>
<p>A Vector representing result of each cluster from second clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterMem</code></td>
<td>
<p>A vector of integers (from 1 to k) indicating the point to which cluster it is allocated from second clusterig.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Spiliopoulou, M., Ntoutsi, I., Theodoridis, Y., Schult, R. MONIC: modeling and monitoring cluster
transitions. In: Eliassi-Rad, T., Ungar, L. H., Craven, M., Gunopulos, D. (eds.) ACM SIGKDD 2006, pp. 706-711. ACM, Philadelphia (2006).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### Example 1: typeind = 1 (listdata Argument)

d1 &lt;- Data2D[[1]][c("X1", "X2")]
d2 &lt;- Data2D[[2]][c("X1", "X2")]
d3 &lt;- Data2D[[3]][c("X1", "X2")]

listdata &lt;- list(d1, d2, d3)

p &lt;- Transition(listdata = listdata, swSize = 1, typeind = 1, Survival_thrHold = 0.8,
                Split_thrHold = 0.3, density_thrHold = 0.3, location_thrHold = 0.3, k = c(3,3,2))

### Example 2: typeind = 3 (listclus Argument)

D1 &lt;- d1
D2 &lt;- merge(d1, d2, all.x = TRUE, all.y = TRUE)
D3 &lt;- merge(D2, d3, all.x = TRUE, all.y = TRUE)

set.seed(10)
f1 &lt;- kmeans(D1, 3)
C1 &lt;- list()
for(i in 1:3)C1[[i]] &lt;- D1[f1$cluster == i, ]
f2 &lt;- kmeans(D2, 3)
C2 &lt;- list()
for(i in 1:3)C2[[i]] &lt;- D2[f2$cluster == i, ]
f3 &lt;- kmeans(D3, 2)
C3 &lt;- list()
for(i in 1:2)C3[[i]] &lt;- D3[f3$cluster == i, ]

listclus &lt;- list(C1, C2, C3)

p &lt;- Transition(listclus = listclus, typeind = 3, Survival_thrHold = 0.8,
                Split_thrHold = 0.3, density_thrHold = 0.3, location_thrHold = 0.3)

### Example 3: typeind = 3 (Overlap Argument)

obj &lt;- new("OverLap")
Overlap1 &lt;- Overlap(obj, e1 = C1, e2 = C2)
Overlap2 &lt;- Overlap(obj, e1 = C2, e2 = C3)

Overlap &lt;- list(Overlap1, Overlap2)
p &lt;- Transition(Overlap = Overlap, typeind = 2, Survival_thrHold = 0.8,
                Split_thrHold = 0.3, density_thrHold = 0.3, location_thrHold = 0.3)


</code></pre>


</div>