<div class="container">

<table style="width: 100%;"><tr>
<td>cooks.distance.zlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cook's Distance for Complex Linear Models</h2>

<h3>Description</h3>

<p>Calculates the Cook's distances (technically a divergence, i.e. distance squared) of a complex linear model.
These serve as a measurement of how much each input data point had on the model.<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'zlm'
cooks.distance(model, lever = zhatvalues(model), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>An object of class "lm" or "rlm". Can be complex or numeric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lever</code></td>
<td>
<p>A list of leverage scores with the same length as <code>model$residuals</code>. By default zhatvalues is called on <code>model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters. Only used if <code>model</code> is numeric; in which case they are passed to <code>stats::cooks.distance</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider a linear model relating a response vector <code>y</code> to a predictor vector <code>x</code>, both of length <code>n</code>. Using the model and predictor vector we can
calculate a vector of predicted values <code>yh</code>. <code>y</code> and <code>yh</code> are points in a <code>n</code> dimensional output space. If we drop the <code>i</code>-th element of <code>x</code> and <code>y</code>, then fit another
model using the "dropped <code>i</code>" vectors, we can get another point in output space, <code>yhi</code>. The squared Euclidean distance between <code>yh</code> and <code>yhi</code>, divided by the
rank of the model (<code>p</code>) times its mean squared error <code>s^2</code>, is the <code>i</code>-th Cook's distance.<br>
\[D_i = (yh - yhi)^t (yh - yhi) / p s^2\]<br>
A more elegant way to calculate it, which this function uses, is with the influence scores, <code>hii</code>.<br>
\[D_i = |r_i|^2 / p s^2 hii / (1 - hii)\]<br>
Where <i>r_i</i> is the <i>i</i>-th residual, and <i>^t</i> is the conjugate transpose.
</p>


<h3>Value</h3>

<p>A numeric vector. The elements are the Cook's distances of each data point in <code>model</code>.
</p>


<h3>Note</h3>

<p>This is a simpler function than stats::cooks.distance, and does not understand any additional parameters not listed in this entry.
</p>


<h3>References</h3>

<p>R. D. Cook, Influential Observations in Linear Regression, Journal of the American Statistical Association 74, 169 (1979).
</p>


<h3>See Also</h3>

<p>stats::cooks.distance, zhatvalues
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slop*xx + interc + e)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
cooks.distance(fit)
</code></pre>


</div>