<div class="container">

<table style="width: 100%;"><tr>
<td>DoptBCD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Atkinson's <code class="reqn">D_A</code>-optimal Biased Coin Design</h2>

<h3>Description</h3>

<p>Allocates patients to one of two treatments based on the <code class="reqn">D_A</code>-optimal biased coin design in the presence of the prognostic factors proposed by Atkinson A C (1982) &lt;doi:10.2307/2335853&gt;.
</p>


<h3>Usage</h3>

<pre><code class="language-R">DoptBCD(data)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame. A row of the dataframe corresponds to the covariate profile of a patient.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Consider an experiment involving <code class="reqn">n</code> patients. Assuming a linear model between response and covariates, Atkinson's <code class="reqn">D_A</code>-optimal biased coin design sequentially assigns patients to minimize the variance of estimated treatment effects. Supposing <code class="reqn">j</code> patients have been assigned, the probability of assigning the <code class="reqn">(j+1)</code>th patient to treatment 1 is
</p>
<p style="text-align: center;"><code class="reqn">\frac{[1 - (1; \bold{x}^t_{j+1})(\bold{F}^t_j\bold{F}_j)^{-1}\bold{b}_j]^2}{[1-(1; \bold{x}^t_{j+1})(\bold{F}_j^t\bold{F}_j)^{-1}\bold{b}_j]^2+[1 + (1; \bold{x}_{j+1}^t)(\bold{F}_j^t\bold{F}_j)^{-1}\bold{b}_j]^2},</code>
</p>

<p>where <code class="reqn">\bold{X} = (\bold{x_i}, i = 1, \dots, j)</code> and <code class="reqn">\bold{x}_i = (x_{i1}, \dots, x_{ij})</code> denote the covariate profile of the <code class="reqn">i</code>th patient; and <code class="reqn">\bold{F}_j = [\bold{1}_j; \bold{X}]</code> is the information matrix; and <code class="reqn">\bold{b}_j^T=(2\bold{T}_j-\bold{1}_j)^T\bold{F}_j</code>, <code class="reqn">\bold{T}_j = (T_1, \dots, T_j)</code> is a sequence containing the first <code class="reqn">j</code> patients' allocations.
</p>
<p>Details of the procedure can be found in A.C.Atkinson (1982).
</p>


<h3>Value</h3>

<p>It returns an object of <code>class</code> <code>"carandom"</code>. 
</p>
<p>An object of class <code>"carandom"</code> is a list containing the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>datanumeric</code></td>
<td>
<p>a bool indicating whether the data is a numeric data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>a character string giving the name(s) of the included covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strt_num</code></td>
<td>
<p>the number of strata.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_num</code></td>
<td>
<p>the number of covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level_num</code></td>
<td>
<p>a vector of level numbers for each covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of patients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cov_Assig</code></td>
<td>
<p>a <code>(cov_num + 1) * n</code> matrix containing covariate profiles for all patients and the corresponding assignments. The <code class="reqn">i</code>th column represents the <code class="reqn">i</code>th patient. The first <code>cov_num</code> rows include patients' covariate profiles, and the last row contains the assignments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assignments</code></td>
<td>
<p>the randomization sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>All strata</code></td>
<td>
<p>a matrix containing all strata involved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Diff</code></td>
<td>
<p>a matrix with only one column. There are final differences at the overall, within-stratum, and within-covariate-margin levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string describing the randomization procedure to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Data Type</code></td>
<td>
<p>a character string giving the data type, <code>Real</code> or <code>Simulated</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>framework</code></td>
<td>
<p>the framework of the used randomization procedure: stratified randomization, or model-based method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data frame.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Atkinson A C. <em>Optimum biased coin designs for sequential clinical trials with prognostic factors</em>[J]. Biometrika, 1982, 69(1): 61-67.
</p>
<p>Ma W, Ye X, Tu F, Hu F. <em>carat: Covariate-Adaptive Randomization for Clinical Trials</em>[J]. Journal of Statistical Software, 2023, 107(2): 1-47.
</p>


<h3>See Also</h3>

<p>See <code>DoptBCD.sim</code> for allocating patients with covariate data generating mechanism.  
See <code>DoptBCD.ui</code> for the command-line user interface.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># a simple use
## Real Data
df &lt;- data.frame("gender" = sample(c("female", "male"), 100, TRUE, c(1 / 3, 2 / 3)), 
                 "age" = sample(c("0-30", "30-50", "&gt;50"), 100, TRUE), 
                 "jobs" = sample(c("stu.", "teac.", "others"), 100, TRUE), 
                 stringsAsFactors = TRUE)
Res &lt;- DoptBCD(df)
## view the output
Res

## view all patients' profile and assignments
## Res$Cov_Assig

## Simulated Data
n &lt;- 1000
cov_num &lt;- 2 

level_num &lt;- c(2, 5)
# Set pr to follow two tips:
#(1) length of pr should be sum(level_num);
#(2)sum of probabilities for each margin should be 1.
pr &lt;- c(0.4, 0.6, rep(0.2, times = 5))
Res.sim &lt;- DoptBCD.sim(n, cov_num, level_num, pr)
## view the output
Res.sim

## view the difference between treatment 1 and treatment 2 
##             at overall, within-strt. and overall levels
Res.sim$Diff


N &lt;- 5
n &lt;- 100
cov_num &lt;- 2
level_num &lt;- c(3, 5) # &lt;&lt; adjust to your CPU and the length should correspond to cov_num
## Set pr to follow two tips:
## (1) length of pr should be sum(level_num);
## (2)sum of probabilities for each margin should be 1
pr &lt;- c(0.3, 0.4, 0.3, rep(0.2, times = 5))
omega &lt;- c(0.2, 0.2, rep(0.6 / cov_num, times = cov_num))

## generate a container to contain Diff
DH &lt;- matrix(NA, ncol = N, nrow = 1 + prod(level_num) + sum(level_num))
DA &lt;- matrix(NA, ncol = N, nrow = 1 + prod(level_num) + sum(level_num))
for(i in 1 : N){
  result &lt;- HuHuCAR.sim(n, cov_num, level_num, pr, omega)
  resultA &lt;- StrBCD.sim(n, cov_num, level_num, pr)
  DH[ , i] &lt;- result$Diff; DA[ , i] &lt;- resultA$Diff
}
## do some analysis
require(dplyr)

## analyze the overall imbalance
Ana_O &lt;- matrix(NA, nrow = 2, ncol = 3)
rownames(Ana_O) &lt;- c("HuHuCAR", "DoptBCD")
colnames(Ana_O) &lt;- c("mean", "median", "95%quantile")
temp &lt;- DH[1, ] %&gt;% abs
tempA &lt;- DA[1, ] %&gt;% abs
Ana_O[1, ] &lt;- c((temp %&gt;% mean), (temp %&gt;% median),
                (temp %&gt;% quantile(0.95)))
Ana_O[2, ] &lt;- c((tempA %&gt;% mean), (tempA %&gt;% median),
                (tempA %&gt;% quantile(0.95)))

## analyze the within-stratum imbalances
tempW &lt;- DH[2 : (1 + prod(level_num)), ] %&gt;% abs
tempWA &lt;- DA[2 : 1 + prod(level_num), ] %&gt;% abs
Ana_W &lt;- matrix(NA, nrow = 2, ncol = 3)
rownames(Ana_W) &lt;- c("HuHuCAR", "DoptBCD")
colnames(Ana_W) &lt;- c("mean", "median", "95%quantile")
Ana_W[1, ] = c((tempW %&gt;% apply(1, mean) %&gt;% mean),
               (tempW %&gt;% apply(1, median) %&gt;% mean),
               (tempW %&gt;% apply(1, mean) %&gt;% quantile(0.95)))
Ana_W[2, ] = c((tempWA %&gt;% apply(1, mean) %&gt;% mean),
               (tempWA %&gt;% apply(1, median) %&gt;% mean),
               (tempWA %&gt;% apply(1, mean) %&gt;% quantile(0.95)))

## analyze the marginal imbalance
tempM &lt;- DH[(1 + prod(level_num) + 1) :
              (1 + prod(level_num) + sum(level_num)), ] %&gt;% abs
tempMA &lt;- DA[(1 + prod(level_num) + 1) :
               (1 + prod(level_num) + sum(level_num)), ] %&gt;% abs
Ana_M &lt;- matrix(NA, nrow = 2, ncol = 3)
rownames(Ana_M) &lt;- c("HuHuCAR", "DoptBCD")
colnames(Ana_M) &lt;- c("mean", "median", "95%quantile")
Ana_M[1, ] = c((tempM %&gt;% apply(1, mean) %&gt;% mean),
               (tempM %&gt;% apply(1, median) %&gt;% mean),
               (tempM %&gt;% apply(1, mean) %&gt;% quantile(0.95)))
Ana_M[2, ] = c((tempMA %&gt;% apply(1, mean) %&gt;% mean),
               (tempMA %&gt;% apply(1, median) %&gt;% mean),
               (tempMA %&gt;% apply(1, mean) %&gt;% quantile(0.95)))

AnaHP &lt;- list(Ana_O, Ana_M, Ana_W)
names(AnaHP) &lt;- c("Overall", "Marginal", "Within-stratum")

AnaHP
</code></pre>


</div>