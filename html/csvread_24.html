<div class="container">

<table style="width: 100%;"><tr>
<td>csvread</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Specialized CSV File Loader.</h2>

<h3>Description</h3>

<p>Package <code>csvread</code> contains a fast specialized CSV and other delimited
file loader, and a basic 64-bit integer class to aid in reading 64-bit
integer values.
</p>
<p>Given a list of the column types, function <code>csvread</code> parses the CSV file
and returns a data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">csvread(
  file,
  coltypes,
  header,
  colnames = NULL,
  nrows = NULL,
  verbose = FALSE,
  delimiter = ",",
  na.strings = c("NA", "na", "NULL", "null", "")
)

map.coltypes(file, header, nrows = 100, delimiter = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Path to the CSV file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coltypes</code></td>
<td>
<p>A vector of column types, e.g., <code>c("integer", "string")</code>.
The accepted types are "integer", "double", "string", "long" and "longhex".
</p>

<ul>
<li> <p><code>integer</code> - the column is parsed into an R integer type (32 bit)
</p>
</li>
<li> <p><code>double</code> - the column is parsed into an R double type
</p>
</li>
<li> <p><code>string</code> - the column is loaded as character type
</p>
</li>
<li> <p><code>long</code> - the column is interpreted as the decimal representation of a 64-bit
integer, stored as a double and assigned the <code>int64</code> class.
</p>
</li>
<li> <p><code>longhex</code> - the column is interpreted as the hex representation of a 64-bit
integer, stored as a double and assigned the <code>int64</code> class
with an additional attribute <code>base = 16L</code> that is used for printing.
</p>
</li>
<li> <p><code>integer64</code> - same as <code>long</code> but produces a column of class <code>integer64</code>,
which should be compatible with package <code>bit64</code> (untested).
</p>
</li>
<li> <p><code>verbose</code> - if <code>TRUE</code>, the function prints number of lines counted in the file.
</p>
</li>
<li> <p><code>delimiter</code> - a single character delimiter, default is <code>","</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>
<p>TRUE (default) or FALSE; indicates whether the file has a header
and serves as the source of column names if <code>colnames</code> is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colnames</code></td>
<td>
<p>Optional column names for the resulting data frame. Overrides the header, if header is present.
If NULL, then the column names are taken from the header, or, if there is no header,
the column names are set to 'COL1', 'COL2', etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrows</code></td>
<td>
<p>If NULL, the function first counts the lines in the file. This step can be avoided if the number
of lines is known by providing a value to <code>nrows</code>. On the other hand, <code>nrows</code> can be
used to read only the first lines of the CSV file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> and <code>nrows</code> is <code>NULL</code>, the function prints
number of lines counted in the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delimiter</code></td>
<td>
<p>A single character delimiter, default is <code>","</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.strings</code></td>
<td>
<p>A vector of strings to be considered NA in the input file.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>csvread</code> provides functionality for loading large (10M+ lines) CSV
and other delimited files, similar to read.csv, but typically faster and
using less memory than the standard R loader. While not entirely general,
it covers many common use cases when the types of columns in the CSV file
are known in advance. In addition, the package provides a class 'int64',
which represents 64-bit integers exactly when reading from a file. The
latter is useful when working with 64-bit integer identifiers exported from
databases. The CSV file loader supports common column types including
<code>integer</code>, <code>double</code>, <code>string</code>, and <code>int64</code>, leaving
further type transformations  to the user.
</p>
<p>If number of columns, which is inferred from the number of provided <code>coltypes</code>, is greater than
the actual number of columns, the extra columns are still created. If the number of columns is
less than the actual number of columns in the file, the extra columns in the file are ignored.
Commas included in double quotes will be considered part of the field, rather than a separator, but
double quotes will NOT be stripped. Runaway double quotes will end at the end of the line.
</p>
<p>See also <code>int64</code> for information about dealing with 64-bit
integers when loading data from CSV files.
</p>


<h3>Value</h3>

<p>A data frame containing the data from the CSV file.
</p>


<h3>Maintainer</h3>

<p>Sergei Izrailev
</p>


<h3>Copyright</h3>

<p>Copyright (C) Collective, Inc.; with portions Copyright (C) Jabiru Ventures LLC
</p>


<h3>License</h3>

<p>Apache License, Version 2.0,
available at http://www.apache.org/licenses/LICENSE-2.0
</p>


<h3>URL</h3>

<p>http://github.com/jabiru/csvread
</p>


<h3>Installation from github</h3>

<p><code>devtools::install_github("jabiru/csvread")</code>
</p>


<h3>Author(s)</h3>

<p>Sergei Izrailev
</p>


<h3>See Also</h3>

<p><code>int64</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Basic use case when column types are known and there's no missing data.

frm &lt;- csvread("inst/10rows.csv",
	coltypes = c("longhex", "string", "double", "integer", "long"),
	header = FALSE)

frm
# COL1       COL2     COL3 COL4 COL5
# 1  11fb89c1558c792 2011-05-06 0.150001 4970 4977
# 2  11fb89c1558c792 2011-05-06 0.150001 4970 4987
# 3  11fb89c1558c792 2011-05-06 0.150001 5200 5528
# 4  11fb89c1558c792 2011-05-06 0.150001 4970 5004
# 5  11fb89c1558c792 2011-05-06 0.150001 4970 4980
# 6  11fb89c1558c792 2011-05-06 0.150001 4970 5020
# 7  11fb89c1558c792 2011-05-06 0.150001 4970 5048
# 8  11fb89c1558c792 2011-05-06 0.150001 4970 5035
# 9  11fb89c1558c792 2011-05-06 0.150001 4970 4971
# 10 11fb89c1558c792 2011-05-06 0.150001 4970 4973

typeof(frm$COL1)
# [1] "double"
class(frm$COL1)
# [1] "int64"

typeof(frm$COL5)
# [1] "double"
class(frm$COL5)
# [1] "int64"

#### Examples with missing data.

## The input file contains values "NA", "NA ", " NA ", "NULL", "na"
## and missing fields in various columns.

writeLines(scan("inst/10rows_na.csv", "character", sep = "\n"))
# Read 10 items
# 11fb89c1558c792,2011-05-06,0.150001,4970,4977
# 11fb89c1558c792,2011-05-06,0.150001,4970,4987
# 11fb89c1558c792, NA ,0.150001,NA ,5528
# NA,2011-05-06,0.150001,4970,5004
# 11fb89c1558c792,na,0.150001,4970,4980
# 11fb89c1558c792,2011-05-06,NA,4970,5020
# 11fb89c1558c792,2011-05-06,0.150001,NULL,5048
# 11fb89c1558c792,2011-05-06,0.150001,4970,NA
# ,2011-05-06,0.150001,4970,4971
# 11fb89c1558c792,2011-05-06,0.150001,4970,

## By default, all missing fields in this input are handled, except
## for the " NA " in a character column COL3, which remains unchanged.
## This is the intended behavior, similar to that of read.csv.

frm &lt;- csvread("inst/10rows_na.csv",
	coltypes = c("longhex", "string", "double", "integer", "long"),
	header = FALSE)

frm
# COL1       COL2     COL3 COL4 COL5
# 1  11fb89c1558c792 2011-05-06 0.150001 4970 4977
# 2  11fb89c1558c792 2011-05-06 0.150001 4970 4987
# 3  11fb89c1558c792        NA  0.150001   NA 5528
# 4             &lt;NA&gt; 2011-05-06 0.150001 4970 5004
# 5  11fb89c1558c792       &lt;NA&gt; 0.150001 4970 4980
# 6  11fb89c1558c792 2011-05-06       NA 4970 5020
# 7  11fb89c1558c792 2011-05-06 0.150001   NA 5048
# 8  11fb89c1558c792 2011-05-06 0.150001 4970 &lt;NA&gt;
# 9             &lt;NA&gt; 2011-05-06 0.150001 4970 4971
# 10 11fb89c1558c792 2011-05-06 0.150001 4970 &lt;NA&gt;

## End(Not run)
## Not run: 
#### The column types can be guessed by using map.coltypes.

coltypes &lt;- map.coltypes("inst/10rows.csv", header = FALSE)
coltypes
#       V1        V2        V3        V4        V5
# "string"  "string"  "double" "integer" "integer"

## Note the difference when "NA"s are present in an integer column 4,
## which is then considered to be a string column.
coltypes.na &lt;- map.coltypes("inst/10rows_na.csv", header = FALSE)
coltypes.na
#        V1        V2        V3        V4        V5
#  "string"  "string"  "double"  "string" "integer"

frm &lt;- csvread(file = "inst/10rows.csv", coltypes = coltypes,
   header = F, verbose = T)
# Counted 10 lines.

frm
#               COL1       COL2     COL3 COL4 COL5
# 1  11fb89c1558c792 2011-05-06 0.150001 4970 4977
# 2  11fb89c1558c792 2011-05-06 0.150001 4970 4987
# 3  11fb89c1558c792 2011-05-06 0.150001 5200 5528
# 4  11fb89c1558c792 2011-05-06 0.150001 4970 5004
# 5  11fb89c1558c792 2011-05-06 0.150001 4970 4980
# 6  11fb89c1558c792 2011-05-06 0.150001 4970 5020
# 7  11fb89c1558c792 2011-05-06 0.150001 4970 5048
# 8  11fb89c1558c792 2011-05-06 0.150001 4970 5035
# 9  11fb89c1558c792 2011-05-06 0.150001 4970 4971
# 10 11fb89c1558c792 2011-05-06 0.150001 4970 4973
typeof(frm$COL1)
# [1] "character"
class(frm$COL1)
# [1] "character"

typeof(frm$COL5)
# [1] "integer"
class(frm$COL5)
# [1] "integer"

## Convert the first column to int64 manually

frm$COL1 &lt;- as.int64(frm$COL1, base = 16)
frm$COL1
# [1] "11fb89c1558c792" "11fb89c1558c792" "11fb89c1558c792" "11fb89c1558c792"
# [5] "11fb89c1558c792" "11fb89c1558c792" "11fb89c1558c792" "11fb89c1558c792"
# [9] "11fb89c1558c792" "11fb89c1558c792"
typeof(frm$COL1)
# [1] "double"
class(frm$COL1)
# [1] "int64"

## Print the first value in base 10.
as.character.int64(frm$COL1[1], base = 10)
# [1] "80986298828507026"

#### Character (string) columns with NAs and non-default na.strings

## A file with NAs and missing values: note that the in the first
## column, an empty string in row 9 is not considered NA because
## na.strings are set to "NA". By default, the empty string will be
## considered NA. Also, in column 2, rows 3 and 5, the values are
## " NA " (with spaces) and "na", respectively, because they don't
## match values in na.strings and therefore are not considered to be NA.

coltypes
#       V1        V2        V3        V4        V5
# "string"  "string"  "double" "integer" "integer"

frm &lt;- csvread(file = "inst/10rows_na.csv", coltypes = coltypes,
   header = F, verbose = T, na.strings = "NA")
# Counted 10 lines.

frm
#               COL1       COL2     COL3 COL4 COL5
# 1  11fb89c1558c792 2011-05-06 0.150001 4970 4977
# 2  11fb89c1558c792 2011-05-06 0.150001 4970 4987
# 3  11fb89c1558c792        NA  0.150001   NA 5528
# 4             &lt;NA&gt; 2011-05-06 0.150001 4970 5004
# 5  11fb89c1558c792         na 0.150001 4970 4980
# 6  11fb89c1558c792 2011-05-06       NA 4970 5020
# 7  11fb89c1558c792 2011-05-06 0.150001   NA 5048
# 8  11fb89c1558c792 2011-05-06 0.150001 4970   NA
# 9                  2011-05-06 0.150001 4970 4971
# 10 11fb89c1558c792 2011-05-06 0.150001 4970   NA


## End(Not run)
</code></pre>


</div>