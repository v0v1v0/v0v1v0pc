<div class="container">

<table style="width: 100%;"><tr>
<td>zykloid.scaleP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Wrapper for <code>zykloid</code> which scales a cycloid by the
circle its peaks are located on and allows free positioning
</h2>

<h3>Description</h3>

<p>While <code>zykloid</code> provides the basic functionality for
calculating cycloids, this functions allows to re-size a cycloid
by freely setting the radius of the circle its peaks are located
on. In addition, the cycloid can be re-positioned by locating
the fixed circle's midpoint. This function behaves similarly as
<code>zykloid.scaleAa</code>. See details. See Figures 1, 2, and
<code>zykloid</code> for the geometrical principles of cycloids.
</p>


<h3>Usage</h3>

<pre><code class="language-R">zykloid.scaleP(A, a, lambda, hypo = TRUE, Cx = 0, Cy = 0,
               RadiusP = 1, steps = 360, start = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>

<p>The Radius of the fix circle before re-sizing. Must be an integer
Number &gt; 0. Together with <code class="reqn">a</code> (see below), <code class="reqn">A</code> is only
determining the cycloid's shape and number of peaks (see
<code>npeaks</code>), while its actual size is defined by the
argument <code class="reqn">RadiusP</code> (see below).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>

<p>The radius of the moving circle before re-sizing. Must be an
integer Number &gt; 0. Together with <code class="reqn">A</code>, <code class="reqn">a</code> only determines
the cycloid's shape and number of peaks (see <code>npeaks</code>),
while its actual size is defined via the argument <code class="reqn">RadiusP</code>
(see below).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>The distance of the tracepoint from the moving circle's (<code class="reqn">cmov</code>)
centre in relative units of its radius <code class="reqn">a</code>. <code class="reqn">lambda = 1</code>
means that the tracepoint is located on <code class="reqn">cmov</code>'s circumference.
For <code class="reqn">lambda &lt; 1</code>, the tracepoint is on <code class="reqn">cmov</code>'s area, e.g.
if <code class="reqn">lambda = 0.5</code>, it is halfway between <code class="reqn">cmov</code>'s centre
and its circumference. If <code class="reqn">lambda &gt; 1</code> the tracepoint is outside
<code class="reqn">cmov</code>'s area, you might imagine it being attached to a rod
which is attached to cmov and crosses its centre. E.g. <code class="reqn">lambda = 2</code>
would mean that the tracepoint's distance from <code class="reqn">cmov</code>'s centre
equals <code class="reqn">2*a</code>. <code class="reqn">lambda = 0</code> produces a circle because the
tracepoint is identical with <code class="reqn">cmov</code>'s centre.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hypo</code></td>
<td>

<p>logical. If TRUE, the resulting figure is a hypocycloid (<code class="reqn">lambda = 1</code>)
or a hypotrochoid (<code class="reqn">lambda != 1</code>), because <code class="reqn">cmov</code> is rolling
along the inner side of the fixed circle (<code class="reqn">cfix</code>). If FALSE,
an epicycloid (<code class="reqn">lambda = 1</code>) or an epitrochoid (<code class="reqn">lambda != 1</code>)
is generated, as <code class="reqn">cmov</code> is rolling at the outside of
<code class="reqn">cfix</code>'s circumference.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cx</code></td>
<td>

<p>x-coordinate of the fix circle's midpoint. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cy</code></td>
<td>

<p>y-coordinate of the fix circle's midpoint. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RadiusP</code></td>
<td>

<p>The actual radius of the circle the cycloid's peaks are located
on. Default is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>

<p>positive integer. The number of steps per circuit of the moving
circle (<code class="reqn">cmov</code>) for which tracepoint positions are calculated.
The default, 360, means steps of 1 degree for the movement of
<code class="reqn">cmov</code>. Analogously, steps = 720 would mean steps of 0.5 degrees.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>Start angle (radians) of the moving circle's (<code class="reqn">cmov</code>) centre
counterclockwise to the horizontal with the fixed circle's (<code class="reqn">cfix</code>)
centre as the pivot. The tracepoint will start at a peak.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function scales the radius of the circle the cycloids peaks
are located on. For hypocycloids and hypotrochoids it will thus
behave the same way as <code>zykloid.scaleAa</code>. For
epicycloids and epitrochoids the output will be different.
While <code>zykloid.scaleAa</code> scales the outer edge of the
figure, zykloid.scaleP always scales the circle where the
peaks of the figure are located on. In the case of epicycloids
and epitrochoids this is at the inside of the figure (see
examples below).<br>
Figure 1 and 2 show the principle behind cycloid construction:
<br><img src="../help/figures/Figure1.png" width="500" height="500" alt="Figure1.png"><img src="../help/figures/Figure2.png" width="500" height="500" alt="Figure2.png"></p>


<h3>Value</h3>

<p>A dataframe with the columns <code class="reqn">x</code> and <code class="reqn">y</code>. Each row represents
a tracepoint position. The positions are ordered along the trace
with the last and the first point being identical in order to
warrant a closed figure when plotting the data.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>See Also</h3>

<p><code>zykloid</code>,
<code>zykloid.scaleA</code>, <code>zykloid.scaleAa</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Epitrochoids with different lambda scaled to the same radius of
# the peak circle
cycl1 &lt;- zykloid.scaleP(A = 21, a = 11, lambda = 1.2, hypo = FALSE,
                         RadiusP = 10)
cycl2 &lt;- zykloid.scaleP(A = 21, a = 11, lambda = 1.0, hypo = FALSE,
                         RadiusP = 10)
cycl3 &lt;- zykloid.scaleP(A = 21, a = 11, lambda = 0.8, hypo = FALSE,
                         RadiusP = 10)
plot (y ~ x, data = cycl1, col = "red", asp = 1, type = "l",
      main = "A = 21, a = 11, RadiusP = 10")
lines(y ~ x, data = cycl2, col = "green")
lines(y ~ x, data = cycl3, col = "blue")
legend("topleft", c("lambda = 1.2", "lambda =  1.0", "lambda =  0.8"),
       lty = rep("solid", 3), col = c("red", "green", "blue"),
       bty = "n")



# Cool Disk by scaling the start angle with an
# exponential function ...
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
n &lt;- 30
ccol &lt;- topo.colors(n)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = 6, lambda = 1,
           start = 2*pi/3 * exp(-0.1 * (i - 1)), hypo = FALSE)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# ... the free space in the centre could be filled with
# the corresponding hypocycloid ...
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
n &lt;- 30
ccol &lt;- topo.colors(n)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = 6, lambda = 1,
           start = 2*pi/3 * exp(-0.1 * (i - 1)), hypo = FALSE)
    lines(y ~ x, data = zzz, col = ccol[i])
    zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = 6, lambda = 1,
           start = 2*pi/3 * exp(-0.1 * (i - 1)), hypo = TRUE)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# ... or the same ring again and again.
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
n &lt;- 30
ccol &lt;- topo.colors(n)
rad &lt;- 6
for(g in c(1:7)) {
    for(i in c(1:n)) {
        zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = rad,
               lambda = 1, start = 2*pi/3 * exp(-0.1 * (i - 1)),
               hypo = FALSE)
        lines(y ~ x, data = zzz, col = ccol[i])
    } # for i
    rad &lt;- rad * 3/5
} # for g
par(op)



# Cauliflower pattern. Here, an exponential function is used
# for scaling the radius of the circle the cycloid's loops
# are on.
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-22, 22), ylim = c(-22, 22))
n &lt;- 15
dcol &lt;- heat.colors(n)
for(i in c(1:n)) {
    lambdax &lt;- seq(2.0, 2.2, 0.1)
    for(j in c(1:length(lambdax))) {
        zzz &lt;- zykloid.scaleP(A = 11, a = 1,
               RadiusP = 15 * exp(-0.3 * (i - 1)),
               lambda = lambdax[j], hypo = FALSE,
               start = pi/2 + (i - 1)*pi/11)
        if(j/2 == floor(j/2)) { colx &lt;- "blue" }
        else                  { colx &lt;- dcol[n + 1 - i] }
        lines(y ~ x, data = zzz, col = colx)
    } # for j
} # for i
par(op)



# Sparkling star
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-15, 15), ylim = c(-15, 15))
llam &lt;- seq(0, 8, 0.2)
ccol &lt;- rainbow(length(llam), start = 2/3, end = 1/3)
for(i in c(1:length(llam))) {
    zzz &lt;- zykloid.scaleP(A = 5, a = 1, RadiusP = 2.1,
           hypo = FALSE, lambda = llam[i], start = pi/5)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)


</code></pre>


</div>