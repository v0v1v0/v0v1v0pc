<div class="container">

<table style="width: 100%;"><tr>
<td>get_isochrone</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute isochrones/isodistances from nodes.</h2>

<h3>Description</h3>

<p>Compute isochrones/isodistances from nodes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_isochrone(Graph, from, lim, setdif = FALSE, keep = NULL, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Graph</code></td>
<td>
<p>An object generated by makegraph or cpp_simplify function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>numeric or character. A vector of one or more vertices from which isochrones/isodistances are calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lim</code></td>
<td>
<p>numeric. A vector of one or multiple breaks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setdif</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>length(lim) &gt; 1</code>, nodes that are reachable in a given break will not appear in a greater one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>numeric or character. Vertices of interest that will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>long</code></td>
<td>
<p>logical. If <code>TRUE</code>, a long <code>data.frame</code> is returned instead of a <code>list</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>length(lim) &gt; 1</code>, value is a <code>list</code> of <code>length(from)</code>, containing <code>list</code>s of <code>length(lim)</code>.
</p>
<p>All algorithms are <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>For large graph, <code>keep</code> argument can be used for saving memory.
</p>


<h3>Value</h3>

<p><code>list</code> or a <code>data.frame</code> containing reachable nodes below cost limit(s).
</p>


<h3>Note</h3>

<p><code>get_isochrone()</code> recursively perform Dijkstra algorithm for each <code>from</code> nodes and stop when cost limit is reached.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

#Construct directed graph
directed_graph&lt;-makegraph(edges,directed=TRUE)

#Get nodes reachable around node 4 with maximum distances of 1 and 2
iso&lt;-get_isochrone(Graph=directed_graph,from = "4",lim=c(1,2))

#With setdif set to TRUE
iso2&lt;-get_isochrone(Graph=directed_graph,from = "4",lim=c(1,2),setdif=TRUE)
print(iso)
print(iso2)
</code></pre>


</div>