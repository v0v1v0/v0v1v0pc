<div class="container">

<table style="width: 100%;"><tr>
<td>convex_clustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find a target number of clusters in the data using convex clustering</h2>

<h3>Description</h3>

<p><code>convex_clustering</code> attempts to find the number of clusters
specified by the user by means of convex clustering. The algorithm looks for
each number of clusters between <code>target_low</code> and <code>target_high</code>. If
<code>target_low</code> = <code>target_high</code>, the algorithm searches for a single
clustering. It is recommended to specify a range around the desired number of
clusters, as not each number of clusters between 1 and <code>nrow(X)</code> may be
attainable due to numerical inaccuracies.
</p>


<h3>Usage</h3>

<pre><code class="language-R">convex_clustering(
  X,
  W,
  target_low,
  target_high = NULL,
  max_iter_phase_1 = 2000,
  max_iter_phase_2 = 20,
  lambda_init = 0.01,
  factor = 0.025,
  tau = 0.001,
  center = TRUE,
  scale = TRUE,
  eps_conv = 1e-06,
  burnin_iter = 25,
  max_iter_conv = 5000,
  save_clusterpath = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> numeric matrix. This function assumes that each
row represents an object with <code class="reqn">p</code> attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>A <code>sparseweights</code> object, see sparse_weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_low</code></td>
<td>
<p>Lower bound on the number of clusters that should be
searched for. If <code>target_high = NULL</code>, this is the exact number of
clusters that is searched for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_high</code></td>
<td>
<p>Upper bound on the number of clusters that should be
searched for. Default is <code>NULL</code>, in that case, it is set equal to
<code>target_low</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_phase_1</code></td>
<td>
<p>Maximum number of iterations to find an upper and
lower bound for the value for lambda for which the desired number of clusters
is attained. Default is 2000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_phase_2</code></td>
<td>
<p>Maximum number of iterations to to refine the upper
and lower bounds for lambda. Default is 20.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_init</code></td>
<td>
<p>The first value for lambda other than 0 to use for convex
clustering. Default is 0.01.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>
<p>The percentage by which to increase lambda in each step.
Default is 0.025.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Parameter to compute the threshold to fuse clusters. Default is
0.001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>If <code>TRUE</code>, center <code>X</code> so that each column has mean
zero. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If <code>TRUE</code>, scale the loss function to ensure that the
cluster solution is invariant to the scale of <code>X</code>. Default is
<code>TRUE</code>. Not recommended to set to <code>FALSE</code> unless comparing to
algorithms that minimize the unscaled convex clustering loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps_conv</code></td>
<td>
<p>Parameter for determining convergence of the minimization.
Default is 1e-6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin_iter</code></td>
<td>
<p>Number of updates of the loss function that are done
without step doubling. Default is 25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_conv</code></td>
<td>
<p>Maximum number of iterations for minimizing the loss
function. Default is 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_clusterpath</code></td>
<td>
<p>If <code>TRUE</code>, store the solution that minimized
the loss function for each lambda. Is required for drawing the clusterpath.
Default is <code>FALSE</code>. To store the clusterpath coordinates, <code class="reqn">n</code> x
<code class="reqn">p</code> x <code class="reqn">no. lambdas</code> values have to be stored, this may require too
much memory for large data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Verbosity of the information printed during clustering.
Default is 0, no output.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>cvxclust</code> object containing the following
</p>
<table>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>A dataframe containing for each value for lambda: the
number of different clusters, and the value of the loss function at the
minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>The merge table containing the order at which the
observations in <code>X</code> are clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>The value for lambda at which each reduction in the
number of clusters occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>The order of the observations in <code>X</code> in order to
draw a dendrogram without conflicting branches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elapsed_time</code></td>
<td>
<p>The number of seconds that elapsed while
running the code. Note that this does not include the time required for
input checking and possibly scaling and centering <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordinates</code></td>
<td>
<p>The clusterpath coordinates. Only part of the
output in case that <code>save_clusterpath=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>The values for lambda for which a clustering was
found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps_fusions</code></td>
<td>
<p>The threshold for cluster fusions that was used by
the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase_1_instances</code></td>
<td>
<p>The number of instances of the loss function
that were minimized while finding an upper and lower bound for lambda. The
sum <code>phase_1_iterations + phase_2_iterations</code> gives the total number of
instances solved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase_2_instances</code></td>
<td>
<p>The number of instances of the loss function
that were minimized while refining the value for lambda. The sum
<code>phase_1_iterations + phase_2_iterations</code> gives the total number of
instances solved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_clusters</code></td>
<td>
<p>The different numbers of clusters that have been
found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of observations in <code>X</code>.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>convex_clusterpath, sparse_weights
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
data(two_half_moons)
data = as.matrix(two_half_moons)
X = data[, -3]
y = data[, 3]

# Get sparse weights in dictionary of keys format with k = 5 and phi = 8
W = sparse_weights(X, 5, 8.0)

# Perform convex clustering with a target number of clusters
res1 = convex_clustering(X, W, target_low = 2, target_high = 5)

# Plot the clustering for 2 to 5 clusters
oldpar = par(mfrow=c(2, 2))
plot(X, col = clusters(res1, 2), main = "2 clusters", pch = 19)
plot(X, col = clusters(res1, 3), main = "3 clusters", pch = 19)
plot(X, col = clusters(res1, 4), main = "4 clusters", pch = 19)
plot(X, col = clusters(res1, 5), main = "5 clusters", pch = 19)

# A more generalized approach to plotting the results of a range of clusters
res2 = convex_clustering(X, W, target_low = 2, target_high = 7)

# Plot the clusterings
k = length(res2$num_clusters)
par(mfrow=c(ceiling(k / ceiling(sqrt(k))), ceiling(sqrt(k))))

for (i in 1:k) {
    labels = clusters(res2, res2$num_clusters[i])
    c = length(unique(labels))

    plot(X, col = labels, main = paste(c, "clusters"), pch = 19)
}
par(oldpar)

</code></pre>


</div>