<div class="container">

<table style="width: 100%;"><tr>
<td>curry</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Curry a function from the start</h2>

<h3>Description</h3>

<p>The <code>curry</code> function and the <code>%&lt;%</code> operator performs currying on
a function by partially applying the first argument, returning a function
that accepts all but the first arguments of the former function. If the first
argument is <code>...</code> the curried argument will be interpreted as part of
the ellipsis and the ellipsis will be retained in the returned function. It
is thus possible to curry functions comtaining ellipis arguments to infinity
(though not adviced).
</p>


<h3>Usage</h3>

<pre><code class="language-R">fun %&lt;% arg

curry(fun, arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A function to be curried. Can be any function (normal,
already curried, primitives).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arg</code></td>
<td>
<p>The value that should be applied to the first argument.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A function with the same arguments as <code>fun</code> except for the
first, unless the first is <code>...</code> in which case it will be retained.
</p>


<h3>Note</h3>

<p>Multiple currying does not result in multiple nested calls, so while
the first currying adds a layer around the curried function, potentially
adding a very small performance hit, currying multiple times will not add to
this effect.
</p>


<h3>See Also</h3>

<p>Other partials: <code>partial</code>,
<code>tail_curry</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Equivalent to curry(`+`, 5)
add_5 &lt;- `+` %&lt;% 5
add_5(10)

# ellipsis are retained when currying
bind_5 &lt;- cbind %&lt;% 5
bind_5(1:10)

</code></pre>


</div>