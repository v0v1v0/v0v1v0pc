<div class="container">

<table style="width: 100%;"><tr>
<td>ConvCheck</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Testing Convergence of mcmc using package coda</h2>

<h3>Description</h3>

<p><code>ConvCheck</code> returns an mcmc.list (mcmc) to be used with the <code>coda</code> package
and the Potential scale reduction factors (Rhat) of the model parameters
computed using the <code>gelman.diag</code> function in the <code>coda</code> package
</p>


<h3>Usage</h3>

<pre><code class="language-R">ConvCheck(mod, startit = 15000, thin = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>is a list with <code class="reqn">m\ge 1</code> elements, one for each chain generated using
<code>WrapSp</code>, <code>ProjSp</code>, <code>WrapSpTi</code> or <code>ProjSpTi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startit</code></td>
<td>
<p>is an integer, the iteration at which the chains start
(required to build the mcmc.list)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>is an integer, the thinning applied to chains</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of two elements
</p>

<dl>
<dt><code>mcmc</code></dt>
<dd>
<p>an <code>mcmc.list</code> (mcmc) to be used with the <code>coda</code> package</p>
</dd>
<dt><code>Rhat</code></dt>
<dd>
<p>the Potential scale reduction factors  of the model parameters
computed using the <code>gelman.diag</code> function in the <code>coda</code> package</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>ProjKrigSp</code> and <code>WrapKrigSp</code> for posterior
spatial estimations,
and
<code>ProjKrigSpTi</code> and <code>WrapKrigSpTi</code> for posterior
spatio-temporal estimations
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
</code></pre>


</div>