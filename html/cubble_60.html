<div class="container">

<table style="width: 100%;"><tr>
<td>match_sites</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Match stations in two cubbles by spatial distance/ temporal similarity</h2>

<h3>Description</h3>

<p>The spatial matching is calculated using <code>sf::st_distance()</code> with different
distance (in meter or degree) available depending on the coordinate reference
system and parameter (<code>which</code> and <code>par</code>). The temporal matching is based on
a temporal matching function (<code>temporal_match_fn</code>) that can be customised.
</p>


<h3>Usage</h3>

<pre><code class="language-R">match_sites(
  df1,
  df2,
  crs = sf::st_crs("OGC:CRS84"),
  which = NULL,
  par = 0,
  spatial_n_each = 1,
  spatial_n_group = 4,
  data_id,
  match_id,
  temporal_matching = TRUE,
  temporal_by,
  temporal_match_fn = match_peak,
  temporal_n_highest = 20,
  temporal_window = 5,
  ...
)

match_spatial(
  df1,
  df2,
  crs = sf::st_crs("OGC:CRS84"),
  which = NULL,
  par = 0,
  spatial_n_each = 1,
  spatial_n_group = 4,
  return_cubble = FALSE
)

match_temporal(
  data,
  data_id,
  match_id = NULL,
  temporal_by,
  return_cubble = FALSE,
  temporal_match_fn = match_peak,
  temporal_n_highest = 30,
  temporal_window = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df1, df2</code></td>
<td>
<p>the two cubble objects to match</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>a crs object from <code>sf::st_crs()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>character; for Cartesian coordinates only: one of <code>Euclidean</code>, <code>Hausdorff</code> or <code>Frechet</code>; for geodetic coordinates, great circle distances are computed; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>for <code>which</code> equal to <code>Hausdorff</code> or <code>Frechet</code>, optionally use a value between 0 and 1 to densify the geometry</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial_n_each</code></td>
<td>
<p>integer, the number of matched "station" in <code>df2</code>
for each <code>df1</code> record</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial_n_group</code></td>
<td>
<p>integer, the number of matched group (pair) return</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_id</code></td>
<td>
<p>a character (or symbol), the variable differentiates
<code>df1</code> and <code>df2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match_id</code></td>
<td>
<p>a character (or symbol), the variable differentiate
each group of match</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temporal_matching</code></td>
<td>
<p>logical, whether to match temporally</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temporal_by</code></td>
<td>
<p>in the <code>by</code> syntax in <code>dplyr::*_join()</code>,
the variables to match temporally in <code>df1</code> and <code>df2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temporal_match_fn</code></td>
<td>
<p>character, the function name on how two time
series should be matched</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temporal_n_highest</code></td>
<td>
<p>numeric, the number of highest peak used for
temporal matching in <code>match_peak</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temporal_window</code></td>
<td>
<p>The temporal window allowed in <code>match_peak</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passing to temporal match</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_cubble</code></td>
<td>
<p>logical (default to false), whether to return the
cubble object or a matching summary table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the resulting cubble object from spatial matching (with
<code>return_cubble = TRUE</code> in spatial matching)</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)
climate_aus &lt;- mutate(climate_aus, type = "climate")
match_spatial(climate_aus, river)
# turn with different distance calculation:
match_spatial(climate_aus, river, which = "Hausdorff")
# tune the number of matches in each group
match_spatial(climate_aus, river, spatial_n_each = 5, spatial_n_group = 2)

a1 &lt;- match_spatial(climate_aus, river, return_cubble = TRUE) |&gt; bind_rows()
match_temporal(a1, data_id = type, match_id = group,
               temporal_by = c("prcp" = "Water_course_level"))
</code></pre>


</div>