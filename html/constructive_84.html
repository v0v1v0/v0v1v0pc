<div class="container">

<table style="width: 100%;"><tr>
<td>opts_list</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructive options for type 'list'</h2>

<h3>Description</h3>

<p>These options will be used on objects of type 'list'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">opts_list(
  constructor = c("list", "list2"),
  ...,
  trim = NULL,
  fill = c("vector", "new_list", "+", "...", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"list"</code> (default): Build the object by calling <code>list()</code>.
</p>
</li>
<li> <p><code>"list2"</code>: Build the object by calling <code>rlang::list2()</code>, the only difference with
the above is that we keep a trailing comma when the list is not trimmed and the call
spans several lines.
</p>
</li>
</ul>
<p>If <code>trim</code> is provided, depending on <code>fill</code> we will present trimmed elements as followed:
</p>

<ul>
<li> <p><code>"vector"</code> (default): Use <code>vector()</code>, so for instance <code>list("a", "b", "c")</code> might become <code>c(list("a"), vector("list", 2))</code>.
</p>
</li>
<li> <p><code>"new_list"</code>: Use <code>rlang::new_list()</code>, so for instance <code>list("a", "b", "c")</code> might become <code>c(list("a"), rlang::new_list(2))</code>.
</p>
</li>
<li> <p><code>"+"</code>: Use unary <code>+</code>, so for instance <code>list("a", "b", "c")</code> might become <code>list("a", +2)</code>.
</p>
</li>
<li> <p><code>"..."</code>: Use <code>...</code>, so for instance <code>list("a", "b", "c")</code> might become <code>list("a", ...)</code>
</p>
</li>
<li> <p><code>"none"</code>: Don't represent trimmed elements.
</p>
</li>
</ul>
<p>When <code>trim</code> is used the output is parsable but might not be possible to evaluate,
especially with <code>fill = "..."</code>. In that case you might want to set <code>check = FALSE</code>
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_list&gt;
</p>


</div>