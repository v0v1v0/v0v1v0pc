<div class="container">

<table style="width: 100%;"><tr>
<td>clsTupleFreqs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute/display tuple frequency counts, and optionally account for 
NA values
</h2>

<h3>Description</h3>

<p>The functions <code>tupleFreqs</code> and <code>discparcoord</code> are
the workhorse functions in the 
package, calculating frequency counts to be used in the graphs and
displaying them. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">    tupleFreqs(dataset,k=5,NAexp=1.0,countNAs=FALSE,saveCounts=FALSE, 
       minFreq=NULL,accentuate=NULL,accval=100) 
    clsTupleFreqs(cls=NULL, dataset, k=5, NAexp=1, countNAs=FALSE)
    discparcoord(data, k=5, grpcategory=NULL, permute=FALSE,
        interactive = TRUE, save=FALSE, name="Parcoords", labelsOff=TRUE,
        NAexp=1.0,countNAs=FALSE, accentuate=NULL, accval=100, inParallel=FALSE,
        cls=NULL, differentiate=FALSE, saveCounts=FALSE, minFreq=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>The data, in data frame or matrix form.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>The number of tuples to return. These will be the <code>k</code> most
frequent tuples, unless <code>k</code> is negative, in which case the
least-frequent tuples will be returned.  The latter is useful
for hunting for outliers.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grpcategory</code></td>
<td>

<p>Grouping column/variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permute</code></td>
<td>

<p>If TRUE, randomly permute the columns before plotting.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactive</code></td>
<td>

<p>If TRUE, use interactive plotting, allowing for interactively
readjusting column order and scrubbing/brushing. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save</code></td>
<td>

<p>If this is TRUE and interactive mode is on, saved plot
will be available from the browser.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>

<p>The name for the plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labelsOff</code></td>
<td>

<p>If TRUE, labels are off. This only comes into
effect when interactive=FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAexp</code></td>
<td>

<p>Scale for NA counts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>countNAs</code></td>
<td>

<p>If TRUE, count NA values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accentuate</code></td>
<td>

<p>Character expression specifying the property to accentuate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accval</code></td>
<td>

<p>Value to accentuate. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inParallel</code></td>
<td>

<p>If TRUE, calculate tuple frequencies in parallel. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>differentiate</code></td>
<td>

<p>If TRUE, randomize coloring to differentiate overlapping
lines. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveCounts</code></td>
<td>

<p>If TRUE, save the tuple counts to the file ‘<span class="file">tupleCounts</span>’.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minFreq</code></td>
<td>

<p>The smallest frequency to be displayed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>

<p>The dataset to process, a data frame or data.table.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cls</code></td>
<td>

<p>Cluster to be used if <code>inParallel</code> is TRUE.  If
<code>inParallel</code> is TRUE and <code>cls</code> is not supplied, 
it will use the sensed number of cores on the calling machine 
by default. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Tuple tabulation is performed by <code>tupleFreqs</code>, or in large
cases, in parallel by <code>clsTupleFreqs</code>.  The display is done by
<code>discparcoord</code>.
</p>
<p>The <code>k</code> most- or least-frequent tuples will be reported, 
with the latter specified via negative <code>k</code>.  Optionally, 
tuples with NA values will count less, but weigh toward 
everything that has existing numbers in common with it.  
</p>
<p>If continuous variables are present, then in most cases, either
convert to discrete using <code>discretize</code> or use
<span class="pkg">freqparcoord</span>.
</p>
<p>The data will be converted into a data.table if it is not already in
that form.  For this and other reasons, it is advantageous to have the
data in that form to begin with, say by using <code>data.table::fread</code> 
to read the data.
</p>
<p>Optionally, tuples that partially match a full tuple pattern except for NA
values will add a partial count to the frequency count for the full
pattern.  If for instance the data consist of 8-tuples and a row in the
data matches a given 8-tuple pattern in 7 of 8 components, this row
would add a count of 7/8 to the frequency for that pattern.  To reduce
this weight, use a value greater than 1.0 for <code>NAexp</code>.  If that
value is 2, for example, the 7/8 increment will be 7/8 squared.
</p>


<h3>Value</h3>

<p>The functions <code>tupleFreqs</code> and <code>clsTupleFreqs</code> return an
object of class <code>c('pna','data.frame')</code>, with each row
consisting of a tuple and its count.  In addition the object will
have attributes <code>k</code> and <code>minFreq</code>.
</p>
<p>The function <code>discparcoord</code> returns an object of class
<code>c('plotly','htmlwidget')</code>.  Printing the object causes display
of the graph.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, 
and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">
   ## Not run: 
       data(Titanic)
       # Find frequencies in parallel
       discparcoord(Titanic, inParallel=TRUE)
    
## End(Not run)

    ## Not run: 
       data(hrdata)
       input1 = list("name" = "average_montly_hours",
                     "partitions" = 3, "labels" = c("low", "med", "high"))
       input = list(input1)
       # this will discretize the data by partitioning average monthly 
       # hours into 3 parts called low, med, and high
       hrdata = discretize(hrdata, input)
       print('first few discretized tuples')
       # first line should be 0.38,0.53,2,low,3,0,1,00,sales,low
       head(hrdata)
       print('first few most-frequent tuples')
       # first line should be 0.40,0.46,2,...,11
       tupleFreqs(hrdata,saveCounts=FALSE)
       # account for NA values and plot with parallel coordinates
       discparcoord(hrdata)
       # same as above, but with scrambled columns
       discparcoord(hrdata, permute=TRUE)
       # same as above, but show top k values
       discparcoord(hrdata, k=8)
       # same as above, but group according to profession
       discparcoord(hrdata, grpcategory="sales")
    
## End(Not run)
</code></pre>


</div>