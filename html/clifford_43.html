<div class="container">

<table style="width: 100%;"><tr>
<td>Ops.clifford</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Arithmetic Ops Group Methods for <code>clifford</code> objects</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>Allows arithmetic operators to be used for
multivariate polynomials  such as addition, multiplication,
integer powers, etc.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'clifford'
Ops(e1, e2)
clifford_negative(C)
geoprod(C1,C2)
clifford_times_scalar(C,x)
clifford_plus_clifford(C1,C2)
clifford_eq_clifford(C1,C2)
clifford_inverse(C)
cliffdotprod(C1,C2)
fatdot(C1,C2)
lefttick(C1,C2)
righttick(C1,C2)
wedge(C1,C2)
scalprod(C1,C2=rev(C1),drop=TRUE)
eucprod(C1,C2=C1,drop=TRUE)
maxyterm(C1,C2=as.clifford(0))
C1 %.% C2
C1 %dot% C2
C1 %^% C2
C1 %X% C2
C1 %star% C2
C1 % % C2
C1 %euc% C2
C1 %o% C2
C1 %_|% C2
C1 %|_% C2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e1,e2,C,C1,C2</code></td>
<td>
<p>Objects of class <code>clifford</code> or coerced if
needed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Scalar, length one numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
constant coerced to numeric, and <code>FALSE</code> meaning to return a
(constant) Clifford object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>Ops.clifford()</code> passes unary and binary arithmetic
operators “<code>+</code>”, “<code>-</code>”, “<code>*</code>”,
“<code>/</code>” and “<code>^</code>” to the appropriate specialist
function.  Function <code>maxyterm()</code> returns the maximum index in the
terms of its arguments.
</p>
<p>The package has several binary operators:
</p>

<table>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
    Geometric product </td>
<td style="text-align: left;"> <code>A*B = geoprod(A,B)</code> </td>
<td style="text-align: left;">
    \(\displaystyle AB=\sum_{r,s}\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Inner product</td>
<td style="text-align: left;"> <code>A %.% B = cliffdotprod(A,B)</code>
</td>
<td style="text-align: left;">
    \(\displaystyle A\cdot B=\sum_{r\neq 0\atop s\ne
    0}^{\vphantom{s\neq 0}}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{\left|s-r\right|}\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Outer product</td>
<td style="text-align: left;"><code>A %^% B = wedge(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\wedge B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{s+r}\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Fat dot product</td>
<td style="text-align: left;"><code>A %o% B = fatdot(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\bullet B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{\left|s-r\right|}\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Left contraction</td>
<td style="text-align: left;"><code>A %_|% B = lefttick(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\rfloor B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{s-r}\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Right contraction</td>
<td style="text-align: left;"><code>A %|_% B = righttick(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\lfloor B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{r-s}\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Cross product</td>
<td style="text-align: left;"><code>A %X% B = cross(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\times
    B=\frac{1}{2_{\vphantom{j}}}\left(AB-BA\right)\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Scalar product</td>
<td style="text-align: left;"><code>A %star% B = star(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\ast B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_0\)</td>
</tr>
<tr>
<td style="text-align: left;">
    Euclidean product</td>
<td style="text-align: left;"><code>A %euc% B = eucprod(A,B)</code></td>
<td style="text-align: left;">
    \(\displaystyle A\star B= A\ast B^\dagger\)</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>In R idiom, the geometric product <code>geoprod(.,.)</code> has to be
indicated with a “<code>*</code>” (as in <code>A*B</code>) and so the
binary operator must be <code>%*%</code>: we need a different idiom for
scalar product, which is why <code>%star%</code> is used.
</p>
<p>Because geometric product is often denoted by juxtaposition, package
idiom includes <code>a % % b</code> for geometric product.
</p>
<p>Binary operator <code>%dot%</code> is a synonym for <code>%.%</code>, which
causes problems for rmarkdown.
</p>
<p>Function <code>clifford_inverse()</code> returns an inverse for nonnull
Clifford objects \(Cl(p,q)\) for \(p+q\leq 5\), and
a few other special cases.  The functionality is problematic as
nonnull blades always have an inverse; but function <code>is.blade()</code>
is not yet implemented.  Blades (including null blades) have a
pseudoinverse, but this is not implemented yet either.
</p>
<p>The <dfn>scalar product</dfn> of two clifford objects is defined as the
zero-grade component of their geometric product:
</p>
\[
    A\ast B=\left\langle AB\right\rangle_0\qquad{\mbox{NB: notation used by both Perwass and Hestenes}}
  \]
<p>In package idiom the scalar product is given by <code>A %star% B</code> or
<code>scalprod(A,B)</code>.  Hestenes and Perwass both use an asterisk for
scalar product as in “\(A*B\)”, but in package idiom, the
asterisk is reserved for geometric product.
</p>
<p><strong>Note: in the package, <code>A*B</code> is the geometric product</strong>.
</p>
<p>The <dfn>Euclidean product</dfn> (or <dfn>Euclidean scalar product</dfn>) of two
clifford objects is defined as 
</p>
\[
    A\star B=
    A\ast B^\dagger=
    \left\langle AB^\dagger\right\rangle_0\qquad{\mbox{Perwass}}
  \]
<p>where \(B^\dagger\) denotes Conjugate [as in <code>Conj(a)</code>].  In
package idiom the Euclidean scalar product is given by
<code>eucprod(A,B)</code> or <code>A %euc% B</code>, both of which return
<code>A * Conj(B)</code>.
</p>
<p>Note that the scalar product \(A\ast A\) can be positive or
negative [that is, <code>A %star% A</code> may be any sign], but the
Euclidean product is guaranteed to be non-negative [that is, <code>A
  %euc% A</code> is always positive or zero].
</p>
<p>Dorst defines the left and right contraction (Chisholm calls these the
left and right inner product) as \(A\rfloor B\) and
\(A\lfloor B\).  See the vignette for more details.
</p>
<p>Division, as in idiom <code>x/y</code>, is defined as
<code>x*clifford_inverse(y)</code>.  Function <code>clifford_inverse()</code> uses
the method set out by Hitzer and Sangwine but is limited to
\(p+q\leq 5\).
</p>
<p>Many of the functions documented here use low-level helper functions
that wrap C code.  For example, <code>fatdot()</code> uses
<code>c_fatdotprod()</code>.  These are documented at <code>lowlevel.Rd</code>.
</p>


<h3>Value</h3>

<p>The high-level functions documented here return a <code>clifford</code>
object.  The low-level functions are not really intended for the
end-user.
</p>


<h3>Note</h3>

<p>In the <span class="pkg">clifford</span> package the caret “<code>^</code>” is reserved
for multiplicative powers, as in <code>A^3=A*A*A</code>.  All the different
Clifford products have binary operators for convenience including the
wedge product <code>%^%</code>.  Compare the <span class="pkg">stokes</span> package, where
multiplicative powers do not really make sense and <code>A^B</code> is
interpreted as a wedge product of differential forms \(A\) and
\(B\).  In <span class="pkg">stokes</span>, the wedge product is the <em>sine qua
non</em> for the whole package and needs a terse idiomatic representation
(although there <code>A%^%B</code> returns the wedge product too).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>E. Hitzer and S. Sangwine 2017.  “Multivector and multivector
matrix inverses in real Clifford algebras”.  <em>Applied Mathematics
and Computation</em> 311:375-389
</p>


<h3>Examples</h3>

<pre><code class="language-R">
u &lt;- rcliff(5)
v &lt;- rcliff(5)
w &lt;- rcliff(5)

u
v
u*v

u+(v+w) == (u+v)+w            # should be TRUE by associativity of "+"
u*(v*w) == (u*v)*w            # should be TRUE by associativity of "*"
u*(v+w) == u*v + u*w          # should be TRUE by distributivity

# Now if x,y are _vectors_ we have:

x &lt;- as.1vector(sample(5))
y &lt;- as.1vector(sample(5))
x*y == x%.%y + x%^%y
x %^% y == x %^% (y + 3*x)  
x %^% y == (x*y-x*y)/2        # should be TRUE 

#  above are TRUE for x,y vectors (but not for multivectors, in general)


## Inner product "%.%" is not associative:
x &lt;- rcliff(5,g=2)
y &lt;- rcliff(5,g=2)
z &lt;- rcliff(5,g=2)
x %.% (y %.% z) == (x %.% y) %.% z

## Other products should work as expected:

x %|_% y   ## left contraction
x %_|% y   ## right contraction
x %o% y    ## fat dot product


</code></pre>


</div>