<div class="container">

<table style="width: 100%;"><tr>
<td>catsim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiscale Categorical Structural Similarity Index Measure</h2>

<h3>Description</h3>

<p>The categorical structural similarity index measure for 2D or 3D categorical or
binary images for multiple scales. The default is to compute over 5 scales.
This determines whether this is a 2D or 3D image and applies the appropriate
windowing, weighting, and scaling. Additional arguments can be passed.
This is a wrapper function for the 2D and 3D functions whose functionality
can be accessed through the ... arguments. This function is a wrapper for the
<code>catmssim_2d()</code>, <code>catmssim_3d_slice()</code>, and
<code>catmssim_3d_cube()</code>
functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">catsim(
  x,
  y,
  ...,
  cube = TRUE,
  levels = NULL,
  weights = NULL,
  method = "Cohen",
  window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>a binary or categorical image</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, such as window, can be passed
as well as arguments for internal functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cube</code></td>
<td>
<p>for the 3D method, whether to use the true 3D method
(cube or <code>catmssim_3d_cube()</code>)
or compute the metric using 2D slices which are then averaged
(<code>catmssim_3d_slice()</code>). By default, <code>TRUE</code>,
which evaluates as a cube. <code>FALSE</code> will treat it as
2D slices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>how many levels of downsampling to use. By default, 5. If
<code>weights</code> is specified and this is left blank, the argument
will be inferred from the number of weights specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a vector of weights for the different scales. By default,
equal to <code>rep(1,levels)/levels</code>. If specified, there must
at least as many  weights as there are levels and the first
<code>levels</code> weights will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>whether to use Cohen's kappa (<code>Cohen</code>),
Jaccard Index (<code>Jaccard</code>), Dice index (<code>Dice</code>),
accuracy (<code>accuracy</code>),  Rand index (<code>Rand</code>),
Adjusted Rand Index (<code>AdjRand</code> or <code>ARI</code>), normalized mutual
information (<code>NMI</code> or <code>MI</code>), or adjusted mutual information
(<code>AMI</code>) as the similarity index.
Note Jaccard and Dice should only be used on binary data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>by default 11 for 2D and 5 for 3D images, but can be
specified as a vector if the window sizes differ by dimension.
The vector must have the same number of
dimensions as the inputted <code>x</code> and <code>y</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a value less than 1 indicating the similarity between the images.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(20181207)
dim &lt;- 16
x &lt;- array(sample(0:4, dim^3, replace = TRUE), dim = c(dim, dim, dim))
y &lt;- x
for (j in 1:dim) {
  for (i in 1:dim) y[i, i, j] &lt;- 0
  for (i in 1:(dim - 1)) y[i, i + 1, j] &lt;- 0
}
catsim(x, y, weights = c(.75, .25))
# Now using a different similarity score
catsim(x, y, levels = 2, method = "accuracy")
# with the slice method:
catsim(x, y, weights = c(.75, .25), cube = FALSE, window = 8)
</code></pre>


</div>