<div class="container">

<table style="width: 100%;"><tr>
<td>Denominate.coin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Denominate data set in a coin</h2>

<h3>Description</h3>

<p>"Denominates" or "scales" indicators by other variables. Typically this is done by dividing extensive variables such as
GDP by a scaling variable such as population, to give an intensive variable (GDP per capita).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'coin'
Denominate(
  x,
  dset,
  denoms = NULL,
  denomby = NULL,
  denoms_ID = NULL,
  f_denom = NULL,
  write_to = NULL,
  out2 = "coin",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A coin class object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>denoms</code></td>
<td>
<p>An optional data frame of denominator data. Columns should be denominator data, with column names corresponding
to entries in <code>denomby</code>. This must also include an ID column identified by <code>denoms_ID</code> to match rows. If <code>denoms</code>
is not specified, will extract any potential denominator columns that were attached to <code>iData</code> when calling <code>new_coin()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>denomby</code></td>
<td>
<p>Optional data frame which specifies which denominators to use for each indicator, and any scaling factors
to apply. Should have columns <code>iCode</code>, <code>Denominator</code>, <code>ScaleFactor</code>. <code>iCode</code> specifies an indicator code found in <code>dset</code>,
<code>Denominator</code> specifies a column name from <code>denoms</code> to use to denominate the corresponding column from <code>x</code>.
<code>ScaleFactor</code> allows the possibility to scale
denominators if needed, and specifies a factor to multiply the resulting values by. For example, if GDP is a denominator and is measured in
dollars, dividing will create very small numbers (order 1e-10 and smaller) which could cause problems with numerical precision. If <code>denomby</code>
is not specified, specifications will be taken from the "Denominator" column in <code>iMeta</code>, if it exists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>denoms_ID</code></td>
<td>
<p>An ID column for matching <code>denoms</code> with the data to be denominated. This column should contain
<code>uMeta</code> codes to match with the data set extracted from the coin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_denom</code></td>
<td>
<p>A function which takes two numeric vector arguments and is used to perform the denomination for each
column. By default, this is division, i.e. <code>x[[col]]/denoms[[col]]</code> for given columns, but any function can be passed
that takes two numeric vectors as inputs and returns a single numeric vector. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Denominated"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out2</code></td>
<td>
<p>Either <code>"coin"</code> (default) to return updated coin or <code>"df"</code> to output the aggregated data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function denominates a data set <code>dset</code> inside the coin. By default, denominating variables are taken from
the coin, specifically as variables in <code>iData</code> with <code>Type = "Denominator"</code> in <code>iMeta</code> (input to <code>new_coin()</code>).
Specifications to map denominators to indicators are also taken by default from <code>iMeta$Denominator</code>, if it exists.
</p>
<p>These specifications can be overridden using the <code>denoms</code> and <code>denomby</code> arguments. The operator for denomination
can also be changed using the <code>f_denom</code> argument.
</p>
<p>See also documentation for <code>Denominate.data.frame()</code> which is called by this method.
</p>


<h3>Value</h3>

<p>An updated coin if <code>out2 = "coin"</code>, else a data frame of denominated data if <code>out2 = "df"</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# denominate (here, we only need to say which dset to use, takes
# specs and denominators from within the coin)
coin &lt;- Denominate(coin, dset = "Raw")

</code></pre>


</div>