<div class="container">

<table style="width: 100%;"><tr>
<td>standardize_dates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standardize date variables</h2>

<h3>Description</h3>

<p>When the format of the values in a column and/or the target columns are not
defined, we strongly recommend checking a few converted dates manually to
make sure that the dates extracted from a <code>character</code> vector or a <code>factor</code>
are correct.
</p>


<h3>Usage</h3>

<pre><code class="language-R">standardize_dates(
  data,
  target_columns = NULL,
  format = NULL,
  timeframe = NULL,
  error_tolerance = 0.5,
  orders = list(world_named_months = c("Ybd", "dby"), world_digit_months = c("dmy",
    "Ymd"), US_formats = c("Omdy", "YOmd")),
  modern_excel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or linelist</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_columns</code></td>
<td>
<p>A vector of the target date column names. When the
input data is a <code>linelist</code> object, this parameter can be set to
<code>linelist_tags</code> if you wish to standardize the date columns across tagged
columns only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>A format of the date values in the date columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeframe</code></td>
<td>
<p>A vector of 2 values of type date. If provided, date values
that do not fall within this timeframe will be set to <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error_tolerance</code></td>
<td>
<p>A number between 0 and 1 indicating the proportion of
entries which cannot be identified as dates to be tolerated; if this
proportion is exceeded, the original vector is returned, and a message is
issued; defaults to 0.4 (40 percent).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orders</code></td>
<td>
<p>The date codes for fine-grained parsing of dates. This allows
for parsing of mixed dates. If a list is supplied, that list will be used
for successive tries in parsing. Default orders are:
</p>
<div class="sourceCode"><pre>list(
  world_named_months = c("Ybd", "dby"),
  world_digit_months = c("dmy", "Ymd"),
  US_formats         = c("Omdy", "YOmd")
)
</pre></div>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modern_excel</code></td>
<td>
<p>When parsing dates from excel, some dates are stored as
integers. Modern versions of Excel represent dates as the number of days
since 1900-01-01, but pre-2011 Excel for OSX have the origin set at
1904-01-01. If this parameter is <code>TRUE</code> (default), then this assumes that
all numeric values represent dates from either a Windows version of Excel
or a 2011 or later version of Excel for OSX. Set this parameter to <code>FALSE</code>
if the data came from an OSX version of Excel before 2011.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Converting ambiguous character strings to dates is difficult for
many reasons:
</p>

<ul>
<li>
<p> dates may not use the standard Ymd format
</p>
</li>
<li>
<p> within the same variable, dates may follow different formats
</p>
</li>
<li>
<p> dates may be mixed with things that are not dates
</p>
</li>
<li>
<p> the behavior of <code>as.Date</code> in the presence of non-date is hard to predict,
sometimes returning <code>NA</code>, sometimes issuing an error.
</p>
</li>
</ul>
<p>This function tries to address all the above issues. Dates with the following
format should be automatically detected, irrespective of separators
(e.g. "-", " ", "/") and surrounding text:
</p>

<ul>
<li>
<p> "19 09 2018"
</p>
</li>
<li>
<p> "2018 09 19"
</p>
</li>
<li>
<p> "19 Sep 2018"
</p>
</li>
<li>
<p> "2018 Sep 19"
</p>
</li>
<li>
<p> "Sep 19 2018"
</p>
</li>
</ul>
<h4>How it works</h4>

<p>This function relies heavily on <code>lubridate::parse_date_time()</code>, which is an
extremely flexible date parser that works well for consistent date formats,
but can quickly become unwieldy and may produce spurious results.
<code>standardize_dates()</code> will use a list of formats in the <code>orders</code> argument to
run <code>parse_date_time()</code> with each format vector separately and take the first
correctly parsed date from all the trials.
</p>
<p>With the default orders shown above, the dates 03 Jan 2018, 07/03/1982, and
08/20/85 are correctly interpreted as 2018-01-03, 1982-03-07, and 1985-08-20.
The examples section will show how you can manipulate the <code>orders</code> to be
customized for your situation.
</p>



<h3>Value</h3>

<p>The input dataset where the date columns have been standardized. The
date values that are out of the specified timeframe will be reported in
the report. Similarly, date values that comply with multiple formats will
also be featured in the report object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c("03 Jan 2018", "07/03/1982", "08/20/85")
# The below will coerce values where the month is written in letters only
# into Date.
as.Date(lubridate::parse_date_time(x, orders = c("Ybd", "dby")))

# coerce values where the month is written in letters or numbers into Date.
as.Date(lubridate::parse_date_time(x, orders = c("dmy", "Ymd")))

# How to use standardize_dates()
dat &lt;- standardize_dates(
  data            = readRDS(system.file("extdata", "test_df.RDS",
                                        package = "cleanepi")),
  target_columns  = "date_first_pcr_positive_test",
  format          = NULL,
  timeframe       = NULL,
  error_tolerance = 0.4,
  orders          = list(world_named_months = c("Ybd", "dby"),
                         world_digit_months = c("dmy", "Ymd"),
                         US_formats         = c("Omdy", "YOmd")),
  modern_excel    = TRUE
)
</code></pre>


</div>