<div class="container">

<table style="width: 100%;"><tr>
<td>loadImage</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Import image and generate filtered 2D pixel array(s)</h2>

<h3>Description</h3>

<p>Imports a single image and returns a list with the original image as a 3D
array, a 2D matrix with background pixels removed, and the absolute path to
the original image.
</p>


<h3>Usage</h3>

<pre><code class="language-R">loadImage(
  path,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  hsv = TRUE,
  CIELab = FALSE,
  sample.size = 1e+05,
  ref.white = NULL,
  alpha.channel = TRUE,
  alpha.message = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>Path to image (a string).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li>
<p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li>
<p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li>
<p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li>
<p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li>
</ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hsv</code></td>
<td>
<p>Logical. Should HSV pixel array also be calculated? Setting to
<code>FALSE</code> will shave some time off the analysis, but not much (a few
microseconds per image).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CIELab</code></td>
<td>
<p>Logical. Should CIEL*a*b color space pixels be calculated from
RGB? Requires specification of a reference white (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.size</code></td>
<td>
<p>Number of pixels to be randomly sampled from filtered pixel
array for conversion. If not numeric, all pixels are converted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref.white</code></td>
<td>
<p>String; white reference for converting from RGB to CIEL*a*b
color space. Accepts any of the standard white references for
<code>convertColor</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code>removeBackground</code> for more
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.message</code></td>
<td>
<p>Logical. Output a message if using alpha channel
transparency to mask background? Helpful for troubleshooting with PNGs.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The upper and lower limits for background pixel elimination set the
inclusive bounds for which pixels should be ignored for the 2D arrays; while
all background pixels are ideally a single color, images photographed against
"uniform" backgrounds often contain some variation, and even segmentation
done with photo editing software will produce some variance as a result of
image compression.
</p>
<p>The upper and lower bounds represent cutoffs: any pixel for which the first
channel falls between the first upper and lower bounds, the second channel
falls between the second upper and lower bounds, and the third channel falls
between the third upper and lower bounds, will be ignored. For example, if
you have a green pixel with RGB channel values [0.1, 0.9, 0.2], and your
upper and lower bounds were (0.2, 1, 0.2) and (0, 0.6, 0) respectively, the
pixel would be ignored because 0 &lt;= 0.1 &lt;= 0.2, 0.6 &lt;= 0.9 &lt;= 1, and 0 &lt;= 0.2
&lt;= 0.2. But a pixel with the RGB channel values [0.3, 0.9, 0.2] would not be
considered background because 0.3 &gt;= 0.2.
</p>
<p>CIEL*a*b color space requires a reference 'white light' color (dimly and
brightly lit photographs of the same object will have very different RGB
palettes, but similar Lab palettes if appropriate white references are used).
The idea here is that the apparent colors in an image depend not just on the
"absolute" color of an object (whatever that means), but also on the
available light in the scene. There are seven CIE standardized illuminants
available in <code>colordistance</code> (A, B, C, E, and D50, D55, and D60), but
the most common are: </p>
 <ul>
<li> <p><code>"A"</code>: Standard incandescent
lightbulb </p>
</li>
<li> <p><code>"D65"</code>: Average daylight </p>
</li>
<li> <p><code>"D50"</code>: Direct
sunlight</p>
</li>
</ul>
<p>Color conversions will be highly dependent on the reference white used, which
is why no default is provided. Users should look into
<a href="https://en.wikipedia.org/wiki/Standard_illuminant">standard
illuminants</a> to choose an appropriate reference for a dataset.
</p>


<h3>Value</h3>

<p>A list with original image ($original.rgb, 3D array), 2D matrix with
background pixels removed ($filtered.rgb.2d and $filtered.hsv.2d), and path
to the original image ($path).
</p>


<h3>Note</h3>

<p>The 3D array is useful for displaying the original image, while the 2D
arrays (RGB and HSV) are treated as rows of data for clustering in the rest
of the package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">loadedImg &lt;- colordistance::loadImage(system.file("extdata",
"Heliconius/Heliconius_A/Heliconius_01.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3))

loadedImgNoHSV &lt;- colordistance::loadImage(system.file("extdata",
"Heliconius/Heliconius_A/Heliconius_01.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3), hsv=FALSE)

</code></pre>


</div>