<div class="container">

<table style="width: 100%;"><tr>
<td>Smooth.LS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model-Based Smoothing Functions</h2>

<h3>Description</h3>

<p>Perform the inner optimization to estimate coefficients given parameters.</p>


<h3>Usage</h3>

<pre><code class="language-R">Smooth.LS(fn,data,times,pars,coefs=NULL,basisvals=NULL,lambda,fd.obj=NULL,
        more=NULL,weights=NULL,quadrature=NULL,likfn = make.id(), 
        likmore = NULL,in.meth='nlminb',control.in,eps=1e-6,
        posproc=FALSE,poslik=FALSE,discrete=FALSE,names=NULL,
        sparse=FALSE)
        
Smooth.multinorm(fn,data,times,pars,coefs=NULL,basisvals=NULL,var=c(1,0.01),
        fd.obj=NULL,more=NULL,quadrature=NULL,in.meth='nlminb',
        control.in,eps=1e-6,posproc=FALSE,poslik=FALSE,discrete=FALSE,
        names=NULL,sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p> A function giving the right hand side of a differential/difference equation.  The function should have arguments
</p>

<ul>
<li>
<p>times The times at which the RHS is being evaluated.
</p>
</li>
<li>
<p>x The state values at those times.
</p>
</li>
<li>
<p>p Parameters to be entered in the system.
</p>
</li>
<li>
<p>more An object containing additional inputs to <code>fn</code>
</p>
</li>
</ul>
<p>It should return a matrix of the same dimension of <code>x</code> giving the right hand side values.
</p>
<p>If <code>fn</code> is given as a single function, its derivatives are estimated by finite-differencing with
stepsize <code>eps</code>. Alternatively, a list can be supplied with elements:
</p>

<ul>
<li>
<p>fn Function to calculate the right hand side should accept a matrix of state values at .
</p>
</li>
<li>
<p>dfdx Function to calculate the derivative with respect to <code>x</code>
</p>
</li>
<li>
<p>dfdp Function to calculate the derivative with respect to <code>p</code>
</p>
</li>
<li>
<p>d2fdx2 Function to calculate the second derivative with respect to <code>x</code>
</p>
</li>
<li>
<p>d2fdxdp Function to calculate the second derivative with respect to <code>x</code> and <code>p</code>
</p>
</li>
</ul>
<p>These functions take the same arguments as <code>fn</code> and should output multidimensional arrays with
the dimensions ordered according to time, state, deriv1, deriv2; here derivatives with respect to <code>x</code>
always precede derivatives with respect to <code>p</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisvals</code></td>
<td>
<p>Values of the collocation basis to be used. This can either be a basis object from the <code>fda</code> package,
or a list elements:
</p>

<ul>
<li>
<p>bvals.obs A matrix giving the values of the basis at the observation times
</p>
</li>
<li>
<p>bvals A matrix giving the values of the basis at the quadrature times
</p>
</li>
<li>
<p>dbvals A matrix giving the derivative of the basis at the quadrature times
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>(<code>Smooth.LS</code> only) Penalty value trading off fidelity to data with fidelity to differential equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>(<code>Smooth.multinorm</code>) A vector of length 2, giving  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fd.obj</code></td>
<td>
<p>(Optional) A functional data object; if this is non-null, <code>coefs</code> and <code>basisvals</code> is extracted from here. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>more</code></td>
<td>
<p>An object specifying additional arguments to <code>fn</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>(<code>Smooth.LS</code> only)  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadrature</code></td>
<td>
<p> Quadrature points, should contain two elements (if not NULL)
</p>

<ul>
<li>
<p>qpts Quadrature points; defaults to midpoints between knots
</p>
</li>
<li>
<p>qwts Quadrature weights; defaults to normalizing by the length of <code>qpts</code>.   
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.meth</code></td>
<td>
<p> Inner optimization function to be used, currently one of 'nlminb', 'MaxNR', 'optim' or 'SplineEst'.
The last calls <code>SplineEst.NewtRaph</code>. This is fast but has poor convergence.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> Finite differencing step size, if needed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posproc</code></td>
<td>
<p> Should the state vector be constrained to be positive? If this is the case, the state is represented by
an exponentiated basis expansion in the <code>proc</code> object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poslik</code></td>
<td>
<p> Should the state be exponentiated before being compared to the data? When the state is represented
on the log scale (<code>posproc=TRUE</code>), this is an alternative to taking the log of the data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete</code></td>
<td>
<p> Is this a discrete or continuous-time system?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p> The names of the state variables if not given by the column names of <code>coefs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p> Should sparse matrices be used for basis values? This option can save memory when 
<code>ProfileGausNewt</code> and <code>SplineEstNewtRaph</code> are called. Otherwise sparse matrices will be converted to 
full matrices and this can slow the code down.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>likfn</code></td>
<td>
<p> Defines a map from the trajectory to the observations. This should be in the same form as
<code>fn</code>. If a function is given, derivatives are estimated by finite differencing, otherwise a list
is expected to provide the same derivatives as <code>fn</code>. If <code>poslik=TRUE</code>, the states are
exponentiated before the <code>likfn</code> is evaluated and the derivatives are updated to account for this.
Defaults to the identity transform. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>likmore</code></td>
<td>
<p> A list containing additional inputs to <code>likfn</code> if needed, otherwise set to <code>NULL</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These routines create <code>lik</code> and <code>proc</code> objects and call <code>inneropt</code>.</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>Optimized coefficients at <code>pars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lik</code></td>
<td>
<p>The <code>lik</code> object generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proc</code></td>
<td>
<p>The <code>proc</code> item generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>The result of the optimization method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data used in doing the fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>The vector of times at which the observations were made</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>inneropt</code>, <code>LS.setup</code>, <code>multinorm.setup</code>, <code>SplineCoefsErr</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
###############################
####   Data             #######
###############################

data(FhNdata)

###############################
####  Basis Object      #######
###############################

knots = seq(0,20,0.2)
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
	norder=norder,breaks=knots)


#### Start from pre-estimated values to speed up optimization

data(FhNest)

spars = FhNestPars
coefs = FhNestCoefs

lambda = 10000

res1 = Smooth.LS(make.fhn(),data=FhNdata,times=FhNtimes,pars=spars,coefs=coefs,
  basisvals=bbasis,lambda=lambda,in.meth='nlminb')


## Not run: 
# Henon system

hpars = c(1.4,0.3)              # Parameters
t = 1:200

x = c(-1,1)                     # Create some dataa
X = matrix(0,200+20,2)
X[1,] = x

for(i in 2:(200+20)){ X[i,] = make.Henon()$ode(i,X[i-1,],hpars,NULL) }

X = X[20+1:200,]

Y = X + 0.05*matrix(rnorm(200*2),200,2)

basisvals = diag(rep(1,200))    # Basis is just identiy
coefs = matrix(0,200,2)


# For sum of squared errors

lambda = 10000

res1	= Smooth.LS(make.Henon(),data=Y,times=t,pars=hpars,coefs,basisvals=basisvals,
  lambda=lambda,in.meth='nlminb',discrete=TRUE)

## End(Not run)


## Not run: 
# For multinormal transitions

var = c(1,0.01)

res2 = Smooth.multinorm(make.Henon(),data=Y,t,pars=hpars,coefs,basisvals=NULL,
  var=var,in.meth='nlminb',discrete=TRUE)

## End(Not run)
</code></pre>


</div>