<div class="container">

<table style="width: 100%;"><tr>
<td>E.theta.toy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expectation and variance with respect to theta</h2>

<h3>Description</h3>

<p>Function 
<code>E.theta.toy</code> returns expectation of <code>H_1(D)</code> with respect to
<code class="reqn">\theta</code>; <code>Edash.theta.toy</code> returns expectation with
respect to <code class="reqn">E'</code>.  Function <code>E.theta.toy</code> also returns
information about nonlinear behaviour of <code>h1(x,theta)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">E.theta.toy(D2=NULL,  H1=NULL, x1=NULL, x2=NULL, phi, give.mean=TRUE)
Edash.theta.toy(x, t.vec, k,  H1, fast.but.opaque=FALSE, a=NULL, b=NULL,
phi=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D2</code></td>
<td>
<p>Observation points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H1</code></td>
<td>
<p>Regression function for D1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>hyperparameters.  Default value of <code>NULL</code> only to be
used in <code>Edash.theta.toy()</code> when <code>fast.but.opaque</code> is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>lat/long point (for <code>Edash.theta.toy</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.vec</code></td>
<td>
<p>Matrix whose rows are parameter values (for <code>Edash.theta.toy</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Integer specifying column (for <code>Edash.theta.toy</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give.mean</code></td>
<td>
<p>In <code>E.theta.toy()</code>, Boolean, with default <code>TRUE</code> meaning to return
the mean (expectation), and <code>FALSE</code> meaning to return the “variance”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast.but.opaque</code></td>
<td>
<p>In <code>Edash.theta.toy()</code>, Boolean, with
default <code>FALSE</code> meaning to use a slow but clear method.  If
<code>TRUE</code>, use faster code but parameters <code>a</code> and <code>b</code> must then be specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Constant term, needed if <code>fast.but.opaque</code> is
<code>TRUE</code>: 
<code class="reqn">\left(V_\theta^{-1}+2\Omega_t\right)^{-1}V_\theta^{-1}m_\theta</code>.
Specifying <code>a</code> in advance saves execution time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Linear term, needed if <code>fast.but.opaque</code> is <code>TRUE</code>:
<code class="reqn">2\left(V_\theta^{-1}+2\Omega_t\right)^{-1}\Omega_t</code>
(multiplied by <code>t[k,]</code> in <code>Edash.theta.toy()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>In <code>E.theta.toy(g=F,...)</code>, the value of <code>x</code> in
<code class="reqn">h_1(x,\theta)</code>.  The default value is <code>NULL</code>
because in simple cases such as that implemented here, the output is
independent of <code>x1</code> and <code>x2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>In <code>E.theta.toy(g=F,...)</code>, the value of <code>x</code> in
<code class="reqn">h_1(x,\theta)</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>A terse discussion follows; see the <code>calex.pdf</code> vignette and the
1D case study in directory <code>inst/doc/one/dim/</code> for more details
and examples.
</p>
<p>Function <code>E.theta.toy(give.mean=FALSE,...)</code> does <strong>not</strong>
return the variance!  The matrix returned is a <strong>different size</strong>
from the variance matrix!
</p>
<p>It returns the thing that must be added to
<code>crossprod(E_theta(h1(x,theta)),t(E_theta(h1(x,theta))))</code> to give
<code>E_theta(h1(x,theta).t(h1(x,theta)))</code>.
</p>
<p>In other words, it returns
<code>E_theta(h1(x,theta).t(h1(x,theta)))</code>-
<code>crossprod(E_theta(h1(x,theta)),t(E_theta(h1(x,theta))))</code>.
</p>
<p>If the terms of
<code>h1()</code> are of the form <code>c(o,theta)</code> (where <code>o</code> is a
vector that is a function of <code>x</code> alone, and independent of
<code>theta</code>), then the function will include the variance matrix, in
the lower right corner (zeroes elsewhere).
</p>
<p>Function <code>E.theta()</code> must be updated if <code>h1.toy()</code>
changes: unlike <code>E.theta()</code> and <code>Edash.theta()</code>, it does not
“know” where the elements that vary with <code>theta</code> are, nor
their (possibly x-dependent) coefficients.
</p>
<p>This form of the function requires <code>x1</code> and <code>x2</code> arguments,
for good form's sake, even though the returned value is independent of
<code>x</code> in the toy example.  To see why it is
necessary to include <code>x</code>, consider a simple case with
<code class="reqn">h_1(x,\theta)=(1,x\theta)^T</code>.  Now
<code class="reqn">E_\theta\left(h(x,\theta)\right)</code> is just
<code class="reqn">(1,x\overline{\theta})^T</code> but
</p>
<p style="text-align: center;"><code class="reqn">E_\theta\left(h_1(x,\theta)h_1(x,\theta)^T\right)</code>
</p>

<p>is a 2-by-2 matrix (<code class="reqn">M</code>, say) with
<code class="reqn">E_\theta(M)=h_1(x,\overline{\theta})h_1(x,\overline{\theta})^T +
  \mbox{variance terms}</code>.
</p>
<p style="text-align: center;"><code class="reqn">
  E_\theta\left(
  \begin{array}{cc}
      1 &amp; x\theta\\
      x\theta &amp; x^2\theta^2
      \end{array}\right)
      </code>
</p>

<p>All three functions here are intimately connected to the form of
<code>h1.toy()</code> and changing it (or indeed <code>H1.toy()</code>) will
usually require rewriting all three functions documented here.  Look
at the definition of <code>E.theta.toy(give=F)</code>, and you will see that
even changing the meat of <code>h1.toy()</code> from <code>c(1,x)</code> to
<code>c(x,1)</code> would require a redefinition of <code>E.theta.toy(g=F)</code>.
</p>
<p>The only place that <code>E.theta.toy(g=F)</code> is used is internally in
<code>hh.fun()</code>.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001. <em>Bayesian
calibration of computer models</em>.  Journal of the Royal Statistical
Society B, 63(3) pp425-464
</p>
</li>
<li>
<p>M. C. Kennedy and A. O'Hagan 2001.  <em>Supplementary details on
Bayesian calibration of computer models</em>, Internal report, University
of Sheffield.  Available at
<a href="http://www.tonyohagan.co.uk/academic/ps/calsup.ps">http://www.tonyohagan.co.uk/academic/ps/calsup.ps</a>
</p>
</li>
<li>
<p>R. K. S. Hankin 2005. <em>Introducing BACCO, an R bundle for
Bayesian analysis of computer code output</em>, Journal of Statistical
Software, 14(16)
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>toys</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(toys)
E.theta.toy(D2=D2.toy,      H1=H1.toy,phi=phi.toy)
E.theta.toy(D2=D2.toy[1,],  H1=H1.toy,phi=phi.toy)
E.theta.toy(D2=x.toy,       H1=H1.toy,phi=phi.toy)
Edash.theta.toy(x=x.toy,t.vec=t.vec.toy,k=1, H1=H1.toy,phi=phi.toy)
</code></pre>


</div>