<div class="container">

<table style="width: 100%;"><tr>
<td>network.comm.num</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</h2>

<h3>Description</h3>

<p>The main function for Consistent Estimation of the Number of Communities via Regularized Network Embedding.
</p>


<h3>Usage</h3>

<pre><code class="language-R">network.comm.num(A, sample.index.n, lambda, Z.int, B.int,
                        a=3, kappa=1, alpha=1, eps=5e-2, niter=20,
               niter.Z=5, update.B="ADMM",local.oppro=FALSE, merge.all=TRUE,
               ad.BIC=FALSE, Fully.Connected=TRUE, trace=FALSE,
               line.search=TRUE, ad.BIC.B=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>An observed n * n adjacency matrix of undirected graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.index.n</code></td>
<td>
<p>A 3 * (n*(n-1)/2) matrix, all pairs of integers from 1 to n.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A list, the sequences of the tuning parameters (<code class="reqn">\lambda_1</code>, <code class="reqn">\lambda_2</code>, and <code class="reqn">\lambda_3</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.int</code></td>
<td>
<p>A n * r matrix, the initial values of embedding vectors corresponding to n nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.int</code></td>
<td>
<p>A n * r matrix, the initial values of community centers corresponding to n nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>A float value, regularization parameter in MCP, the default setting is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>A float value, the penalty parameter in ADMM algorithm, the default setting is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A float value, the step size of coordinate descent algorithm updating Z, the default setting is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A float value, algorithm termination threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Int, maximum number of cycles of the overall ADMM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter.Z</code></td>
<td>
<p>Int, maximum number of cycles of coordinate descent algorithm updating Z.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.B</code></td>
<td>
<p>The optimization algorithm updating B, which can be selected "ADMM" (default) and "AMA".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local.oppro</code></td>
<td>
<p>The logical variable, whether to use local approximations when updating Z, the default setting is F.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge.all</code></td>
<td>
<p>Whether to merge pairs of nodes indirectly connected (but without the direct edge) in the estimated community membership matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ad.BIC</code></td>
<td>
<p>Whether to use the adjusted BIC, the default setting is F.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fully.Connected</code></td>
<td>
<p>Whether to use the all pairs (i,j) in fusion penalty, the default setting is T. If F, the pairs (i,j) in fusion penalty will be determined by the observed n * n adjacency matrix A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Whether to output the intermediate process of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line.search</code></td>
<td>
<p>Linear search or not, the default setting is T.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ad.BIC.B</code></td>
<td>
<p>Whether the BIC criterion contains terms involving the B matrix, the default setting is F.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list including all estimated parameters and the BIC values with all choices of given tuning parameters, and the selected optional parameters.
Opt_Z: A n * r matrix, the estimated embedding vectors corresponding to n nodes;
Opt_B: A n * r matrix, the estimated community centers corresponding to n nodes;
Opt_K: Int, the estimated number of communities;
Opt_member: A n-dimensional vector, describing the membership of n nodes;
Opt_cluster.matrix: A n * n membership matrix, whose (i,j)-element is 1, if nodes i and j belong to the same community, and 0, otherwise.
</p>


<h3>Author(s)</h3>

<p>Mingyang Ren, Sanguo Zhang, Junhui Wang. Maintainer: Mingyang Ren <a href="mailto:renmingyang17@mails.ucas.ac.cn">renmingyang17@mails.ucas.ac.cn</a>.
</p>


<h3>References</h3>

<p>Ren, M., Zhang S. and Wang J. (2022). Consistent Estimation of the Number of Communities via Regularized Network Embedding.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(cencrne)
data(example.data)
A                   = example.data$A
K.true              = example.data$K.true
Z.true              = example.data$Z.true
B.true              = example.data$B.true
P.true              = example.data$P.true
Theta.true          = example.data$Theta.true
cluster.matrix.true = example.data$cluster.matrix.true

n       = dim(A)[1]
lam.max = 3
lam.min = 0.5
lam1.s  = 2/log(n)
lam2.s  = sqrt(8*log(n)/n)
lam3.s  = 1/8/log(n)/sqrt(n)
lambda  = genelambda.obo(nlambda1=3,lambda1_max=lam.max*lam1.s,lambda1_min=lam.min*lam1.s,
                         nlambda2=10,lambda2_max=lam.max*lam2.s,lambda2_min=lam.min*lam2.s,
                         nlambda3=1,lambda3_max=lam.max*lam3.s,lambda3_min=lam.min*lam3.s)

sample.index.n = rbind(combn(n,2),1:(n*(n-1)/2))
int.list       = gen.int(A)
Z.int          = int.list$Z.int
B.int          = int.list$B.int
res            = network.comm.num(A, sample.index.n, lambda, Z.int, B.int)

K.hat = res$Opt_K # the estimated number of communities
Z.hat = res$Opt_Z # the estimated embedding vectors corresponding to n nodes
cluster.matrix.hat = res$Opt_cluster.matrix # the n * n estimated membership matrix
evaluation(Z.hat, Z.true, cluster.matrix.hat, cluster.matrix.true,
           P.true, Theta.true, K.hat, K.true)


</code></pre>


</div>