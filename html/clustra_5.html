<div class="container">

<table style="width: 100%;"><tr>
<td>clustra</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster longitudinal trajectories over time</h2>

<h3>Description</h3>

<p>The usual top level function for clustering longitudinal trajectories. After
initial setup, it calls <code>trajectories</code> to perform k-means
clustering on continuous <code>response</code> measured over <code>time</code>, where each mean
is defined by a thin plate spline fit to all points in a cluster. See
<code>clustra_vignette.Rmd</code> for examples of use.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clustra(
  data,
  k,
  starts = "random",
  maxdf = 30,
  conv = c(10, 0),
  mccores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame or, preferably, also a data.table with response measurements, one
response per observation. Required variables are (id, time, response).
Other variables are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starts</code></td>
<td>
<p>One of c("random", "distant") or an integer vector
with values 1:k corresponding to unique ids of starting cluster assignments.
For "random", starting clusters are assigned
at random.
For "distant", a FastMap-like algorithm selects k distant ids to
which TPS models are fit and used as starting cluster centers to which ids
are classified. Only id with more than median number of time points are
used. Distance from an id to a TPS model is median absolute difference
at id time points. Starting with a random id, distant ids are selected
sequentially as the id with the largest minimum absolute distance to
previous selections (a maximin concept). The first random selection is
discarded and the next k selected ids are kept. Their TPS fits become the
first cluster centers to
which all ids are classified. See comments in code and
DOI: 10.1109/TPAMI.2005.164 for the FastMap analogy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdf</code></td>
<td>
<p>Fitting parameters. See <code>trajectories</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>Fitting parameters. See <code>trajectories</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mccores</code></td>
<td>
<p>See <code>trajectories</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical to turn on more output during fit iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters of optional plotting under <code>verbose = 2</code>. At this time,
only <code>xlim</code> and <code>ylim</code> are allowed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list returned by <code>trajectories</code> plus one more element <code>ido</code>,
giving the original id numbers is invisibly returned. Invisible returns are
useful for repeated runs that explore verbose clustra output.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(13)
data = gen_traj_data(n_id = c(50, 100), types = c(1, 2), 
                     intercepts = c(100, 80), m_obs = 20, 
                     s_range = c(-365, -14), e_range = c(0.5*365, 2*365))
cl = clustra(data, k = 2, maxdf = 20, conv = c(5, 0), verbose = TRUE)
tabulate(data$group)
tabulate(data$true_group)

</code></pre>


</div>