<div class="container">

<table style="width: 100%;"><tr>
<td>conreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convex / Concave Regression</h2>

<h3>Description</h3>

<p>Compute a univariate concave or convex regression, i.e.,
for given vectors, <code class="reqn">x,y,w</code> in <code class="reqn">R^n</code>, where <code class="reqn">x</code> has to be
strictly sorted (<code class="reqn">x_1 &lt; x_2 &lt; \ldots &lt; x_n</code>), compute an
<code class="reqn">n</code>-vector <code class="reqn">m</code> minimizing the weighted sum of squares
<code class="reqn">\sum_{i=1}^n {w_i (y_i - m_i)^2}</code>
under the constraints
</p>
<p style="text-align: center;"><code class="reqn">(m_i - m_{i-1})/(x_i - x_{i-1}) \ge (m_{i+1} - m_i)/(x_{i+1} - x_i),</code>
</p>

<p>for <code class="reqn">1 \le i \le n</code> and
<code class="reqn">m_0 := m_{n+1} := -\infty</code>,
for concavity.
For convexity (<code>convex=TRUE</code>), replace <code class="reqn">\ge</code> by
<code class="reqn">\le</code> and <code class="reqn">-\infty</code> by <code class="reqn">+\infty</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">conreg(x, y = NULL, w = NULL, convex = FALSE,
       method = c("Duembgen06_R", "SR"),
       tol = c(1e-10, 1e-7), maxit = c(500, 20),
       adjTol = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>numeric vectors giving the values of the predictor and
response variable.  Alternatively a single “plotting”
structure (two-column matrix / y-values only / list, etc) can be
specified: see <code>xy.coords</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>for <code>method</code> <code>"Duembgen06_R"</code> only: optional vector
of weights of the same length as <code>x</code>; defaults to all 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convex</code></td>
<td>
<p>logical indicating if convex or concave regression is
desired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string indicating the method used,
</p>

<dl>
<dt>"Duembgen06_R"</dt>
<dd>
<p>is an active set method written by Lutz
Duembgen (University of Berne, CH) in Matlab in 2006 and
translated to <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> by Martin Maechler.</p>
</dd>
<dt>"SR"</dt>
<dd>
<p>is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> interface to the C code of a <b>S</b>upport
<b>R</b>eduction algorithm written by Piet Groeneboom (TU Delft,
NL) and donated to the <span class="pkg">cobs</span> package in July 2012.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>convergence tolerance(s); do not make this too small!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximal number of (outer and inner) iterations of knot
selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjTol</code></td>
<td>
<p>(for <code>"Duembgen06_R"</code> only:) logical indicating if
the convergence test tolerance is to be adjusted (increased) in some cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical or integer indicating if (and how much) knot
placement and fitting iterations should be “reported”.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both algorithms need some numerical tolerances because of rounding
errors in computation of finite difference ratios.
The active-set <code>"Duembgen06_R"</code> method notably has two different
such tolerances which were both <code>1e-7</code><code class="reqn">= 10^{7}</code> up to March
2016.
</p>
<p>The two default tolerances (and the exact convergence checks) may
change in the future, possibly to become more adaptive.


</p>


<h3>Value</h3>

<p>an object of class <code>conreg</code> which is basically a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>sorted (and possibly aggregated) abscissa values <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>corresponding y values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>corresponding weights, <b>only</b> for <code>"Duembgen06_R"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yf</code></td>
<td>
<p>corresponding fitted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convex</code></td>
<td>
<p>logical indicating if a convex or a concave fit has been
computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iKnots</code></td>
<td>
<p>integer vector giving indices of the <em>knots</em>,
i.e. locations where the fitted curve has kinks.
Formally, these are exactly those indices where the constraint is
fulfilled strictly, i.e., those <code class="reqn">i</code> where
</p>
<p style="text-align: center;"><code class="reqn">(m_i - m_{i-1})/(x_i-x_{i-1}) &gt; (m_{i+1} - m_i)/(x_{i+1}-x_i).</code>
</p>

</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the <code>call</code> to <code>conreg()</code> used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>integer (vector of length one or two) with the number of
iterations used (in the outer and inner loop for <code>"Duembgen06_R"</code>).</p>
</td>
</tr>
</table>
<p>Note that there are several methods defined for <code>conreg</code> objects,
see <code>predict.conreg</code> or <code>methods(class = "conreg")</code>.
</p>
<p>Notably <code>print</code> and <code>plot</code>; also
<code>predict</code>, <code>residuals</code>, <code>fitted</code>,
<code>knots</code>.
</p>
<p>Also, <code>interpSplineCon()</code> to construct a more smooth
(<em>cubic</em>) spline, and <code>isIsplineCon()</code> which checks
if the int is strictly concave or convex the same as the
<code>conreg()</code> result from which it was constructed.
</p>


<h3>Author(s)</h3>

<p>Lutz Duembgen programmed the original Matlab code in July 2006;
Martin Maechler ported it to <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, tested, catch infinite loops, added
more options, improved tolerance, etc;  from April 27, 2007.









</p>


<h3>See Also</h3>

<p><code>isoreg</code> for isotone (monotone) regression;
CRAN packages <span class="pkg">ftnonpar</span>, <span class="pkg">cobs</span>, <span class="pkg">logcondens</span>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Generated data :
N &lt;- 100
f &lt;- function(X) 4*X*(1 - X)

xx &lt;- seq(0,1, length=501)# for plotting true f()
set.seed(1)# -&gt; conreg does not give convex cubic

x &lt;- sort(runif(N))
y &lt;- f(x) + 0.2 * rnorm(N)
plot(x,y, cex = 0.6)
lines(xx, f(xx), col = "blue", lty=2)
rc &lt;- conreg(x,y)
lines(rc, col = 2, force.iSpl = TRUE)
 # 'force.iSpl': force the drawing of the cubic spline through the kinks
title("Concave Regression in R")

y2 &lt;- y


## Trivial cases work too:
(r.1 &lt;- conreg(1,7))
(r.2 &lt;- conreg(1:2,7:6))
(r.3  &lt;- conreg(1:3,c(4:5,1)))
</code></pre>


</div>