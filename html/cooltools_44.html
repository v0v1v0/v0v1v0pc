<div class="container">

<table style="width: 100%;"><tr>
<td>ndft</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Non-uniform Discrete Fourier Transform</h2>

<h3>Description</h3>

<p>Compute the one-dimensional Non-uniform Discrete Fourier Transform (NDFT). This is needed if the data are sampled at irregularly spaced times.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ndft(
  f,
  x = seq(0, length(f) - 1)/length(f),
  nu = seq(0, length(f) - 1),
  inverse = FALSE,
  weighing = TRUE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>vector of real or complex function values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of points in direct space, typically time or position coordinates. If <code>inverse=FALSE</code>, <code>x</code> must have the same length as <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>vector of frequencies in units of [1/units of x]. If <code>inverse=TRUE</code>, <code>nu</code> must have the same length as <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverse</code></td>
<td>
<p>logical flag; if TRUE, the inverse Fourier transform is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighing</code></td>
<td>
<p>logical flag; if TRUE, irregularly spaced evaluations of <code>f</code> will be weighted proportionally to their bin width in <code>x</code> (if <code>inverse=FALSE</code>) or <code>nu</code> (if <code>inverse=FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>logical flag; if TRUE, the complex output array will be simplified to a real array, if it is real within the floating point accuracy.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The one-dimensional NDFT of a vector <code class="reqn">f=(f_1,...,f_N)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">F_j=\sum_i w_i f_i exp(-2\pi i*x_i*\nu_j)</code>
</p>
<p> where <code class="reqn">w_i</code> are optional weights, proportional to the interval around <code class="reqn">x_i</code>, only used if <code>weighing=TRUE</code>. Likewise, the inverse NDFT is defined as </p>
<p style="text-align: center;"><code class="reqn">f_i=\sum_j w_j F_j exp(+2\pi i*x_i*nu_j)</code>
</p>
<p> where <code class="reqn">w_j</code> are optional weights, proportional to the interval around <code class="reqn">\nu_j</code>. In this implementation NDFTs are computed using a brute force algorithm, scaling as <code class="reqn">O(N*N)</code>, which is considerably worse than the <code class="reqn">O(N)*log(N)</code> scaling of FFT algorithms. It is therefore important to pick the required frequencies wisely to minimise computing times.
</p>


<h3>Value</h3>

<p>Returns a vector of the same length as <code>x</code> (if <code>inverse=FALSE</code>) or <code>nu</code> (if <code>inverse=TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code>fft</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Define an example signal
nu1 = 1 # [Hz] first frequency
nu2 = 8 # [Hz] second frequency in the signal
s = function(t) sin(2*pi*nu1*t)+0.7*cos(2*pi*nu2*t+5)

# Discretize signal
N = 50 # number of samples
t.uniform = seq(0,N-1)/N
t.nonuniform = t.uniform^1.3
s.uniform = s(t.uniform)
s.nonuniform = s(t.nonuniform)

# Plot signal
oldpar = par(mfrow = c(1, 2))
curve(s,0,1,500,xaxs='i',main='Time signal',xlab='Time t',ylab='s(t)',col='grey')
points(t.uniform,s.uniform,pch=16,cex=0.8)
points(t.nonuniform,s.nonuniform,pch=4,col='blue')
legend('topright',c('Continuous signal','Uniform sample','Non-uniform sample'),
       lwd=c(1,NA,NA),pch=c(NA,16,4),col=c('grey','black','blue'),pt.cex=c(1,0.8,1))

# Uniform and non-uniform DFT
nu = seq(0,N-1) # discrete frequencies
spectrum.uniform = stats::fft(s.uniform)
spectrum.nonuniform = ndft(s.nonuniform,t.nonuniform,nu)
spectrum.wrong = stats::fft(s.nonuniform)

# Evaluate power
power.uniform = Mod(spectrum.uniform)^2
power.nonuniform = Mod(spectrum.nonuniform)^2
power.wrong = Mod(spectrum.wrong)^2

# Plot DFT and NDFT up to Nyquist frequency
plot(nu,power.uniform,pch=16,cex=0.8,xlim=c(0,N/2),xaxs='i',
               main='Power spectrum',xlab=expression('Frequency'~nu~'[Hz]'),ylab='Power')
points(nu,power.nonuniform,pch=4,col='blue')
points(nu,power.wrong,pch=1,col='red')
abline(v=c(nu1,nu2),col='grey',lty=2)
legend('topright',c('DFT of uniform sample','NDFT of non-uniform sample',
'DFT of non-uniform sample (wrong)','Input frequencies'),
       lwd=c(NA,NA,NA,1),lty=c(NA,NA,NA,2),pch=c(16,4,1,NA),
       col=c('black','blue','red','grey'),pt.cex=c(0.8,1,1,NA))
par(oldpar)

</code></pre>


</div>