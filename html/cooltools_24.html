<div class="container">

<table style="width: 100%;"><tr>
<td>griddata</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distribute a point set onto a regular grid</h2>

<h3>Description</h3>

<p>Distributes a set of points in D dimensions onto a regular, D-dimensional grid, using a fast nearest neighbor algorithm. Weights can be used optionally.
</p>


<h3>Usage</h3>

<pre><code class="language-R">griddata(x, w = NULL, n = 10, min = NULL, max = NULL, type = "counts")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>N-element vector (if D=1) or N-by-D matrix (if D&gt;1), giving the Cartesian coordinates of N points in D dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>optional N-element vector with weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>scalar or D-element vector specifying the number of equally space grid cells along each dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min</code></td>
<td>
<p>optional scalar or D-element vector specifying the lower bound of the grid. If not given, min is adjusted to the range of x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max</code></td>
<td>
<p>optional scalar or D-element vector specifying the upper bound of the grid. If not given, max is adjusted to the range of x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character string ("counts", "density", "probability") specifying the normalization of the output: "counts" (default) returns the number of points (multiplied by their weights, if given) in each cell; thus the total number of points (or total mass, if weights are given) is <code>sum(field)</code>. "density" returns the density, such that the total number of points (or total mass, if weights are given) is <code>sum(field) dV</code>. "probability" returns a probability density, such that <code>sum(field) dV</code>=1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list of items
</p>
<table>
<tr style="vertical-align: top;">
<td><code>field</code></td>
<td>
<p>D-dimensional array representing the value in each grid cell. See parameter <code>type</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>List of D elements with the grid properties along each dimension. n: number of grid cells; mid: n-vector of mid-cell coordinates; breaks: (n+1)-vector of cell edges; lim: 2-vector of considered range; delta: cell width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dV</code></td>
<td>
<p>Single number representing the volume of the D-dimensional grid cells.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Distribute 1-dimensional data onto a regular grid
npoints = 1e4
x = rnorm(npoints)
g = griddata(x,min=-3,max=3,n=100,type='probability')
curve(dnorm(x),-3,3)
points(g$grid$mid,g$field,pch=16)

# Distribute 2-dimensional data onto a regular grid
x = runif(100,max=2)
y = runif(100)
g = griddata(cbind(x,y),min=c(0,0),max=c(2,1),n=c(20,10))
image(g$grid[[1]]$breaks,g$grid[[2]]$breaks,g$field,
      asp=1,col=grey.colors(100,0,1),xlab='x',ylab='y')
points(x,y,col='red',pch=16)

# ... same with weights
w = runif(100)
g = griddata(cbind(x,y),w,min=c(0,0),max=c(2,1),n=c(20,10))
image(g$grid[[1]]$breaks,g$grid[[2]]$breaks,g$field,
      asp=1,col=grey.colors(100,0,1),xlab='x',ylab='y')
points(x,y,col='red',pch=16,cex=w)

</code></pre>


</div>