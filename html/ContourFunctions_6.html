<div class="container">

<table style="width: 100%;"><tr>
<td>cf_highdim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot 2D contour slices of higher dimensional functions</h2>

<h3>Description</h3>

<p>Plots a grid of contour plots.
Each contour plot is a contour over two dimensions with the remaining
dimensions set to the baseline value.
Similar to plots created in Hwang et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">cf_highdim(
  func,
  D,
  low = rep(0, D),
  high = rep(1, D),
  baseline = (low + high)/2,
  same_scale = TRUE,
  n = 20,
  batchmax = 1,
  var_names = c(expression(), lapply(1:D, function(ti) bquote(x[.(ti)]))),
  pts = NULL,
  average = FALSE,
  average_reps = 10000,
  axes = TRUE,
  key.axes,
  key.title,
  nlevels = 20,
  levels = pretty(zlim, nlevels),
  color.palette = cm.colors.strong,
  col = color.palette(length(levels) - 1),
  edge_width = 0.04,
  cex.var_names = 1.3,
  bar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>Function to plot contours of</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>Input dimension of function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low</code></td>
<td>
<p>Low input value for each dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>high</code></td>
<td>
<p>High input value for each dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline</code></td>
<td>
<p>Baseline input value for each dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same_scale</code></td>
<td>
<p>Should all contour plots be on the same scale?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of points in grid on each dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batchmax</code></td>
<td>
<p>number of datapoints that can be computed at a time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_names</code></td>
<td>
<p>Variable names to add to plot
Takes longer since it has to precalculate range of outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pts</code></td>
<td>
<p>Matrix of points to show on plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>average</code></td>
<td>
<p>Should the background dimensions be averaged over instead of
set to baseline value? Much slower.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>average_reps</code></td>
<td>
<p>Number of points to average over when using average</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p>logical indicating if axes should be drawn, as in plot.default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.axes</code></td>
<td>
<p>statements which draw axes on the plot key. This overrides the default axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.title</code></td>
<td>
<p>statements which add titles for the plot key.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevels</code></td>
<td>
<p>if levels is not specified, the range of z, values is
divided into approximately this many levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>a set of levels which are used to partition the range of z.
Must be strictly increasing (and finite). Areas with z values between
consecutive levels are painted with the same color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color.palette</code></td>
<td>
<p>A color palette function to be used to assign colors
in the plot. Defaults to cm.colors.strong. Other options include rainbow,
heat.colors, terrain.colors, topo.colors, and function(x) {gray((1:x)/x)}.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>an explicit set of colors to be used in the plot.
This argument overrides any palette function specification.
There should be one less color than levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_width</code></td>
<td>
<p>How wide should edges with variable names be? As proportion of full screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.var_names</code></td>
<td>
<p>Size of var_names printed on edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bar</code></td>
<td>
<p>Should a bar showing the output range and colors be shown on the top right?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to cf_func, and then probably through to cf_grid</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Hwang, Yongmoon, Sang-Lyul Cha, Sehoon Kim, Seung-Seop Jin,
and Hyung-Jo Jung. "The Multiple-Update-Infill Sampling Method Using
Minimum Energy Design for Sequential Surrogate Modeling."
Applied Sciences 8, no. 4 (2018): 481.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Only use 4 dims of 8 for borehole function
cf_highdim(function(x) TestFunctions::borehole(c(x,.5,.5,.5,.5)), 4)
# Add points
cf_highdim(function(x) TestFunctions::borehole(c(x,.5,.5,.5,.5)), 4,
           pts=matrix(c(.1,.3,.6,.9),1,4))

# Full 8D borehole function
cf_highdim(TestFunctions::borehole, 8)

# Putting each plot on separate scale
cf_highdim(TestFunctions::borehole, 8, n=10, same_scale = FALSE)

## End(Not run)

cf_highdim(function(x) {x[1]^2 + exp(x[2])}, D=3)

friedman &lt;- function(x) {
  10*sin(pi*x[1]*x[2]) + 20*(x[3]-.5)^2 + 10*x[4] + 5*x[5]
}
cf_highdim(friedman, 5, color.palette=topo.colors)
cf_highdim(friedman, 5, 
           color.palette=function(x) {gray((1:x)/x)},
           nlevels=10)
           
## Not run: 
# Recreate Plate 1 or Figure 1.1 from Engineering Design via Surrogate
# Modelling by Forrester, Sobester, and Keane (2008).
cf_highdim(function(x)TestFunctions::wingweight(x, scale_it=FALSE),
  D=10, low = c(150,220,6,-10,16,.5,.08,2.5,1700,.025),
  high = c(200,300,10,10,45,1,.18,6,2500,.08),
  baseline=c(174,252,7.52,0,34,.672,.12,3.8,2000,.064),
  color.palette=topo.colors, 
  var_names=c('SW', 'Wtw', 'A', 'Lambda', 'q', 'lambda', 'tc', 'Nz', 'Wdg'))

## End(Not run)

# Average over background dimensions, use higher reps to reduce noise.
f1 &lt;- function(x) {x[1] + x[2]^2 + x[3]^3}
cf_highdim(f1, 4, average=TRUE, average_reps=1e2, n=10)
f1b &lt;- function(x) {x[,1] + x[,2]^2 + x[,3]^3}
cf_highdim(f1b, 4, average=TRUE, average_reps=1e2, n=10, batchmax=Inf)
cf_highdim(f1b, 4, average_reps=1e2, n=10, batchmax=Inf,
           color.palette = topo.colors, nlevels=3)

# This was giving bad result
csa()
split.screen(c(2,1))
screen(2)
cf_highdim(f1b, 4, n=10, batchmax=Inf)
csa()
</code></pre>


</div>