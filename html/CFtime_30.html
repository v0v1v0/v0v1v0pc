<div class="container">

<table style="width: 100%;"><tr>
<td>indexOf,ANY,CFtime-method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the index of timestamps in the time series</h2>

<h3>Description</h3>

<p>In the CFtime instance <code>y</code>, find the index in the time series for each
timestamp given in argument <code>x</code>. Values of <code>x</code> that are before the earliest
value in <code>y</code> will be returned as <code>0</code> (except when the value is before the
datum of <code>y</code>, in which case the value returned is <code>NA</code>); values of <code>x</code> that
are after the latest values in <code>y</code> will be returned as
<code>.Machine$integer.max</code>. Alternatively, when <code>x</code> is a numeric vector of index
values, return the valid indices of the same vector, with the side effect
being the attribute "CFtime" associated with the result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'ANY,CFtime'
indexOf(x, y, method = "constant")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of character, POSIXt or Date values to find indices for, or a
numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>CFtime instance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Single value of "constant" or "linear". If <code>"constant"</code> or when
bounds are set on argument <code>y</code>, return the index value for each match. If
<code>"linear"</code>, return the index value with any fractional value.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Timestamps can be provided as vectors of character strings, <code>POSIXct</code> or
<code>Date.</code>
</p>
<p>Matching also returns index values for timestamps that fall between two
elements of the time series - this can lead to surprising results when time
series elements are positioned in the middle of an interval (as the CF
Metadata Conventions instruct us to "reasonably assume"): a time series of
days in January would be encoded in a netCDF file as
<code>c("2024-01-01 12:00:00", "2024-01-02 12:00:00", "2024-01-03 12:00:00", ...)</code>
so <code>x &lt;- c("2024-01-01", "2024-01-02", "2024-01-03")</code> would result in
<code style="white-space: pre;">⁠(NA, 1, 2)⁠</code> (or <code style="white-space: pre;">⁠(NA, 1.5, 2.5)⁠</code> with <code>method = "linear"</code>) because the date
values in <code>x</code> are at midnight. This situation is easily avoided by ensuring
that <code>y</code> has bounds set (use <code>bounds(y) &lt;- TRUE</code> as a proximate solution if
bounds are not stored in the netCDF file). See the Examples.
</p>
<p>If bounds are set, the indices are taken from those bounds. Returned indices
may fall in between bounds if the latter are not contiguous, with the
exception of the extreme values in <code>x</code>.
</p>
<p>Values of <code>x</code> that are not valid timestamps according to the calendar of <code>y</code>
will be returned as <code>NA</code>.
</p>
<p><code>x</code> can also be a numeric vector of index values, in which case the valid
values in <code>x</code> are returned. If negative values are passed, the positive
counterparts will be excluded and then the remainder returned. Positive and
negative values may not be mixed. Using a numeric vector has
the side effect that the result has the attribute "CFtime" describing the
temporal dimension of the slice. If index values outside of the range of <code>y</code>
(<code>1:length(y)</code>) are provided, an error will be thrown.
</p>


<h3>Value</h3>

<p>A numeric vector giving indices into the "time" dimension of the
dataset associated with <code>y</code> for the values of <code>x</code>. If there is at least 1
valid index, then attribute "CFtime"
contains an instance of CFtime that describes the dimension of filtering
the dataset associated with <code>y</code> with the result of this function, excluding
any <code>NA</code>, <code>0</code> and <code>.Machine$integer.max</code> values.
</p>


<h3>Examples</h3>

<pre><code class="language-R">cf &lt;- CFtime("days since 2020-01-01", "360_day", 1440:1799 + 0.5)
as_timestamp(cf)[1:3]
x &lt;- c("2024-01-01", "2024-01-02", "2024-01-03")
indexOf(x, cf)
indexOf(x, cf, method = "linear")

bounds(cf) &lt;- TRUE
indexOf(x, cf)

# Non-existent calendar day in a `360_day` calendar
x &lt;- c("2024-03-30", "2024-03-31", "2024-04-01")
indexOf(x, cf)

# Numeric x
indexOf(c(29, 30, 31), cf)
</code></pre>


</div>