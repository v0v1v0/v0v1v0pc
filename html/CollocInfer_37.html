<div class="container">

<table style="width: 100%;"><tr>
<td>make.transfer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transfer Functions</h2>

<h3>Description</h3>

<p>Returns a list of functions that calculate the transform and its derivatives. </p>


<h3>Usage</h3>

<pre><code class="language-R">make.id()

make.exp()

make.exptrans()

make.genlin()

make.fhn()

make.Henon()

make.SEIR()

make.NS()

chemo.fun(times,y,p,more=NULL)
</code></pre>


<h3>Arguments</h3>

<p>All the functions 
created by <code>make...</code> functions, require the arguments needed by  <code>chemo.fun</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p> Evaluation times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> Values of the state at the evaluation times </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p> Parameters to be used </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>more</code></td>
<td>
<p> A list of additional arguments, in this case <code>NULL</code>, for
<code>pomp.sekelton</code> and <code>pomp.dmeasure</code>, <code>more</code> should be a list containing a <code>pomp</code> object
in the element <code>pomp.obj</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>make.genlin</code> requires the specification of further elements in the list. In particular
the element <code>more</code> should be a list containing
</p>

<ul>
<li>
<p><code>mat</code> a matrix defining the linear transform before any parameters are added.
This may be all zero, but it may also specify fixed elements, if desired. 
</p>
</li>
<li>
<p><code>sub</code> a k-by-3 matrix indicating which parameters should be entered into
which elements of <code>mat</code>. Each row is a triple giving the row and colum of <code>mat</code> to be 
specified and the element of the parameter vector that should be substituted. <code>sub</code> over-rides
any values in <code>mat</code>.
</p>
</li>
<li>
<p><code>force</code> if input functions are given, these are given as a list.
</p>
</li>
<li>
<p><code>force.mat</code> specifying the influence of the elements of <code>force</code> on the state
variables. Defined as in <code>mat</code>.
</p>
</li>
<li>
<p><code>force.sub</code> defined as in <code>sub</code>, over-rides the elements of <code>force.mat</code> with
parameter values.
</p>
</li>
</ul>
<p><code>make.diagnostics</code> estimates forcing-function diagnostics as in Hooker, 2009 for 
goodness-of-fit assessment. It requires
</p>

<ul>
<li>
<p><code>psi</code> Values of a basis expansion for forcing functions at the quadrature points. 
</p>
</li>
<li>
<p><code>which</code> Which states are to be forced? 
</p>
</li>
<li>
<p><code>fn</code>, <code>dfdx</code>, <code>d2fdx2</code> Functions and derivatives as would be used to estimate 
parameters for the original equations. 
</p>
</li>
<li>
<p>pars Parameters to go into <code>more$fn</code>. 
</p>
</li>
</ul>
<p><code>make.SEIR</code> estimates parameters and a seasonal variation in the infection rate in an 
SEIR model.  It requires the specification of the seasonal change rate in <code>more</code> by
a list with objects
</p>

<ul>
<li>
<p><code>beta.fun</code> A function to calculate beta, it should have arguments <code>t</code>, 
<code>p</code> and <code>betadef</code> and return a matrix giving the value of beta at times <code>t</code> 
with parameters <code>p</code>. 
</p>
</li>
<li>
<p><code>beta.dfdp</code> Should calculate the derivative of <code>beta.fun</code> with respect to <code>p</code>,
at times <code>t</code> returning a matrix. The matrix should be of size <code>length(t)</code> by
<code>length(p)</code> where <code>p</code> is the entire parameter vector. 
</p>
</li>
<li>
<p><code>betadef</code> Additional inputs (eg bases) to <code>beta.fun</code> and <code>beta.dfdp</code>.
</p>
</li>
</ul>
<p><code>make.NS</code> provides functions for the North Shore example. This is a possibly time-varying
forced linear system of one dimension. It requires <code>more</code> to specify <code>betabasis</code> to
describe the autoregressive coefficient, and <code>alphabasis</code> to provide a contant in front of
the functional data object <code>rainfd</code>.
</p>
<p><code>chemo.fun</code> Is a five-state predator-prey-resources model used as an example. It stands
alone as a function and should be used with the <code>findif.ode</code> functions. 
</p>


<h3>Value</h3>

<p>A list of functions that calculate the transform and its derivatives,
in a form compatible with the collocation inference functions.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>make.id</code></td>
<td>
<p> returns the identity transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.exp</code></td>
<td>
<p> returns the exponential transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.genlin</code></td>
<td>
<p> returns a linear combination transform â€“ see details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.fhn</code></td>
<td>
<p> returns the FitzHugh-Nagumo equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.Henon</code></td>
<td>
<p> reutrns the Henon map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.SEIR</code></td>
<td>
<p> returns SEIR equations for estimating the shape of a seasonal forcing component. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.diagnostics</code></td>
<td>
<p> functions to perform forcing function diagnostics. </p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>LS.setup</code>, <code>multinorm.setup</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
# Observe the FitzHugh-Nagumo equations

proc = make.SSEproc()
proc$more = make.fhn()

lik = make.SSElik()
lik$more = make.id()

# Observe an unknown scalar transform of each component of a Henon map, given
# in the first two elements of the parameter vector:

proc = make.Dproc()
proc$more = make.multinorm()
proc$more$more = c(make.Henon,make.cvar)

lik = make.multinorm()
lik$more = c(make.genlin,make.cvar)
lik$more$more = list(mat = matrix(0,2,2),sub=matrix(c(1,1,1,2,2,2),2,3,byrow=TRUE))

# Model SEIR equations on the log scale and then exponentiate

lik = make.SSElik()
lik$more = make.exp()

proc = make.SSEproc()
proc$more = make.logtrans()
proc$more$more = make.SEIR()

</code></pre>


</div>