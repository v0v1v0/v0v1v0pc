<div class="container">

<table style="width: 100%;"><tr>
<td>fnth-fmedian</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast (Grouped, Weighted) N'th Element/Quantile for Matrix-Like Objects
</h2>

<h3>Description</h3>

<p><code>fnth</code> (column-wise) returns the n'th smallest element from a set of unsorted elements <code>x</code> corresponding to an integer index (<code>n</code>), or to a probability between 0 and 1. If <code>n</code> is passed as a probability, ties can be resolved using the lower, upper, or average of the possible elements, or, since v1.9.0, continuous quantile estimation. The new default is quantile type 7 (as in <code>quantile</code>). For <code>n &gt; 1</code>, the lower element is always returned (as in <code>sort(x, partial = n)[n]</code>). See Details.
</p>
<p><code>fmedian</code> is a simple wrapper around <code>fnth</code>, which fixes <code>n = 0.5</code> and (default) <code>ties = "mean"</code> i.e. it averages eligible elements. See Details. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">fnth(x, n = 0.5, ...)
fmedian(x, ...)

## Default S3 method:
fnth(x, n = 0.5, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, ties = "q7", nthreads = .op[["nthreads"]],
     o = NULL, check.o = is.null(attr(o, "sorted")), ...)
## Default S3 method:
fmedian(x, ..., ties = "mean")

## S3 method for class 'matrix'
fnth(x, n = 0.5, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ties = "q7", nthreads = .op[["nthreads"]], ...)
## S3 method for class 'matrix'
fmedian(x, ..., ties = "mean")

## S3 method for class 'data.frame'
fnth(x, n = 0.5, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ties = "q7", nthreads = .op[["nthreads"]], ...)
## S3 method for class 'data.frame'
fmedian(x, ..., ties = "mean")

## S3 method for class 'grouped_df'
fnth(x, n = 0.5, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE, stub = .op[["stub"]],
     ties = "q7", nthreads = .op[["nthreads"]], ...)
## S3 method for class 'grouped_df'
fmedian(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
        use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE, stub = .op[["stub"]],
        ties = "mean", nthreads = .op[["nthreads"]], ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the element to return using a single integer index such that <code>1 &lt; n &lt; NROW(x)</code>, or a probability <code>0 &lt; n &lt; 1</code>. See Details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a factor, <code>GRP</code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code>GRP</code> object) used to group <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values only where <code>x</code> is also missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - "na"     |     1 - "fill"     |     2 - "replace"     |     3 - "-"     |     4 - "-+"     |     5 - "/"     |     6 - "%"     |     7 - "+"     |     8 - "*"     |     9 - "%%"     |     10 - "-%%". See <code>TRA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties</code></td>
<td>
<p>an integer or character string specifying the method to resolve ties between adjacent qualifying elements:
</p>

<table>
<tr>
<td style="text-align: left;">
<em> Int. </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> String </em>   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
<td style="text-align: left;">
                 1 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "mean"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> take the arithmetic mean of all qualifying elements. </td>
</tr>
<tr>
<td style="text-align: left;">
                 2 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "min" </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> take the smallest of the elements. </td>
</tr>
<tr>
<td style="text-align: left;">
                 3 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "max"   </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> take the largest of the elements. </td>
</tr>
<tr>
<td style="text-align: left;">
                 5-9 </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> "qn" </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> continuous quantile types 5-9, see <code>fquantile</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
                </td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>integer. The number of threads to utilize. Parallelism is across groups for grouped computations on vectors and data frames, and at the column-level otherwise. See Details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o</code></td>
<td>
<p>integer. A valid ordering of <code>x</code>, e.g. <code>radixorder(x)</code>. With groups, the grouping needs to be accounted e.g. <code>radixorder(g, x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.o</code></td>
<td>
<p>logical. <code>TRUE</code> checks that each element of <code>o</code> is within <code>[1, length(x)]</code>. The default uses the fact that orderings from <code>radixorder</code> have a <code>"sorted"</code> attribute which let's <code>fnth</code> infer that the ordering is valid. The length and data type of <code>o</code> is always checked, regardless of <code>check.o</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain <code>sum</code> of weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the summed weights column is prefixed by <code>"sum."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for <code>fmedian</code>: further arguments passed to <code>fnth</code> (apart from <code>n</code>). If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For v1.9.0 <code>fnth</code> was completely rewritten in C and offers significantly enhanced speed and functionality. It uses a combination of quickselect, quicksort, and radixsort algorithms, combined with several (weighted) quantile estimation methods and, where possible, OpenMP multithreading. This synthesis can be summarised as follows:
</p>

<ul>
<li>
<p> without weights, quickselect is used to determine a (lower) order statistic. If <code>ties %!in% c("min", "max")</code> a second order statistic is found by taking the max of the upper part of the partitioned array, and the two statistics are averaged using a simple mean (<code>ties = "mean"</code>), or weighted average according to a <code>quantile</code> method (<code>ties = "q5"-"q9"</code>). For <code>n = 0.5</code>, all supported quantile methods give the sample median. With matrices, multithreading is always across columns, for vectors and data frames it is across groups unless <code>is.null(g)</code> for data frames.
</p>
</li>
<li>
<p> with weights and no groups (<code>is.null(g)</code>), <code>radixorder</code> is called internally (on each column of <code>x</code>). The ordering is used to sum the weights in order of <code>x</code> and determine weighted order statistics or quantiles. See details below. Multithreading is disabled as <code>radixorder</code> cannot be called concurrently on the same memory stack.
</p>
</li>
<li>
<p> with weights and groups (<code>!is.null(g)</code>), R's quicksort algorithm is used to sort the data in each group and return an index which can be used to sum the weights in order and proceed as before. This is multithreaded across columns for matrices, and across groups otherwise.
</p>
</li>
<li>
<p> in <code>fnth.default</code>, an ordering of <code>x</code> can be supplied to '<code>o</code>' e.g. <code>fnth(x, 0.75, o = radixorder(x))</code>. This dramatically speeds up the estimation both with and without weights, and is useful if <code>fnth</code> is to be invoked repeatedly on the same data. With groups, <code>o</code> needs to also account for the grouping e.g. <code>fnth(x, 0.75, g, o = radixorder(g, x))</code>. Multithreading is possible across groups. See Examples.
</p>
</li>
</ul>
<p>If <code>n &gt; 1</code>, the result is equivalent to (column-wise) <code>sort(x, partial = n)[n]</code>. Internally, <code>n</code> is converted to a probability using <code>p = (n-1)/(NROW(x)-1)</code>, and that probability is applied to the set of non-missing elements to find the <code>as.integer(p*(fnobs(x)-1))+1L</code>'th element (which corresponds to option <code>ties = "min"</code>). 
When using grouped computations with <code>n &gt; 1</code>, <code>n</code> is transformed to a probability <code>p = (n-1)/(NROW(x)/ng-1)</code> (where <code>ng</code> contains the number of unique groups in <code>g</code>).
</p>
<p>If weights are used and <code>ties = "q5"-"q9"</code>, weighted continuous quantile estimation is done as described in <code>fquantile</code>.
</p>
<p>For <code>ties %in% c("mean", "min", "max")</code>, a target partial sum of weights <code>p*sum(w)</code> is calculated, and the weighted n'th element is the element k such that all elements smaller than k have a sum of weights <code>&lt;= p*sum(w)</code>, and all elements larger than k have a sum of weights <code>&lt;= (1 - p)*sum(w)</code>. If the partial-sum of weights (<code>p*sum(w)</code>) is reached exactly for some element k, then (summing from the lower end) both k and k+1 would qualify as the weighted n'th element. If the weight of element k+1 is zero, k, k+1 and k+2 would qualify... . If <code>n &gt; 1</code>, k is chosen (consistent with the unweighted behavior). 
If <code>0 &lt; n &lt; 1</code>, the <code>ties</code> option regulates how to resolve such conflicts, yielding lower (<code>ties = "min"</code>: k), upper (<code>ties = "max"</code>: k+2) or average weighted (<code>ties = "mean"</code>: mean(k, k+1, k+2)) n'th elements.
</p>
<p>Thus, in the presence of zero weights, the weighted median (default <code>ties = "mean"</code>) can be an arithmetic average of &gt;2 qualifying elements. Users may prefer a quantile based weighted median by setting <code>ties = "q5"-"q9"</code>, which is a continuous function of <code>p</code> and ignores elements with zero weights.
</p>
<p>For data frames, column-attributes and overall attributes are preserved if <code>g</code> is used or <code>drop = FALSE</code>.
</p>


<h3>Value</h3>

<p>The (<code>w</code> weighted) n'th element/quantile of <code>x</code>, grouped by <code>g</code>, or (if <code>TRA</code> is used) <code>x</code> transformed by its (grouped, weighted) n'th element/quantile.
</p>


<h3>See Also</h3>

<p><code>fquantile</code>, <code>fmean</code>, <code>fmode</code>, Fast Statistical Functions, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">## default vector method
mpg &lt;- mtcars$mpg
fnth(mpg)                         # Simple nth element: Median (same as fmedian(mpg))
fnth(mpg, 5)                      # 5th smallest element
sort(mpg, partial = 5)[5]         # Same using base R, fnth is 2x faster.
fnth(mpg, 0.75)                   # Third quartile
fnth(mpg, 0.75, w = mtcars$hp)    # Weighted third quartile: Weighted by hp
fnth(mpg, 0.75, TRA = "-")        # Simple transformation: Subtract third quartile
fnth(mpg, 0.75, mtcars$cyl)             # Grouped third quartile
fnth(mpg, 0.75, mtcars[c(2,8:9)])       # More groups..
g &lt;- GRP(mtcars, ~ cyl + vs + am)       # Precomputing groups gives more speed !
fnth(mpg, 0.75, g)
fnth(mpg, 0.75, g, mtcars$hp)           # Grouped weighted third quartile
fnth(mpg, 0.75, g, TRA = "-")           # Groupwise subtract third quartile
fnth(mpg, 0.75, g, mtcars$hp, "-")      # Groupwise subtract weighted third quartile

## data.frame method
fnth(mtcars, 0.75)
head(fnth(mtcars, 0.75, TRA = "-"))
fnth(mtcars, 0.75, g)
fnth(fgroup_by(mtcars, cyl, vs, am), 0.75)   # Another way of doing it..
fnth(mtcars, 0.75, g, use.g.names = FALSE)   # No row-names generated

## matrix method
m &lt;- qM(mtcars)
fnth(m, 0.75)
head(fnth(m, 0.75, TRA = "-"))
fnth(m, 0.75, g) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fnth(0.75)
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fnth(0.75, hp)         # Weighted
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fnth(0.75, TRA = "/")  # Divide by third quartile
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg, hp) |&gt;    # Faster selecting
      fnth(0.75, hp, "/")  # Divide mpg by its third weighted group-quartile, using hp as weights

# Efficient grouped estimation of multiple quantiles
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt;
    fmutate(o = radixorder(GRPid(), mpg)) |&gt;
    fsummarise(mpg_Q1 = fnth(mpg, 0.25, o = o),
               mpg_median = fmedian(mpg, o = o),
               mpg_Q3 = fnth(mpg, 0.75, o = o))

## fmedian()
fmedian(mpg)                         # Simple median value
fmedian(mpg, w = mtcars$hp)          # Weighted median: Weighted by hp
fmedian(mpg, TRA = "-")              # Simple transformation: Subtract median value
fmedian(mpg, mtcars$cyl)             # Grouped median value
fmedian(mpg, mtcars[c(2,8:9)])       # More groups..
fmedian(mpg, g)
fmedian(mpg, g, mtcars$hp)           # Grouped weighted median
fmedian(mpg, g, TRA = "-")           # Groupwise subtract median value
fmedian(mpg, g, mtcars$hp, "-")      # Groupwise subtract weighted median value

## data.frame method
fmedian(mtcars)
head(fmedian(mtcars, TRA = "-"))
fmedian(mtcars, g)
fmedian(fgroup_by(mtcars, cyl, vs, am))   # Another way of doing it..
fmedian(mtcars, g, use.g.names = FALSE)   # No row-names generated

## matrix method
fmedian(m)
head(fmedian(m, TRA = "-"))
fmedian(m, g) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmedian()
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmedian(hp)           # Weighted
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmedian(TRA = "-")    # De-median
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg, hp) |&gt;   # Faster selecting
      fmedian(hp, "-")  # Weighted de-median mpg, using hp as weights
</code></pre>


</div>