<div class="container">

<table style="width: 100%;"><tr>
<td>mle.getPtDist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CTDncd: A network-based distance metric.</h2>

<h3>Description</h3>

<p>This function calculates the universal distance between patients, using a
mutual information metric, where self-information comes from the minimum
encoding length of each patient's encoded modular perturbations in the
network.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mle.getPtDist(p1.optBS,ptID,p2.optBS,ptID2,data_mx,ranks,p1,
                        thresholdDiff,adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p1.optBS</code></td>
<td>
<p>- The optimal bitstring associated with patient 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ptID</code></td>
<td>
<p>- The identifier associated with patient 1's sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p2.optBS</code></td>
<td>
<p>- The optimal bitstring associated with patient 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ptID2</code></td>
<td>
<p>- The identifier associated with patient 2's sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_mx</code></td>
<td>
<p>- The matrix that gives the perturbation strength
(z-scores) for all variables (columns) for each
patient (rows).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranks</code></td>
<td>
<p>- The list of node ranks, starting with each node in patient
1&amp;2's subsets of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>- The probability that is preferentially distributed between
network nodes by the probability diffusion algorithm based
solely on network connectivity. The remaining probability
(i.e., "p0") is uniformally distributed between network nodes,
regardless of connectivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholdDiff</code></td>
<td>
<p>- When the probability diffusion algorithm exchanges
this amount (thresholdDiff) or less between nodes,
the algorithm returns up the call stack.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj_mat</code></td>
<td>
<p>- The adjacency matrix that encodes the edge weights for the
network, G.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>patientDistances - a distance matrix, where row and columns are
patient identifiers.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Get patient distances for the first 2 patients in the Miller 2015 dataset.
data("Miller2015")
data_mx = Miller2015[-c(1,grep("x - ", rownames(Miller2015))),
                        grep("IEM",colnames(Miller2015))]
data_mx = apply(data_mx[,c(1,2)], c(1,2), as.numeric)
# Build a network, G
adj_mat = matrix(0, nrow=nrow(data_mx), ncol=nrow(data_mx))
rows = sample(seq_len(ncol(adj_mat)), 0.1*ncol(adj_mat))
cols = sample(seq_len(ncol(adj_mat)), 0.1*ncol(adj_mat))
for (i in rows) {for (j in cols) {adj_mat[i,j]=rnorm(1,mean=0,sd=1)}}
colnames(adj_mat) = rownames(data_mx)
rownames(adj_mat) = rownames(data_mx)
G = vector("numeric", length=ncol(adj_mat))
names(G)=colnames(adj_mat) 
# Look at the top 5 metabolites for each patient. 
kmx=5
topMets_allpts = c()
for (pt in seq_len(ncol(data_mx))) {
    topMets_allpts=c(topMets_allpts, 
                    rownames(data_mx)[order(abs(data_mx[,pt]),
                                            decreasing=TRUE)[seq_len(kmx)]])}
topMets_allpts = unique(topMets_allpts)
# Pre-compute node ranks for all metabolites in topMets_allpts
# for faster distance calculations.
ranks = list()
for (n in seq_len(length(topMets_allpts))) { 
    ind = which(names(G)==topMets_allpts[n])
    ranks[[n]]=singleNode.getNodeRanksN(ind,G,0.9,0.01,adj_mat,
                                        topMets_allpts,log2(length(G))) 
}
names(ranks) = topMets_allpts
# Also pre-compute patient bitstrings for faster distance calculations.
ptBSbyK = list()
for (pt in seq_len(ncol(data_mx))) {
    S=rownames(data_mx)[order(abs(data_mx[,pt]),
                                decreasing=TRUE)[seq_len(kmx)]]
    ptBSbyK[[pt]] = mle.getPtBSbyK(S, ranks)
}
# Build your results ("res") list object to store patient distances at
# different size k's.
res = list()
t = list(ncd=matrix(NA, nrow=ncol(data_mx), ncol=ncol(data_mx)))
rownames(t$ncd) = colnames(data_mx)
colnames(t$ncd) = colnames(data_mx)
for (i in seq_len(kmx)) { res[[i]] = t }
for (pt in seq_len(ncol(data_mx))) {
    print(pt)
    ptID = colnames(data_mx)[pt]
    for (pt2 in pt:ncol(data_mx)) {
        ptID2 = colnames(data_mx)[pt2]
        tmp=mle.getPtDist(ptBSbyK[[pt]],ptID,ptBSbyK[[pt2]],ptID2,
                            data_mx,ranks,p1=0.9,thresholdDiff=0.01,adj_mat)
        for (k in seq_len(kmx)) {
            res[[k]]$ncd[ptID, ptID2] = tmp$NCD[k]
            res[[k]]$ncd[ptID2, ptID] = tmp$NCD[k]
        }
    }
}
</code></pre>


</div>