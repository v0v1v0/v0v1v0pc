<div class="container">

<table style="width: 100%;"><tr>
<td>krscvNOMAD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Categorical Kernel Regression Spline Cross-Validation</h2>

<h3>Description</h3>

<p><code>krscvNOMAD</code> computes NOMAD-based (Nonsmooth Optimization by Mesh
Adaptive Direct Search, Abramson, Audet, Couture and Le Digabel
(2011)) cross-validation directed search for a regression spline
estimate of a one (1) dimensional dependent variable on an
<code>r</code>-dimensional vector of continuous and nominal/ordinal
(<code>factor</code>/<code>ordered</code>) predictors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">krscvNOMAD(xz,
           y,
           degree.max = 10, 
           segments.max = 10, 
           degree.min = 0, 
           segments.min = 1,
           cv.df.min = 1,
           complexity = c("degree-knots","degree","knots"),
           knots = c("quantiles","uniform","auto"),
           basis = c("additive","tensor","glp","auto"),
           cv.func = c("cv.ls","cv.gcv","cv.aic"),
           degree = degree,
           segments = segments,
           lambda = lambda, 
           lambda.discrete = FALSE, 
           lambda.discrete.num = 100, 
           random.seed = 42,
           max.bb.eval = 10000,
           initial.mesh.size.real = "r0.1",
           initial.mesh.size.integer = "1",
           min.mesh.size.real = paste("r",sqrt(.Machine$double.eps),sep=""),
           min.mesh.size.integer = "1", 
           min.poll.size.real = "1",
           min.poll.size.integer = "1", 
           opts=list(),
           nmulti = 0,
           tau = NULL,
           weights = NULL,
           singular.ok = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>continuous univariate vector
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xz</code></td>
<td>
<p> continuous and/or nominal/ordinal
(<code>factor</code>/<code>ordered</code>) predictors </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree.max</code></td>
<td>
<p> the maximum degree of the B-spline basis for
each of the continuous predictors (default <code>degree.max=10</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments.max</code></td>
<td>
<p> the maximum segments of the B-spline basis for
each of the continuous predictors (default <code>segments.max=10</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree.min</code></td>
<td>
<p> the minimum degree of the B-spline basis for
each of the continuous predictors (default <code>degree.min=0</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments.min</code></td>
<td>
<p> the minimum segments of the B-spline basis for
each of the continuous predictors (default <code>segments.min=1</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.df.min</code></td>
<td>
<p> the minimum degrees of freedom to allow when
conducting cross-validation (default <code>cv.df.min=1</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complexity</code></td>
<td>
<p>a character string (default
<code>complexity="degree-knots"</code>) indicating whether model
‘complexity’ is determined by the degree of the spline or by
the number of segments (‘knots’). This option allows the user
to use cross-validation to select either the spline degree (number
of knots held fixed) or the number of knots (spline degree held
fixed) or both the spline degree and number of knots</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p> a character string (default <code>knots="quantiles"</code>)
specifying where knots are to be placed. ‘quantiles’ specifies
knots placed at equally spaced quantiles (equal number of observations
lie in each segment) and ‘uniform’ specifies knots placed at
equally spaced intervals. If <code>knots="auto"</code>, the knot type will
be automatically determined by cross-validation </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis</code></td>
<td>
<p> a character string (default <code>basis="additive"</code>)
indicating whether the additive or tensor product B-spline basis
matrix for a multivariate polynomial spline or generalized B-spline
polynomial basis should be used. Note this can be automatically
determined by cross-validation if <code>cv=TRUE</code> and
<code>basis="auto"</code>, and is an ‘all or none’ proposition
(i.e. interaction terms for all predictors or for no predictors
given the nature of ‘tensor products’). Note also that if
there is only one predictor this defaults to <code>basis="additive"</code>
to avoid unnecessary computation as the spline bases are equivalent
in this case </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.func</code></td>
<td>
<p>a character string (default <code>cv.func="cv.ls"</code>)
indicating which method to use to select smoothing
parameters. <code>cv.gcv</code> specifies generalized cross-validation
(Craven and Wahba (1979)), <code>cv.aic</code> specifies expected
Kullback-Leibler cross-validation (Hurvich, Simonoff, and Tsai
(1998)), and <code>cv.ls</code> specifies least-squares
cross-validation  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p> integer/vector specifying the degree of the B-spline
basis for each dimension of the continuous <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments</code></td>
<td>
<p> integer/vector specifying the number of segments of
the B-spline basis for each dimension of the continuous <code>x</code>
(i.e. number of knots minus one)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> real/vector for the categorical predictors. If it is
not NULL, it will be the starting value(s) for lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.discrete</code></td>
<td>
<p> if <code>lambda.discrete=TRUE</code>, the bandwidth
will be discretized into <code>lambda.discrete.num+1</code> points and
<code>lambda</code> will be chosen from these points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.discrete.num</code></td>
<td>
<p>a positive integer indicating the number of
discrete values that lambda can assume - this parameter will only be
used when <code>lambda.discrete=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.seed</code></td>
<td>

<p>when it is not missing and not equal to 0, the initial points  will 
be generated using this seed when <code>nmulti &gt; 0</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.bb.eval</code></td>
<td>

<p>argument passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.mesh.size.real</code></td>
<td>

<p>argument passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.mesh.size.integer</code></td>
<td>

<p>argument passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.mesh.size.real</code></td>
<td>

<p>argument passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.mesh.size.integer</code></td>
<td>

<p>arguments passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.poll.size.real</code></td>
<td>

<p>arguments passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.poll.size.integer</code></td>
<td>

<p>arguments passed to the NOMAD solver (see <code>snomadr</code> for
further details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p> list of optional arguments to be passed to
<code>snomadr</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmulti</code></td>
<td>

<p>integer number of times to restart the process of finding extrema of
the cross-validation function from different (random) initial
points (default <code>nmulti=0</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>if non-null a number in (0,1) denoting the quantile for which a quantile
regression spline is to be estimated rather than estimating the
conditional mean (default <code>tau=NULL</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
Should be ‘NULL’ or a numeric vector.  If non-NULL, weighted least
squares is used with weights ‘weights’ (that is, minimizing
‘sum(w*e^2)’); otherwise ordinary least squares is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>singular.ok</code></td>
<td>

<p>a logical value (default <code>singular.ok=FALSE</code>) that, when
<code>FALSE</code>, discards singular bases during cross-validation (a check
for ill-conditioned bases is performed).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>krscvNOMAD</code> computes NOMAD-based cross-validation for a
regression spline estimate of a one (1) dimensional dependent variable
on an <code>r</code>-dimensional vector of continuous and nominal/ordinal
(<code>factor</code>/<code>ordered</code>) predictors.  Numerical
search for the optimal <code>degree</code>/<code>segments</code>/<code>lambda</code> is
undertaken using <code>snomadr</code>.
</p>
<p>The optimal <code>K</code>/<code>lambda</code> combination is returned along with
other results (see below for return values). The method uses kernel
functions appropriate for categorical (ordinal/nominal) predictors
which avoids the loss in efficiency associated with sample-splitting
procedures that are typically used when faced with a mix of continuous
and nominal/ordinal (<code>factor</code>/<code>ordered</code>)
predictors.
</p>
<p>For the continuous predictors the regression spline model employs
either the additive or tensor product B-spline basis matrix for a
multivariate polynomial spline via the B-spline routines in the GNU
Scientific Library (<a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a>) and the
<code>tensor.prod.model.matrix</code> function.
</p>
<p>For the discrete predictors the product kernel function is of the
‘Li-Racine’ type (see Li and Racine (2007) for details).
</p>


<h3>Value</h3>

<p><code>krscvNOMAD</code> returns a <code>crscv</code> object. Furthermore, the
function <code>summary</code> supports objects of this type. The
returned objects have the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p> scalar/vector containing optimal degree(s) of spline or
number of segments </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.mat</code></td>
<td>
<p> vector/matrix of values of <code>K</code> evaluated during search </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree.max</code></td>
<td>
<p> the maximum degree of the B-spline basis for
each of the continuous predictors (default <code>degree.max=10</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments.max</code></td>
<td>
<p> the maximum segments of the B-spline basis for
each of the continuous predictors (default <code>segments.max=10</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree.min</code></td>
<td>
<p> the minimum degree of the B-spline basis for
each of the continuous predictors (default <code>degree.min=0</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments.min</code></td>
<td>
<p> the minimum segments of the B-spline basis for
each of the continuous predictors (default <code>segments.min=1</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restarts</code></td>
<td>
<p> number of restarts during search, if any </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> optimal bandwidths for categorical predictors </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.mat</code></td>
<td>
<p> vector/matrix of optimal bandwidths for each degree of spline </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.func</code></td>
<td>
<p> objective function value at optimum </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.func.vec</code></td>
<td>
<p> vector of objective function values at each degree
of spline or number of segments in <code>K.mat</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jeffrey S. Racine <a href="mailto:racinej@mcmaster.ca">racinej@mcmaster.ca</a> and Zhenghua Nie <a href="mailto:niez@mcmaster.ca">niez@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Abramson, M.A. and C. Audet and G. Couture and J.E. Dennis Jr. and
S. Le Digabel (2011), “The NOMAD project”. Software available
at https://www.gerad.ca/nomad.
</p>
<p>Craven, P. and G. Wahba (1979), “Smoothing Noisy Data With
Spline Functions,” Numerische Mathematik, 13, 377-403.
</p>
<p>Hurvich, C.M. and J.S. Simonoff and C.L. Tsai (1998),
“Smoothing Parameter Selection in Nonparametric Regression
Using an Improved Akaike Information Criterion,” Journal of the
Royal Statistical Society B, 60, 271-293.
</p>
<p>Le Digabel, S. (2011), “Algorithm 909: NOMAD: Nonlinear
Optimization With The MADS Algorithm”. ACM Transactions on
Mathematical Software, 37(4):44:1-44:15.
</p>
<p>Li, Q. and J.S. Racine (2007), <em>Nonparametric Econometrics:
Theory and Practice,</em> Princeton University Press.
</p>
<p>Ma, S. and J.S. Racine and L. Yang (2015), “Spline
Regression in the Presence of Categorical Predictors,” Journal of
Applied Econometrics, Volume 30, 705-717.
</p>
<p>Ma, S. and J.S. Racine (2013), “Additive Regression
Splines with Irrelevant Categorical and Continuous Regressors,”
Statistica Sinica, Volume 23, 515-541.
</p>


<h3>See Also</h3>

<p><code>loess</code>, <code>npregbw</code>, 
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(42)
## Simulated data
n &lt;- 1000

x &lt;- runif(n)
z &lt;- round(runif(n,min=-0.5,max=1.5))
z.unique &lt;- uniquecombs(as.matrix(z))
ind &lt;-  attr(z.unique,"index")
ind.vals &lt;-  sort(unique(ind))
dgp &lt;- numeric(length=n)
for(i in 1:nrow(z.unique)) {
  zz &lt;- ind == ind.vals[i]
  dgp[zz] &lt;- z[zz]+cos(2*pi*x[zz])
}
y &lt;- dgp + rnorm(n,sd=.1)

xdata &lt;- data.frame(x,z=factor(z))

## Compute the optimal K and lambda, determine optimal number of knots, set
## spline degree for x to 3

cv &lt;- krscvNOMAD(x=xdata,y=y,complexity="knots",degree=c(3),segments=c(5))
summary(cv)
</code></pre>


</div>