<div class="container">

<table style="width: 100%;"><tr>
<td>kproto</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>k-Prototypes Clustering</h2>

<h3>Description</h3>

<p>Computes k-prototypes clustering for mixed-type data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kproto(x, ...)

## Default S3 method:
kproto(
  x,
  k,
  lambda = NULL,
  type = "huang",
  iter.max = 100,
  nstart = 1,
  na.rm = "yes",
  keep.data = TRUE,
  verbose = TRUE,
  init = NULL,
  p_nstart.m = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Data frame with both numerics and factors (also ordered factors are possible).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Either the number of clusters, a vector specifying indices of initial prototypes, or a data frame of 
prototypes of the same columns as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Parameter &gt; 0 to trade off between Euclidean distance of numeric variables and simple matching 
coefficient between categorical variables (if <code>type = "huang"</code>). Also a vector of variable specific factors 
is possible where the order must correspond to the order of the variables in the data. In this case all variables' 
distances will be multiplied by their corresponding lambda value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character, to specify the distance for clustering. Either <code>"huang"</code> or <code>"gower"</code> (cf. details 
below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>
<p>Numeric; maximum number of iterations if no convergence before.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>Numeric; If &gt; 1 repetitive computations with random initializations are computed and the result with 
minimum <code>tot.dist</code> is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Character, either <code>"yes"</code> to strip <code>NA</code> values for complete case analysis, <code>"no"</code> to 
keep and ignore <code>NA</code> values, <code>"imp.internal"</code> to impute the <code>NAs</code> within the algorithm or 
<code>"imp.onestep"</code> to apply the algorithm ignoring the <code>NAs</code> and impute them after the partition is determined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>Logical, whether original should be included in the returned object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, whether additional information about process should be printed. 
Caution: For <code>verbose=FALSE</code>, if the number of clusters is reduced during the iterations it will not mentioned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Character, to specify the initialization strategy. Either <code>"nbh.dens"</code>, <code>"sel.cen"</code> or 
<code>"nstart.m"</code>. Default is <code>"NULL"</code>, which results in nstart repetitive algorithm computations with random 
starting prototypes. Otherwise, <code>nstart</code> is not used. Argument <code>k</code> must be a number if a specific 
initialization strategy is choosen!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_nstart.m</code></td>
<td>
<p>Numeric, probability(=0.9 is default) for <code>init="nstart.m"</code>, where the strategy assures 
that with a probability of <code>p_nstart.m</code> at least one of the m sets of initial prototypes contains objects 
of every cluster group (cf. Aschenbruck et al. (2023): Random-based Initialization for clustering mixed-type data 
with the k-Prototypes algorithm. In: <em>Cladag 2023 Book of abstracts and short spapers</em>, isbn: 9788891935632.).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Like k-means, the k-prototypes algorithm iteratively recomputes cluster prototypes and reassigns 
clusters, whereby with <code>type = "huang"</code> clusters are assigned using the distance
<code class="reqn">d(x,y) =  d_{euclid}(x,y) + \lambda d_{simple\,matching}(x,y)</code>. Cluster prototypes are computed as 
cluster means for numeric variables and modes for factors (cf. Huang, 1998). Ordered factors variables 
are treated as categorical variables.<br>
For <code>type = "gower"</code> range-normalized absolute distances from the cluster median are computed for 
the numeric variables (and for the ranks of the ordered factors respectively). For factors simple matching 
distance is used as in the original k prototypes algorithm. The prototypes are given by the median for 
numeric variables, the mode for factors and the level with the closest rank to the median rank of the 
corresponding cluster (cf. Szepannek et al., 2024).<br>
In case of <code>na.rm = FALSE</code>: for each observation variables with missings are ignored (i.e. only the 
remaining variables are considered for distance computation). In consequence for observations with missings 
this might result in a change of variable's weighting compared to the one specified by <code>lambda</code>. For 
these observations distances to the prototypes will typically be smaller as they are based on fewer variables.<br>
The <code>type</code> argument also accepts input <code>"standard"</code>, but this naming convention is deprecated and 
has been renamed to <code>"huang"</code>. Please use <code>"huang"</code> instead.
</p>


<h3>Value</h3>

<p><code>kmeans</code> like object of class <code>kproto</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Vector of cluster memberships.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>Data frame of cluster prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Distance parameter lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Vector of cluster sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinss</code></td>
<td>
<p>Vector of within cluster distances for each cluster, i.e. summed distances of all observations belonging to a cluster to their respective prototype.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tot.withinss</code></td>
<td>
<p>Target function: sum of all observations' distances to their corresponding cluster prototype.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dists</code></td>
<td>
<p>Matrix with distances of observations to all cluster prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Prespecified maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>List with two elements (vectors) tracing the iteration process: 
<code>tot.dists</code> and <code>moved</code> number of observations over all iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inits</code></td>
<td>
<p>Initial prototypes determined by specified initialization strategy, if init is either 'nbh.dens' or 'sel.cen'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart.m</code></td>
<td>
<p>only for 'init = nstart_m': determined number of randomly choosen sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>if 'keep.data = TRUE' than the original data will be added to the output list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type argument of the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stdization</code></td>
<td>
<p>Only returned for <code>type = "gower"</code>: List of standardized ranks for ordinal variables 
and an additional element <code>num_ranges</code> with ranges of all numeric variables. Used by <code>predict.kproto</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p><a href="mailto:gero.szepannek@web.de">gero.szepannek@web.de</a>
</p>


<h3>References</h3>


<ul>
<li>
<p> Szepannek, G. (2018): clustMixType: User-Friendly Clustering of Mixed-Type Data in R, 
<em>The R Journal 10/2</em>, 200-208, <a href="https://doi.org/10.32614/RJ-2018-048">doi:10.32614/RJ-2018-048</a>.
</p>
</li>
<li>
<p> Aschenbruck, R., Szepannek, G., Wilhelm, A. (2022): Imputation Strategies for Clustering Mixedâ€‘Type Data with Missing Values, 
<em>Journal of Classification</em>, <a href="https://doi.org/10.1007/s00357-022-09422-y">doi:10.1007/s00357-022-09422-y</a>. 
</p>
</li>
<li>
<p> Szepannek, G., Aschenbruck, R., Wilhelm, A. (2024): Clustering Large Mixed-Type Data with Ordinal Variables,
<em>Advances in Data Analysis and Classification</em>, <a href="https://doi.org/10.1007/s11634-024-00595-5">doi:10.1007/s11634-024-00595-5</a>.
</p>
</li>
<li>
<p> Z.Huang (1998): Extensions to the k-Means Algorithm for Clustering Large Data Sets with Categorical Variables, 
<em>Data Mining and Knowledge Discovery 2</em>, 283-304.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># generate toy data with factors and numerics

n   &lt;- 100
prb &lt;- 0.9
muk &lt;- 1.5 
clusid &lt;- rep(1:4, each = n)

x1 &lt;- sample(c("A","B"), 2*n, replace = TRUE, prob = c(prb, 1-prb))
x1 &lt;- c(x1, sample(c("A","B"), 2*n, replace = TRUE, prob = c(1-prb, prb)))
x1 &lt;- as.factor(x1)

x2 &lt;- sample(c("A","B"), 2*n, replace = TRUE, prob = c(prb, 1-prb))
x2 &lt;- c(x2, sample(c("A","B"), 2*n, replace = TRUE, prob = c(1-prb, prb)))
x2 &lt;- as.factor(x2)

x3 &lt;- c(rnorm(n, mean = -muk), rnorm(n, mean = muk), rnorm(n, mean = -muk), rnorm(n, mean = muk))
x4 &lt;- c(rnorm(n, mean = -muk), rnorm(n, mean = muk), rnorm(n, mean = -muk), rnorm(n, mean = muk))

x &lt;- data.frame(x1,x2,x3,x4)

# apply k-prototypes
kpres &lt;- kproto(x, 4)
clprofiles(kpres, x)

# in real world clusters are often not as clear cut
# by variation of lambda the emphasize is shifted towards factor / numeric variables    
kpres &lt;- kproto(x, 2)
clprofiles(kpres, x)

kpres &lt;- kproto(x, 2, lambda = 0.1)
clprofiles(kpres, x)

kpres &lt;- kproto(x, 2, lambda = 25)
clprofiles(kpres, x)

</code></pre>


</div>