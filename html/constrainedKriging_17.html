<div class="container">

<table style="width: 100%;"><tr>
<td>preCKrige</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial Variance-Covariance Matrices for Sets of Points and Polygons</h2>

<h3>Description</h3>

<p>The function <code>preCKrige</code> computes (approximated) spatial
variance-covariance matrices for user-defined sets of points or polygons
(blocks) of any shape for two-dimensional isotropic random fields.  The
areas of a set of polygons (polygon neighbourhood configuration) are
approximated by pixels and the block-block covariances are approximated by
averaging covariances between the pixels used to approximate the polygons.
</p>
<p>The object returned by <code>preCKrige</code> is needed by <code>CKrige</code>
for computing spatial point or block predictions by constrained,
covariance-matching constrained or universal (external drift) Kriging.
</p>


<h3>Usage</h3>

<pre><code class="language-R">preCKrige(newdata, neighbours, model, ...)

## S4 method for signature 'SpatialPoints,ANY,covmodel'
preCKrige(newdata, neighbours, model)

## S4 method for signature 'SpatialPointsDataFrame,ANY,covmodel'
preCKrige(newdata, neighbours, model)

## S4 method for signature 'SpatialPolygons,ANY,covmodel'
preCKrige(newdata, neighbours, model,
  pwidth = 0, pheight = 0, napp = 1, ncores = 1L,
  fork = !identical( .Platform[["OS.type"]], "windows"))

## S4 method for signature 'SpatialPolygonsDataFrame,ANY,covmodel'
preCKrige(newdata, neighbours,
  model, pwidth = 0, pheight = 0, napp = 1, ncores = 1L,
  fork = !identical( .Platform[["OS.type"]], "windows"))
</code></pre>


<h3>Arguments</h3>


<table><tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>either an object of the class
“<code>SpatialPointsDataFrame</code>”
or “<code>SpatialPoints</code>” that contains the coordinates of the
prediction points and optionally additional information (covariates) stored
in the <code>data</code> slot of the <code>SpatialPointsDataFrame</code>,
or an object of the class “<code>SpatialPolygonsDataFrame</code>” or
“<code>SpatialPolygons</code>”
with the coordinates of the polygons (blocks) for which predictions are
computed and optionally additional information (covariates) stored in the
<code>data</code> slot of the
<code>SpatialPolygonsDataFrame</code>.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>neighbours</code></td>
<td>
<p>a list of length <var>n</var> with integer vectors as
components.  <var>n</var> is equal to the number of points if
<code>newdata</code> is an object of class
“<code>SpatialPointsDataFrame</code>” or
“<code>SpatialPoints</code>” or equal to number of polygons (blocks)
if <code>newdata</code> is an object of class
“<code>SpatialPolygonsDataFrame</code>” or
“<code>SpatialPolygons</code>”.
</p>
<p>The <var>i</var>th list component defines the neighbours of the <var>i</var>th
point or <var>i</var>th polygon (block) in <code>newdata</code>, which form
jointly with the <var>i</var>th point or polygon the so-called <em>point</em>
or <em>polygon neighbourhood configuration</em>.  If <code>newdata</code> is
an object of class “<code>SpatialPolygonsDataFrame</code>” or
“<code>SpatialPolygons</code>” the <var>i</var>th list component contains
the indices of the neighbouring polygons for the <var>i</var>th polygon.
If <code>newdata</code> is an object of class “<code>SpatialPoints</code>”
or “<code>SpatialPointsDataFrame</code>” the <var>i</var>th list component
contains the row indices of the neighbouring points in the point
coordinate matrix.  The <var>i</var>th list component is set to
<code>integer(0)</code> if the <var>i</var>th polygon or <var>i</var>th point have no
(defined) neighbours.  By default, the points or polygons have no
neighbours.
</p>
<p>See the second example below where the function <code>poly2nb</code> of the
package <span class="pkg">spdep</span> is used to build a list of neighbours for target
polygons of the  data set <code>meuse.blocks</code>.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an object of class “<code>covmodel</code>”.  The object
contains the parameters of the isotropic covariance function,
generated by the function <code>covmodel</code>.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments if <code>newdata</code> is of class
“<code>SpatialPolygonsDataFrame</code>” or<br>
“<code>SpatialPolygons</code>”.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>pwidth</code></td>
<td>
<p>a positive numeric scalar, defines the width of the
pixels used to approximate the polygon (block) areas.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>pheight</code></td>
<td>
<p>a positive numeric scalar, defines the height of the
pixels used to approximate the polygon (block) areas.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>napp</code></td>
<td>
<p>a positive integer scalar.  <code>napp</code> &gt; 1 reduces the
block-block variance-covariance approximation error.  By default,
<code>napp</code> = 1, see <em>Details.</em></p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer scalar with the number of CPUs to
use for parallel computations.</p>
</td>
</tr></table>
<table><tr style="vertical-align: top;">
<td><code>fork</code></td>
<td>
<p>a logical scalar to control whether parallel
computations are done by forking using <code>mclapply</code>
(non-windows OSes) or by socket clusters using
<code>parLapply</code> (windows OS).</p>
</td>
</tr></table>
<h3>Details</h3>

<p> If the object <code>newdata</code> is of class
“<code>SpatialPolygonsDataFrame</code>” or
“<code>SpatialPolygons</code>” then<br><code>preCKrige</code> searches the
polygon neighbourhood configuration (defined by <code>neighbours</code>)
with the largest bounding box and generates a pixel grid that
completely covers the largest bounding box.  Subsequently, the
covariance matrix of this set of pixels is calculated by the
<span class="pkg">spatialCovariance</span> package and the polygon (block) areas of each
polygon neighbourhood configuration are approximated by intersecting
the polygons with the shifted pixel grid, which yields a pixel
representation of the polygon neighbourhood configuration.  Finally,
the block-block covariances of the polygons are approximated by
averaging the covariances of the pixel representation of the
polygon neighbourhood configuration.
</p>
<p>By default, <code>napp = 1</code>, which means that the approximation of the
block-block variance-covariance matrix for each polygon neighbourhood
configuration is computed just once.  If <code>napp</code> &gt; 1 the
approximation of the block-block variance-covariance matrix for one
polygon neighbourhood configuration is based on the mean of
<code>napp</code> repetitions of the approximation to reduce the
approximation error.  Each of the <code>napp</code> block-block
variance-covariance approximations are based on a new, randomly
shifted pixel gird which results each time in a new pixel
representation of the polygon neighbourhood configuration.  Large
values of the argument <code>napp</code> increases the computation time.
</p>
<p>There is a plot method <code>plot.preCKrigePolygons</code> for
<code>preCKrige</code> output objects of class<br>
“<code>preCKrigePolygons</code>” to visually control the polygon
(block) area approximation by the pixels.  </p>


<h3>Value</h3>

<p><code>preCKrige</code> returns an S4 object, either of class
“<code>preCKrigePolygons</code>” if
<code>newdata</code> is of class<br> “<code>SpatialPolygons</code>” or
“<code>SpatialPolygonsDataFrame</code>” or an S4 object of class
“<code>preCKrigePoints</code>” if
<code>newdata</code> is of class “<code>SpatialPoints</code>” or
“<code>SpatialPointsDataFrame</code>”.
</p>
<p><em>Notation</em>:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code class="reqn">n</code> </td>
<td style="text-align: left;"> number of polygons or points in <code>newdata</code>,
               <var>i</var> = 1, ..., <code class="reqn">n</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
  <code class="reqn">m_i</code> </td>
<td style="text-align: left;"> size of point or polygon neighbourhood configuration </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> <code class="reqn">m_i</code> = 1 + number of (defined) neighbours of the <var>i</var>th point
               or <var>i</var>th polygon </td>
</tr>
<tr>
<td style="text-align: left;">
  <code class="reqn">r_{\mathrm{pix}}</code> </td>
<td style="text-align: left;"> number of pixel grid rows </td>
</tr>
<tr>
<td style="text-align: left;">
  <code class="reqn">c_{\mathrm{pix}}</code>  </td>
<td style="text-align: left;"> number of pixel grid columns </td>
</tr>
<tr>
<td style="text-align: left;">
  <code class="reqn">n_{\mathrm{pix}}</code>  </td>
<td style="text-align: left;"> number of pixels in pixel grid
     <code class="reqn">n_{\mathrm{pix}} = r_{\mathrm{pix}} \cdot c_{\mathrm{pix}}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>An object of class “<code>preCKrigePoints</code>” contains the
following slots:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>covmat</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list component
contains the point-point covariance matrix of the <code class="reqn">i</code>th prediction
point and its neighbours, i.e. of the <code class="reqn">i</code>th point neighbourhood
configuration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posindex</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list component
contains a vector with the row indices of the <code class="reqn">m_i - 1</code> neighbours
in the <code class="reqn">i</code>th point neighbourhood configuration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an object of class “<code>covmodel</code>” with the
parameters of the used covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame, which is the <code>data</code> slot of the
<code>SpatialPointsDataFrame</code> object.  This data frame is used to
build the design matrix of the prediction points by the
<code>CKrige</code> function.  <code>data</code> is empty with
<code>dim(data)</code> = (0, 0) if <code>newdata</code> is an object of class
“<code>SpatialPoints</code>”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>a matrix with <code>dim(coords)</code> = (<code class="reqn">n</code>, 2) with the
coordinates of the prediction points.</p>
</td>
</tr>
</table>
<p>An object of class “<code>preCKrigePolygons</code>” contains the
following slots:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>covmat</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list component
contains the approximated block-block covariance matrix of the
<code class="reqn">i</code>th polygon and its neighbours, i.e. of the <code class="reqn">i</code>th polygon
neighbourhood configuration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.covmat</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list
component contains a matrix with the standard errors of the
approximated block-block covariances of the <code class="reqn">i</code>th polygon
neighbourhood configuration. Values are equal to <code>NaN</code> for
argument <code>napp = 1</code>, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixconfig</code></td>
<td>
<p>a list of lists of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list
component contains a list with the information about the pixels used
for the covariance approximation of the <code class="reqn">i</code>th polygon
neighbourhood configuration.  The components of <code>pixconfig</code> are
described below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixcovmat</code></td>
<td>
<p>a matrix, <code>dim(matrix)</code> =
(<code class="reqn">n_{\mathrm{pix}}</code>, <code class="reqn">n_{\mathrm{pix}}</code> ), with
the covariance matrix of the pixels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an object of class “<code>covmodel</code>” with the
parameters of the used covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame which is the <code>data</code> slot of the
<code>SpatialPolygonsDataFrame</code> object.  This data frame is used to
build the design matrix of the prediction polygons by the
<code>CKrige</code> function.  <code>data</code> is empty with
<code>dim(data)</code> = (0, 0) if <code>newdata</code> is an object of class
“<code>SpatialPolygons</code>”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polygons</code></td>
<td>
<p>a <code>SpatialPolygons</code> object.  A list of length
<code class="reqn">n</code> with the polygons of the <code>newdata</code> object.</p>
</td>
</tr>
</table>
<p>The <code class="reqn">i</code>th component of <code>pixconfig</code> is a list with the
following 10 components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pixcenter</code></td>
<td>
<p>a matrix with <code>dim(pixcenter)</code> =
(<code class="reqn">n_{\mathrm{pix}}</code>, 2) with the coordinates of the pixels
centroids for the <code class="reqn">i</code>th polygon neighbourhood configuration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowwidth</code></td>
<td>
<p><code>preCKrige</code> input argument <code>pheight</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colwidth</code></td>
<td>
<p><code>preCKrige</code> input argument <code>pwidth</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrows</code></td>
<td>
<p>a numeric scalar with number of rows
<code class="reqn">r_{\mathrm{pix}}</code> of the pixel grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncols</code></td>
<td>
<p>a numeric scalar with number of columns
<code class="reqn">c_{\mathrm{pix}}</code> of the pixel grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.pix.in.poly</code></td>
<td>
<p>a numeric vector of length <code class="reqn">m_i</code>, each
number indicates by how many pixels a polygon of the <code class="reqn">i</code>th polygon
configuration is approximated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sa.polygons</code></td>
<td>
<p>a logical vector of length <code class="reqn">m_i</code>, TRUE means
that the <code class="reqn">i</code>th polygon is treated as a point because its area is
smaller than the area of a pixel, and FALSE means that the polygon is
approximated by pixels, see <em>Note</em> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polygon.centroids</code></td>
<td>
<p>a matrix with <code>dim(polygon.centroids)</code> =
(<code class="reqn">m_i</code>, 2) with the coordinates of the polygon centroids of the
<code class="reqn">i</code>th polygon neighbourhood configuration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posindex</code></td>
<td>
<p>an integer vector of length <code class="reqn">m_i</code> with indices of
the <code class="reqn">i</code>th polygon and its neighbours as defined by the argument
<code>neighbours</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pix.in.poly</code></td>
<td>
<p>is a binary matrix with <code>dim(pix.in.poly)</code> =
(<code class="reqn">n_{\mathrm{pix}}</code>, <code class="reqn">m_i</code>).  <code>pix.in.poly[k, j] = 1</code>
indicates that the centroid of the <var>k</var>th pixel lies in the
<var>j</var>th polygon, and <code>pix.in.poly[k, j] = 0</code> indicates that the
<var>k</var>th pixel centroid does not lie in the <var>j</var>th
polygon.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>A polygon (block) is treated as point if the polygon area is smaller than
the (defined) pixel area or if all pixel centroids of the generated pixel grid
lie outside the polygon (block) area.  If a pixel centroid lies
inside a polygon that has a smaller area than a pixel, the pixel is
allocated to the polygon (block) by which it shares the largest area.
</p>
<p>The point-point correlations are calculated via the internal function
<code>CorrelationFct</code> (this function implements a subset of the
covariance models available previously in the function
<code>CovarianceFct</code> of the archived package <span class="pkg">RandomFields</span>,
version 2.0.71) and the point-block covariances are calculated by the C
function <code>PointRectCov</code> of the package.</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a>
</p>


<h3>References</h3>

<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562–1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>
</p>


<h3>See Also</h3>

 <p><code>CKrige</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
### first example
### load data
data(meuse, package = "sp")
data(meuse.blocks)

### plot blocks
plot(meuse.blocks)

### compute the approximated block variance of each block in meuse.blocks
### without any neighbouring blocks (default, required for in universal
### and constrained Kriging) for an exponential covariance function without
### a measurement error, a nugget  = 0.15 (micro scale white noise process),
### a partial sill variance = 0.15 and a scale parameter = 192.5
### approximation of block variance by pixel of size 75m x 75m
preCK_1 &lt;- preCKrige(newdata = meuse.blocks, model = covmodel(modelname =
    "exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### plot block approximation for block 59
plot(preCK_1, 59)

### second example
### define neighbours by using the poly2nb function
### of the spdep package
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours &lt;- spdep::poly2nb(meuse.blocks)
class(neighbours)
### neighbours should be an object of class "list"
class(neighbours) &lt;- "list"
### compute the approximated block variance-covariance
### matrices of each block in meuse.blocks without the
### defined block neighbours
preCK_2 &lt;- preCKrige(newdata = meuse.blocks, neighbours = neighbours,
  model = covmodel("exponential", nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### plot block approximation of block 59 and its
### block neighbours
plot(preCK_2, 59)

</code></pre>


</div>