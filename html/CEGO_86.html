<div class="container">

<table style="width: 100%;"><tr>
<td>nearCNSD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nearest CNSD matrix</h2>

<h3>Description</h3>

<p>This function
implements the alternating projection algorithm by Glunt et al. (1990) to calculate the nearest conditionally
negative semi-definite (CNSD) matrix (or: the nearest Euclidean distance matrix).
The function is similar to the <code>nearPD</code> function from the <code>Matrix</code> package, 
which implements a very similar algorithm for finding the nearest Positive Semi-Definite (PSD) matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nearCNSD(
  x,
  eig.tol = 1e-08,
  conv.tol = 1e-08,
  maxit = 1000,
  conv.norm.type = "F"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>symmetric matrix, to be turned into a CNSD matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eig.tol</code></td>
<td>
<p>eigenvalue torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv.tol</code></td>
<td>
<p>convergence torelance value. The algorithm stops if the norm of the difference between two iterations is below this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations. The algorithm stops if this value is exceeded, even if not converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv.norm.type</code></td>
<td>
<p>type of norm, by default the F-norm (Frobenius). See <code>norm</code> for other choices.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list with:
</p>

<dl>
<dt><code>mat</code></dt>
<dd>
<p> nearestCNSD matrix</p>
</dd>
<dt><code>normF</code></dt>
<dd>
<p> F-norm between original and resulting matrices</p>
</dd>
<dt><code>iterations</code></dt>
<dd>
<p> the number of performed</p>
</dd>
<dt><code>rel.tol</code></dt>
<dd>
<p> the relative value used for the tolerance convergence criterion</p>
</dd>
<dt><code>converged</code></dt>
<dd>
<p> a boolean that records whether the algorithm</p>
</dd>
</dl>
<h3>References</h3>

<p>Glunt, W.; Hayden, T. L.; Hong, S. and Wells, J. An alternating projection algorithm for computing the nearest Euclidean distance matrix, SIAM Journal on Matrix Analysis and Applications, SIAM, 1990, 11, 589-600
</p>


<h3>See Also</h3>

<p><code>nearPD</code>, <code>correctionCNSD</code>, <code>correctionDistanceMatrix</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># example using Insert distance with permutations:
x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
print(D)
is.CNSD(D)
nearD &lt;- nearCNSD(D)
print(nearD)
is.CNSD(nearD$mat)
# or example matrix from Glunt et al. (1990):
D &lt;- matrix(c(0,1,1,1,0,9,1,9,0),3,3)
print(D)
is.CNSD(D)
nearD &lt;- nearCNSD(D)
print(nearD)
is.CNSD(nearD$mat)
# note, that the resulting values given by Glunt et al. (1990) are 19/9 and 76/9
</code></pre>


</div>