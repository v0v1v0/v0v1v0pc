<div class="container">

<table style="width: 100%;"><tr>
<td>covdepGE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Covariate Dependent Graph Estimation</h2>

<h3>Description</h3>

<p>Model the conditional dependence structure of <code>X</code> as a function
of <code>Z</code> as described in (1)
</p>


<h3>Usage</h3>

<pre><code class="language-R">covdepGE(
  X,
  Z = NULL,
  hp_method = "hybrid",
  ssq = NULL,
  sbsq = NULL,
  pip = NULL,
  nssq = 5,
  nsbsq = 5,
  npip = 5,
  ssq_mult = 1.5,
  ssq_lower = 1e-05,
  snr_upper = 25,
  sbsq_lower = 1e-05,
  pip_lower = 1e-05,
  pip_upper = NULL,
  tau = NULL,
  norm = 2,
  center_X = TRUE,
  scale_Z = TRUE,
  alpha_tol = 1e-05,
  max_iter_grid = 10,
  max_iter = 100,
  edge_threshold = 0.5,
  sym_method = "mean",
  parallel = FALSE,
  num_workers = NULL,
  prog_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code class="reqn">n \times p</code> numeric matrix; data matrix. For best
results, <code class="reqn">n</code> should be greater than <code class="reqn">p</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p><code>NULL</code> OR <code class="reqn">n \times q</code> numeric matrix; extraneous
covariates. If <code>NULL</code>, <code>Z</code> will be treated as constant for all observations,
i.e.:
</p>
<div class="sourceCode"><pre>Z &lt;- rep(0, nrow(X))
</pre></div>
<p>If <code>Z</code> is constant, the estimated graph will be homogeneous throughout the
data. <code>NULL</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hp_method</code></td>
<td>
<p><code>character</code> in <code>c("grid_search","model_average","hybrid")</code>;
method for selecting hyperparameters from the the hyperparameter grid. The
grid will be generated as the Cartesian product of <code>ssq</code>, <code>sbsq</code>, and <code>pip</code>.
Fix <code class="reqn">X_j</code>, the <code class="reqn">j</code>-th column of <code>X</code>, as the response; then, the
hyperparameters will be selected as follows:
</p>

<ul>
<li>
<p> If <code>"grid_search"</code>, the point in the hyperparameter grid that
maximizes the total ELBO summed across all <code class="reqn">n</code> regressions will be
selected
</p>
</li>
<li>
<p> If <code>"model_average"</code>, then all posterior quantities will be an
average of the variational estimates resulting from the model fit for each
point in the hyperparameter grid. The unnormalized averaging weights for
each of the <code class="reqn">n</code> regressions are the exponentiated ELBO
</p>
</li>
<li>
<p> If <code>"hybrid"</code>, then models will be averaged over <code>pip</code> as in
<code>"model_average"</code>, with <code class="reqn">\sigma^2</code> and
<code class="reqn">\sigma_\beta^2</code> chosen for each <code class="reqn">\pi</code> in <code>pip</code>
by maximizing the total ELBO over the grid defined by the Cartesian
product of <code>ssq</code> and <code>sbsq</code> as in <code>"grid_search"</code>
</p>
</li>
</ul>
<p><code>"hybrid"</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssq</code></td>
<td>
<p><code>NULL</code> OR numeric vector with positive entries; candidate values
of the hyperparameter <code class="reqn">\sigma^2</code> (prior residual variance). If
<code>NULL</code>, <code>ssq</code> will be generated for each variable <code class="reqn">X_j</code> fixed as the
response as:
</p>
<div class="sourceCode"><pre>ssq &lt;- seq(ssq_lower, ssq_upper, length.out = nssq)
</pre></div>
<p><code>NULL</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sbsq</code></td>
<td>
<p><code>NULL</code> OR numeric vector with positive entries; candidate values
of the hyperparameter <code class="reqn">\sigma_\beta^2</code> (prior slab
variance). If <code>NULL</code>, <code>sbsq</code> will be generated for each variable
<code class="reqn">X_j</code> fixed as the response as:
</p>
<div class="sourceCode"><pre>sbsq &lt;- seq(sbsq_lower, sbsq_upper, length.out = nsbsq)
</pre></div>
<p><code>NULL</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pip</code></td>
<td>
<p><code>NULL</code> OR numeric vector with entries in <code class="reqn">(0, 1)</code>; candidate
values of the hyperparameter <code class="reqn">\pi</code> (prior inclusion probability). If
<code>NULL</code>, <code>pip</code> will be generated for each variable <code class="reqn">X_j</code> fixed as the
response as:
</p>
<div class="sourceCode"><pre>pip &lt;- seq(pip_lower, pi_upper, length.out = npip)
</pre></div>
<p><code>NULL</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nssq</code></td>
<td>
<p>positive integer; number of points to generate for <code>ssq</code> if
<code>ssq</code> is <code>NULL</code>. <code>5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsbsq</code></td>
<td>
<p>positive integer; number of points to generate for <code>sbsq</code> if
<code>sbsq</code> is <code>NULL</code>. <code>5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npip</code></td>
<td>
<p>positive integer; number of points to generate for <code>pip</code> if <code>pip</code>
is <code>NULL</code>. <code>5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssq_mult</code></td>
<td>
<p>positive numeric; if <code>ssq</code> is <code>NULL</code>, then for each variable
<code class="reqn">X_j</code> fixed as the response:
</p>
<div class="sourceCode"><pre>ssq_upper &lt;- ssq_mult * stats::var(X_j)
</pre></div>
<p>Then, <code>ssq_upper</code> will be the greatest value in <code>ssq</code> for variable
<code class="reqn">X_j</code>. <code>1.5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssq_lower</code></td>
<td>
<p>positive numeric; if <code>ssq</code> is <code>NULL</code>, then <code>ssq_lower</code> will
be the least value in <code>ssq</code>. <code>1e-5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snr_upper</code></td>
<td>
<p>positive numeric; upper bound on the signal-to-noise ratio.
If <code>sbsq</code> is <code>NULL</code>, then for each variable <code class="reqn">X_j</code> fixed as the
response:
</p>
<div class="sourceCode"><pre>s2_sum &lt;- sum(apply(X, 2, stats::var))
sbsq_upper &lt;- snr_upper / (pip_upper * s2_sum)
</pre></div>
<p>Then, <code>sbsq_upper</code> will be the greatest value in <code>sbsq</code>. <code>25</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sbsq_lower</code></td>
<td>
<p>positive numeric; if <code>sbsq</code> is <code>NULL</code>, then <code>sbsq_lower</code>
will be the least value in <code>sbsq</code>. <code>1e-5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pip_lower</code></td>
<td>
<p>numeric in <code class="reqn">(0, 1)</code>; if <code>pip</code> is <code>NULL</code>, then
<code>pip_lower</code> will be the least value in <code>pip</code>. <code>1e-5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pip_upper</code></td>
<td>
<p><code>NULL</code> OR  numeric in <code class="reqn">(0, 1)</code>; if <code>pip</code> is <code>NULL</code>, then
<code>pip_upper</code> will be the greatest value in <code>pip</code>. If <code>sbsq</code> is <code>NULL</code>,
<code>pip_upper</code> will be used to calculate <code>sbsq_upper</code>. If <code>NULL</code>, <code>pip_upper</code>
will be calculated for each variable <code class="reqn">X_j</code> fixed as the response as:
</p>
<div class="sourceCode"><pre>lasso &lt;- glmnet::cv.glmnet(X, X_j)
non0 &lt;- sum(glmnet::coef.glmnet(lasso, s = "lambda.1se")[-1] != 0)
non0 &lt;- min(max(non0, 1), p - 1)
pip_upper &lt;- non0 / p
</pre></div>
<p><code>NULL</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p><code>NULL</code> OR positive numeric OR numeric vector of length <code class="reqn">n</code>
with positive entries; bandwidth parameter. Greater values allow for more
information to be shared between observations. Allows for global or
observation-specific specification. If <code>NULL</code>, use 2-step KDE methodology as
described in (2) to calculate observation-specific bandwidths. <code>NULL</code> by
default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>numeric in <code class="reqn">[1, \infty]</code>; norm to use when
calculating weights. <code>Inf</code> results in infinity norm. <code>2</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center_X</code></td>
<td>
<p>logical; if <code>TRUE</code>, center <code>X</code> column-wise to mean <code class="reqn">0</code>.
<code>TRUE</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_Z</code></td>
<td>
<p>logical; if <code>TRUE</code>, center and scale <code>Z</code> column-wise to mean
<code class="reqn">0</code>, standard deviation <code class="reqn">1</code> prior to calculating the weights. <code>TRUE</code>
by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_tol</code></td>
<td>
<p>positive numeric; end CAVI when the Frobenius norm of the
change in the alpha matrix is within <code>alpha_tol</code>. <code>1e-5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_grid</code></td>
<td>
<p>positive integer; if tolerance criteria has not been
met by <code>max_iter_grid</code> iterations during grid search, end CAVI. After grid
search has completed, CAVI is performed with the final hyperparameters
selected by grid search for at most <code>max_iter</code> iterations. Does not apply to
<code>hp_method = "model_average"</code>. <code>10</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>positive integer; if tolerance criteria has not been met by
<code>max_iter</code> iterations, end CAVI. <code>100</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_threshold</code></td>
<td>
<p>numeric in <code class="reqn">(0, 1)</code>; a graph for each observation
will be constructed by including an edge between variable <code class="reqn">i</code> and
variable <code class="reqn">j</code> if, and only if, the <code class="reqn">(i, j)</code> entry of the symmetrized
posterior inclusion probability matrix corresponding to the observation is
greater than <code>edge_threshold</code>. <code>0.5</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sym_method</code></td>
<td>
<p><code>character</code> in <code>c("mean","max","min")</code>; to symmetrize
the posterior inclusion probability matrix for each observation, the
<code class="reqn">(i, j)</code> and <code class="reqn">(j, i)</code> entries will be post-processed as <code>sym_method</code>
applied to the <code class="reqn">(i, j)</code> and <code class="reqn">(j, i)</code> entries. <code>"mean"</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical; if <code>TRUE</code>, hyperparameter selection and CAVI for
each of the <code class="reqn">p</code> variables will be performed in parallel using <code>foreach</code>.
Parallel backend may be registered prior to making a call to <code>covdepGE</code>. If
no active parallel backend can be detected, then parallel backend will be
automatically registered using:
</p>
<div class="sourceCode"><pre>doParallel::registerDoParallel(num_workers)
</pre></div>
<p><code>FALSE</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_workers</code></td>
<td>
<p><code>NULL</code> OR positive integer less than or equal to
<code>parallel::detectCores()</code>; argument to <code>doParallel::registerDoParallel</code> if
<code>parallel = TRUE</code> and no parallel backend is detected. If <code>NULL</code>, then:
</p>
<div class="sourceCode"><pre>num_workers &lt;- floor(parallel::detectCores() / 2)
</pre></div>
<p><code>NULL</code> by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prog_bar</code></td>
<td>
<p>logical; if <code>TRUE</code>, then a progress bar will be displayed
denoting the number of remaining variables to fix as the response and perform
CAVI. If <code>parallel</code>, no progress bar will be displayed. <code>TRUE</code> by default</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns object of class <code>covdepGE</code> with the following values:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>graphs</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>graphs</code>: list of <code class="reqn">n</code> numeric matrices of dimension
<code class="reqn">p \times p</code>; the <code class="reqn">l</code>-th matrix is the adjacency matrix
for the <code class="reqn">l</code>-th observation
</p>
</li>
<li> <p><code>unique_graphs</code>: list; the <code class="reqn">l</code>-th element is a list containing
the <code class="reqn">l</code>-th unique graph and the indices of the observation(s)
corresponding to this graph
</p>
</li>
<li> <p><code>inclusion_probs_sym</code>: list of <code class="reqn">n</code> numeric matrices of
dimension <code class="reqn">p \times p</code>; the <code class="reqn">l</code>-th matrix is the
symmetrized posterior inclusion probability matrix for the <code class="reqn">l</code>-th
observation
</p>
</li>
<li> <p><code>inclusion_probs_asym</code>: list of <code class="reqn">n</code> numeric matrices of
dimension <code class="reqn">p \times p</code>; the <code class="reqn">l</code>-th matrix is the
posterior inclusion probability matrix for the <code class="reqn">l</code>-th observation
prior to symmetrization
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variational_params</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>alpha</code>: list of <code class="reqn">p</code> numeric matrices of dimension
<code class="reqn">n \times (p - 1)</code>; the <code class="reqn">(i, j)</code> entry of the
<code class="reqn">k</code>-th matrix is the variational approximation to the posterior
inclusion probability of the <code class="reqn">j</code>-th variable in a weighted
regression with variable <code class="reqn">k</code> fixed as the response, where the
weights are taken with respect to observation <code class="reqn">i</code>
</p>
</li>
<li> <p><code>mu</code>: list of <code class="reqn">p</code> numeric matrices of dimension
<code class="reqn">n \times (p - 1)</code>; the <code class="reqn">(i, j)</code> entry of the
<code class="reqn">k</code>-th matrix is the variational approximation to the posterior slab
mean for the <code class="reqn">j</code>-th variable in a weighted regression with variable
<code class="reqn">k</code> fixed as the response, where the weights are taken with respect
to observation <code class="reqn">i</code>
</p>
</li>
<li> <p><code>ssq_var</code>: list of <code class="reqn">p</code> numeric
matrices of dimension <code class="reqn">n \times (p - 1)</code>; the
<code class="reqn">(i, j)</code> entry of the <code class="reqn">k</code>-th matrix is the variational
approximation to the posterior slab variance for the <code class="reqn">j</code>-th variable
in a weighted regression with variable <code class="reqn">k</code> fixed as the response,
where the weights are taken with respect to observation <code class="reqn">i</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyperparameters</code></td>
<td>
<p>list of <code class="reqn">p</code> lists; the <code class="reqn">j</code>-th list has the
following values for variable <code class="reqn">j</code> fixed as the response:
</p>

<ul>
<li> <p><code>grid</code>: matrix of candidate hyperparameter values, corresponding
ELBO, and iterations to converge
</p>
</li>
<li> <p><code>final</code>: the final hyperparameters chosen by grid search and the
ELBO and iterations to converge for these hyperparameters
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_details</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>elapsed</code>: amount of time to fit the model
</p>
</li>
<li> <p><code>n</code>: number of observations
</p>
</li>
<li> <p><code>p</code>: number of variables
</p>
</li>
<li> <p><code>ELBO</code>: ELBO summed across all observations and variables. If
<code>hp_method</code> is <code>"model_average"</code> or <code>"hybrid"</code>, this ELBO is averaged
across the hyperparameter grid using the model averaging weights for
each variable
</p>
</li>
<li> <p><code>num_unique</code>: number of unique graphs
</p>
</li>
<li> <p><code>grid_size</code>: number of points in the hyperparameter grid
</p>
</li>
<li> <p><code>args</code>: list containing all passed arguments of length <code class="reqn">1</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>weights</code>: <code class="reqn">n\times n</code> numeric matrix. The <code class="reqn">(i, j)</code>
entry is the similarity weight of the <code class="reqn">i</code>-th observation with
respect to the <code class="reqn">j</code>-th observation using the <code class="reqn">j</code>-th observation's
bandwidth
</p>
</li>
<li> <p><code>bandwidths</code>: numeric vector of length <code class="reqn">n</code>. The <code class="reqn">i</code>-th
entry is the bandwidth for the <code class="reqn">i</code>-th observation
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>References</h3>

<p>(1) Sutanoy Dasgupta, Peng Zhao, Prasenjit Ghosh, Debdeep Pati, and Bani
Mallick. An approximate Bayesian approach to covariate-dependent graphical
modeling. pages 1–59, 2022.
</p>
<p>(2) Sutanoy Dasgupta, Debdeep Pati, and Anuj Srivastava. A Two-Step Geometric
Framework For Density Modeling. <em>Statistica Sinica</em>, 30(4):2155–2177, 2020.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(ggplot2)

# get the data
set.seed(12)
data &lt;- generateData()
X &lt;- data$X
Z &lt;- data$Z
interval &lt;- data$interval
prec &lt;- data$true_precision

# get overall and within interval sample sizes
n &lt;- nrow(X)
n1 &lt;- sum(interval == 1)
n2 &lt;- sum(interval == 2)
n3 &lt;- sum(interval == 3)

# visualize the distribution of the extraneous covariate
ggplot(data.frame(Z = Z, interval = as.factor(interval))) +
  geom_histogram(aes(Z, fill = interval), color = "black", bins = n %/% 5)

# visualize the true precision matrices in each of the intervals

# interval 1
matViz(prec[[1]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 1, observations 1,...,", n1))

# interval 2 (varies continuously with Z)
cat("\nInterval 2, observations ", n1 + 1, ",...,", n1 + n2, sep = "")
int2_mats &lt;- prec[interval == 2]
int2_inds &lt;- c(5, n2 %/% 2, n2 - 5)
lapply(int2_inds, function(j) matViz(int2_mats[[j]], incl_val = TRUE) +
         ggtitle(paste("True precision matrix, interval 2, observation", j + n1)))

# interval 3
matViz(prec[[length(prec)]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 3, observations ",
                 n1 + n2 + 1, ",...,", n1 + n2 + n3))

# fit the model and visualize the estimated graphs
(out &lt;- covdepGE(X, Z))
plot(out)

# visualize the posterior inclusion probabilities for variables (1, 3) and (1, 2)
inclusionCurve(out, 1, 2)
inclusionCurve(out, 1, 3)

## End(Not run)
</code></pre>


</div>