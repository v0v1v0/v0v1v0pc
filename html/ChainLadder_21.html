<div class="container">

<table style="width: 100%;"><tr>
<td>chainladder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Estimate age-to-age factors </h2>

<h3>Description</h3>

<p>Basic chain-ladder function to estimate age-to-age factors for a given
cumulative run-off triangle. This function is used by Mack- and MunichChainLadder.
</p>


<h3>Usage</h3>

<pre><code class="language-R">chainladder(Triangle, weights = 1, delta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Triangle</code></td>
<td>
<p>cumulative claims triangle.  A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code>qpaid</code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g annual).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights. Default: 1, which sets the weights for all
triangle entries to 1. Otherwise specify weights as a matrix of the same
dimension as <code>Triangle</code> with all weight entries in [0; 1], where entry
<code class="reqn">w_{i,k}</code> corresponds to the point <code class="reqn">C_{i,k+1}/C_{i,k}</code>. 
Hence, any entry set to 0 or <code>NA</code> eliminates that age-to-age factor 
from inclusion in the model. See also 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>'weighting' parameters. Default: 1;
delta=1 gives the historical chain-ladder age-to-age factors, 
delta=2 gives the straight average of the
observed individual development factors and delta=0 is the result of
an ordinary regression of <code class="reqn">C_{i,k+1}</code> against <code class="reqn">C_{i,k}</code> with
intercept 0, see Barnett &amp; Zehnwirth (2000).
</p>
<p>Please note that <code>MackChainLadder</code> uses the argument <code>alpha</code>, 
with <code>alpha = 2 - delta</code>, following the original paper Mack (1999)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The key idea is to see the chain-ladder algorithm as a special form of a
weighted linear regression through the origin, applied to each development 
period.
</p>
<p>Suppose <code>y</code> is the vector of cumulative claims at development period
<code>i+1</code>, and <code>x</code> at development period <code>i</code>, <code>weights</code> are
weighting factors and <code>F</code> the individual age-to-age factors <code>F=y/x</code>. Then
we get the various age-to-age factors:
</p>

<ul>
<li>
<p>Basic (unweighted) linear regression through the origin:
<code>lm(y~x + 0)</code> 

</p>
</li>
<li>
<p>Basic weighted linear regression through the origin:
<code>lm(y~x + 0, weights=weights)</code> 

</p>
</li>
<li>
<p>Volume weighted chain-ladder age-to-age factors: 
<code>lm(y~x + 0, weights=1/x)</code>

</p>
</li>
<li>
<p>Simple average of age-to-age factors:
<code>lm(y~x + 0, weights=1/x^2)</code>
 
</p>
</li>
</ul>
<p>Barnett &amp; Zehnwirth (2000) use delta = 0, 1, 2 to distinguish between the above 
three different regression approaches: <code>lm(y~x + 0, weights=weights/x^delta)</code>.
</p>
<p>Thomas Mack uses the notation <code>alpha = 2 - delta</code> to achieve the same result:
<code>sum(weights*x^alpha*F)/sum(weights*x^alpha) # Mack (1999) notation</code>
</p>


<h3>Value</h3>

<p>chainladder returns a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Models</code></td>
<td>
<p>linear regression models for each development period</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Triangle</code></td>
<td>
<p>input triangle of cumulative claims</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>deltas used</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Gesmann &lt;markus.gesmann@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin</em>. Vol. 29. No 2. 1999. pp.361:366</cite>
</p>
<p><cite>G. Barnett and B. Zehnwirth. Best Estimates for
Reserves. <em>Proceedings of the CAS.</em> Volume LXXXVII. Number 167. November 2000.</cite>
</p>


<h3>See Also</h3>

<p>See also
<code>ata</code>,	
<code>predict.ChainLadder</code>
<code>MackChainLadder</code>,  
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Concept of different chain-ladder age-to-age factors.
## Compare Mack's and Barnett &amp; Zehnwirth's papers.
x &lt;- RAA[1:9,1]
y &lt;- RAA[1:9,2]

F &lt;- y/x
## wtd. average chain-ladder age-to-age factors
alpha &lt;- 1 ## Mack notation
delta &lt;- 2 - alpha ## Barnett &amp; Zehnwirth notation

sum(x^alpha*F)/sum(x^alpha)
lm(y~x + 0 ,weights=1/x^delta)
summary(chainladder(RAA, delta=delta)$Models[[1]])$coef

## straight average age-to-age factors
alpha &lt;- 0
delta &lt;- 2 - alpha 
sum(x^alpha*F)/sum(x^alpha)
lm(y~x + 0, weights=1/x^(2-alpha))
summary(chainladder(RAA, delta=delta)$Models[[1]])$coef

## ordinary regression age-to-age factors
alpha=2
delta &lt;- 2-alpha
sum(x^alpha*F)/sum(x^alpha)
lm(y~x + 0, weights=1/x^delta)
summary(chainladder(RAA, delta=delta)$Models[[1]])$coef

## Compare different models
CL0 &lt;- chainladder(RAA)
## age-to-age factors
sapply(CL0$Models, function(x) summary(x)$coef["x","Estimate"])
## f.se
sapply(CL0$Models, function(x) summary(x)$coef["x","Std. Error"])
## sigma
sapply(CL0$Models, function(x) summary(x)$sigma)
predict(CL0)

CL1 &lt;- chainladder(RAA, delta=1)
## age-to-age factors
sapply(CL1$Models, function(x) summary(x)$coef["x","Estimate"])
## f.se
sapply(CL1$Models, function(x) summary(x)$coef["x","Std. Error"])
## sigma
sapply(CL1$Models, function(x) summary(x)$sigma)
predict(CL1)

CL2 &lt;- chainladder(RAA, delta=2)
## age-to-age factors
sapply(CL2$Models, function(x) summary(x)$coef["x","Estimate"])
## f.se
sapply(CL2$Models, function(x) summary(x)$coef["x","Std. Error"])
## sigma
sapply(CL2$Models, function(x) summary(x)$sigma)
predict(CL2)

## Set 'weights' parameter to use only the last 5 diagonals, 
## i.e. the last 5 calendar years
calPeriods &lt;- (row(RAA) + col(RAA) - 1)
(weights &lt;- ifelse(calPeriods &lt;= 5, 0, ifelse(calPeriods &gt; 10, NA, 1)))
CL3 &lt;- chainladder(RAA, weights=weights)
summary(CL3$Models[[1]])$coef
predict(CL3)
</code></pre>


</div>