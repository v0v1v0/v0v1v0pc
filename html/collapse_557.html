<div class="container">

<table style="width: 100%;"><tr>
<td>timeid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate Integer-Id From Time/Date Sequences
</h2>

<h3>Description</h3>

<p><code>timeid</code> groups time vectors in a way that preserves the temporal structure. It generate an integer id where unit steps represent the greatest common divisor in the original sequence e.g <code>c(4, 6, 10) -&gt; c(1, 2, 4)</code> or <code>c(0.25, 0.75, 1) -&gt; c(1, 3, 4)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">timeid(x, factor = FALSE, ordered = factor, extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric time object such as a <code>Date</code>, <code>POSIXct</code> or other integer or double vector representing time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>
<p>logical. <code>TRUE</code> returns an (ordered) factor with levels corresponding to the full sequence (without irregular gaps) of time. This is useful for inclusion in the index but might be computationally expensive for long sequences, see Details. <code>FALSE</code> returns a simpler object of class '<code>qG</code>'. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>logical. <code>TRUE</code> adds a class 'ordered'. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra</code></td>
<td>
<p>logical. <code>TRUE</code> attaches a set of 4 diagnostic items as attributes to the result:
</p>

<ul>
<li> <p><code>"unique_ints"</code>: <code>unique(unattrib(timeid(x)))</code> - the unique integer time steps in first-appearance order. This can be useful to check the size of gaps in the sequence. 
</p>
</li>
<li> <p><code>"sort_unique_x"</code>: <code>sort(unique(x))</code>.
</p>
</li>
<li> <p><code>"range_x"</code>: <code>range(x)</code>.
</p>
</li>
<li> <p><code>"step_x"</code>: <code>vgcd(sort(unique(diff(sort(unique(x))))))</code> - the greatest common divisor.
</p>
</li>
</ul>
<p><em>Note</em> that returning these attributes does not incur additional computations.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code>range_x</code> and <code>step_x</code> be the like-named attributes returned when <code>extra = TRUE</code>, then, if <code>factor = TRUE</code>, a complete sequence of levels is generated as <code>seq(range_x[1], range_x[2], by = step_x) |&gt; copyMostAttrib(x) |&gt; as.character()</code>. If <code>factor = FALSE</code>, the number of timesteps recorded in the <code>"N.groups"</code> attribute is computed as <code>(range_x[2]-range_x[1])/step_x + 1</code>, which is equal to the number of factor levels. In both cases the underlying integer id is the same and preserves gaps in time. Large gaps (strong irregularity) can result in many unused factor levels, the generation of which can become expensive. Using <code>factor = FALSE</code> (the default) is thus more efficient.
</p>


<h3>Value</h3>

<p>A factor or '<code>qG</code>' object, optionally with additional attributes attached.
</p>


<h3>See Also</h3>

<p><code>seqid</code>, Indexing, Time Series and Panel Series, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">oldopts &lt;- options(max.print = 30)

# A normal use case
timeid(wlddev$decade)
timeid(wlddev$decade, factor = TRUE)
timeid(wlddev$decade, extra = TRUE)

# Here a large number of levels is generated, which is expensive
timeid(wlddev$date, factor = TRUE)
tid &lt;- timeid(wlddev$date, extra = TRUE) # Much faster
str(tid)

# The reason for step = 1 are leap years with 366 days every 4 years
diff(attr(tid, "unique"))

# So in this case simple factor generation gives a better result
qF(wlddev$date, ordered = TRUE, na.exclude = FALSE)

# The best way to deal with this data would be to convert it
# to zoo::yearmon and then use timeid:
timeid(zoo::as.yearmon(wlddev$date), factor = TRUE, extra = TRUE)

options(oldopts)
rm(oldopts, tid)
</code></pre>


</div>