<div class="container">

<table style="width: 100%;"><tr>
<td>lcomoms2.ABcop2parameter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert L-comoments to Parameters of Alpha-Beta Compositions of Two One-Parameter Copulas</h2>

<h3>Description</h3>

<p><em>EXPERIMENTAL</em>—This function converts the <em>L-comoments</em> of a bivariate sample to the four parameters of a composition of two one-parameter copulas. Critical inputs are of course the first three dimensionless L-comoments: <em>L-correlation</em>, <em>L-coskew</em>, and <em>L-cokurtosis</em>. The most complex input is the <code>solutionenvir</code>, which is an <code>environment</code> containing arbitrarily long, but individual tables, of L-comoment and parameter pairings. These pairings could be computed from the examples in <code>simcompositeCOP</code>.
</p>
<p>The individual tables are prescanned for potentially acceptable solutions and the absolute additive error of both L-comoments for a given order is controlled by the <code>tNeps</code> arguments. The default values seem acceptable. The purpose of the prescanning is to reduce the computation space from perhaps millions of solutions to a few orders of magnitude. The computation of the solution error can be further controlled by <code class="reqn">X</code> or <code class="reqn">u</code> with respect to <code class="reqn">Y</code> or <code class="reqn">v</code> using the <code>comptNerrXY</code> arguments, but experiments thus far indicate that the defaults are likely the most desired. A solution “matching” the L-correlation is always sought; thus there is no <code>uset2err</code> argument. The arguments <code>uset3err</code> and <code>uset4err</code> provide some level of granular control on addition error minimization; the defaults seek to “match” L-coskew and ignore L-cokurtosis. The <code>setreturn</code> controls which rank of computed solution is returned; users might want to manually inspect a few of the most favorable solutions, which can be done by the <code>setreturn</code> or inspection of the returned object from the <code>lcomoms2.cop2parameter</code> function. The examples are detailed and self-contained to the <span class="pkg">copBasic</span> package; curious users are asked to test these.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lcomoms2.ABcop2parameter(solutionenvir=NULL,
                         T2.12=NULL, T2.21=NULL,
                         T3.12=NULL, T3.21=NULL,
                         T4.12=NULL, T4.21=NULL,
                         t2eps=0.1, t3eps=0.1, t4eps=0.1,
                         compt2erruv=TRUE, compt2errvu=TRUE,
                         compt3erruv=TRUE, compt3errvu=TRUE,
                         compt4erruv=TRUE, compt4errvu=TRUE,
                         uset3err=TRUE, uset4err=FALSE,
                         setreturn=1, maxtokeep=1e5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>solutionenvir</code></td>
<td>
<p>The environment containing solutions;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T2.12</code></td>
<td>
<p>L-correlation <code class="reqn">\tau_2^{[12]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T2.21</code></td>
<td>
<p>L-correlation <code class="reqn">\tau_2^{[21]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T3.12</code></td>
<td>
<p>L-coskew <code class="reqn">\tau_3^{[12]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T3.21</code></td>
<td>
<p>L-coskew <code class="reqn">\tau_3^{[21]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T4.12</code></td>
<td>
<p>L-cokurtosis <code class="reqn">\tau_4^{[12]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T4.21</code></td>
<td>
<p>L-cokurtosis <code class="reqn">\tau_4^{[21]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t2eps</code></td>
<td>
<p>An error term in which to pick a potential solution as close enough on preliminary processing for <code class="reqn">\tau_2^{[1 \leftrightarrow 2]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t3eps</code></td>
<td>
<p>An error term in which to pick a potential solution as close enough on preliminary processing for <code class="reqn">\tau_3^{[1 \leftrightarrow 2]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t4eps</code></td>
<td>
<p>An error term in which to pick a potential solution as close enough on preliminary processing for <code class="reqn">\tau_4^{[1 \leftrightarrow 2]}</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt2erruv</code></td>
<td>
<p>Compute an L-correlation error using the 1 with respect to 2 (or <code class="reqn">u</code> wrt <code class="reqn">v</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt2errvu</code></td>
<td>
<p>Compute an L-correlation error using the 2 with respect to 1 (or <code class="reqn">v</code> wrt <code class="reqn">u</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt3erruv</code></td>
<td>
<p>Compute an L-coskew error using the 1 with respect to 2 (or <code class="reqn">u</code> wrt <code class="reqn">v</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt3errvu</code></td>
<td>
<p>Compute an L-coskew error using the 2 with respect to 1 (or <code class="reqn">v</code> wrt <code class="reqn">u</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt4erruv</code></td>
<td>
<p>Compute an L-cokurtosis error using the 1 with respect to 2 (or <code class="reqn">u</code> wrt <code class="reqn">v</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compt4errvu</code></td>
<td>
<p>Compute an L-cokurtosis error using the 2 with respect to 1 (or <code class="reqn">v</code> wrt <code class="reqn">u</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uset3err</code></td>
<td>
<p>Use the L-coskew error in the determination of the solution. The L-correlation error is always used;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uset4err</code></td>
<td>
<p>Use the L-cokurtosis error in the determination of the solution. The L-correlation error is always used;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setreturn</code></td>
<td>
<p>Set (index) number of the solution to return. The default of 1 returns the preferred solutions based on the controls for the minimization; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxtokeep</code></td>
<td>
<p>The value presets the number of rows in the solution matrix. This matrix is filled with potential solutions as the various subfiles of the <code>solutionenvir</code> are scanned. The matrix is trimmed of <code>NA</code>s and error trapping is in place for too small values of <code>maxtokeep</code>. The default value appears appropriate for the feeding of massively large simulated parameter spaces.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> is returned.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Asquith, W.H., 2011, Distributional analysis with L-moment statistics using the R environment for statistical computing: Createspace Independent Publishing Platform, ISBN 978–146350841–8.
</p>
<p>Salvadori, G., De Michele, C., Kottegoda, N.T., and Rosso, R., 2007, Extremes in Nature—An approach using copulas: Springer, 289 p.
</p>


<h3>See Also</h3>

<p><code>simCOP</code>, <code>simcompositeCOP</code>, <code>composite2COP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Build an initial parameter to L-comoment mapping table.
  mainpara &lt;- list(cop1=PLACKETTcop, cop2=PLACKETTcop,
                   para1gen=function() { return(10^runif(1, min=-5, max=0)) },
                   para2gen=function() { return(10^runif(1, min=0,  max=5)) })
  nsim &lt;- 1E4
  sample.size.for.estimation &lt;- 1000 # really use vastly larger sample size
  PlackettPlackettNP &lt;-
      simcompositeCOP(n=sample.size.for.estimation, nsim=nsim, parent=mainpara)
  save(PlackettPlackettNP, file="PlackettPlackettNP.RData", compress="xz")

# Plackett-Plackett composited copula from the copBasic package
# Then create an environment to house the "table."
PlackettPlackett &lt;- new.env()
assign("NeedToCreateForDemo", PlackettPlackettNP, envir=PlackettPlackett)
# Now that the table is assigned into the environment, the parameter
# estimation function can be used. In reality, a much much larger
# solution set is needed, but this effort is experimental.

# Now grab the closest Plackett-Plackett solution having the following six
# arbitrary L-comoments. Then simulate 1000 values and plot them to show
# the underlying bivariate distribution.
PPcop &lt;- lcomoms2.ABcop2parameter(solutionenvir=PlackettPlackett,
                                  T2.12=-0.5059, T2.21=-0.5110,
                                  T3.12= 0.1500, T3.21= 0.1700,
                                  T4.12=-0.0500, T4.21= 0.0329,
                                  uset3err=TRUE, uset4err=TRUE)
# A user in encouraged to inspect the contents of PPcop to "assess" the
# solution by a method of L-comoments, we will now proceed with showing the
# copula via a simulation of the fitted version.
para &lt;- list(cop1=PLACKETTcop, cop2=PLACKETTcop, alpha=PPcop$alpha, beta=PPcop$beta,
             para1=PPcop$Cop1Thetas, para2=PPcop$Cop2Thetas)

D &lt;- simCOP(n=5000, cop=composite2COP, para=para, col=rgb(0,0,0,0.1), pch=16)
# The sample L-comoments of the fitted Plackett-Plackett may be found by
lmomco::lcomoms2(D, nmom=4) # from the lmomco package, and six sample values shown
T2.12 &lt;- -0.5151547; T2.21 &lt;- -0.5139863
T3.12 &lt;-  0.1502336; T3.21 &lt;-  0.1721355
T4.12 &lt;- -0.0326277; T4.21 &lt;-  0.0233979
PPcop &lt;- lcomoms2.ABcop2parameter(solutionenvir=PlackettPlackett,
                                  T2.12=T2.12, T2.21=T2.21,
                                  T3.12=T3.12, T3.21=T3.21,
                                  T4.12=T4.12, T4.21=T4.21, uset4err=TRUE)
para &lt;- list(cop1=PLACKETTcop, cop2=PLACKETTcop, alpha=PPcop$alpha, beta=PPcop$beta,
             para1=PPcop$Cop1Thetas, para2=PPcop$Cop2Thetas)
D &lt;- simCOP(n=5000, cop=composite2COP, para=para, col=rgb(0,0,0,0.1), pch=16)
level.curvesCOP(cop=composite2COP, para=para, delt=.1, ploton=FALSE)
qua.regressCOP.draw(cop=composite2COP, para=para,
                    ploton=FALSE, f=seq(0.05, 0.95, by=0.05))
qua.regressCOP.draw(cop=composite2COP, para=para, wrtV=TRUE,
                    ploton=FALSE, f=seq(0.05, 0.95, by=0.05), col=c(3,2))
diag &lt;- diagCOP(cop=composite2COP, para=para, ploton=FALSE, lwd=4)

image(gridCOP(cop=composite2COP, para=para), col=terrain.colors(20))
# One can inspect alternative solutions like this
# S &lt;- PPcop$solutions$solutions[,1:16]
# B &lt;- S[abs(S$t2.12res) &lt; 0.02 &amp; abs(S$t2.21res) &lt; 0.02 &amp;
#        abs(S$t3.12res) &lt; 0.02 &amp; abs(S$t3.21res) &lt; 0.02, ]
#print(B)
## End(Not run)
</code></pre>


</div>