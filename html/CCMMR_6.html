<div class="container">

<table style="width: 100%;"><tr>
<td>sparse_weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computation of sparse weight matrix</h2>

<h3>Description</h3>

<p>Construct a sparse weight matrix in a dictionary-of-keys format.
Each nonzero weight is computed as <code class="reqn">exp(-phi * ||x_i - x_j||^2)</code>, where
the squared Euclidean distance may be scaled by the average squared Euclidean
distance, depending on the argument <code>scale</code>. Sparsity is achieved by
only setting weights to nonzero values that correspond to two objects that
are among each other's <code class="reqn">k</code> nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sparse_weights(
  X,
  k,
  phi,
  connected = TRUE,
  scale = TRUE,
  connection_type = "SC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> numeric matrix. This function assumes that each
row represents an object with <code class="reqn">p</code> attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of nearest neighbors to be used for non-zero weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>Tuning parameter of the Gaussian weights. Input should be a
nonnegative value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connected</code></td>
<td>
<p>If <code>TRUE</code>, guarantee a connected structure of the
weight matrix. This ensures that groups of observations that would not be
connected through weights that are based only on the <code>k</code> nearest
neighbors are (indirectly) connected anyway. The method is determined by
the argument <code>connection_type</code>. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If <code>TRUE</code>, scale each squared l2-norm by the mean squared
l2-norm to ensure scale invariance of the weights. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connection_type</code></td>
<td>
<p>Determines the method to ensure a connected weight
matrix if <code>connected</code> is <code>TRUE</code>. Should be one of
<code>c("SC", "MST")</code>. SC stands for the method using a symmetric circulant
matrix, connecting objects <code class="reqn">i</code> with objects <code class="reqn">i+1</code> (and <code class="reqn">n</code> with
<code class="reqn">1</code>). MST stands for minimum spanning tree. The graph that results from
the nonzero weights determined by the <code class="reqn">k</code> nearest neighbors is divided
into <code class="reqn">c</code> subgraphs and a minimum spanning tree algorithm is used to add
<code class="reqn">c-1</code> nonzero weights to ensure that all objects are indirectly
connected. Default is <code>"SC"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>sparseweights</code> object containing the nonzero weights in
dictionary-of-keys format.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
data(two_half_moons)
data = as.matrix(two_half_moons)
X = data[, -3]
y = data[, 3]

# Get sparse distances in dictionary of keys format with k = 5 and phi = 8
W = sparse_weights(X, 5, 8.0)

</code></pre>


</div>