<div class="container">

<table style="width: 100%;"><tr>
<td>cv.customizedGlmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
cross validation for customizedGlmnet
</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation for customizedGlmnet and returns a values for
<code>G</code> and <code>lambda</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.customizedGlmnet(xTrain, yTrain, xTest = NULL, groupid = NULL, Gs = NULL,
    dendrogram = NULL, dendrogramCV = NULL, lambda = NULL,
    nfolds = 10, foldid = NULL, keep = FALSE,
    family = c("gaussian", "binomial", "multinomial"), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xTrain</code></td>
<td>

<p>an n-by-p matrix of training covariates
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yTrain</code></td>
<td>

<p>a length-n vector of training responses. Numeric for family = <code>"gaussian"</code>.
Factor or character for <code>family = "binomial"</code> or
<code>family = "multinomial"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xTest</code></td>
<td>

<p>an m-by-p matrix of test covariates. May be left NULL, in which case cross
validation predictions are made internally on the training set and no test
predictions are returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupid</code></td>
<td>

<p>an optional length-m vector of group memberships for the test set. If
specified, customized training subsets are identified using the union of
nearest neighbor sets for each test group, in which case cross-validation is
used only to select the regularization parameter <code>lambda</code>, not the number
of clusters <code>G</code>. Either <code>groupid</code> or <code>Gs</code> must be specified
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gs</code></td>
<td>

<p>a vector of positive integers indicating the numbers of clusters over which to
perform cross-validation to determine the best number. Ignored if <code>groupid</code>
is specified. Either <code>groupid</code> or <code>Gs</code> must be specified
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dendrogram</code></td>
<td>

<p>optional output from <code>hclust</code> on the joint covariate data. Useful if method
is being used several times to avoid redundancy in calculations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dendrogramCV</code></td>
<td>

<p>optional output from <code>hclust</code> on the training covariate data. Used as joint
clustering result for cross-validation. Useful to specify in advance if method
is being used several times to avoid redundancy in calculations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>sequence of values to use for the regularization parameter lambda. Recomended
to leave as NULL and allow <code>glmnet</code> to choose automatically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>

<p>number of folds â€“ default is 10. Ignored if foldid is specified
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>

<p>an optional length-n vector of fold memberships used for cross-validation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>

<p>Should fitted values on the training set from cross validation be included in
output? Default is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>response type
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Should progress be printed to console as folds are evaluated during
cross-validation? Default is FALSE.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of class <code>cv.customizedGlmnet</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the call that produced this object
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G.min</code></td>
<td>

<p>unless groupid is specified, the number of clusters minimizing CV error
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>the sequence of values of the regularization parameter <code>lambda</code> considered
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>

<p>the value of the regularization parameter <code>lambda</code> minimizing CV error
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>

<p>a matrix containing the CV error for each <code>G</code> and <code>lambda</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>a <code>customizedGlmnet</code> object fit using <code>G.min</code> and <code>lambda.min</code>.
Only returned if <code>xTest</code> is not NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction</code></td>
<td>

<p>a length-m vector of predictions for the test set, using the tuning parameters
which minimize cross-validation error. Only returned if <code>xTest</code> is not
NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected</code></td>
<td>

<p>a list of nonzero variables for each customized training set, using
<code>G.min</code> and <code>lambda.min</code>. Only returned if <code>xTest</code> is not NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.fit</code></td>
<td>

<p>a array containing fitted values on the training set from cross validation.
Only returned if <code>keep</code> is TRUE.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Scott Powers, Trevor Hastie, Robert Tibshirani
</p>


<h3>References</h3>

<p>Scott Powers, Trevor Hastie and Robert Tibshirani (2015) "Customized training
with an application to mass specrometric imaging of gastric cancer data."
Annals of Applied Statistics 9, 4:1709-1725.
</p>


<h3>See Also</h3>

<p><code>customizedGlmnet</code>, <code>plot.cv.customizedGlmnet</code>,
<code>predict.cv.customizedGlmnet</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(glmnet)

# Simulate synthetic data

n = m = 150
p = 50
q = 5
K = 3
sigmaC = 10
sigmaX = sigmaY = 1
set.seed(5914)

beta = matrix(0, nrow = p, ncol = K)
for (k in 1:K) beta[sample(1:p, q), k] = 1
c = matrix(rnorm(K*p, 0, sigmaC), K, p)
eta = rnorm(K)
pi = (exp(eta)+1)/sum(exp(eta)+1)
z = t(rmultinom(m + n, 1, pi))
x = crossprod(t(z), c) + matrix(rnorm((m + n)*p, 0, sigmaX), m + n, p)
y = rowSums(z*(crossprod(t(x), beta))) + rnorm(m + n, 0, sigmaY)

x.train = x[1:n, ]
y.train = y[1:n]
x.test = x[n + 1:m, ]
y.test = y[n + 1:m]
foldid = sample(rep(1:10, length = nrow(x.train)))


# Example 1: Use clustering to fit the customized training model to training
# and test data with no predefined test-set blocks

fit1 = cv.customizedGlmnet(x.train, y.train, x.test, Gs = c(1, 2, 3, 5),
    family = "gaussian", foldid = foldid)

# Print the optimal number of groups and value of lambda:
fit1$G.min
fit1$lambda.min

# Print the customized training model fit:
fit1

# Compute test error using the predict function:
mean((y[n + 1:m] - predict(fit1))^2)

# Plot nonzero coefficients by group:
plot(fit1)


# Example 2: If the test set has predefined blocks, use these blocks to define
# the customized training sets, instead of using clustering.
foldid = apply(z == 1, 1, which)[1:n]
group.id = apply(z == 1, 1, which)[n + 1:m]

fit2 = cv.customizedGlmnet(x.train, y.train, x.test, group.id, foldid = foldid)

# Print the optimal value of lambda:
fit2$lambda.min

# Print the customized training model fit:
fit2

# Compute test error using the predict function:
mean((y[n + 1:m] - predict(fit2))^2)

# Plot nonzero coefficients by group:
plot(fit2)


# Example 3: If there is no test set, but the training set is organized into
# blocks, you can do cross validation with these blocks as the basis for the
# customized training sets.

fit3 = cv.customizedGlmnet(x.train, y.train, foldid = foldid)

# Print the optimal value of lambda:
fit3$lambda.min

# Print the customized training model fit:
fit3

# Compute test error using the predict function:
mean((y[n + 1:m] - predict(fit3))^2)

# Plot nonzero coefficients by group:
plot(fit3)
</code></pre>


</div>