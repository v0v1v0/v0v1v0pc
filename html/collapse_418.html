<div class="container">

<table style="width: 100%;"><tr>
<td>join</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Table Joins</h2>

<h3>Description</h3>

<p>Join two data frame like objects <code>x</code> and <code>y</code> <code>on</code> columns. Inspired by <em>polars</em> and by default uses a vectorized hash join algorithm (workhorse function <code>fmatch</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">join(x, y,
     on = NULL,
     how = "left",
     suffix = NULL,
     validate = "m:m",
     multiple = FALSE,
     sort = FALSE,
     keep.col.order = TRUE,
     drop.dup.cols = FALSE,
     verbose = .op[["verbose"]],
     column = NULL,
     attr = NULL,
     ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data frame-like object. The result will inherit the attributes of this object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a data frame-like object to join with <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>on</code></td>
<td>
<p>character. vector of columns to join on. <code>NULL</code> uses <code>intersect(names(x), names(y))</code>. Use a named vector to match columns named differently in <code>x</code> and <code>y</code>, e.g. <code>c("x_id" = "y_id")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>how</code></td>
<td>
<p>character. Join type: <code>"left"</code>, <code>"right"</code>, <code>"inner"</code>, <code>"full"</code>, <code>"semi"</code> or <code>"anti"</code>. The first letter suffices. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>character(1 or 2). Suffix to add to duplicate column names. <code>NULL</code> renames duplicate <code>y</code> columns as <code>paste(col, y_name, sep = "_")</code>, where <code>y_name = as.character(substitute(y))</code> i.e. the name of the data frame as passed into the function. In general, passing <code>suffix</code> length 1 will only rename <code>y</code>, whereas a length 2 suffix will rename both <code>x</code> and <code>y</code>, respectively. If <code>verbose &gt; 0</code> a message will be printed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate</code></td>
<td>
<p>character. (Optional) check if join is of specified type. One of <code>"1:1"</code>, <code>"1:m"</code>, <code>"m:1"</code> or <code>"m:m"</code>. The default <code>"m:m"</code> does not perform any checks. Checks are done before the actual join step and failure results in an error. <em>Note</em> that this argument does not affect the result, it only triggers a check.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>logical. Handling of rows in <code>x</code> with multiple matches in <code>y</code>. The default <code>FALSE</code> takes the first match in <code>y</code>. <code>TRUE</code> returns every match in <code>y</code> (a full cartesian product), increasing the size of the joined table. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>logical. <code>TRUE</code> implements a sort-merge-join: a completely separate join algorithm that sorts both datasets on the join columns using <code>radixorder</code> and then matches the rows without hashing. <em>Note</em> that in this case the result will be sorted by the join columns, whereas <code>sort = FALSE</code> preserves the order of rows in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.col.order</code></td>
<td>
<p>logical. Keep order of columns in <code>x</code>? <code>FALSE</code> places the <code>on</code> columns in front.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.dup.cols</code></td>
<td>
<p>instead of renaming duplicate columns in <code>x</code> and <code>y</code> using <code>suffix</code>, this option simply drops them: <code>TRUE</code> or <code>"y"</code> drops them from <code>y</code>, <code>"x"</code> from <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>integer. Prints information about the join. One of 0 (off), 1 (default, see Details) or 2 (additionally prints the classes of the <code>on</code> columns). <em>Note:</em> <code>verbose &gt; 0</code> or <code>validate != "m:m"</code> invoke the <code>count</code> argument to <code>fmatch</code>, so <code>verbose = 0</code> is slightly more efficient. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>column</code></td>
<td>
<p>(optional) name for an extra column to generate in the output indicating which dataset a record came from. <code>TRUE</code> calls this column <code>".join"</code> (inspired by STATA's '_merge' column). By default this column is generated as the last column, but, if <code>keep.col.order = FALSE</code>, it is placed after the 'on' columns. The column is a factor variable with levels corresponding to the dataset names (inferred from the input) or <code>"matched"</code> for matched records. Alternatively, it is possible to specify a list of 2, where the first element is the column name, and the second a length 3 (!) vector of levels e.g. <code>column = list("joined", c("x", "y", "x_y"))</code>, where <code>"x_y"</code> replaces <code>"matched"</code>. The column has an additional attribute <code>"on.cols"</code> giving the join columns corresponding to the factor levels. See Examples. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr</code></td>
<td>
<p>(optional) name for attribute providing information about the join performed (including the output of <code>fmatch</code>) to the result. <code>TRUE</code> calls this attribute <code>"join.match"</code>. <em>Note:</em> this also invokes the <code>count</code> argument to <code>fmatch</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to <code>fmatch</code> (if <code>sort = FALSE</code>). Notably, <code>overid</code> can bet set to 0 or 2 (default 1) to control the matching process if the join condition more than identifies the records.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>verbose &gt; 0</code>, <code>join</code> prints a compact summary of the join operation using <code>cat</code>. If the names of <code>x</code> and <code>y</code> can be extracted (if <code>as.character(substitute(x))</code> yields a single string) they will be displayed (otherwise 'x' and 'y' are used) followed by the respective join keys in brackets. This is followed by a summary of the records used from each table. If <code>multiple = FALSE</code>, only the first matches from <code>y</code> are used and counted here (or the first matches of <code>x</code> if <code>how = "right"</code>). <em>Note</em> that if <code>how = "full"</code> any further matches are simply appended to the results table, thus it may make more sense to use <code>multiple = TRUE</code> with the full join when suspecting multiple matches.
</p>
<p>If <code>multiple = TRUE</code>, <code>join</code> performs a full cartesian product matching every key in <code>x</code> to every matching key in <code>y</code>. This can considerably increase the size of the resulting table. No memory checks are performed (your system will simply run out of memory; usually this should not terminate R).
</p>
<p>In both cases, <code>join</code> will also determine the average order of the join as the number of records used from each table divided by the number of unique matches and display it between the two tables at up to 2 digits. For example <code>"&lt;4:1.5&gt;"</code> means that on average 4 records from <code>x</code> match 1.5 records from <code>y</code>, implying on average <code>4*1.5 = 6</code> records generated per unique match. If <code>multiple = FALSE</code> <code>"1st"</code> will be displayed for the using table (<code>y</code> unless <code>how = "right"</code>), indicating that there could be multiple matches but only the first is retained. <em>Note</em> that an order of '1' on either table must not imply that the key is unique as this value is generated from <code>round(v, 2)</code>. To be sure about a keys uniqueness employ the <code>validate</code> argument.
</p>


<h3>Value</h3>

<p>A data frame-like object of the same type and attributes as <code>x</code>. <code>"row.names"</code> of <code>x</code> are only preserved in left-join operations.
</p>


<h3>See Also</h3>

<p><code>fmatch</code>, Data Frame Manipulation, Fast Grouping and Ordering, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">df1 &lt;- data.frame(
  id1 = c(1, 1, 2, 3),
  id2 = c("a", "b", "b", "c"),
  name = c("John", "Jane", "Bob", "Carl"),
  age = c(35, 28, 42, 50)
)
df2 &lt;- data.frame(
  id1 = c(1, 2, 3, 3),
  id2 = c("a", "b", "c", "e"),
  salary = c(60000, 55000, 70000, 80000),
  dept = c("IT", "Marketing", "Sales", "IT")
)

# Different types of joins
for(i in c("l","i","r","f","s","a"))
    join(df1, df2, how = i) |&gt; print()

# With multiple matches
for(i in c("l","i","r","f","s","a"))
    join(df1, df2, on = "id2", how = i, multiple = TRUE) |&gt; print()

# Adding join column: useful esp. for full join
join(df1, df2, how = "f", column = TRUE)
# Custom column + rearranging
join(df1, df2, how = "f", column = list("join", c("x", "y", "x_y")), keep = FALSE)

# Attaching match attribute
str(join(df1, df2, attr = TRUE))

</code></pre>


</div>