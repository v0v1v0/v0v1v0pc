<div class="container">

<table style="width: 100%;"><tr>
<td>ciu.new</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create CIU object</h2>

<h3>Description</h3>

<p>Sets up a CIU object with the given parameters. CIU objects have "public"
and "private" methods. A CIU object is actually a list whose elements
are the public functions (methods).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ciu.new(
  bb,
  formula = NULL,
  data = NULL,
  in.min.max.limits = NULL,
  abs.min.max = NULL,
  input.names = NULL,
  output.names = NULL,
  predict.function = NULL,
  vocabulary = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bb</code></td>
<td>
<p>Model/"black-box" object. At least all <code>caret</code> models, the
<code>lda</code> model from MASS, and the <code>lm</code> model are supported.
Otherwise, the prediction
function to be used can be gives as value of the <code>predict.function</code>
parameter.
A more powerful way is to inherit from FunctionApproximator class and
implement an "eval" method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Formula that describes input versus output values. Only to
be used together with <code>data</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The training data used for training the model. If this parameter
is provided, a <code>formula</code> MUST be given also.
<code>ciu.new</code> attempts to infer the other parameters from
<code>data</code> and <code>formula</code>. i.e. <code>in.min.max.limits</code>,
<code>abs.min.max</code>, <code>input.names</code>
and <code>output.names</code>. If those parameters are provided, then they
override the inferred ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.min.max.limits</code></td>
<td>
<p>matrix with one row per output and two columns,
where the first column indicates the minimal value and the second column
the maximal value for that input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs.min.max</code></td>
<td>
<p>data.frame or matrix of min-max values of
outputs, one row per output, two columns (min, max).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input.names</code></td>
<td>
<p>labels of inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.names</code></td>
<td>
<p>labels of outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict.function</code></td>
<td>
<p>can be supplied if a model that is not supported by
ciu should be used. As an example, this is the function for lda:</p>
<pre>
o.predict.function &lt;- function(model, inputs) {
    pred &lt;- predict(model,inputs)
        return(pred$posterior)
}</pre>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vocabulary</code></td>
<td>
<p>list of labels/concepts to be used when producing
explanations and what combination of inputs they correspond to. Example of
two intermediate concepts and a higher-level one that combines them:
<code>list(intermediate.concept1=c(1,2,3), intermediate.concept2=c(4,5), higher.level.concept=c(1,2,3,4,5))</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>CIU is implemented in an object-oriented manner, where a CIU
object is a <code>list</code> whose methods are made visible as
elements of the list. The general way for using <code>CIU</code> objects is to
first get a <code>CIU</code> object by calling <code>ciu.new</code> as e.g.
<code>ciu &lt;- ciu.new(...)</code>, then call <code>ciu.res &lt;- ciu$&lt;method&gt;(...)</code>.
The methods that can be used in <code style="white-space: pre;">⁠&lt;method&gt;⁠</code> are:
</p>

<ul>
<li> <p><code>explain</code>, see ciu.explain (but omit first parameter <code>ciu</code>)
</p>
</li>
<li> <p><code>meta.explain</code>, see ciu.meta.explain (but omit first parameter <code>ciu</code>).
</p>
</li>
<li> <p><code>barplot.ciu</code>, see ciu.barplot (but omit first parameter <code>ciu</code>)
</p>
</li>
<li> <p><code>ggplot.col.ciu</code>, see ciu.ggplot.col (but omit first parameter <code>ciu</code>)
</p>
</li>
<li> <p><code>pie.ciu</code>, see ciu.pie (but omit first parameter <code>ciu</code>)
</p>
</li>
<li> <p><code>plot.ciu</code>, see ciu.plot (but omit first parameter <code>ciu</code>)
</p>
</li>
<li> <p><code>plot.ciu.3D</code>, see ciu.plot.3D (but omit first parameter <code>ciu</code>)
</p>
</li>
<li> <p><code>textual</code>, see ciu.textual (but omit first parameter <code>ciu</code>).
</p>
</li>
</ul>
<p><em>"Usage" section is here in "Details" section because Roxygen etc.
don't support documentation of functions within functions.</em>
</p>


<h3>Value</h3>

<p>Object of class <code>CIU</code>.
</p>
<p><code>ciu</code> object
</p>


<h3>Author(s)</h3>

<p>Kary Främling
Create <code>ciu</code> object from this <code>CIU</code> object.
</p>


<h3>References</h3>

<p>Främling, K. <em>Contextual Importance and Utility in R: the 'ciu' Package.</em>
In: Proceedings of 1st Workshop on Explainable Agency in Artificial Intelligence,
at 35th AAAI Conference on Artificial Intelligence. Virtual, Online. February 8-9, 2021. pp. 110-114.
</p>
<p>Främling, K. <em>Explainable AI without Interpretable Model</em>. 2020, <a href="https://arxiv.org/abs/2009.13996">https://arxiv.org/abs/2009.13996</a>.
</p>
<p>Främling, K. <em>Decision Theory Meets Explainable AI</em>. 2020, &lt;doi.org/10.1007/978-3-030-51924-7_4&gt;.
</p>
<p>Främling, K. <em>Modélisation et apprentissage des préférences par réseaux de neurones pour l'aide à la décision multicritère</em>. 1996, <a href="https://tel.archives-ouvertes.fr/tel-00825854/document">https://tel.archives-ouvertes.fr/tel-00825854/document</a> (title translation in English: <em>Learning and Explaining Preferences with Neural Networks for Multiple Criteria Decision Making</em>)
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Explaining the classification of an Iris instance with lda model.
# We use a versicolor (instance 100).
library(MASS)
test.ind &lt;- 100
iris_test &lt;- iris[test.ind, 1:4]
iris_train &lt;- iris[-test.ind, 1:4]
iris_lab &lt;- iris[[5]][-test.ind]
model &lt;- lda(iris_train, iris_lab)

# Create CIU object
ciu &lt;- ciu.new(model, Species~., iris)

# This can be used with explain method for getting CIU values
# of one or several inputs. Here we get CIU for all three outputs
# with input feature "Petal.Length" that happens to be the most important.
ciu$explain(iris_test, 1)

# It is, however, more convenient to use one of the graphical visualisations.
# Here's one using ggplot.
ciu$ggplot.col.ciu(iris_test)

# LDA creates very sharp class limits, which can also be seen in the CIU
# explanation. We can study what the underlying model looks like using
# plot.ciu and plot.ciu.3D methods. Here is a 3D plot for all three classes
# as a function of Petal Length&amp;Width. Iris #100 (shown as the red dot)
# is on the ridge of the "versicolor" class, which is quite narrow for
# Petal Length&amp;Width.
ciu$plot.ciu.3D(iris_test,c(3,4),1,main=levels(iris$Species)[1],)
ciu$plot.ciu.3D(iris_test,c(3,4),2,main=levels(iris$Species)[2])
ciu$plot.ciu.3D(iris_test,c(3,4),3,main=levels(iris$Species)[3])

## Not run: 
# Same thing with a regression task, the Boston Housing data set. Instance
# #370 has the highest valuation (50k$). Model is gbm, which performs
# decently here. Plotting with "standard" bar plot this time.
# Use something like "par(mai=c(0.8,1.2,0.4,0.2))" for seeing Y-axis labels.
library(caret)
gbm &lt;- train(medv ~ ., Boston, method="gbm", trControl=trainControl(method="cv", number=10))
ciu &lt;- ciu.new(gbm, medv~., Boston)
ciu$barplot.ciu(Boston[370,1:13])

# Same but sort by CI.
ciu$barplot.ciu(Boston[370,1:13], sort = "CI")

# The two other possible plots
ciu$ggplot.col(Boston[370,1:13])
ciu$pie.ciu(Boston[370,1:13])

# Method "plot" for studying the black-box behavior and CIU one input at a time.
ciu$plot.ciu(Boston[370,1:13],13)

## End(Not run)

</code></pre>


</div>