<div class="container">

<table style="width: 100%;"><tr>
<td>dict.table</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combining Dict and data.table</h2>

<h3>Description</h3>

<p>The dict.table is a combination of dict and
<a href="https://CRAN.R-project.org/package=data.table">data.table</a>
and basically can be considered a
<a href="https://CRAN.R-project.org/package=data.table">data.table</a>
with unique
column names and an extended set of functions to add, extract and
remove data columns with the goal to further facilitate code development
using <a href="https://CRAN.R-project.org/package=data.table">data.table</a>.
A dict.table object provides all dict and
<a href="https://CRAN.R-project.org/package=data.table">data.table</a>
functions and operators at the same time.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dict.table(...)

as.dict.table(x, ...)

## S3 method for class 'data.table'
as.dict.table(x, copy = TRUE, ...)

is.dict.table(x)

## S3 method for class 'dict.table'
rbind(x, ...)

## S3 method for class 'dict.table'
cbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>elements put into the dict.table and/or additional
arguments to be passed on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>any <code>R</code> object or a dict.table object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>if <code>TRUE</code> creates a copy of the data.table object otherwise
works on the passed object by reference.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Methods that alter dict.table objects usually come in two versions
providing either copy or reference semantics where the latter start with
<code>'ref_'</code> to note the reference semantic, for example, <code>add()</code> and <code>ref_add()</code>.
</p>

<ul><li> <p><code>dict.table(...)</code> initializes and returns a dict object.
</p>
</li></ul>
<ul><li> <p><code>as.dict.table(x, ...)</code> coerce <code>x</code> to a dict.table
</p>
</li></ul>
<ul><li> <p><code>is.dict.table(x)</code> check if <code>x</code> is a <code>dict.table</code>
</p>
</li></ul>
<ul><li> <p><code>add(.x, ...)</code> and <code>ref_add(.x, ...)</code> add columns to <code>.x</code>. If the column name
already exists, an error is given.
</p>
</li></ul>
<ul><li> <p><code>at(.x, ...)</code> returns the columns at the given indices. Indices
can be letters or numbers or both. All columns must exist.
</p>
</li></ul>
<ul><li> <p><code>at2(x, index)</code> returns the column at the given <code>index</code> or signals
an error if not found.
</p>
</li></ul>
<ul><li> <p><code>clear(x)</code> and <code>ref_clear(x)</code> remove all elements from <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>clone(x)</code> create a copy of <code>x</code>.
</p>
</li></ul>
<ul><li> <p><code>delete_at(.x, ...)</code> and <code>ref_delete_at(.x, ...)</code> find and remove columns either by
name or index (or both). If one or more columns don't exist, an error is signaled.
</p>
</li></ul>
<ul><li> <p><code>discard_at(.x, ...)</code> and <code>ref_discard_at(.x, ...)</code> find and remove columns
either by name or index (or both). Invalid column indices are ignored.
</p>
</li></ul>
<ul><li> <p><code>has(x, column)</code> check if some <code>column</code> is in dict.table object.
</p>
</li></ul>
<ul><li> <p><code>has_name(x, name)</code> check if <code>x</code> has the given column name.
</p>
</li></ul>
<ul><li> <p><code>is_empty(x)</code> <code>TRUE</code> if object is empty otherwise <code>FALSE</code>
</p>
</li></ul>
<ul><li> <p><code>peek_at(x, ..., .default = NULL)</code> returns the columns at the given
indices or (if not found) columns with the given default value.
</p>
</li></ul>
<ul><li> <p><code>peek_at2(x, index, default = NULL)</code> return column named <code>index</code> if it exist
otherwise the given <code>default</code> value. If the default length does not match
the number of rows, it is recycled accordingly and a warning is given,
unless the default value has a length of 1, in which case recycling is
done silently.
</p>
</li></ul>
<ul><li> <p><code>ref_pop(.x, index)</code> return element at given column index and remove the
column from the dict.table object.
</p>
</li></ul>
<ul><li> <p><code>rename(.x, old, new)</code> and <code>ref_rename(.x, old, new)</code> rename one or more
columns from <code>old</code> to <code>new</code>, respectively, by copy and in place (i.e. by
reference).
</p>
</li></ul>
<ul><li> <p><code>replace_at(.x, .., .add = FALSE)</code> and <code>ref_replace_at(.x, ..., .add = FALSE)</code>
replace values at given indices. If a given index is invalid, an error is
signaled unless <code>.add</code> was set to <code>TRUE</code>.
</p>
</li></ul>
<ul><li> <p><code>update(object, other)</code> and <code>ref_update(object, other)</code> adds columns of <code>other</code> dict
that are not yet in <code>object</code> and replaces the values at existing columns.
</p>
</li></ul>
<h3>See Also</h3>

<p>dict, <a href="https://CRAN.R-project.org/package=data.table">data.table</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Some basic examples using some typical data.table and dict operations.
# The constructor can take the 'key' argument known from data.table():
require(data.table)
dit = dict.table(x = rep(c("b","a","c"), each = 3), y = c(1,3,6), key = "y")
print(dit)
setkey(dit, "x")                             # sort by 'x'
print(dit)
(add(dit, "v" = 1:9))                        # add column v = 1:9
dit[y &gt; 5]
(ref_discard_at(dit, "x"))                   # discard column 'x'

try(at(dit, "x"))                            # index 'x' not found
try(replace_at(dit, x = 0))                  # cannot be replaced, if it does not exist

dit = replace_at(dit, x = 0, .add = TRUE)    # ok - re-adds column 'x' with all 0s
peek_at(dit, "x")                            # glance at column 'x'
has_name(dit, "x")                           # TRUE
ref_pop(dit, "x")                            # get column and remove it
has_name(dit, "x")                           # FALSE


# Copy and reference semantics when coercing *from* a data.table
dat = data.table(a = 1, b = 2)
dit = as.dict.table(dat)
is.dict.table(dit)                           # TRUE
is.dict.table(dat)                           # FALSE
ref_replace_at(dit, "a", 9)
dit[["a"]]                                   # 9
dat[["a"]]                                   # 1
dit.dat = as.dict.table(dat, copy = FALSE)   # init by reference
ref_replace_at(dit.dat, "a", 9)
dat[["a"]]                                   # 9
is.dict.table(dit.dat)                       # TRUE
is.dict.table(dat)                           # TRUE now as well!

# Coerce from dict
d = dict(a = 1, b = 1:3)
as.dict.table(d)

dit = dict.table(a = 1:2, b = 1:2)
rbind(dit, dit)

# rbind ...
dit = dict.table(a = 1:2, b = 1:2)
rbind(dit, dit)

# ... can be mixed with data.tables
dat = data.table(a = 3:4, b = 3:4)
rbind(dit, dat)  # yields a dict.table
rbind(dat, dit)  # yields a data.table

# cbind ...
dit = dict.table(a = 1:2, b = 1:2)
dit2 = dict.table(c = 3:4, d = 5:6)
cbind(dit, dit2)

# ... can be mixed with data.tables
dat = data.table(x = 3:4, y = 3:4)
cbind(dit, dat)

dit = dict.table(a = 1:3)
add(dit, b = 3:1, d = 4:6)

try(add(dit, a = 7:9))  # column 'a' already exists

dit = dict.table(a = 1:3, b = 4:6)
at(dit, "a")
at(dit, 2)
at(dit, "a", 2)
try(at(dit, "x"))     # index 'x' not found
try(at(dit, 1:3))     # index 3 exceeds length of dict.table

dit = dict.table(a = 1:3, b = 4:6)
at2(dit, 1)
at2(dit, "a")
at2(dit, 2)
try(at2(dit, "x"))     # index 'x' not found
try(at2(dit, 5))       # index 5 exceeds length of dict.table

dit = dict.table(a = 1, b = 2)
clear(dit)
dit
ref_clear(dit)
dit

d = dict.table(a = 1:2, b = 3:4)
d2 = clone(d)
ref_clear(d)
print(d2)

(dit = as.dict.table(head(sleep)))
delete_at(dit, "ID")
delete_at(dit, "ID", 1)

try({
delete_at(dit, "foo")   # Column 'foo' not in dict.table
})

dit = as.dict.table(head(sleep))
discard_at(dit, "ID")
discard_at(dit, "ID", 1)
discard_at(dit, "foo")  # ignored

dit = dict.table(a = 1:3, b = as.list(4:6))
has(dit, 1:3)            # TRUE
has(dit, 4:6)            # FALSE
has(dit, as.list(4:6))   # TRUE

dit = dict.table(a = 1, b = 2)
has_name(dit, "a")    # TRUE
has_name(dit, "x")    # FALSE

d = dict.table(a = 1:4, b = 4:1)
is_empty(d)
is_empty(clear(d))

dit = dict.table(a = 1:3, b = 4:6)
peek_at(dit, "a")
peek_at(dit, 1)
peek_at(dit, 3)
peek_at(dit, "x")
peek_at(dit, "x", .default = 0)
peek_at(dit, "a", "x", .default = 0)

dit = dict.table(a = 1:3, b = 4:6)
peek_at2(dit, "a")
peek_at2(dit, 1)
peek_at2(dit, 3)
peek_at2(dit, 3, default = 9)
peek_at2(dit, "x")
peek_at2(dit, "x", default = 0)

dit = dict.table(a = 1:3, b = 4:6)
ref_pop(dit, "a")
ref_pop(dit, 1)

try({
ref_pop(dit, "x")  # index 'x' not found
})

dit = dict.table(a = 1, b = 2, c = 3)
rename(dit, c("a", "b"), c("a1", "y"))
print(dit)
ref_rename(dit, c("a", "b"), c("a1", "y"))
print(dit)

dit = dict.table(a = 1:3)
replace_at(dit, "a", 3:1)

try({
replace_at(dit, "b", 4:6)               # column 'b' not in dict.table
})
replace_at(dit, "b", 4:6, .add = TRUE)  # ok, adds column

# Update parts of tables (second overwrites columns of the first)
dit1 = dict.table(a = 1:2, b = 3:4)
dit2 = dict.table(         b = 5:6, c = 8:9)
update(dit1, dit2)
update(dit2, dit1)
</code></pre>


</div>