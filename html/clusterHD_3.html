<div class="container">

<table style="width: 100%;"><tr>
<td>HTKmeans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
HTK-Means Clustering
</h2>

<h3>Description</h3>

<p>Perform HTK-means clustering (Raymaekers and Zamar, 2022) on a data matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">HTKmeans(X, k, lambdas = NULL,
         standardize = TRUE,
         iter.max = 100, nstart = 100,
         nlambdas = 50,
         lambda_max = 1,
         verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p> a matrix containing the data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>the number of clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>

<p>a vector of values for the regularization parameter <code>lambda</code>.
Defaults to <code>NULL</code>, which generates a sequence of values automatically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>

<p>logical flag for standardization to mean 0 and variance 1 of
the data in <code>X</code>. This is recommended, unless the variance
of the variables is known to quantify relevant information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>

<p>the maximum number of iterations allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>

<p>number of starts used when k-means is applied to generate
the starting values for HTK-means. See below for more info.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambdas</code></td>
<td>

<p>Number of lambda values to generate automatically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_max</code></td>
<td>

<p>Maximum value for the regularization paramater <code class="reqn">lambda</code>. If
<code>standardize = TRUE</code>, the default of 1 works well.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Whether or not to print progress. Defaults to <code>FALSE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm starts by generating a number of sparse starting values. This is done using k-means on subsets of variables. See 
Raymaekers and Zamar (2022) for details. 
</p>


<h3>Value</h3>

<p>A list with components: <br></p>

<ul>
<li>
<p><code>HTKmeans.out</code> <br>
A list with length equal to the number of lambda values supplied in <code>lambdas</code>.
Each element of this list is in turn a list containing
</p>
<p>centers A matrix of cluster centres.
</p>
<p>cluster A vector of integers (from 1:<code>k</code>) indicating the cluster to which each point is allocated.
</p>
<p>itnb The number of iterations executed until convergence
</p>
<p>converged Whether the algorithm stopped by converging or through reaching the maximum number of itertions.

</p>
</li>
<li>
<p><code>inputargs</code> <br>
the input arguments to the function.

</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>J. Raymaekers and R.H. Zamar
</p>


<h3>References</h3>

<p>Raymaekers, Jakob, and Ruben H. Zamar. "Regularized K-means through hard-thresholding." arXiv preprint arXiv:2010.00950 (2020).
</p>


<h3>See Also</h3>

<p><code>kmeans</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">X &lt;- iris[, 1:4]
HTKmeans.out &lt;- HTKmeans(X, k = 3, lambdas = 0.8)
HTKmeans.out[[1]]$centers
pairs(X, col = HTKmeans.out[[1]]$cluster)
</code></pre>


</div>