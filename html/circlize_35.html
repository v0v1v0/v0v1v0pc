<div class="container">

<table style="width: 100%;"><tr>
<td>circos.heatmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Make circular heatmaps
</h2>

<h3>Description</h3>

<p>Make circular heatmaps
</p>


<h3>Usage</h3>

<pre><code class="language-R">circos.heatmap(mat, split = NULL, col, na.col = "grey",
    cell.border = NA, cell.lty = 1, cell.lwd = 1,
    bg.border = NA, bg.lty = par("lty"), bg.lwd = par("lwd"),
    ignore.white = is.na(cell.border),
    cluster = TRUE, clustering.method = "complete", distance.method = "euclidean",
    dend.callback = function(dend, m, si) reorder(dend, rowMeans(m)),
    dend.side = c("none", "outside", "inside"), dend.track.height = 0.1,
    rownames.side = c("none", "outside", "inside"), rownames.cex = 0.5,
    rownames.font = par("font"), rownames.col = "black",
    show.sector.labels = FALSE, cell_width = rep(1, nrow(mat)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A matrix or a vector. The vector is transformed as a one-column matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>A categorical variable. It splits the matrix into a list of matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>If the values in the matrices are continuous, the color should be a color mapping generated by  <code>colorRamp2</code>. If the values are characters, the color should be a named color vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.col</code></td>
<td>
<p>Color for <code>NA</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.border</code></td>
<td>
<p>Border color of cells. A single scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.lty</code></td>
<td>
<p>Line type of cell borders. A single scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.lwd</code></td>
<td>
<p>Line width of cell borders. A single scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bg.border</code></td>
<td>
<p>Color for background border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bg.lty</code></td>
<td>
<p>Line type of the background border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bg.lwd</code></td>
<td>
<p>Line width of the background border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.white</code></td>
<td>
<p>Whether to draw the white color?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>whether to apply clustering on rows. The value can also be a <code>dendrogram</code>/<code>hclust</code> object or other objects that can be converted to with <code>as.dendrogram</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering.method</code></td>
<td>
<p>Clustering method, pass to <code>hclust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.method</code></td>
<td>
<p>Distance method, pass to <code>dist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dend.callback</code></td>
<td>
<p>A callback function that is applied to the dendrogram in every sector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dend.side</code></td>
<td>
<p>Side of the dendrograms relative to the heatmap track.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dend.track.height</code></td>
<td>
<p>Track height of the dendrograms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownames.side</code></td>
<td>
<p>Side of the row names relative to the heatmap track.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownames.cex</code></td>
<td>
<p>Cex of row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownames.font</code></td>
<td>
<p>Font of row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownames.col</code></td>
<td>
<p>Color of row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.sector.labels</code></td>
<td>
<p>Whether to show sector labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell_width</code></td>
<td>
<p>Relative widths of heatmap cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Pass to <code>circos.track</code> which draws the heatmap track.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><a href="https://jokergoo.github.io/2020/05/21/make-circular-heatmaps/">https://jokergoo.github.io/2020/05/21/make-circular-heatmaps/</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(123)
mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), 
                   matrix(rnorm(50*5, mean = -1), nr = 50)),
             cbind(matrix(rnorm(50*5, mean = -1), nr = 50), 
                   matrix(rnorm(50*5, mean = 1), nr = 50))
            )
rownames(mat1) = paste0("R", 1:100)
colnames(mat1) = paste0("C", 1:10)
mat1 = mat1[sample(100, 100), ] # randomly permute rows
split = sample(letters[1:5], 100, replace = TRUE)
spilt = factor(split, levels = letters[1:5])
col_fun1 = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))
circos.heatmap(mat1, split = split, col = col_fun1)
circos.clear()

</code></pre>


</div>