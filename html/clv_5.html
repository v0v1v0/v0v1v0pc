<div class="container">

<table style="width: 100%;"><tr>
<td>cls.scatt.data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Intercluster distances and intracluster diameters - Internal Measures</h2>

<h3>Description</h3>

<p>Two functions which find most popular <em>intercluster distances</em> and <em>intracluster diameters</em>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cls.scatt.data(data, clust, dist="euclidean")
cls.scatt.diss.mx(diss.mx, clust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>numeric matrix</code> or <code>data.frame</code> where columns correspond to variables and rows to 
observations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diss.mx</code></td>
<td>

<p>square, symmetric <code>numeric matrix</code> or <code>data.frame</code>, representation of 
dissimilarity matrix where infomartion about distances between objects is stored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust</code></td>
<td>

<p>integer <code>vector</code> with information about cluster id the object is assigned to.
If vector is not integer type, it will be coerced with warning.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>

<p>chosen metric: "euclidean" (default value), "manhattan", "correlation"
(variable enable only in <code>cls.scatt.data</code> function). 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Six <em>intercluster distances</em> and three <em>intracluster diameters</em> can be used to 
calculate such validity indices as <em>Dunn</em> and <em>Davies-Bouldin</em> like.
Let <code>d(x,y)</code> be a distance function between two objects comming from our data set.
</p>
<p><em>Intracluster diameters</em>
</p>
<p>The <em>complete diameter</em> represents the distance between two the most remote objects belonging 
to the same cluster. 
</p>
<p>diam1(C) = max{ d(x,y): x,y belongs to cluster C }
</p>
<p>The <em>average diameter</em> distance defines the average distance between all of the 
samples belonging to the same cluster. 
</p>
<p>diam2(C) = 1/|C|(|C|-1) * sum{ forall x,y belongs to cluster C and x != y } d(x,y)
</p>
<p>The <em>centroid diameter</em> distance reflects the double average distance between all of the 
samples and the cluster's center (v(C) - cluster center).
</p>
<p>diam3(C) = 1/|C| * sum{ forall x belonging to cluster C} d(x,v(C))
</p>
<p><em>Intercluster distances</em>
</p>
<p>The <em>single linkage</em> distance defines the closest distance between two samples 
belonging to two different clusters. 
</p>
<p>dist1(Ci,Cj) = min{ d(x,y): x belongs to Ci and y to Cj cluster }
</p>
<p>The <em>complete linkage</em> distance represents the distance between the most remote samples
belonging to two different clusters. 
</p>
<p>dist2(Ci,Cj) = max{ d(x,y): x belongs to Ci and y to Cj cluster }
</p>
<p>The <em>average linkage</em> distance defines the average distance between all of the samples 
belonging to two different clusters. 
</p>
<p>dist3(Ci,Cj) = 1/(|Ci|*|Cj|) * sum{ forall x belongs Ci and y to Cj } d(x,y)
</p>
<p>The <em>centroid linkage</em> distance reflects the distance between the centres of two clusters
(v(i), v(j) - clusters' centers).
</p>
<p>dist4(Ci,Cj) = d(v(i), V(j))
</p>
<p>The <em>average of centroids linkage</em> represents the distance between the centre of a cluster 
and all of samples belonging to a different cluster. 
</p>
<p>dist5(Ci,Cj) = 1/(|Ci|+|Cj|) * 
( sum{ forall x belongs Ci } d(x,v(j)) + sum{ forall y belongs Cj } d(y,v(i)) )
</p>
<p><em>Hausdorff metrics</em> are based on the discovery of a maximal distance from samples of one 
cluster to the nearest sample of another cluster. 
</p>
<p>dist6(Ci,Cj) = max{ distH(Ci,Cj), distH(Cj,Ci) }
</p>
<p>where: distH(A,B) = max{ min{ d(x,y): y belongs to B}: x belongs to A }
</p>


<h3>Value</h3>

<p><code>cls.scatt.data</code> returns an object of class <code>"list"</code>.
Intracluster diameters: 
<code>intracls.complete</code>,
<code>intracls.average</code>,
<code>intracls.centroid</code>,
are stored in vectors and intercluster distances:
<code>intercls.single</code>, 
<code>intercls.complete</code>,
<code>intercls.average</code>,
<code>intercls.centroid</code>,
<code>intercls.ave_to_cent</code>,
<code>intercls.hausdorff</code>
in symmetric matrices.
Vectors' lengths and both dimensions of each matrix are equal to number of clusters.
Additionally in result list <code>cluster.center</code> matrix (rows correspond to clusters centers) 
and <code>cluster.size</code> vector is given (information about size of each cluster).
<br><br><code>cls.scatt.diss.mx</code> returns an object of class <code>"list"</code>.
Intracluster diameters: 
<code>intracls.complete</code>,
<code>intracls.average</code>,
are stored in vectors and intercluster distances:
<code>intercls.single</code>, 
<code>intercls.complete</code>,
<code>intercls.average</code>,
<code>intercls.hausdorff</code>
in symmetric matrices.
Vectors' lengths and both dimensions of each matrix are equal to number of clusters.
Additionally in result list <code>cluster.size</code> vector is given (information about size of each cluster).
</p>


<h3>Author(s)</h3>

<p>Lukasz Nieweglowski</p>


<h3>References</h3>

<p>J. Handl, J. Knowles and D. B. Kell <em>Computational cluster validation in post-genomic data analysis</em>,
<a href="http://bioinformatics.oxfordjournals.org/cgi/reprint/21/15/3201?ijkey=VbTHU29vqzwkGs2&amp;keytype=ref">http://bioinformatics.oxfordjournals.org/cgi/reprint/21/15/3201?ijkey=VbTHU29vqzwkGs2&amp;keytype=ref</a>
</p>
<p>N. Bolshakova, F. Azuajeb <em>Cluster validation techniques for genome expression data</em>,
<a href="http://citeseer.ist.psu.edu/552250.html">http://citeseer.ist.psu.edu/552250.html</a>
</p>


<h3>See Also</h3>

<p>Result used in: <code>clv.Dunn</code>, <code>clv.Davies.Bouldin</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load and prepare data
library(clv)
data(iris)
iris.data &lt;- iris[,1:4]

# cluster data
pam.mod &lt;- pam(iris.data,5) # create five clusters
v.pred &lt;- as.integer(pam.mod$clustering) # get cluster ids associated to given data objects

# compute intercluster distances and intracluster diameters
cls.scatt1 &lt;- cls.scatt.data(iris.data, v.pred)
cls.scatt2 &lt;- cls.scatt.data(iris.data, v.pred, dist="manhattan")
cls.scatt3 &lt;- cls.scatt.data(iris.data, v.pred, dist="correlation")

# the same using dissimilarity matrix
iris.diss.mx &lt;- as.matrix(daisy(iris.data))
cls.scatt4 &lt;- cls.scatt.diss.mx(iris.diss.mx, v.pred)
</code></pre>


</div>