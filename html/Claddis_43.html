<div class="container">

<table style="width: 100%;"><tr>
<td>find_unique_trees</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Finds only the unique topologies amongst a set</h2>

<h3>Description</h3>

<p>Given a set of trees with the same tip labels, returns just the unique topologies present.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find_unique_trees(trees)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>trees</code></td>
<td>
<p>An object of class <code>multiPhylo</code>.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Where labelled topologies are generated randomly or modified by (e.g.) removing a tip, it may be useful to isolate just those that are truly unique. The <code>ape</code> package already has a function for this (unique.multiPhylo), but it can be slow when the number of trees is large. This function is thus intended as a faster version.
</p>
<p>The function works by breaking down a tree into its' component bipartitions and treating the combination of these as the definition of the tree. It thus escapes problems due to the principle of free rotation. Specifically, these two trees are actually identical:
</p>
<pre>A  B  C   D  E
 \/    \   \/
  \     \  /
   \     \/
    \    /
     \  /
      \/

B  A  D  E   C
 \/    \/   /
  \     \  /
   \     \/
    \    /
     \  /
      \/</pre>
<p>This becomes clearer if we decompose them into their bipartitions:
</p>
<p>AB, DE, CDE, ABCDE
</p>
<p>These correspond to the descendants of each internal node (branching point) and the last one is actually ignored (the root node) as it will be present in any tree.
</p>


<h3>Value</h3>

<p>An object of class <code>"multiPhylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Graeme T. Lloyd <a href="mailto:graemetlloyd@gmail.com">graemetlloyd@gmail.com</a>
</p>


<h3>See Also</h3>

<p>unique.multiPhylo
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Make a set of three identical trees (differing only in "rotation" of nodes):
trees &lt;- ape::read.tree(text = c(
  "((A,B),(C,(D,E)));",
  "((C,(D,E)),(A,B));",
  "((B,A),(C,(E,D)));")
)

# Show that there is only one unique tree:
find_unique_trees(trees = trees)

</code></pre>


</div>