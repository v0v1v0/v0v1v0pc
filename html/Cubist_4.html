<div class="container">

<table style="width: 100%;"><tr>
<td>dotplot.cubist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Visualization of Cubist Rules and Equations</h2>

<h3>Description</h3>

<p>Lattice dotplots of the rule conditions or the linear model
coefficients produced by <code>cubist()</code> objects
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cubist'
dotplot(x, data = NULL, what = "splits", committee = NULL, rule = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>cubist()</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>not currently used (here for lattice compatibility)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>either "splits" or "coefs"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>committee</code></td>
<td>
<p>which committees to plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>which rules to plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>options to pass to <code>lattice::dotplot()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the splits, a panel is created for each predictor. The
x-axis is the range of the predictor scaled to be between zero
and one and the y-axis has a line for each rule (within each
committee). Areas are colored as based on their region. For
example, if one rule has <code>var1 &lt; 10</code>, the linear for this rule
would be colored. If another rule had the complementary region
of <code>var1 &lt;= 10</code>, it would be on another line and shaded a
different color.
</p>
<p>For the coefficient plot, another dotplot is made. The layout
is the same except the the x-axis is in the original units and
has a dot if the rule used that variable in a linear model.
</p>


<h3>Value</h3>

<p>a <code>lattice::dotplot()</code> object
</p>


<h3>Author(s)</h3>

<p>R code by Max Kuhn, original C sources by R Quinlan and
modifications be Steve Weston
</p>


<h3>References</h3>

<p>Quinlan. Learning with continuous classes.
Proceedings of the 5th Australian Joint Conference On Artificial
Intelligence (1992) pp. 343-348
</p>
<p>Quinlan. Combining instance-based and model-based learning.
Proceedings of the Tenth International Conference on Machine
Learning (1993) pp. 236-243
</p>
<p>Quinlan. <strong>C4.5: Programs For Machine Learning</strong> (1993)
Morgan Kaufmann Publishers Inc. San Francisco, CA
</p>
<p><a href="http://rulequest.com/cubist-info.html">http://rulequest.com/cubist-info.html</a>
</p>


<h3>See Also</h3>

<p><code>cubist()</code>, <code>cubistControl()</code>,
<code>predict.cubist()</code>, <code>summary.cubist()</code>,
<code>predict.cubist()</code>, <code>lattice::dotplot()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(mlbench)
data(BostonHousing)

## 1 committee and no instance-based correction, so just an M5 fit:
mod1 &lt;- cubist(x = BostonHousing[, -14], y = BostonHousing$medv)
dotplot(mod1, what = "splits")
dotplot(mod1, what = "coefs")

## Now with 10 committees
mod2 &lt;- cubist(x = BostonHousing[, -14], 
               y = BostonHousing$medv, 
               committees = 10)
dotplot(mod2, scales = list(y = list(cex = .25)))
dotplot(mod2, what = "coefs", 
        between = list(x = 1, y = 1),
        scales = list(x = list(relation = "free"), 
                      y = list(cex = .25)))

</code></pre>


</div>