<div class="container">

<table style="width: 100%;"><tr>
<td>cirPAVA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Returns centered-isotonic-regression estimate</h2>

<h3>Description</h3>

<p>Nonparametric forward point estimation of a monotone response (y) as a function of dose (x), using the centered-isotonic-regression (CIR) algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cirPAVA(
  y,
  x = NULL,
  wt = NULL,
  outx = NULL,
  full = FALSE,
  dec = FALSE,
  strict = FALSE,
  interiorStrict = TRUE,
  ybounds = 0:1,
  adaptiveShrink = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>can be either of the following: y values (response rates), a <code>DRtrace</code> object,a <code>doseResponse</code> object, or valid input (potentially together with <code>x,wt</code>) to generate a <code>doseResponse</code> object. See <code>doseResponse</code> help for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>dose levels (if not included in y).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>weights (if not included in y).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outx</code></td>
<td>
<p>vector of x values for which predictions will be made. If <code>NULL</code> (default), this will be set to the set of unique values in the x argument (or equivalently in y$x). Non-NULL inputs are relevant only if <code>full=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>logical, is a more complete output desired? if <code>FALSE</code> (default), only a vector of point estimates for y at the provided dose levels is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dec</code></td>
<td>
<p>logical, is the true function is assumed to be monotone decreasing? Default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>logical, should CIR enforce strict monotonicity by "fixing" flat intervals as well? Default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interiorStrict</code></td>
<td>
<p>logical, should CIR enforce strict monotonicity, but only for y values inside of <code>ybounds</code>?  Default <code>TRUE</code>. Choosing <code>FALSE</code> will be overridden if <code>strict=TRUE</code>, and a warning will be given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ybounds</code></td>
<td>
<p>numeric vector of length 2, relevant only under the default setting of <code>strict=FALSE,interiorStrict=TRUE</code>. Default <code>0:1</code>. See 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptiveShrink</code></td>
<td>
<p>logical, should the y-values be pre-shrunk towards an experiment's target? Recommended if data were obtained via an adaptive dose-finding design. If <code>TRUE</code>, then must also provide a <code>target</code> argument that will be passed via <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to pre-processing functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is the underlying "engine" function implementing CIR. For a quick and somewhat more user-friendly wrapper, use <code>quickIsotone</code>. CIR is a variation of isotonic regression (IR) that shrinks IR's constant ("flat") intervals to single points and interpolates between these points, generating a curve that is strictly monotone everywhere except (possibly) near the boundaries.
</p>
<p>Flat intervals in the raw input data, are handled with care. Under the default setting (<code>strict=FALSE,interiorStrict=TRUE</code>), flat intervals are treated as monotonicity violations, unless the <code class="reqn">y</code> value is on the boundary of its allowed range (default <code class="reqn">[0,1]</code>, appropriate for binary-response data). On that boundary, flat intervals are left unchanged.
</p>
<p>The algorithm is documented and discussed in Oron and Flournoy (2017). The function now include an <code>adaptiveShrink</code> option, to mitigate bias caused when using adaptive designs (Flournoy and Oron, 2020).
</p>


<h3>Value</h3>

<p>under default, returns a vector of y estimates at unique x values. With <code>full=TRUE</code>, returns a list of 3 <code>doseResponse</code> objects name <code>output,input,shrinkage</code> for the output data at dose levels, the input data, and the function as fit at algorithm-generated shrinkage points, respectively.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Oron, A.P. and Flournoy, N., 2017. Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. Statistics in Biopharmaceutical Research 9, 258-267. (author's public version available on arxiv.org).
</p>
<p>Flournoy, N. and Oron, A.P., 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.
</p>


<h3>See Also</h3>

<p><code>oldPAVA</code>,<code>quickIsotone</code>; <code>DRshrink</code> for explanation about <code>adaptiveShrink</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# CIR, using the default 'quick' function that also provides CIs (default 90%).
# The experiment's goal is to find the 30th percentile. We deploy the empirical bias correction.
quick1=quickIsotone(dat, adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3)
quick1
# Use 'estfun' argument to operate the same function with old PAVA as the estimator
# Here we neglect the bias correction to sharpen the old:new contrast
quick0=quickIsotone(dat,estfun=oldPAVA)
quick0

### Showing the data and the fits
par(mar=c(3,3,1,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat, ylim=c(0.05,0.55), las=1) # uses plot.doseResponse()
# The IR fit: a straightforward interpolation
lines(quick0$y,lty=2) 

# With CIR, 'quickIsotone' cannot show us the true underlying interpolation; 
# it only provides the estimates at requested points.  Interpolation should be done between 
# shrinkage points, not the original design points. So we must call the full 'cirPAVA' function:

slow1 = cirPAVA(dat, full=TRUE, adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3)
# Now, compare these 3 (the first one is wrong, b/c it interpolates from design points):
midpts = 1:4 + 0.5
approx(1:5,quick1$y, xout=midpts)$y
# instead, you can just call 'quickIsotone' and specify 'outx'
quickIsotone(dat,outx=midpts , adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3) 
approx(slow1$shrinkage$x,slow1$shrinkage$y,xout=midpts)$y # Or use 'cirPAVA'

# Ok... finally plotting the CIR curve
# Both flat intervals are shrunk, because neither are at y=0 or y=1
lines(slow1$shrinkage$x,slow1$shrinkage$y, lwd = 2)

# Last but not least, here's the true response function
lines(seq(1,5,0.1),pweibull(seq(1,5,0.1),shape=1.1615,scale=8.4839),col=2)
legend('topleft',pch=c(NA,'X',NA,NA),lty=c(1,NA,2,1),col=c(2,1,1,1),
	legend=c('True Curve','Observations','IR','CIR'), bty='n')
</code></pre>


</div>