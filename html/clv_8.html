<div class="container">

<table style="width: 100%;"><tr>
<td>cls.stab.sim.ind.usr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster Stability - Similarity Index and Pattern-wise Stability Approaches with User Defined Cluster Algorithms</h2>

<h3>Description</h3>

<p><code>cls.stab.sim.ind.usr</code> and <code>cls.stab.opt.assign.usr</code> reports validation measures for clustering results. Both functions return lists of  
cluster stability results computed for user defined cluster algorithms according to similarity index and pattern-wise stability approaches.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cls.stab.sim.ind.usr( data, cl.num, clust.alg, sim.ind.type, rep.num, subset.ratio )
cls.stab.opt.assign.usr( data, cl.num, clust.alg, rep.num, subset.ratio )
cls.alg( clust.method, clust.wrap, fast )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>numeric matrix</code> or <code>data.frame</code> where columns correspond to variables and rows to 
observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl.num</code></td>
<td>

<p>integer <code>vector</code> with information about numbers of cluster to which <code>data</code> will be partitioned.
If vector is not an integer type, it will be coerced with warning.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust.alg</code></td>
<td>

<p>there are two possible types of input:
</p>
<p>1. clustering function that takes two arguments: "data" to be partitioned described in <code>data</code> section 
and "clust.num" that represents number of cluster to which data will be partitioned. Function represents partitioning algorithm.
</p>
<p>2. an object of type "cls.alg" returned by <code>cls.alg</code> function (see "Details" for explanation). Object represents 
hierarchical algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust.method</code></td>
<td>

<p>hierarchical clustering function that takes only one argument named "data" described in <code>data</code> section.
Function should return hierarchical structure that might be applied as parameter to <code>clust.wrap</code> function. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust.wrap</code></td>
<td>

<p>cluster function that takes exactly two arguments: "clust.res" that represents the result of <code>clust.method</code> function and
"clust.num" which is the number of clusters to which "clust.res" is going to be cut. Function should return integer vector that 
represents object id (comming from <code>data</code> set) to cluster id (integer between 1 and <code>clust.num</code>) association.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.ind.type</code></td>
<td>

<p>string vector with information useful only for <code>cls.stab.sim.ind.usr</code> function. User is able to choose which 
similarity indicies (external measures) to use to compare two partitionings. Available are:
"dot.pr", "sim.ind", "rand", "jaccard" (for more details see <code>similarity.index</code>,
<code>dot.product</code>, <code>std.ext</code>). Combinations are also possible.
By default <code>c("dot.pr","sim.ind")</code> vector is applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep.num</code></td>
<td>

<p>integer number which tells how many pairs of data subsets will be partitioned for particular number of clusters.
The results of partitioning for given pair of subsets is used to compute similarity indices (in case of <code>cls.stab.sim.ind.usr</code>) 
or <em>pattern-wise stability</em> (in case of <code>cls.stab.opt.assign.usr</code>, for more details see references). 
By default <code>rep.num</code> value is 10. If wrong argument is applied it will be repaced with default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset.ratio</code></td>
<td>

<p>a number comming from (0,1) section which tells how big data subsets should be. 0 means empty subset, 1 means all data. 
By default <code>subset.ratio</code> is set to 0.75. If wrong argument is applied it will be repaced with default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast</code></td>
<td>

<p>logical argument which sets the way of computing cluster stability for hierarchical algorithms. By default it is set to
TRUE, which means that each result produced by hierarchical algorithm is partitioned for the number of clusters chosen in 
<code>cl.num</code> argument and given clustering results are put for further computation. In this way computation of cluster 
stability is faster. If wrong argument is applied it will be repaced with default value.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both functions realize cluster stability approaches described in <em>Detecting stable clusters using principal component analysis</em> 
chapters <em>3.1</em> and <em>3.2</em> (see references).
</p>
<p>The <code>cls.stab.sim.ind.usr</code> as well as <code>cls.stab.opt.assign.usr</code> do the same thing as <code>cls.stab.sim.ind</code> and 
<code>cls.stab.opt.assign</code> functions. Main difference is that using this functions user is able to define and apply its own cluster 
algorithm to measure its cluster stability. For that reason <code>clust.alg</code> argument is introduced. This argument may represent partitioning 
algorithm (by passing it directly as a function) or hierarchical algorithm (by passing an object of "cls.alg" type produced by <code>cls.alg</code> 
function).
</p>
<p>If a partitioning algorithm is going to be used the decalration of this function that represents this algorithm should always look 
like this: <code> function(data, clust.num) { ... return(integer.vector)} </code>.
As an output function should always return integer vector that represents single clustering result on <code>data</code>. 
</p>
<p>If a hierarchical algorithm is going to be used user has to use helper <code>cls.alg</code> function that produces an object of "cls.alg" type.
This object encapsulates a pair of methods that are used in hierarchical version (which is faster if the <code>fast</code> argument is not FALSE) 
of cluster stability approach. These methods are:<br>
1. <em>clust.method</em> - which builds hierarchical structure that might be cut. The declaration of this function should always look like 
this one: <kbd> function(data) { ... return(hierarchical.struct) } </kbd>,<br>
2. <em>clust.wrap</em> - which cuts this hierarchical structure to <code>clust.num</code> clusters. This function definition should always look 
like this one: <kbd> function(clust.res, clust.num) { ... return(integer.vector)} </kbd>. As an output function should 
always return integer vector that represents single clustering result on <code>clust.res</code>.
</p>
<p><code>cls.alg</code> function has also third argument that indicates if fast computation should be taken (when <code>TRUE</code>) or if these two 
methods should be converted to one partitioning algorithm and to be run as a normal partitioning algorithm.
</p>
<p>Well defined cluster functions "f" should always follow this rules (size(data) means number of object to be partitioned, 
res - integer vector with cluster ids):<br>
1. when <code>data</code> is empty or <code>cl.num</code> is less than 2 or more than <code>size(data)</code> then <code>f(data, cl.num)</code> returns error.
2. if <code>f(data, cl.num) -&gt; res</code> then length(res) == size(data),<br>
3. if <code>f(data, cl.num) -&gt; res</code> then for all "elem" in "res" the folowing condition is true: <code>0 &lt; elem &lt;= cl.num</code>.
</p>
<p>It often happens that clustering algorithms can't produce amount of clusters that user wants. In this situation only the warning is 
produced and cluster stability is computed for partitionings with unequal number of clusters.
</p>
<p>The cluster stability will not be calculated for all cluster numbers that are bigger than the subset size.
For example if <code>data</code> contains about 20 objects and the <code>subset.ratio</code> equals 0.5 then the highest cluster number to 
calculate is 10. In that case all elements above 10 will be removed from <code>cl.num</code> vector.
</p>


<h3>Value</h3>

<p><code>cls.stab.sim.ind.usr</code> returns a lists of matrices. Each matrix consists of the set of external similarity indices (which one similarity 
index see below) where number of columns is equal to <code>cl.num</code> vector length and row number is equal to <code>rep.num</code> value what means
that each column contain a set of similarity indices computed for fixed number of clusters. The order of the matrices depends on 
<code>sim.ind.type</code> argument. Each element of this list correspond to one of similarity index type chosen thanks to <code>sim.ind.type</code> argument. 
The order of the names exactly match to the order given in those arguments description.<br></p>
<p><code>cls.stab.opt.assign.usr</code> returns a vector. The vector consists of the set of cluster stability indices described in 
<em>Detecting stable clusters using principal component analysis</em> chapter <em>3.2</em> (see references). Vector length is equal to <code>cl.num</code> vector length what 
means that each position in vector is assigned to proper clusters' number given in <code>cl.num</code> argument.
</p>


<h3>Author(s)</h3>

<p>Lukasz Nieweglowski</p>


<h3>References</h3>

<p>A. Ben-Hur and I. Guyon <em>Detecting stable clusters using principal component analysis</em>,
<a href="http://citeseerx.ist.psu.edu/">http://citeseerx.ist.psu.edu/</a>
</p>
<p>C. D. Giurcaneanu, I. Tabus, I. Shmulevich, W. Zhang <em>Stability-Based Cluster Analysis Applied To Microarray Data</em>, 
<a href="http://citeseerx.ist.psu.edu/">http://citeseerx.ist.psu.edu/</a>.
</p>
<p>T. Lange, V. Roth, M. L. Braun and J. M. Buhmann <em>Stability-Based Validation of Clustering Solutions</em>,
<a href="ml-pub.inf.ethz.ch/publications/papers/2004/lange.neco_stab.03.pdf">ml-pub.inf.ethz.ch/publications/papers/2004/lange.neco_stab.03.pdf</a>
</p>


<h3>See Also</h3>

<p>Other cluster stability methods:
<code>cls.stab.sim.ind</code>, <code>cls.stab.opt.assign</code>.
</p>
<p>Functions that compare two different partitionings:
<code>clv.Rand</code>, <code>dot.product</code>,<code>similarity.index</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# load and prepare data
library(clv)
data(iris)
iris.data &lt;- iris[,1:4]

# example of wrapper for partitioning algorithm 
pam.clust &lt;- function(data, clust.num) pam(data, clust.num, cluster.only=TRUE)

# example of wrapper for hierarchical algorithm
cutree.wrap &lt;- function(clust.res, clust.num)  cutree(clust.res, clust.num)
agnes.single &lt;- function(data) agnes(data, method="single") 

# converting hierarchical algorithm to partitioning one
agnes.part1 &lt;- function(data, clust.num) cutree.wrap( agnes.single(data), clust.num )
# the same using "cls.alg"
agnes.part2 &lt;- cls.alg(agnes.single, cutree.wrap, fast=FALSE)

# fix arguments for cls.stab.* function
iter = c(2,4,5,7,9,12,15)

res1 = cls.stab.sim.ind.usr( iris.data, iter, pam.clust, 
    sim.ind.type=c("rand","dot.pr","sim.ind"), rep.num=5, subset.ratio=0.7 )
res2 = cls.stab.opt.assign.usr( iris.data, iter, clust.alg=cls.alg(agnes.single, cutree.wrap) )

res3 = cls.stab.sim.ind.usr( iris.data, iter, agnes.part1,
     sim.ind.type=c("rand","dot.pr","sim.ind"), rep.num=5, subset.ratio=0.7 )
res4 = cls.stab.opt.assign.usr( iris.data, iter, clust.alg=agnes.part2 )

print(res1)
boxplot(res1$sim.ind)
plot(res2)


</code></pre>


</div>