<div class="container">

<table style="width: 100%;"><tr>
<td>kfuncCOPlmoms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The L-moments of the Kendall Function of a Copula</h2>

<h3>Description</h3>

<p>Compute the L-moments of the <em>Kendall Function</em> (<code class="reqn">F_K(z; \mathbf{C})</code>) of a copula <code class="reqn">\mathbf{C}(u,v)</code> where the <code class="reqn">z</code> is the joint probability of the <code class="reqn">\mathbf{C}(u,v)</code>. The Kendall Function (or <em>Kendall Distribution Function</em>) is the cumulative distribution function (CDF) of the joint probability <code class="reqn">Z</code> of the coupla. The expected value of the <code class="reqn">z(F_K)</code> (mean, first L-moment <code class="reqn">\lambda_1</code>), because <code class="reqn">Z</code> has nonzero probability for <code class="reqn">0 \le Z \le \infty</code>, is
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{E}[Z] = \lambda_1 = \int_0^\infty \bigl[1 - F_K(t)\bigr]\,\mathrm{d}t = \int_0^1 \bigl[1 - F_K(t)\bigr] \,\mathrm{d}t\mbox{,}</code>
</p>

<p>where for circumstances here <code class="reqn">0 \le Z \le 1</code>. The <code class="reqn">\infty</code> is mentioned only because expectations of such CDFs are usually shown using <code class="reqn">(0,\infty)</code> limits, whereas integration of quantile functions (CDF inverses) use limits <code class="reqn">(0, 1)</code>. Because the support of <code class="reqn">Z</code> is <code class="reqn">(0, 1)</code>, like the probability <code class="reqn">F_K</code>, showing just it (<code class="reqn">\infty</code>) as the upper limit could be confusing—statements such as “probabilities of probabilities” are rhetorically complex. So, pursuit of word precision is made herein.
</p>
<p>An expression for <code class="reqn">\lambda_r</code> for <code class="reqn">r \ge 2</code> in terms of the <code class="reqn">F_K(z)</code> is
</p>
<p style="text-align: center;"><code class="reqn">
\lambda_r = \frac{1}{r}\sum_{j=0}^{r-2} (-1)^j {r-2 \choose j}{r \choose j+1} \int_{0}^{1} \! \bigl[F_K(t)\bigr]^{r-j-1}\times \bigl[1 - F_K(t)\bigr]^{j+1}\, \mathrm{d}t\mbox{,}
</code>
</p>

<p>where because of these circumstances the limits of integration are <code class="reqn">(0, 1)</code> and not <code class="reqn">(-\infty, \infty)</code> as in the usual definition of L-moments in terms of a distribution's CDF. (Note, such expressions did not make it into Asquith (2011), which needs rectification if that monograph ever makes it to a 2nd edition.)
</p>
<p>The mean, L-scale, coefficient of L-variation (<code class="reqn">\tau_2</code>, LCV, L-scale/mean), L-skew (<code class="reqn">\tau_3</code>, TAU3), L-kurtosis (<code class="reqn">\tau_4</code>, TAU4), and <code class="reqn">\tau_5</code> (TAU5) are computed. In usual nomenclature, the L-moments are
<code class="reqn"> \lambda_1 = \mbox{mean,}</code>
<code class="reqn"> \lambda_2 = \mbox{L-scale,}</code>
<code class="reqn"> \lambda_3 = \mbox{third L-moment,}</code>
<code class="reqn"> \lambda_4 = \mbox{fourth L-moment, and}</code>
<code class="reqn"> \lambda_5 = \mbox{fifth L-moment,}</code>
whereas the L-moment ratios are
<code class="reqn"> \tau_2 = \lambda_2/\lambda_1 = \mbox{coefficient of L-variation, }</code>
<code class="reqn"> \tau_3 = \lambda_3/\lambda_2 = \mbox{L-skew, }</code>
<code class="reqn"> \tau_4 = \lambda_4/\lambda_2 = \mbox{L-kurtosis, and}</code>
<code class="reqn"> \tau_5 = \lambda_5/\lambda_2 = \mbox{not named.}</code>
It is common amongst practitioners to lump the L-moment ratios into the general term “L-moments” and remain inclusive of the L-moment ratios. For example, L-skew then is referred to as the 3rd L-moment when it technically is the 3rd L-moment ratio. There is no first L-moment ratio (meaningless); so, results from <code>kfuncCOPlmoms</code> function will canoncially show a <code>NA</code> in that slot. The coefficient of L-variation is <code class="reqn">\tau_2</code> (subscript 2) and not <em>Kendall Tau</em> (<code class="reqn">\tau</code>). Sample L-moments are readily computed by several packages in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> (<em>e.g.</em> <span class="pkg">lmomco</span>, <span class="pkg">lmom</span>, <span class="pkg">Lmoments</span>, <span class="pkg">POT</span>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">kfuncCOPlmom(r, cop=NULL, para=NULL, ...)

kfuncCOPlmoms(cop=NULL, para=NULL, nmom=5, begin.mom=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The <code class="reqn">r</code>th order of a single L-moment to compute;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmom</code></td>
<td>
<p>The number of L-moments to compute;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>begin.mom</code></td>
<td>
<p>The <code class="reqn">r</code>th order to begin the sequence <code>lambegr:nmom</code> for L-moment computation. The rarely used argument is means to bypass the computation of the mean if the user has an alternative method for the mean or other central tendency characterization in which case <code>begin.mom = 2</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>list</code> is returned by <code>kfuncCOPlmoms</code> and only the scalar value of <code class="reqn">\lambda_r</code> by <code>kfuncCOPlmom</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>Vector of the L-moments. First element is <code class="reqn">\lambda_1</code>, second element is <code class="reqn">\lambda_2</code>, and so on;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratios</code></td>
<td>
<p>Vector of the L-moment ratios. Second element is <code class="reqn">\tau</code>, third element is <code class="reqn">\tau_3</code> and so on; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>An attribute identifying the computational source of the L-moments: “kfuncCOPlmoms”.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The L-moments of Kendall Functions appear to be not yet fully researched. An interesting research direction would be the trajectories of the L-moments or <em>L-moment ratio diagrams</em> for the Kendall Function and the degree to which distinction between copulas becomes evident—such diagrams are in wide-spread use for distinquishing between univariate distributions. It is noted, however, that <em>Kendall Function L-moment ratio diagrams</em> might be of less utility that in the univariate world—recalling that a univariate distribution is unique characteristized by its L-moments—because different copulas can have the same <code class="reqn">F_K(z)</code>, such as all bivariate extreme value copulas (see also <b>Examples</b>).
</p>
<pre>
  Rhos &lt;- c(0.001, 0.01, seq(0.05, 0.95, by=0.05), 0.99, 0.999)
  L1 &lt;- T2 &lt;- T3 &lt;- T4 &lt;- Thetas &lt;- vector(mode="numeric", length(Rhos))
  for(i in 1:length(Thetas)) {
     Thetas[i] &lt;- uniroot(function(p)
                 Rhos[i] - rhoCOP(cop=PARETOcop, para=p), c(0,200))$root
     message("Rho = ", Rhos[i], " and Pareto theta = ",
                                             round(Thetas[i], digits=4))
     lmr &lt;- kfuncCOPlmoms(cop=PARETOcop, para=Thetas[i], nmom=4)
     L1[i] &lt;- lmr$lambdas[1]; T2[i] &lt;- lmr$ratios[2]
     T3[i] &lt;- lmr$ratios[3];  T4[i] &lt;- lmr$ratios[4]
  }
  LMR &lt;- data.frame(Rho=Rhos, Theta=Thetas, L1=L1, T2=T2, T3=T3, T4=T4)
  plot(LMR$Rho, LMR$T2, ylim=c(-0.04, 0.5), xlim=c(0, 1),
       xlab="Spearman Rho or coefficient of L-variation",
       ylab="L-moment ratio", type="l", col="black")
  lines(LMR$Rho, LMR$T3, lty=1, col="red"         )
  lines(LMR$Rho, LMR$T4, lty=1, col="green"       )
  lines(LMR$T2,  LMR$T3, lty=2, col="blue"        )
  lines(LMR$T2,  LMR$T4, lty=2, col="deepskyblue2")
  lines(LMR$T3,  LMR$T4, lty=2, col="purple"      )
</pre>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Asquith, W.H., 2011, Distributional analysis with L-moment statistics using the R environment for statistical computing: Createspace Independent Publishing Platform, ISBN 978–146350841–8.
</p>


<h3>See Also</h3>

<p><code>kfuncCOP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
kfuncCOPlmom(1, cop=P) # 0.5 * 0.5 = 0.25 is expected joint prob. of independence
#[1] 0.2499999  (in agreement with theory)

ThetaGH &lt;- 4.21
Rho &lt;- rhoCOP(cop=GHcop, para=ThetaGH)
ThetaHR &lt;- uniroot(function(p) Rho - rhoCOP(cop=HRcop, para=p), c(0, 100))$root
ThetaHR &lt;- uniroot(function(p) Rho - rhoCOP(cop=HRcop, para=p), c(0, 100))$root
ThetaGL &lt;- uniroot(function(p) Rho - rhoCOP(cop=GLcop, para=p), c(0, 100))$root
ls.str(kfuncCOPlmoms(cop=GHcop, para=ThetaGH)) # Gumbel-Hougaard copula
# lambdas :  num [1:5] 0.440617 0.169085 0.011228 -0.000797 0.000249
# ratios  :  num [1:5]       NA 0.383750 0.066400 -0.004720 0.001470
#                               L-skew = 0.066400
ls.str(kfuncCOPlmoms(cop=HRcop, para=ThetaHR)) # Husler-Reiss copula
# lambdas :  num [1:5] 0.439627 0.169052 0.011427 -0.000785 0.000249
# ratios  :  num [1:5]       NA 0.384540 0.067590 -0.004640 0.001470
#                               L-skew = 0.067590
ls.str(kfuncCOPlmoms(cop=GLcop, para=ThetaGL)) # Galambos copula
# lambdas :  num [1:5] 0.440415 0.169079 0.011268 -0.000795 0.000248
# ratios  :  num [1:5]       NA 0.383910 0.066650 -0.004700 0.001470
#                               L-skew = 0.066650
# These L-moments are extremely similar and within the numerics used.
# Extreme value copula all have the same Kendall Distribution function.
## End(Not run)

## Not run: 
UV &lt;- simCOP(200, cop=PLcop, para=1/pi, graphics=FALSE)
theta &lt;- PLpar(UV[,1], UV[,2])
zs &lt;- c(0.001, seq(0.01, 0.99, by=0.01), 0.999) # for later

# Take the sample estimated parameter and convert to joint probabilities Z
# Convert the Z to the Kendall Function estimates again with the sample parameter
Z  &lt;- PLcop(UV[,1], UV[,2], para=theta); KF &lt;- kfuncCOP(Z, cop=PLcop, para=theta)

# Compute L-moments of the "Kendall function" and the sample versions
# and again see that the L-moment are for the distribution of the Z!
KNFlmr &lt;- kfuncCOPlmoms(cop=PLcop, para=theta); SAMlmr &lt;- lmomco::lmoms(Z)
knftxt &lt;- paste0("Kendall L-moments: ",
                 paste(round(KNFlmr$lambdas, digits=4), collapse=", "))
samtxt &lt;- paste0("Sample L-moments: " ,
                 paste(round(SAMlmr$lambdas, digits=4), collapse=", "))

plot(Z, KF, xlim=c(0,1), ylim=c(0,1), col="black",
     xlab="COPULA(u,v) VALUE [JOINT PROBABILITY]",
     ylab="KENDALL DISTRIBUTION FUNCTION (KDF), AS NONEXCEEDANCE PROBABILITY")
rug(Z, side=1, col="red", lwd=0.5); rug(KF, side=2, col="red", lwd=0.5) # rug plots
lines(zs, kfuncCOP(zs, cop=PLcop, para=1/pi), col="darkgreen")
knf_meanZ &lt;- KNFlmr$lambdas[1]; sam_meanZ &lt;- SAMlmr$lambdas[1]
knf_mean  &lt;- kfuncCOP(knf_meanZ, cop=PLcop, para=theta) # theo. Kendall function
sam_mean  &lt;- kfuncCOP(sam_meanZ, cop=PLcop, para=theta) # sam. est. of Kendall func
points(knf_meanZ, knf_mean, pch=16, col="blue", cex=3)
points(sam_meanZ, sam_mean, pch=16, col="cyan", cex=2)
lines(zs, zs-zs*log(zs), lty=2, lwd=0.8) # dash ref line for independence
text(0.2, 0.30, knftxt, pos=4, cex=1); text(0.2, 0.25, samtxt, pos=4, cex=1)
text(0.2, 0.18, paste0("Notice uniform distribution of vertical axis rug.\n",
                       "A Critical remark with respect to to KDFs."), cex=1, pos=4)
legend("bottomright", c("Independence copula", "KDF of Plackett copula",
                        "Theoretical mean", "Sample mean"), bty="n", y.intersp=1.5,
       lwd=c(1, 1, NA, NA), lty=c(2, 1, NA, NA), pch=c(NA, NA, 16, 16),
       col=c("black", "darkgreen", "blue", "cyan"), pt.cex=c(NA, NA, 3, 2)) #
## End(Not run)
</code></pre>


</div>