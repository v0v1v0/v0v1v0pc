<div class="container">

<table style="width: 100%;"><tr>
<td>approx_df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interpolate time-indexed data frame</h2>

<h3>Description</h3>

<p>Given a numeric data frame <code>Y</code> with rows indexed by a time vector <code>tt</code>, interpolates at time values
specified by the vector <code>tt_est</code>. If <code>tt_est</code> is not in <code>tt</code>, will create new rows in the data frame
corresponding to these interpolated points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">approx_df(Y, tt, tt_est = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A data frame with all numeric columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tt</code></td>
<td>
<p>A time vector with length equal to <code>nrow(Y)</code>, indexing the rows in <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tt_est</code></td>
<td>
<p>A time vector of points to interpolate in <code>Y</code>. If <code>NULL</code>, will attempt to interpolate all
points in <code>Y</code> (you may need to adjust the <code>rule</code> argument of <code>stats::approx()</code> here). Note that points not
specified in <code>tt_est</code> will not be interpolated. <code>tt_est</code> does not need to be a subset of <code>tt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to pass to <code>stats::approx()</code> other than <code>x</code>, <code>y</code> and <code>xout</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a wrapper for <code>stats::approx()</code>, with some differences. In the first place, <code>stats::approx()</code> is
applied to each column of <code>Y</code>, using <code>tt</code> each time as the corresponding time vector indexing <code>Y</code>. Interpolated
values are generated at points specified in <code>tt_est</code> but these are appended to the existing data (whereas
<code>stats::approx()</code> will only return the interpolated points and nothing else). Further arguments to
<code>stats::approx()</code> can be passed using the <code>...</code> argument.
</p>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>.$tt</code> the vector of time points, including time values of interpolated points
</p>
</li>
<li> <p><code>.$Y</code>  the corresponding interpolated data frame
</p>
</li>
</ul>
<p>Both outputs are sorted by <code>tt</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># a time vector
tt &lt;- 2011:2020

# two random vectors with some missing values
y1 &lt;- runif(10)
y2 &lt;- runif(10)
y1[2] &lt;- y1[5] &lt;- NA
y2[3] &lt;- y2[5] &lt;- NA
# make into df
Y &lt;- data.frame(y1, y2)

# interpolate for time = 2012
Y_int &lt;- approx_df(Y, tt, 2012)
Y_int$Y

# notice Y_int$y2 is unchanged since at 2012 it did not have NA value
stopifnot(identical(Y_int$Y$y2, y2))

# interpolate at value not in tt
approx_df(Y, tt, 2015.5)

</code></pre>


</div>