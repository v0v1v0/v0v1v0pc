<div class="container">

<table style="width: 100%;"><tr>
<td>homophily.fe</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating network formation models with degree heterogeneity: the fixed effect approach</h2>

<h3>Description</h3>

<p><code>homophily.fe</code> implements a Logit estimator for network formation model with homophily. The model includes degree heterogeneity using fixed effects (see details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">homophily.fe(
  network,
  formula,
  data,
  symmetry = FALSE,
  fe.way = 1,
  init = NULL,
  opt.ctr = list(maxit = 10000, eps_f = 1e-09, eps_g = 1e-09),
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>
<p>matrix or list of sub-matrix of social interactions containing 0 and 1, where links are represented by 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class formula: a symbolic description of the model. The <code>formula</code> should be as for example <code>~ x1 + x2</code>
where <code>x1</code>, <code>x2</code> are explanatory variable of links formation. If missing, the model is estimated with fixed effects only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetry</code></td>
<td>
<p>indicates whether the network model is symmetric (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fe.way</code></td>
<td>
<p>indicates whether it is a one-way or two-way fixed effect model. The expected value is 1 or 2 (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>(optional) either a list of starting values containing <code>beta</code>, an K-dimensional vector of the explanatory variables parameter,
<code>mu</code> an n-dimensional vector, and <code>nu</code> an n-dimensional vector,
where K is the number of explanatory variables and n is the number of individuals; or a vector of starting value for <code>c(beta, mu, nu)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.ctr</code></td>
<td>
<p>(optional) is a list of <code>maxit</code>, <code>eps_f</code>, and <code>eps_g</code>, which are control parameters used by the solver <code>optim_lbfgs</code>, of the package <span class="pkg">RcppNumerical</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>Boolean indicating if the estimation progression should be printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be a probability for a link to go from the individual <code class="reqn">i</code> to the individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>fe.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_j + \nu_j)</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative of the standard logistic distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. The latter are treated as fixed effects (see <code>homophily.re</code> for random effect models).
As shown by Yan et al. (2019), the estimator of
the parameter <code class="reqn">\beta</code> is biased. A bias correction is then necessary and is not implemented in this version. However
the estimator of <code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code> are consistent.<br>
For one-way fixed effect models (<code>fe.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed and the
fixed effects need to be one way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model.info</code></td>
<td>
<p>list of model information, such as the type of fixed effects, whether the model is symmetric,
number of observations, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>maximizer of the log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike</code></td>
<td>
<p>maximized log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>returned value of the optimization solver, which contains details of the optimization. The solver used is <code>optim_lbfgs</code> of the
package <span class="pkg">RcppNumerical</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>returned list of starting value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike(init)</code></td>
<td>
<p>log-likelihood at the starting value.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p><code>homophily.re</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(1234)
M            &lt;- 2 # Number of sub-groups
nvec         &lt;- round(runif(M, 20, 50))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
Emunu        &lt;- runif(M, -1.5, 0) #expectation of mu + nu
smu2         &lt;- 0.2
snu2         &lt;- 0.2
for (m in 1:M) {
  n          &lt;- nvec[m]
  mum        &lt;- rnorm(n, 0.7*Emunu[m], smu2)
  num        &lt;- rnorm(n, 0.3*Emunu[m], snu2)
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rlogis(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.fe(network =  Glist, formula = ~ -1 + dX, fe.way = 2)
muhat &lt;- out$estimate$mu
nuhat &lt;- out$estimate$nu
plot(mu, muhat)
plot(nu, nuhat)

</code></pre>


</div>