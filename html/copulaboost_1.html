<div class="container">

<table style="width: 100%;"><tr>
<td>copulaboost</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>copulaboost</h2>

<h3>Description</h3>

<p>This is the main function of the package, which
fits an additive model with a fixed number of components, each
involving a fixed number of covariates, where each component is a 
copula regression model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">copulaboost(
  y,
  x,
  cov_types,
  n_models = 100,
  n_covs = 5,
  learning_rate = 0.33,
  eps = 0.05,
  verbose = FALSE,
  cont_method = "Localmedian",
  family_set = c("gaussian", "clayton", "gumbel"),
  jitter_sel = TRUE,
  ml_update = FALSE,
  ml_sel = FALSE,
  max_ml_scale = 1,
  keep_sel_struct = TRUE,
  approx_order = 2,
  parametric_margs = TRUE,
  parallel = FALSE,
  par_method_sel = "itau",
  update_intercept = TRUE,
  model = NULL,
  xtreme = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector of n observations of the (univariate) binary outcome
variable y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A (n x p) matrix of n observations of p covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_types</code></td>
<td>
<p>A vector of p characters that have to take the value
"c" or "d" to indicate whether each margin of the covariates is discrete
or continuous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_models</code></td>
<td>
<p>The number of model components to fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_covs</code></td>
<td>
<p>The number of covariates included in each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learning_rate</code></td>
<td>
<p>Factor to scale (down) the each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Control parameter for the approximation to the conditional
expectation (the prediction) for each copula model (component), which
splits the interval [-1, 1] into equal pieces of eps length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical indicator of whether a progressbar should be shown
in the terminal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cont_method</code></td>
<td>
<p>Method to use for the approximation of each conditional
expectation, can either be "Localmedian" or "Trapezoidalsurv", for the 
former, see section 3.2 of 
https://arxiv.org/ftp/arxiv/papers/2208/2208.04669.pdf. The latter uses 
the so called "Darth vader rule" in conjuction with a simple translative
transformation to write the conditional expectation as an integral along
the conditional survival function, which is then approximated by the 
trapezoidal method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family_set</code></td>
<td>
<p>A vector of strings that specifies the set of
pair-copula families that the fitting algorithm chooses from. For an
overview of which values that can be specified, see the documentation for
bicop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter_sel</code></td>
<td>
<p>Logical indicator of whether jittering should
be used for any discrete covariates when selecting the variables for each
component (improves computational speed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ml_update</code></td>
<td>
<p>Logical indicator of whether each new component should
be scaled by a number between 0 and max_ml_scale by maximising the 
log-likelihood of the scaling factor given the current model and the new
component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ml_sel</code></td>
<td>
<p>The same as ml_update, but for the variable selection
algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_ml_scale</code></td>
<td>
<p>The maximum scaling factor allowed for each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_sel_struct</code></td>
<td>
<p>Logical indicator of whether the d-vine structures found
by the model selection algorithm should be kept when fitting the
components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx_order</code></td>
<td>
<p>The order of the approximation used for evaluating the
conditional expectations when selecting covariates for each component. The
allowed values for approx_order are 1, 2, 3, 4, 5, and 6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametric_margs</code></td>
<td>
<p>Logical indicator of whether parametric (gaussian
or bernoulli) models should be used for the marginal distributions of the
covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>(Experimental) Logical indicator of whether
parallelization should be used when selecting covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_method_sel</code></td>
<td>
<p>Estimation method for copulas used when selecting
the model components, either "itau" or "mle", see the documentation for
bicop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_intercept</code></td>
<td>
<p>Logical indicator of whether the intercept
parameter should be updated (by univariate maximum likelihood) after
each component is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Initial copulaboost-model. If model is a copulaboost model
with k components, the resulting model will have k + n_models components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xtreme</code></td>
<td>
<p>(Experimental) Logical indicator of whether a second order 
expansion of the log-likelihood should be used in each gradient boosting 
step, similar to the xgboost algorithm.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A copulaboost object, which contains a nested list 'object$model'
which contains all of the model components. The first element of each
list contains a copulareg object, and the second element contains a vector
listing the indexes of the covariates that are a part of the component.
The object also contains a list of the updated intercepts 
'object$f0_updated' at each stage of the fitting process, so that the
j-th intercept is the intercept for the model that is the weighted sum of 
the j first components. 'object$scaling' contains a vector of weights for
each components, equal to the learning rate, possibly multiplied by an
individual factor if ml_update = TRUE. In addition the object contains
the values of the arguments learning_rate, cov_types, and eps that where
used when calling copulaboost().
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compile some test data
data('ChickWeight')
set.seed(10)
tr &lt;- sample(c(TRUE, FALSE), nrow(ChickWeight), TRUE, c(0.7, 0.3))
y_tr &lt;- as.numeric(ChickWeight$weight[tr] &gt; 100)
y_te &lt;- as.numeric(ChickWeight$weight[!tr] &gt; 100)
x_tr &lt;- apply(ChickWeight[tr, -1], 2, as.numeric)
x_te &lt;- apply(ChickWeight[!tr, -1], 2, as.numeric)
cov_types &lt;- apply(x_tr, 2,
                   function(x) if(length(unique(x)) &lt; 10) "d" else "c")

# Fit model to training data
md &lt;- copulaboost::copulaboost(y_tr, x_tr, cov_types, n_covs = 2, 
                               n_models = 5, verbose = TRUE)

# Out of sample predictions for a new data matrix
preds &lt;- predict(md, new_x = x_te, all_parts = TRUE)

# Plot log-likelihood
plot(apply(preds, 2,
           function(eta) {
             sum(stats::dbinom(y_te, 1, stats::plogis(eta), log = TRUE))
             }),
     type = "s")

</code></pre>


</div>