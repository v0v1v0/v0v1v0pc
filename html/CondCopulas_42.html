<div class="container">

<table style="width: 100%;"><tr>
<td>simpA.kendallReg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test of the simplifying assumption using the constancy
of conditional Kendall's tau</h2>

<h3>Description</h3>

<p>This function computes Kendall's regression, a regression-like
model for conditional Kendall's tau. More precisely, it fits the model
</p>
<p style="text-align: center;"><code class="reqn">\Lambda(\tau_{X_1, X_2 | Z = z}) = \sum_{j=1}^{p'} \beta_j \psi_j(z),</code>
</p>

<p>where <code class="reqn">\tau_{X_1, X_2 | Z = z}</code> is the conditional Kendall's tau
between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally to <code class="reqn">Z=z</code>,
<code class="reqn">\Lambda</code> is a function from <code class="reqn">]-1, 1]</code> to <code class="reqn">R</code>,
<code class="reqn">(\beta_1, \dots, \beta_p)</code> are unknown coefficients to be estimated
and <code class="reqn">\psi_1, \dots, \psi_{p'})</code> are a dictionary of functions.
Then, this function tests the assumption
</p>
<p style="text-align: center;"><code class="reqn">\beta_2 = \beta_3 = ... = \beta_{p'} = 0,</code>
</p>

<p>where the coefficient corresponding to the intercept is removed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simpA.kendallReg(
  X1,
  X2,
  Z,
  vectorZToEstimate = NULL,
  listPhi = list(z = function(z) {
     return(z)
 }),
  typeEstCKT = 4,
  h_kernel,
  Lambda = function(x) {
     return(x)
 },
  Lambda_deriv = function(x) {
     return(1)
 },
  Lambda_inv = function(x) {
     return(x)
 },
  lambda = NULL,
  h_lambda = h_kernel,
  Kfolds_lambda = 5,
  l_norm = 1
)

## S3 method for class 'simpA_kendallReg_test'
coef(object, ...)

## S3 method for class 'simpA_kendallReg_test'
vcov(object, ...)

## S3 method for class 'simpA_kendallReg_test'
print(x, ...)

## S3 method for class 'simpA_kendallReg_test'
plot(x, ylim = c(-1.5, 1.5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p>vector of observations of the first conditioned variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>vector of observations of the second conditioned variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>vector of observations of the conditioning variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectorZToEstimate</code></td>
<td>
<p>vector containing the points <code class="reqn">Z'_i</code>
to be used at which the conditional Kendall's tau should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listPhi</code></td>
<td>
<p>the list of transformations <code class="reqn">phi</code> to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeEstCKT</code></td>
<td>
<p>the type of estimation of the kernel-based estimation
of conditional Kendall's tau.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h_kernel</code></td>
<td>
<p>the bandwidth used for the kernel-based estimations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>the function to be applied on conditional Kendall's tau.
By default, the identity function is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda_deriv</code></td>
<td>
<p>the derivative of the function <code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda_inv</code></td>
<td>
<p>the inverse function of <code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the penalization parameter used for Kendall's regression.
By default, cross-validation is used to find the best value of <code>lambda</code>
if <code>length(listPhi) &gt; 1</code>. Otherwise <code>lambda = 0</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h_lambda</code></td>
<td>
<p>bandwidth used for the smooth cross-validation
in order to get a value for <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kfolds_lambda</code></td>
<td>
<p>the number of subsets used for the cross-validation
in order to get a value for <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l_norm</code></td>
<td>
<p>type of norm used for selection of the optimal lambda
by cross-validation. <code>l_norm=1</code> corresponds to the sum of
absolute values of differences between predicted and estimated
conditional Kendall's tau while <code>l_norm=2</code> corresponds to
the sum of squares of differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object, x</code></td>
<td>
<p>an <code>S3</code> object of class <code>simpA_kendallReg_test</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments, unused</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>graphical parameter, see plot</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>simpA.kendallReg</code> returns an <code>S3</code> object of
class <code>simpA_kendallReg_test</code>, containing
</p>

<ul>
<li> <p><code>statWn</code>: the value of the test statistic.
</p>
</li>
<li> <p><code>p_val</code>: the p-value of the test.
</p>
</li>
</ul>
<p><code>plot.simpA_kendallReg_test</code> returns (invisibly) a matrix with columns
<code>z</code>, <code>est_CKT_NP</code>, <code>asympt_se_np</code>, <code>est_CKT_NP_q025</code>,
<code>est_CKT_NP_q975</code>, <code>est_CKT_reg</code>, <code>asympt_se_reg</code>,
<code>est_CKT_reg_q025</code>, <code>est_CKT_reg_q975</code>.
The first column correspond to the grid of values of z. The next 4 columns
are the NP (kernel-based) estimator of conditional Kendall's tau, with its
standard error, and lower/upper confidence bands. The last 4 columns are the
equivalents for the estimator based on Kendall's regression.
</p>
<p><code>plot.simpA_kendallReg_test</code> plots the kernel-based estimator and its
confidence band (in red), and the estimator based on Kendall's regression
and its confidence band (in blue).
</p>
<p>Usually the confidence band for Kendall's regression is much tighter than the
pure non-parametric counterpart. This is because the parametric model is
sparser and the corresponding estimator converges faster (even without
penalization).
</p>
<p><code>print.simpA_kendallReg_test</code> has no return values and is only called
for its side effects.
</p>
<p>Function <code>coef.simpA_kendallReg_test</code> returns the matrix of coefficients
with standard errors, z values and p-values.
</p>
<p>Function <code>vcov.simpA_kendallReg_test</code> returns the (estimated)
variance-covariance matrix of the estimated coefficients.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2020).
On Kendallâ€™s regression.
Journal of Multivariate Analysis, 178, 104610.
(page 7)
<a href="https://doi.org/10.1016/j.jmva.2020.104610">doi:10.1016/j.jmva.2020.104610</a>
</p>


<h3>See Also</h3>

<p>The function to fit Kendall's regression:
<code>CKT.kendallReg.fit</code>.
</p>
<p>Other tests of the simplifying assumption:
</p>

<ul>
<li> <p><code>simpA.NP</code> in a nonparametric setting
</p>
</li>
<li> <p><code>simpA.param</code> in a (semi)parametric setting,
where the conditional copula belongs to a parametric family,
but the conditional margins are estimated arbitrarily through
kernel smoothing
</p>
</li>
<li>
<p> the counterparts of these tests in the discrete conditioning setting:
<code>bCond.simpA.CKT</code>
(test based on conditional Kendall's tau)
<code>bCond.simpA.param</code>
(test assuming a parametric form for the conditional copula)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">

# We simulate from a non-simplified conditional copula
set.seed(1)
N = 300
Z = runif(n = N, min = 0, max = 1)
conditionalTau = -0.9 + 1.8 * Z
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

result = simpA.kendallReg(
  X1, X2, Z, h_kernel = 0.03,
  listPhi = list(z = function(z){return(z)} ) )
print(result)
plot(result)
# Obtain matrix of coefficients, std err, z values and p values
coef(result)
# Obtain variance-covariance matrix of the coefficients
vcov(result)

result_morePhi = simpA.kendallReg(
   X1, X2, Z, h_kernel = 0.03,
   listPhi = list(
     z = function(z){return(z)},
     cos10z = function(z){return(cos(10 * z))},
     sin10z = function(z){return(sin(10 * z))},
     `1(z &lt;= 0.4)` = function(z){return(as.numeric(z &lt;= 0.4))},
     `1(z &lt;= 0.6)` = function(z){return(as.numeric(z &lt;= 0.6))}) )
print(result_morePhi)
plot(result_morePhi)

# We simulate from a simplified conditional copula
set.seed(1)
N = 300
Z = runif(n = N, min = 0, max = 1)
conditionalTau = -0.3
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

result = simpA.kendallReg(
   X1, X2, Z, h_kernel = 0.03,
   listPhi = list(
     z = function(z){return(z)},
     cos10z = function(z){return(cos(10 * z))},
     sin10z = function(z){return(sin(10 * z))},
     `1(z &lt;= 0.4)` = function(z){return(as.numeric(z &lt;= 0.4))},
     `1(z &lt;= 0.6)` = function(z){return(as.numeric(z &lt;= 0.6))}) )
print(result)
plot(result)


</code></pre>


</div>