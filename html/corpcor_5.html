<div class="container">

<table style="width: 100%;"><tr>
<td>powcor.shrink</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Computation of the Power of the Shrinkage Correlation Matrix</h2>

<h3>Description</h3>

<p>The function <code>powcor.shrink</code> efficiently computes the <code>alpha</code>-th power
of the shrinkage correlation matrix produced by <code>cor.shrink</code>. 
</p>
<p>For instance, this function may be used for fast computation of the (inverse)
square root of the  shrinkage correlation matrix (needed, e.g., for decorrelation).
</p>
<p><code>crossprod.powcor.shrink</code> efficiently computes <code class="reqn">R^{\alpha} y</code> without
actually computing the full matrix <code class="reqn">R^{\alpha}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">powcor.shrink(x, alpha, lambda, w, verbose=TRUE)
crossprod.powcor.shrink(x, y, alpha, lambda, w, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a matrix, the number of rows of y must be the same as the number of columns of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>exponent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the correlation shrinkage intensity (range 0-1).
If <code>lambda</code> is not specified (the default) it is estimated
using an analytic formula from Sch\"afer and Strimmer (2005) 
- see <code>cor.shrink</code>.  
For <code>lambda=0</code> the empirical correlations are recovered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>optional: weights for each data point - if not specified uniform weights are assumed
(<code>w = rep(1/n, n)</code> with <code>n = nrow(x)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>output status while computing (default: TRUE)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function employs a special matrix identity to speed up the computation of
the matrix power of the shrinkage correlation matrix (see Zuber and Strimmer 2009 for details).
</p>
<p>Apart from a scaling factor the shrinkage correlation matrix computed 
by <code>cor.shrink</code>  takes
on the form
</p>
<p style="text-align: center;"><code class="reqn">Z = I_p + V M V^T ,</code>
</p>
   
<p>where <code>V M V^T</code> is a multiple of the empirical correlation matrix.
Crucially, <code>Z</code> is a matrix of size <code>p</code> times <code>p</code>
whereas  <code>M</code> is a potentially much smaller matrix of size <code>m</code> times <code>m</code>,
where <code>m</code> is the rank of the empirical correlation matrix.  
</p>
<p>In order to calculate the <code>alpha</code>-th power of <code>Z</code>
the function uses the identity
</p>
<p style="text-align: center;"><code class="reqn">Z^\alpha = I_p - V (I_m -(I_m + M)^\alpha) V^T</code>
</p>

<p>requiring only the computation of the <code>alpha</code>-th power of the <code>m</code> by <code>m</code> matrix
<code class="reqn">I_m + M</code>.  This trick enables substantial computational savings especially when the number
of observations is much smaller than the number of variables.
</p>
<p>Note that the above identity is related but not identical to the Woodbury matrix
identity for inversion of a matrix.
For <code class="reqn">\alpha=-1</code> the above identity reduces to
</p>
<p style="text-align: center;"><code class="reqn">Z^{-1} = I_p - V (I_m -(I_m + M)^{-1}) V^T ,</code>
</p>

<p>whereas the Woodbury matrix identity equals
</p>
<p style="text-align: center;"><code class="reqn">Z^{-1} = I_p - V (I_m + M^{-1})^{-1} V^T .</code>
</p>



<h3>Value</h3>

<p><code>powcor.shrink</code> returns a matrix of the same size as the correlation matrix <code>R</code>
</p>
<p><code>crossprod.powcor.shrink</code> returns a matrix of the same size as <code>R</code> <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Verena Zuber, A. Pedro Duarte Silva, and Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Zuber, V., and K. Strimmer. 2009. Gene ranking and biomarker
discovery under correlation.  Bioinformatics <b>25</b>:2700-2707.
&lt;DOI:10.1093/bioinformatics/btp460&gt;
</p>
<p>Zuber, V.,  A. P. Duarte Silva, and K. Strimmer. 2012. A novel algorithm for 
simultaneous SNP selection in high-dimensional genome-wide association studies.
BMC Bioinformatics 13: 284
&lt;DOI:10.1186/1471-2105-13-284&gt;
</p>


<h3>See Also</h3>

<p><code>invcor.shrink</code>, <code>cor.shrink</code>, <code>mpower</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R"># load corpcor library
library("corpcor")

# generate data matrix
p = 500
n = 10
X = matrix(rnorm(n*p), nrow = n, ncol = p)

lambda = 0.23  # some arbitrary lambda

### computing the inverse ###
# slow
system.time(
  (W1 = solve(cor.shrink(X, lambda=lambda)))
)

# very fast
system.time(
  (W2 = powcor.shrink(X, alpha=-1, lambda=lambda))
)

# no difference
sum((W1-W2)^2)

### computing the square root ###

system.time(
  (W1 = mpower(cor.shrink(X, lambda=lambda), alpha=0.5))
)

# very fast
system.time(
  (W2 = powcor.shrink(X, alpha=0.5, lambda=lambda))
)

# no difference
sum((W1-W2)^2)


### computing an arbitrary power (alpha=1.23) ###

system.time(
  (W1 = mpower(cor.shrink(X, lambda=lambda), alpha=1.23))
)

# very fast
system.time(
  (W2 = powcor.shrink(X, alpha=1.23, lambda=lambda))
)

# no difference
sum((W1-W2)^2)


### fast computation of cross product

y = rnorm(p)

system.time(
  (CP1 = crossprod(powcor.shrink(X, alpha=1.23, lambda=lambda), y))
)

system.time(
  (CP2 = crossprod.powcor.shrink(X, y, alpha=1.23, lambda=lambda))
)

# no difference
sum((CP1-CP2)^2)

</code></pre>


</div>