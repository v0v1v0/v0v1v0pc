<div class="container">

<table style="width: 100%;"><tr>
<td>bs_ciuupi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the the functions <code class="reqn">b</code> and <code class="reqn">s</code>
that specify the CIUUPI for all possible
values of <code class="reqn">\sigma</code> and the observed response vector</h2>

<h3>Description</h3>

<p>Chooses the positive number <code class="reqn">d</code> and the positive integer <code class="reqn">q</code>, sets
<code class="reqn">h=d/q</code>, and then computes the
<code class="reqn">(2q-1)</code>-vector
<code class="reqn">\big(b(h),...,b((q-1)h),
s(0),s(h)...,s((q-1)h)\big)</code>
that determines, via cubic spline interpolation, the functions
<code class="reqn">b</code> and <code class="reqn">s</code> which specify
the confidence interval for <code class="reqn">\theta</code>
that utilizes the uncertain prior information (CIUUPI),
for all possible values of <code class="reqn">\sigma</code> and the observed response vector.
To an excellent approximation, this confidence interval
has minimum coverage probability
<code class="reqn">1-\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bs_ciuupi(alpha, rho, natural = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The desired minimum coverage probability
is <code class="reqn">1-\alpha</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>The known correlation <code class="reqn">\rho</code> between
<code class="reqn">\widehat{\theta}</code> and <code class="reqn">\widehat{\tau}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>natural</code></td>
<td>
<p>Equal to 1 (default) if the functions <code class="reqn">b</code>
and <code class="reqn">s</code> are specified by natural cubic spline interpolation
or 0 if these functions are specified by clamped cubic
spline interpolation in an interval <code class="reqn">[-d, d]</code>, where <code class="reqn">d</code>
is computed by <code>bs_ciuupi</code> using a specified
function of
<code>alpha</code> and <code>rho</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose that </p>
<p style="text-align: center;"><code class="reqn">y = X \beta + \varepsilon</code>
</p>
<p> where <code class="reqn">y</code>
is a random <code class="reqn">n</code>-vector of
responses, <code class="reqn">X</code> is a known <code class="reqn">n</code> by <code class="reqn">p</code> matrix
with linearly
independent columns, <code class="reqn">\beta</code> is an unknown parameter
<code class="reqn">p</code>-vector and
<code class="reqn">\varepsilon</code> is the random error with components that are iid normally distributed
with zero mean and known variance <code class="reqn">\sigma^2</code>.
The parameter of interest is
<code class="reqn">\theta = a^{\top} \beta</code>.
Also let <code class="reqn">\tau = c^{\top}\beta -t</code>, where <code class="reqn">a</code>
and <code class="reqn">c</code> are specified linearly independent
vectors and <code class="reqn">t</code> is a specified number.
The uncertain prior information is that <code class="reqn">\tau = 0</code>.
</p>
<p>Let <code>rho</code> denote the known
correlation between the <code class="reqn">\widehat{\theta}</code> and <code class="reqn">\widehat{\tau}</code>.
We can compute <code>rho</code>
from given values of <code class="reqn">a</code>, <code class="reqn">c</code> and <code class="reqn">X</code>
using the function <code>acX_to_rho</code>.
</p>
<p>The confidence interval for <code class="reqn">\theta</code>,
with minimum coverage probability
1<code class="reqn">-</code><code>alpha</code>, that utilizes the uncertain prior
information that
<code class="reqn">\tau = </code> 0 belongs to a class of confidence
intervals indexed
by the functions <code class="reqn">b</code> and <code class="reqn">s</code>.
The function <code class="reqn">b</code> is an odd continuous function and
the function <code class="reqn">s</code> is an even
continuous function. In addition, <code class="reqn">b(x)=0</code> and
<code class="reqn">s(x)</code> is equal to the
1<code class="reqn">-</code><code>alpha</code><code class="reqn">/2</code>
quantile of the
standard normal distribution for all <code class="reqn">|x| \ge d</code>, where
<code class="reqn">d</code> is a given positive number.
Extensive numerical explorations
have been used to find a formula (in terms of
<code>alpha</code> and <code>rho</code>) for a 'goldilocks'
value of <code class="reqn">d</code> that is neither too large nor too small.
Then let <code class="reqn">q</code>=ceiling(<code class="reqn">d</code>/0.75) and <code class="reqn">h=d/q</code>.
The values of the functions <code class="reqn">b</code> and <code class="reqn">s</code> in
the interval <code class="reqn">[-d,d]</code>
are specified by the <code class="reqn">(2q-1)</code>-vector
</p>
<p><code class="reqn">\big(b(h),...,b((q-1)h), s(0),s(h)...,s((q-1)h) \big)</code>.
</p>
<p>The values of <code class="reqn">b(kh)</code> and <code class="reqn">s(kh)</code> for <code class="reqn">k=-q,...,q</code> are
deduced from this vector using the assumptions made about
the functions <code class="reqn">b</code> and <code class="reqn">s</code>.
The values of <code class="reqn">b(x)</code> and <code class="reqn">s(x)</code> for any <code class="reqn">x</code> in the interval
<code class="reqn">[-d, d]</code>
are then found using cube spline interpolation using the
values of <code class="reqn">b(kh)</code> and <code class="reqn">s(kh)</code> for <code class="reqn">k=-q,...,q</code>.
For <code>natural</code>=1 (default) this is 'natural' cubic
spline interpolation and for <code>natural</code>=0 this is
'clamped' cubic spline interpolation.
</p>
<p>The vector <code class="reqn">\big(b(h),...,b((q-1)h), s(0),s(h)...,s((q-1)h)\big)</code>
is found by numerical nonlinear constrained optimization
so that the confidence interval has minimum
coverage probability 1<code class="reqn">-</code><code>alpha</code> and utilizes
the uncertain prior information
through its desirable expected length properties.
This optimization is performed using the
<code>slsqp</code> function
in the <code>nloptr</code> package.
</p>


<h3>Value</h3>

<p>A list with the following components.
</p>
<p>alpha, rho, natural: the inputs
</p>
<p>d: a 'goldilocks' value of <code class="reqn">d</code> that is not too large
and not too small
</p>
<p>n.ints: number of equal-length consecutive
intervals whose union is <code class="reqn">[0,d]</code>,
this is the same as <code class="reqn">q</code>
</p>
<p>lambda.star: the computed value of <code class="reqn">\lambda^*</code>
</p>
<p>bsvec: the vector
<code class="reqn">\big(b(h),...,b((q-1)h), s(0),s(h)...,s((q-1)h) \big)</code> that determines
the functions <code class="reqn">b</code> and <code class="reqn">s</code> that specify the CIUUPI for all possible
values of <code class="reqn">\sigma</code> and observed response vector
</p>
<p>comp.time: the computation time in seconds
</p>


<h3>Examples</h3>

<pre><code class="language-R">alpha &lt;- 0.05
rho &lt;- - 1 / sqrt(2)
bs.list &lt;- bs_ciuupi(alpha, rho)


</code></pre>


</div>