<div class="container">

<table style="width: 100%;"><tr>
<td>prepareData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prepare data for modeling in one step (convenience method)</h2>

<h3>Description</h3>

<p>This is a convenience method to either load the inbuilt sample dataset, or
to provide a data frame with the variables "raw" (for the raw scores) and "group"
The function ranks the data within groups, computes norm values, powers of the norm
scores and interactions. Afterwards, you can use these preprocessed data to
determine the best fitting model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prepareData(
  data = NULL,
  group = "group",
  raw = "raw",
  age = "group",
  k = 4,
  t = NULL,
  width = NA,
  weights = NULL,
  scale = "T",
  descend = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data.frame with a grouping variable named 'group' and a raw score variable
named 'raw'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>grouping variable in the data, e. g. age groups, grades ...
Setting group = FALSE deactivates modeling in dependence of age. Use this in case you do want
conventional norm tables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>the raw scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>age</code></td>
<td>
<p>the continuous explanatory variable; by default set to "group"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The power parameter, default = 4</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>the age power parameter (default NULL). If not set, cNORM automatically uses k. The age power parameter
can be used to specify the k to produce rectangular matrices and specify the course of scores per  independently from k</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>if a width is provided, the function switches to rankBySlidingWindow to determine the
observed raw scores, otherwise, ranking is done by group (default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Vector or variable name in the dataset with weights for each individual case. It can be used
to compensate for moderate imbalances due to insufficient norm data stratification. Weights should be numerical
and positive. Please use the 'computeWeights' function for this purpose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>type of norm scale, either T (default), IQ, z or percentile (= no
transformation); a double vector with the mean and standard deviation can as well,
be provided f. e. c(10, 3) for Wechsler scale index point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>descend</code></td>
<td>
<p>ranking order (default descent = FALSE): inverses the
ranking order with higher raw scores getting lower norm scores; relevant
for example when norming error scores, where lower scores mean higher
performance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>set to TRUE to suppress messages</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The functions <code>rankBySlidingWindow</code>, <code>rankByGroup</code>, <code>bestModel</code>,
<code>computePowers</code> and <code>prepareData</code> are usually not called directly, but accessed
through other functions like <code>cnorm</code>.
</p>


<h3>Value</h3>

<p>data frame including the norm scores, powers and interactions of the norm score and
grouping variable
</p>


<h3>See Also</h3>

<p>Other prepare: 
<code>computePowers()</code>,
<code>rankByGroup()</code>,
<code>rankBySlidingWindow()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># conducts ranking and computation of powers and interactions with the 'elfe' dataset
data.elfe &lt;- prepareData(elfe)

# use vectors instead of data frame
data.elfe &lt;- prepareData(raw=elfe$raw, group=elfe$group)

# variable names can be specified as well, here with the BMI data included in the package
## Not run: 
data.bmi &lt;- prepareData(CDC, group = "group", raw = "bmi", age = "age")

## End(Not run)

# modeling with only one group with the 'elfe' dataset as an example
# this results in conventional norming
data.elfe2 &lt;- prepareData(data = elfe, group = FALSE)
m &lt;- bestModel(data.elfe2)
</code></pre>


</div>