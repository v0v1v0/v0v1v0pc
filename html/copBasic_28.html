<div class="container">

<table style="width: 100%;"><tr>
<td>densityCOPplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Contour Density Plot of a Copula</h2>

<h3>Description</h3>

<p>Generate a <em>contour density plot</em> after the advocation of Joe (2014, pp. 9–15). Such graphics are plots of <em>scaled copula densities</em> (<code class="reqn">c^\star(u,v)</code>, bivariate herein) that are copula densities scaled to the standard normal distribution <code class="reqn">\sim</code> N(0,1) margins. Joe (2014) repeatedly emphasizes such plots in contrast to the uniform distribution <code class="reqn">\sim</code> U(0,1) margins. Nelsen (2006) does not discuss such scaling but seemingly Nelsen's objectives for his book were somewhat different.
</p>
<p>The density of copula <code class="reqn">\mathbf{C}(u,v)</code> is numerically estimated by
</p>
<p style="text-align: center;"><code class="reqn">c(u,v) = \bigl[\mathbf{C}(u_2,v_2) - \mathbf{C}(u_2,v_1) - \mathbf{C}(u_1,v_2) + \mathbf{C}(u_1,v_1)\bigr]\, /\, \bigl[\Delta(uv)\times\Delta(uv)\bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">c(u,v) \ge 0</code> (see Nelsen, 2006, p. 10; <code>densityCOP</code>). Given a numerically estimated quantity <code class="reqn">c^\star(u,v) = c(u,v)\times\phi(\Phi^{(-1)}(u))\times\phi(\Phi^{(-1)}(v))</code> for copula density <code class="reqn">c(u,v)</code>, a grid of the <code class="reqn">c^\star(u,v)</code> values can be contoured by the <code>contour()</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.  The density function of the N(0,1) is <code class="reqn">\phi(z)</code> for standard normal variate <code class="reqn">z</code> and the quantile function of the N(0,1) is <code class="reqn">\Phi^{(-1)}(t)</code> for nonexceedance probability <code class="reqn">t</code>.
</p>
<p>A grid (matrix) of <code class="reqn">c(u,v)</code> or <code class="reqn">c^\star(u,v)</code> is defined for sequence of <code class="reqn">u</code> and <code class="reqn">v</code> probabilities for which each sequence has equal steps that are equal to <code class="reqn">\Delta(uv)</code>. This function has as focus on plotting of the contour lines of <code class="reqn">c^\star(u,v)</code> but the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>matrix</code> of either <code class="reqn">c(u,v)</code> or <code class="reqn">c^\star(u,v)</code> can be requested on return. For either matrix, the <code>colnames()</code> and <code>rownames()</code> (the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions) are set equal to the sequence of <code class="reqn">u</code> and <code class="reqn">v</code>, respectively. Neither the column or row names are set to the standard normal variates for the matrix of <code class="reqn">c^\star(u,v)</code>, the names remain in terms of nonexceedance probability.
</p>
<p>For plotting and other uses of normal scores of data, Joe (2014, p. 245) advocates that one should use the plotting position formula <code class="reqn">u_i = (i-1/2)/n</code> (<em>Hazen plotting position</em>) for normal scores <code class="reqn">z_i = \Phi^{-1}(u_i)</code> in preference to <code class="reqn">i/(n+1)</code> (<em>Weibull plotting position</em>) because <code class="reqn">n^{-1}\sum_{i=1}^{n} z^2_i</code> is closer to unity. Other examples of Joe's advocation for the Hazen plotting positions are available (Joe, 2014, pp. 9, 17, 245, 247–248).
</p>


<h3>Usage</h3>

<pre><code class="language-R">densityCOPplot(cop=NULL, para=NULL, deluv=0.002,
               getmatrix=c("none", "cdenzz", "cden"), n=0,
               ploton=TRUE, snv=TRUE, origins=TRUE,
               contour.col=1, contour.lwd=1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deluv</code></td>
<td>
<p>The change in the sequences <code class="reqn">\{u, v\} \mapsto \delta, \ldots, 1-\delta; \delta = \Delta(uv)</code> probabilities;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getmatrix</code></td>
<td>
<p>A trigger on whether the density matrix is to be returned. The option <code>cdenzz</code> returns the density scaled by the two standard normal densities (<code class="reqn">c^\star(u,v)</code>), whereas the option <code>cden</code> returns simply the copula density (<code class="reqn">c(u,v)</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ploton</code></td>
<td>
<p>A logical to toggle on the plot;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snv</code></td>
<td>
<p>A logical to toggle standard normal variates for the axes;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origins</code></td>
<td>
<p>A logical to plot the origin lines, if and only if <code>snv</code> is true;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour.col</code></td>
<td>
<p>The color of the contour lines, which corresponds to the <code>col</code> argument of the <code>contour</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour.lwd</code></td>
<td>
<p>The width of the contour lines, which corresponds to the <code>lwd</code> argument of the <code>contour</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>An optional sample size for which simulation of this many values from the copula will be made by <code>simCOP</code> and drawn; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copula function and to the <code>contour</code> function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> (<em>e.g.</em> to turn off labeling of contours add <code>drawlabels=FALSE</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This is a high-level function used for its side effects; an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>matrix</code> can be triggered, however, as a returned value.
</p>


<h3>Note</h3>

<p>Joe (2014, p. 244) says “if [density] plots show multimodality, then multivariate techniques of mixture models, cluster analysis[,] and nonparametric functional data analysis might be more appropriate” than relatively straightforward parametric copula models.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Joe, H., 2014, Dependence modeling with copulas: Boca Raton, CRC Press, 462 p.
</p>
<p>Nelsen, R.B., 2006, An introduction to copulas: New York, Springer, 269 p.
</p>


<h3>See Also</h3>

<p><code>simCOP</code>, <code>densityCOP</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Joe (2014, p. 5) names rMTCJ = reflected Mardia-Takahasi-Cook-Johnson copula
"rMTCJ" &lt;- function(u, v, para, ...) {
   u + v - 1 + ((1-u)^(-para) + (1-v)^(-para) - 1)^(-1/para)
} # Survival Copula ("reflected" in Joe's terms)
densityCOPplot(cop=rMTCJ, para=1.0760, n=9000, snv=TRUE)
# The density plot matches that shown by Joe (2014, p. 11, fig. 1.2, lower left plot)
# for a Spearman Rho equaling 0.5. Let us compute then Rho:
rhoCOP(cop=rMTCJ, para=1.076075) # 0.4999958

# Now let us get really wild with a composition with TWO modes!
# This example also proves that the grid orientation is consistent with respect
# to the orientation of the simulations.
para &lt;- list(alpha=0.15, beta=0.90, kappa=0.06, gamma=0.96,
             cop1=GHcop, cop2=PLACKETTcop, para1=5.5, para2=0.07)
densityCOPplot(cop=composite2COP, para=para, n=9000)

# Now, let us hack back to a contour density plot with U(0,1) and not N(0,1) margins
# just so show that capability exists, but emphasis of densityCOPplot is clearly
# on Joe's advocation, because it does not have a default trigger to use U(0,1) margins.
set.seed(12)
H &lt;- densityCOPplot(cop=PLACKETTcop, para=41.25, getmatrix="cdenzz", n=1000, snv=FALSE)
set.seed(12)
UV &lt;- simCOP(cop=PLACKETTcop, para=41.25, n=1000, col=8, snv=FALSE)
U  &lt;- as.numeric(colnames(H)); V &lt;- as.numeric(rownames(H))
contour(x=U, y=V, z=t(H), lwd=1.5, cex=2, add=TRUE, col=2) #
## End(Not run)

## Not run: 
set.seed(12)
UV &lt;- rCOP(400,  cop=PSP, pch=16, col=8, n=400)
CL &lt;- mleCOP(UV, cop=CLcop,   interval=c(1  , 20))
JO &lt;- mleCOP(UV, cop=JOcopB5, interval=c(0.1, 20))
PL &lt;- mleCOP(UV, cop=PLcop,   interval=c(0.1, 20))

AICs &lt;- c(CL$AIC, JO$AIC, PL$AIC)
names(AICs) &lt;- c("Clayton", "Joe(B5)", "Plackett")
print(round(AICs, digits=2))
#  Clayton    Joe(B5)   Plackett
#  -156.77     -36.91    -118.38
# So, we conclude Clayton must be the best fit of the three.

plot(qnorm(UV[,1]), qnorm(UV[,2]), pch=16, col=8, cex=0.5,
        xlab="Standard normal variate of U", xlim=c(-3,3),
        ylab="Standard normal variate of V", ylim=c(-3,3))
densityCOPplot(cop=PSP, contour.col=grey(0.5), lty=2,
               contour.lwd=3.5, ploton=FALSE, snv=TRUE)
densityCOPplot(cop=CLcop,     para=CL$para,
               contour.col=2,   ploton=FALSE, snv=TRUE)
densityCOPplot(cop=JOcopB5,   para=JO$para,
               contour.col=3,   ploton=FALSE, snv=TRUE)
densityCOPplot(cop=PLcop,     para=PL$para,
               contour.col=4,   ploton=FALSE, snv=TRUE) #
## End(Not run)
</code></pre>


</div>