<div class="container">

<table style="width: 100%;"><tr>
<td>fbetween-fwithin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast Between (Averaging) and (Quasi-)Within (Centering) Transformations
</h2>

<h3>Description</h3>

<p><code>fbetween</code> and <code>fwithin</code> are S3 generics to efficiently obtain between-transformed (averaged) or (quasi-)within-transformed (demeaned) data. These operations can be performed groupwise and/or weighted. <code>B</code> and <code>W</code> are wrappers around <code>fbetween</code> and <code>fwithin</code> representing the 'between-operator' and the 'within-operator'.
</p>
<p>(<code>B</code> / <code>W</code> provide more flexibility than <code>fbetween</code> / <code>fwithin</code> when applied to data frames (i.e.  column subsetting, formula input, auto-renaming and id-variable-preservation capabilities...), but are otherwise identical.)
</p>



<h3>Usage</h3>

<pre><code class="language-R">fbetween(x, ...)
 fwithin(x, ...)
       B(x, ...)
       W(x, ...)

## Default S3 method:
fbetween(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## Default S3 method:
fwithin(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## Default S3 method:
B(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## Default S3 method:
W(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)

## S3 method for class 'matrix'
fbetween(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'matrix'
fwithin(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'matrix'
B(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, stub = .op[["stub"]], ...)
## S3 method for class 'matrix'
W(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1,
  stub = .op[["stub"]], ...)

## S3 method for class 'data.frame'
fbetween(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'data.frame'
fwithin(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'data.frame'
B(x, by = NULL, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  fill = FALSE, stub = .op[["stub"]], keep.by = TRUE, keep.w = TRUE, ...)
## S3 method for class 'data.frame'
W(x, by = NULL, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  mean = 0, theta = 1, stub = .op[["stub"]], keep.by = TRUE, keep.w = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fbetween(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'pseries'
fwithin(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'pseries'
B(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'pseries'
W(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)

## S3 method for class 'pdata.frame'
fbetween(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'pdata.frame'
fwithin(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'pdata.frame'
B(x, effect = 1L, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  fill = FALSE, stub = .op[["stub"]], keep.ids = TRUE, keep.w = TRUE, ...)
## S3 method for class 'pdata.frame'
W(x, effect = 1L, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  mean = 0, theta = 1, stub = .op[["stub"]], keep.ids = TRUE, keep.w = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fbetween(x, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE,
         keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
fwithin(x, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1,
        keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
B(x, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE,
  stub = .op[["stub"]], keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
W(x, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1,
  stub = .op[["stub"]], keep.group_vars = TRUE, keep.w = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector, matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a factor, <code>GRP</code> object, or atomic vector / list of vectors (internally grouped with <code>group</code>) used to group <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p><em>B and W data.frame method</em>: Same as g, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a numeric vector of (non-negative) weights. <code>B</code>/<code>W</code> data frame and <code>pdata.frame</code> methods also allow a one-sided formula i.e. <code>~ weightcol</code>. The <code>grouped_df</code> (<em>dplyr</em>) method supports lazy-evaluation. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p><em>B/W (p)data.frame methods</em>: Select columns to scale using a function, column names, indices or a logical vector. Default: All numeric columns. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code> and <code>w</code> when computing averages. If <code>na.rm = FALSE</code> and a <code>NA</code> or <code>NaN</code> is encountered, the average for that group will be <code>NA</code>, and all data points belonging to that group in the output vector will also be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect</code></td>
<td>
<p><em>plm</em> methods: Select which panel identifier should be used as grouping variable. 1L takes the first variable in the index, 2L the second etc. Index variables can also be called by name using a character string. If more than one variable is supplied, the corresponding index-factors are interacted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stub</code></td>
<td>
<p>character. A prefix/stub to add to the names of all transformed columns. <code>TRUE</code> (default) uses <code>"W."/"B."</code>, <code>FALSE</code> will not rename columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p><em>option to <code>fbetween</code>/<code>B</code></em>: Logical. <code>TRUE</code> will overwrite missing values in <code>x</code> with the respective average. By default missing values in <code>x</code> are preserved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p><em>option to <code>fwithin</code>/<code>W</code></em>: The mean to center on, default is 0, but a different mean can be supplied and will be added to the data after the centering is performed. A special option when performing grouped centering is <code>mean = "overall.mean"</code>. In that case the overall mean of the data will be added after subtracting out group means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p><em>option to <code>fwithin</code>/<code>W</code></em>: Double. An optional scalar parameter for quasi-demeaning i.e. <code>x - theta * xi.</code>. This is useful for variance components ('random-effects') estimators. see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.by, keep.ids, keep.group_vars</code></td>
<td>
<p><em>B and W data.frame, pdata.frame and grouped_df methods</em>: Logical. Retain grouping / panel-identifier columns in the output. For data frames this only works if grouping variables were passed in a formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.w</code></td>
<td>
<p><em>B and W data.frame, pdata.frame and grouped_df methods</em>: Logical. Retain column containing the weights in the output. Only works if <code>w</code> is passed as formula / lazy-expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Without groups, <code>fbetween</code>/<code>B</code> replaces all data points in <code>x</code> with their mean or weighted mean (if <code>w</code> is supplied). Similarly <code>fwithin/W</code> subtracts the (weighted) mean from all data points i.e. centers the data on the mean. <br></p>
<p>With groups supplied to <code>g</code>, the replacement / centering performed by <code>fbetween/B</code> | <code>fwithin/W</code> becomes groupwise. In terms of panel data notation: If <code>x</code> is a vector in such a panel dataset, <code>xit</code> denotes a single data-point belonging to group <code>i</code> in time-period <code>t</code> (<code>t</code> need not be a time-period). Then <code>xi.</code> denotes <code>x</code>, averaged over <code>t</code>. <code>fbetween</code>/<code>B</code> now returns <code>xi.</code> and <code>fwithin</code>/<code>W</code> returns <code>x - xi.</code>. Thus for any data <code>x</code> and any grouping vector <code>g</code>: <code>B(x,g) + W(x,g) = xi. + x - xi. = x</code>. In terms of variance, <code>fbetween/B</code> only retains the variance between group averages, while <code>fwithin</code>/<code>W</code>, by subtracting out group means, only retains the variance within those groups. <br></p>
<p>The data replacement performed by <code>fbetween</code>/<code>B</code> can keep (default) or overwrite missing values (option <code>fill = TRUE</code>) in <code>x</code>. <code>fwithin/W</code> can center data simply (default), or add back a mean after centering (option <code>mean = value</code>), or add the overall mean in groupwise computations (option <code>mean = "overall.mean"</code>). Let <code>x..</code> denote the overall mean of <code>x</code>, then <code>fwithin</code>/<code>W</code> with <code>mean = "overall.mean"</code> returns <code>x - xi. + x..</code> instead of <code>x - xi.</code>. This is useful to get rid of group-differences but preserve the overall level of the data. In regression analysis, centering with <code>mean = "overall.mean"</code> will only change the constant term. See Examples.
</p>
<p>If <code>theta != 1</code>, <code>fwithin</code>/<code>W</code> performs quasi-demeaning <code>x - theta * xi.</code>. If <code>mean = "overall.mean"</code>, <code>x - theta * xi. + theta * x..</code> is returned, so that the mean of the partially demeaned data is still equal to the overall data mean <code>x..</code>. A numeric value passed to <code>mean</code> will simply be added back to the quasi-demeaned data i.e. <code>x - theta * xi. + mean</code>.
</p>
<p>Now in the case of a linear panel model <code class="reqn">y_{it} = \beta_0 + \beta_1 X_{it} + u_{it}</code> with <code class="reqn">u_{it} = \alpha_i + \epsilon_{it}</code>. If <code class="reqn">\alpha_i \neq \alpha = const.</code> (there exists individual heterogeneity), then pooled OLS is at least inefficient and inference on <code class="reqn">\beta_1</code> is invalid. If <code class="reqn">E[\alpha_i|X_{it}] = 0</code> (mean independence of individual heterogeneity <code class="reqn">\alpha_i</code>), the variance components or 'random-effects' estimator provides an asymptotically efficient FGLS solution by estimating a transformed model <code class="reqn">y_{it}-\theta y_{i.}  = \beta_0 + \beta_1 (X_{it} - \theta X_{i.}) + (u_{it} - \theta u_{i.}</code>), where <code class="reqn">\theta = 1 - \frac{\sigma_\alpha}{\sqrt(\sigma^2_\alpha + T \sigma^2_\epsilon)}</code>. An estimate of <code class="reqn">\theta</code> can be obtained from the an estimate of <code class="reqn">\hat{u}_{it}</code> (the residuals from the pooled model). If <code class="reqn">E[\alpha_i|X_{it}] \neq 0</code>, pooled OLS is biased and inconsistent, and taking <code class="reqn">\theta = 1</code> gives an unbiased and consistent fixed-effects estimator of <code class="reqn">\beta_1</code>. See Examples.
</p>


<h3>Value</h3>

<p><code>fbetween</code>/<code>B</code> returns <code>x</code> with every element replaced by its (groupwise) mean (<code>xi.</code>). Missing values are preserved if <code>fill = FALSE</code> (the default). <code>fwithin/W</code> returns <code>x</code> where every element was subtracted its (groupwise) mean (<code>x - theta * xi. + mean</code> or, if <code>mean = "overall.mean"</code>, <code>x - theta * xi. + theta * x..</code>). See Details.
</p>


<h3>References</h3>

<p>Mundlak, Yair. 1978. On the Pooling of Time Series and Cross Section Data. <em>Econometrica</em> 46 (1): 69-85.
</p>


<h3>See Also</h3>

<p><code>fhdbetween/HDB and fhdwithin/HDW</code>, <code>fscale/STD</code>, <code>TRA</code>, Data Transformations, Collapse Overview
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simple centering and averaging
head(fbetween(mtcars))
head(B(mtcars))
head(fwithin(mtcars))
head(W(mtcars))
all.equal(fbetween(mtcars) + fwithin(mtcars), mtcars)

## Groupwise centering and averaging
head(fbetween(mtcars, mtcars$cyl))
head(fwithin(mtcars, mtcars$cyl))
all.equal(fbetween(mtcars, mtcars$cyl) + fwithin(mtcars, mtcars$cyl), mtcars)

head(W(wlddev, ~ iso3c, cols = 9:13))    # Center the 5 series in this dataset by country
head(cbind(get_vars(wlddev,"iso3c"),     # Same thing done manually using fwithin..
      add_stub(fwithin(get_vars(wlddev,9:13), wlddev$iso3c), "W.")))

## Using B() and W() for fixed-effects regressions:

# Several ways of running the same regression with cyl-fixed effects
lm(W(mpg,cyl) ~ W(carb,cyl), data = mtcars)                     # Centering each individually
lm(mpg ~ carb, data = W(mtcars, ~ cyl, stub = FALSE))           # Centering the entire data
lm(mpg ~ carb, data = W(mtcars, ~ cyl, stub = FALSE,            # Here only the intercept changes
                        mean = "overall.mean"))
lm(mpg ~ carb + B(carb,cyl), data = mtcars)                     # Procedure suggested by
# ..Mundlak (1978) - partialling out group averages amounts to the same as demeaning the data
plm::plm(mpg ~ carb, mtcars, index = "cyl", model = "within")   # "Proof"..

# This takes the interaction of cyl, vs and am as fixed effects
lm(W(mpg) ~ W(carb), data = iby(mtcars, id = finteraction(cyl, vs, am)))
lm(mpg ~ carb, data = W(mtcars, ~ cyl + vs + am, stub = FALSE))
lm(mpg ~ carb + B(carb,list(cyl,vs,am)), data = mtcars)

# Now with cyl fixed effects weighted by hp:
lm(W(mpg,cyl,hp) ~ W(carb,cyl,hp), data = mtcars)
lm(mpg ~ carb, data = W(mtcars, ~ cyl, ~ hp, stub = FALSE))
lm(mpg ~ carb + B(carb,cyl,hp), data = mtcars)       # WRONG ! Gives a different coefficient!!

## Manual variance components (random-effects) estimation
res &lt;- HDW(mtcars, mpg ~ carb)[[1]]  # Get residuals from pooled OLS
sig2_u &lt;- fvar(res)
sig2_e &lt;- fvar(fwithin(res, mtcars$cyl))
T &lt;- length(res) / fndistinct(mtcars$cyl)
sig2_alpha &lt;- sig2_u - sig2_e
theta &lt;- 1 - sqrt(sig2_alpha) / sqrt(sig2_alpha + T * sig2_e)
lm(mpg ~ carb, data = W(mtcars, ~ cyl, theta = theta, mean = "overall.mean", stub = FALSE))

# A slightly different method to obtain theta...
plm::plm(mpg ~ carb, mtcars, index = "cyl", model = "random")
</code></pre>


</div>