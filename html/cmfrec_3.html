<div class="container">

<table style="width: 100%;"><tr>
<td>CMF.from.model.matrices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a CMF model object from fitted matrices</h2>

<h3>Description</h3>

<p>Creates a 'CMF' or 'CMF_implicit' model object based on fitted
latent factor matrices, which might have been obtained from a different software.
For example, the package 'recosystem' has functionality for obtaining these matrices,
but not for producing recommendations or latent factors for new users, for which
this function can come in handy as it will turn such model into a 'CMF' model which
provides all such functionality.
</p>
<p>This is only available for models without side information, and does not support
user/item mappings.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CMF.from.model.matrices(
  A,
  B,
  glob_mean = 0,
  implicit = FALSE,
  precompute = TRUE,
  user_bias = NULL,
  item_bias = NULL,
  lambda = 10,
  scale_lam = FALSE,
  l1_lambda = 0,
  nonneg = FALSE,
  NA_as_zero = FALSE,
  scaling_biasA = NULL,
  scaling_biasB = NULL,
  apply_log_transf = FALSE,
  alpha = 1,
  nthreads = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The obtained user factors (numeric matrix). Dimension is [k, n_users].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>The obtained item factors (numeric matrix). Dimension is [k, n_items].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob_mean</code></td>
<td>
<p>The obtained global mean, if the model is for explicit feedback
and underwent centering. If passing zero, will assume that the values are not to
be centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>implicit</code></td>
<td>
<p>Whether this is an implicit-feedback model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precompute</code></td>
<td>
<p>Whether to generate pre-computed matrices which can help to speed
up computations on new data (see fit_models for more details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_bias</code></td>
<td>
<p>The obtained user biases (numeric vector).
If passing 'NULL', will assume that the model did not include user biases.
Dimension is [n_users].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item_bias</code></td>
<td>
<p>The obtained item biases (numeric vector).
If passing 'NULL', will assume that the model did not include item biases.
Dimension is [n_item].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Regularization parameter for the L2 norm of the model matrices
(see fit_models for more details). Can pass different parameters for each.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_lam</code></td>
<td>
<p>In the explicit-feedback models, whether to scale the regularization
parameter according to the number of entries. This should always be assumed 'TRUE'
for models that are fit through stochastic procedures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l1_lambda</code></td>
<td>
<p>Regularization parameter for the L1 norm of the model matrices.
Same format as for 'lambda'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonneg</code></td>
<td>
<p>Whether the model matrices should be constrained to be non-negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NA_as_zero</code></td>
<td>
<p>When passing sparse matrices, whether to take missing entries as
zero (counting them towards the optimization objective), or to ignore them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling_biasA</code></td>
<td>
<p>If passing it, will assume that the model uses the option
'scale_bias_const=TRUE', and will use this number as scaling
for the regularization of the user biases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling_biasB</code></td>
<td>
<p>If passing it, will assume that the model uses the option
'scale_bias_const=TRUE', and will use this number as scaling
for the regularization of the item biases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apply_log_transf</code></td>
<td>
<p>If passing 'implicit=TRUE', whether to apply a logarithm
transformation on the values of 'X'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>If passing 'implicit=TRUE', multiplier to apply to the confidence scores
given by 'X'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>Number of parallel threads to use for further computations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A 'CMF' (if passing 'implicit=FALSE') or 'CMF_implicit' (if passing
'implicit=TRUE') model object without side information, for which the usual
prediction functions such as topN and topN_new can be used as if
it had been fitted through this software.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example 'adopting' a model from 'recosystem'
library(cmfrec)
library(recosystem)
library(recommenderlab)
library(MatrixExtra)

### Fitting a model with 'recosystem'
data("MovieLense")
X &lt;- as.coo.matrix(MovieLense@data)
r &lt;- Reco()
r$train(data_matrix(X),
        out_model = NULL,
        opts = list(dim=10, costp_l2=0.1, costq_l2=0.1,
                    verbose=FALSE, nthread=1))
matrices &lt;- r$output(out_memory(), out_memory())
glob_mean &lt;- as.numeric(r$model$matrices$b)

### Now converting it to CMF
model &lt;- CMF.from.model.matrices(
    A=t(matrices$P), B=t(matrices$Q),
    glob_mean=glob_mean,
    lambda=0.1, scale_lam=TRUE,
    implicit=FALSE, nonneg=FALSE,
    nthreads=1
)

### Make predictions about new users
factors_single(model, X[10,,drop=TRUE])
topN_new(model,
         X=X[10,,drop=TRUE],
         exclude=X[10,,drop=TRUE])
</code></pre>


</div>