<div class="container">

<table style="width: 100%;"><tr>
<td>avg_fitness_diff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Average fitness differences</h2>

<h3>Description</h3>

<p>computes the average fitness differences among two or more species according to the formulation
of the MCT (Chesson 2012, Godoy and Levine 2014), and according to the structural approach (Saavedra et al. 2017).
For the MCT version, the average fitness ratio is decomposed in a 'demographic ratio' and a 'competitive response ratio',
the product of which is the average fitness ratio (Godoy and Levine 2014). This formulation is only valid for competitive
interaction coefficients (i.e. positive alpha values in the interaction matrix). The structural analog can be computed
for any interaction matrix, on the other hand. Note that the 'demographic ratio' is model-specific (Hart et al. 2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">avg_fitness_diff(
  cxr_multifit = NULL,
  cxr_sp1 = NULL,
  cxr_sp2 = NULL,
  pair_lambdas = NULL,
  pair_matrix = NULL,
  model_family = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cxr_multifit</code></td>
<td>
<p>cxr_pm_multifit object, with parameters for a series of species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cxr_sp1</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the first species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cxr_sp2</code></td>
<td>
<p>cxr_pm_fit object giving the parameters from the second species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pair_lambdas</code></td>
<td>
<p>numeric vector of length 2 giving lambda values for the two species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pair_matrix</code></td>
<td>
<p>2x2 matrix with intra and interspecific interaction
coefficients between the two species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_family</code></td>
<td>
<p>model family for which to calculate fitness differences.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function, as in <code>niche_overlap</code> and <code>competitive_ability</code>, accepts three different parameterizations:
</p>

<ul>
<li>
<p> A cxr_pm_multifit object, from which average fitness differences will be computed across all species pairs.
</p>
</li>
<li>
<p> two cxr_pm_fit objects, one for each species.
</p>
</li>
<li>
<p> explicit lambda and alpha values, as well as the model family from which these parameters were obtained.
</p>
</li>
</ul>
<p>If using the third parameterization, the function will try to find a model-specific function
for obtaining the demographic ratio, by looking at the 'model_family' parameter.
If this specific function is not found, it will resort to the standard Lotka-Volterra
formulation (lambda in the numerator term).
Overall, we strongly suggest that you use the standard formulation ONLY if you are completely confident
that your custom model is consistent with it.
Otherwise, you should include your own formulation of the demographic ratio (see vignette 4).
</p>


<h3>Value</h3>

<p>data frame with variable number of rows, and columns specifying the different components of the MCT average fitness ratio,
as well as its structural analog. The average fitness ratio informs quantitatively about the better competitor.
If the ratio is &lt; 1, sp2 is the better competitor; if = 1, both species are equivalent competitors, if &gt; 1, sp1 is the better competitor.
</p>


<h3>Examples</h3>

<pre><code class="language-R">avg_fitness_diff(pair_lambdas = runif(2,1,10),
                 pair_matrix = matrix(runif(4,0,1),nrow = 2),
                 model_family = "BH")
</code></pre>


</div>