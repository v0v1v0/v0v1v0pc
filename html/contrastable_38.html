<div class="container">

<table style="width: 100%;"><tr>
<td>decompose_contrasts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Decompose contrasts into new columns</h2>

<h3>Description</h3>

<p>Given a dataframe with factor columns, this function will extract the
contrasts from the factor column and place them inside new columns. This is
useful for cases where you want to work with the numeric values of the
contrasts. For a pedagogical example, you can explicitly show how factor
variables are transformed into numeric values. For a practical example,
you're typically allowed n-1 contrasts for n levels of a factor. If you don't
want to use all of the contrasts, you can extract the ones you want and use
them in your model. This is sometimes used with polynomial contrasts when you
don't want to use higher order polynomials.
</p>


<h3>Usage</h3>

<pre><code class="language-R">decompose_contrasts(
  model_data,
  extract,
  remove_intercept = TRUE,
  remove_original = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model_data</code></td>
<td>
<p>Dataframe with factor columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extract</code></td>
<td>
<p>A one-sided formula denoting the factors to extract. Note this
should ideally be what you would pass to your model fitting function, sans
any non-factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_intercept</code></td>
<td>
<p>Logical, whether to remove the column corresponding
to the intercept. Default <code>TRUE</code>  since it's always just a column of 1s</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_original</code></td>
<td>
<p>Logical, whether to remove the original columns in
the data frame after decomposing into separate columns. Default <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An additional usage for this function is to compute the contrasts for
interaction terms in a model. In <code>lm(y ~ A * B)</code>, where A and B are factors,
the expanded form is <code>lm(y ~ A + B + A:B)</code> with an equation of <code class="reqn">y =
\beta_Ax_A + \beta_Bx_B + \beta_{A:B}x_Ax_B</code>. The thing to note is that the
coefficient for the interaction(s) are multiplied by the product of <code class="reqn">x_A</code>
and <code class="reqn">x_B</code>. Let's call this product <code class="reqn">x_C</code>. For example, if one value
of <code class="reqn">x_A</code> is
-1/3 and one value of <code class="reqn">x_B</code> is 2/3, then the product <code class="reqn">x_C</code> is -2/9.
But, if there are 3 levels for <code class="reqn">x_A</code> and 3 levels for <code class="reqn">x_B</code>, then we
get 4 columns for the fixed effects <em>and</em> 4 <em>more</em> columns for the
interaction terms. It can be a lot of tedious work to precompute the products
manually, so we can use this function with <code>extract_interaction = TRUE</code> to
compute everything at once.
</p>


<h3>Value</h3>

<p><code>model_data</code> but with new columns corresponding to the numeric coding
of the given factor's contrasts
</p>


<h3>See Also</h3>

<p><code>set_contrasts()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Decompose contrasts for carb and gear columns into new columns, using
# the contrast labels used when setting the contrasts
mtcars |&gt;
  set_contrasts(
    carb ~ scaled_sum_code,
    gear ~ contr.sum | c("4-mean", "5-mean")
  ) |&gt;
  decompose_contrasts(~ carb + gear) |&gt;
  str()

# Decompose an interaction term between the two factors
mtcars |&gt;
  set_contrasts(
    carb ~ scaled_sum_code,
    gear ~ contr.sum | c("4-mean", "5-mean")
  ) |&gt;
  decompose_contrasts(~ carb * gear) |&gt;
  str()

</code></pre>


</div>