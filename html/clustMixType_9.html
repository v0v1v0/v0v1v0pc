<div class="container">

<table style="width: 100%;"><tr>
<td>validation_kproto</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Validating k Prototypes Clustering</h2>

<h3>Description</h3>

<p>Calculating the preferred validation index for a k-Prototypes clustering with k clusters or computing the optimal number of clusters based on the choosen index for k-Prototype clustering. Possible validation indices are: <code>cindex</code>, <code>dunn</code>, <code>gamma</code>, <code>gplus</code>, <code>mcclain</code>, <code>ptbiserial</code>, <code>silhouette</code> and <code>tau</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">validation_kproto(
  method = "silhouette",
  object = NULL,
  data = NULL,
  type = "huang",
  k = NULL,
  lambda = NULL,
  kp_obj = "optimal",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character specifying the validation index: <code>cindex</code>, <code>dunn</code>, <code>gamma</code>, <code>gplus</code>, <code>mcclain</code>, <code>ptbiserial</code>, <code>silhouette</code> (default) or <code>tau</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>kproto</code> resulting from a call with <code>kproto(..., keep.data=TRUE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Original data; only required if <code>object == NULL</code> and neglected if <code>object != NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character, to specify the distance for clustering; either <code>"huang"</code> or <code>"gower"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Vector specifying the search range for optimum number of clusters; if <code>NULL</code> the range will set as <code>2:sqrt(n)</code>. Only required if <code>object == NULL</code> and neglected if <code>object != NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Factor to trade off between Euclidean distance of numeric variables and simple matching coefficient between categorical variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kp_obj</code></td>
<td>
<p>character either "optimal" or "all": Output of the index-optimal clustering (kp_obj == "optimal") or all computed cluster partitions (kp_obj == "all"); only required if <code>object != NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, whether additional information about process should be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>kproto</code>, like:
</p>

<ul>
<li> <p><code>nstart</code>: If &gt; 1 repetitive computations of <code>kproto</code> with random initializations are computed.
</p>
</li>
<li> <p><code>na.rm</code>: Character, either <code>"yes"</code> to strip <code>NA</code> values for complete case analysis, <code>"no"</code> to keep and ignore <code>NA</code> values, <code>"imp.internal"</code> to impute the <code>NAs</code> within the algorithm or <code>"imp.onestep"</code> to apply the algorithm ignoring the <code>NAs</code> and impute them after the partition is determined.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>More information about the implemented validation indices:
</p>

<ul>
<li> <p><code>cindex</code> </p>
<p style="text-align: center;"><code class="reqn">Cindex = \frac{S_w-S_{min}}{S_{max}-S_{min}}</code>
</p>
 <p><br>
For <code class="reqn">S_{min}</code> and <code class="reqn">S_{max}</code> it is necessary to calculate the distances between all pairs of points in the entire data set (<code class="reqn">\frac{n(n-1)}{2}</code>). 
<code class="reqn">S_{min}</code> is the sum of the "total number of pairs of objects belonging to the same cluster" smallest distances and 
<code class="reqn">S_{max}</code> is the sum of the "total number of pairs of objects belonging to the same cluster" largest distances. <code class="reqn">S_w</code> is the sum of the within-cluster distances. <br>
The minimum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li> <p><code>dunn</code> </p>
<p style="text-align: center;"><code class="reqn">Dunn = \frac{\min_{1 \leq i &lt; j \leq q} d(C_i, C_j)}{\max_{1 \leq k \leq q} diam(C_k)}</code>
</p>
 <p><br>
The following applies: The dissimilarity between the two clusters <code class="reqn">C_i</code> and <code class="reqn">C_j</code> is defined as <code class="reqn">d(C_i, C_j)=\min_{x \in C_i, y \in C_j} d(x,y)</code> and
the diameter of a cluster is defined as <code class="reqn">diam(C_k)=\max_{x,y \in C} d(x,y)</code>. <br>
The maximum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li> <p><code>gamma</code> </p>
<p style="text-align: center;"><code class="reqn">Gamma = \frac{s(+)-s(-)}{s(+)+s(-)}</code>
</p>
 <p><br> 
Comparisons are made between all within-cluster dissimilarities and all between-cluster dissimilarities. 
<code class="reqn">s(+)</code> is the number of concordant comparisons and <code class="reqn">s(-)</code> is the number of discordant comparisons.
A comparison is named concordant (resp. discordant) if a within-cluster dissimilarity is strictly less (resp. strictly greater) than a between-cluster dissimilarity.<br>
The maximum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li> <p><code>gplus</code> </p>
<p style="text-align: center;"><code class="reqn">Gplus = \frac{2 \cdot s(-)}{\frac{n(n-1)}{2} \cdot (\frac{n(n-1)}{2}-1)}</code>
</p>
 <p><br> 
Comparisons are made between all within-cluster dissimilarities and all between-cluster dissimilarities. 
<code class="reqn">s(-)</code> is the number of discordant comparisons and a comparison is named discordant if a within-cluster 
dissimilarity is strictly greater than a between-cluster dissimilarity. <br>
The minimum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li> <p><code>mcclain</code> </p>
<p style="text-align: center;"><code class="reqn">McClain = \frac{\bar{S}_w}{\bar{S}_b}</code>
</p>
 <p><br><code class="reqn">\bar{S}_w</code> is the sum of within-cluster distances divided by the number of within-cluster distances and 
<code class="reqn">\bar{S}_b</code> is the sum of between-cluster distances divided by the number of between-cluster distances.<br>
The minimum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li>
<p><code>ptbiserial</code> </p>
<p style="text-align: center;"><code class="reqn">Ptbiserial = \frac{(\bar{S}_b-\bar{S}_w) \cdot (\frac{N_w \cdot N_b}{N_t^2})^{0.5}}{s_d}</code>
</p>
 <p><br><code class="reqn">\bar{S}_w</code> is the sum of within-cluster distances divided by the number of within-cluster distances and 
<code class="reqn">\bar{S}_b</code> is the sum of between-cluster distances divided by the number of between-cluster distances.<br><code class="reqn">N_t</code> is the total number of pairs of objects in the data, <code class="reqn">N_w</code> is the total number of pairs of 
objects belonging to the same cluster and <code class="reqn">N_b</code> is the total number of pairs of objects belonging to different clusters.
<code class="reqn">s_d</code> is the standard deviation of all distances.<br>
The maximum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li> <p><code>silhouette</code> </p>
<p style="text-align: center;"><code class="reqn">Silhouette = \frac{1}{n} \sum_{i=1}^n \frac{b(i)-a(i)}{max(a(i),b(i))}</code>
</p>
 <p><br><code class="reqn">a(i)</code> is the average dissimilarity of the i<em>th</em> object to all other objects of the same/own cluster.
<code class="reqn">b(i)=min(d(i,C))</code>, where <code class="reqn">d(i,C)</code> is the average dissimilarity of the i<em>th</em> object to all the other clusters except the own/same cluster.<br>
The maximum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
<li> <p><code>tau</code> </p>
<p style="text-align: center;"><code class="reqn">Tau = \frac{s(+) - s(-)}{((\frac{N_t(N_t-1)}{2}-t)\frac{N_t(N_t-1)}{2})^{0.5}}</code>
</p>
 <p><br> 
Comparisons are made between all within-cluster dissimilarities and all between-cluster dissimilarities. 
<code class="reqn">s(+)</code> is the number of concordant comparisons and <code class="reqn">s(-)</code> is the number of discordant comparisons.
A comparison is named concordant (resp. discordant) if a within-cluster dissimilarity is strictly less 
(resp. strictly greater) than a between-cluster dissimilarity.<br><code class="reqn">N_t</code> is the total number of distances <code class="reqn">\frac{n(n-1)}{2}</code> and <code class="reqn">t</code> is the number of comparisons 
of two pairs of objects where both pairs represent within-cluster comparisons or both pairs are between-cluster
comparisons. <br>
The maximum value of the index is used to indicate the optimal number of clusters.
</p>
</li>
</ul>
<h3>Value</h3>

<p>For computing the optimal number of clusters based on the choosen validation index for k-Prototype clustering the output contains:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>k_opt</code></td>
<td>
<p>optimal number of clusters (sampled in case of ambiguity)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_opt</code></td>
<td>
<p>index value of the index optimal clustering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indices</code></td>
<td>
<p>calculated indices for <code class="reqn">k=2,...,k_{max}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kp_obj</code></td>
<td>
<p>if(kp_obj == "optimal") the kproto object of the index optimal clustering and if(kp_obj == "all") all kproto which were calculated</p>
</td>
</tr>
</table>
<p>For computing the index-value for a given k-Prototype clustering the output contains:
</p>
<table><tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>calculated index-value</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>Rabea Aschenbruck
</p>


<h3>References</h3>


<ul>
<li>
<p> Aschenbruck, R., Szepannek, G. (2020): 
Cluster Validation for Mixed-Type Data. 
<em>Archives of Data Science, Series A, Vol 6, Issue 1</em>.
<a href="https://doi.org/10.5445/KSP/1000098011/02">doi:10.5445/KSP/1000098011/02</a>.
</p>
</li>
<li>
<p> Charrad, M., Ghazzali, N., Boiteau, V., Niknafs, A. (2014): 
NbClust: An R Package for Determining the Relevant Number of Clusters in a Data Set. 
<em>Journal of Statistical Software, Vol 61, Issue 6</em>.
<a href="https://doi.org/10.18637/jss.v061.i06">doi:10.18637/jss.v061.i06</a>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# generate toy data with factors and numerics
n   &lt;- 10
prb &lt;- 0.99
muk &lt;- 2.5 

x1 &lt;- sample(c("A","B"), 2*n, replace = TRUE, prob = c(prb, 1-prb))
x1 &lt;- c(x1, sample(c("A","B"), 2*n, replace = TRUE, prob = c(1-prb, prb)))
x1 &lt;- as.factor(x1)
x2 &lt;- sample(c("A","B"), 2*n, replace = TRUE, prob = c(prb, 1-prb))
x2 &lt;- c(x2, sample(c("A","B"), 2*n, replace = TRUE, prob = c(1-prb, prb)))
x2 &lt;- as.factor(x2)
x3 &lt;- c(rnorm(n, mean = -muk), rnorm(n, mean = muk), rnorm(n, mean = -muk), rnorm(n, mean = muk))
x4 &lt;- c(rnorm(n, mean = -muk), rnorm(n, mean = muk), rnorm(n, mean = -muk), rnorm(n, mean = muk))
x &lt;- data.frame(x1,x2,x3,x4)


# calculate optimal number of cluster, index values and clusterpartition with Silhouette-index
val &lt;- validation_kproto(method = "silhouette", data = x, k = 3:5, nstart = 5)


# apply k-prototypes
kpres &lt;- kproto(x, 4, keep.data = TRUE)

# calculate cindex-value for the given clusterpartition
cindex_value &lt;- validation_kproto(method = "cindex", object = kpres)

## End(Not run)

</code></pre>


</div>