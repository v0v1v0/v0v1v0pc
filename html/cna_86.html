<div class="container">

<table style="width: 100%;"><tr>
<td>redundant</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Identify structurally redundant asf in a csf
</h2>

<h3>Description</h3>

<p><code>redundant</code> takes a character vector <code>cond</code> containing complex solution formulas (csf) as input and tests for each element of <code>cond</code> whether the atomic solution formulas (asf) it consists of are structurally redundant. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">redundant(cond, x = NULL, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>

<p>Character vector specifying complex solution formulas (csf); only strings of type csf are allowed, meaning conjunctions of one or more asf. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>An optional argument providing a <code>configTable</code>, a data frame, or a list specifying the factors' value ranges if <code>cond</code> contains multi-value factors; if <code>x</code> is not <code>NULL</code>, <code>cond</code> is tested for redundancy-freeness relative to <code>full.ct(x)</code>, otherwise relative to <code>full.ct(cond)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the result for csfs with the same number of component asfs is presented as a matrix, otherwise all results are presented as a list of logical vectors.  
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>According to the regularity theory of causation underlying CNA, a Boolean dependency structure is causally interpretable only if it does not contain any redundant elements. Boolean dependency structures may feature various types of redundancies, one of which are so-called <em>structural redundancies</em>. A csf <code class="reqn">\Phi</code> has a structural redundancy if, and only if, reducing <code class="reqn">\Phi</code> by one or more of the asf it is composed of results in a csf <code class="reqn">\Phi'</code> that is logically equivalent to <code class="reqn">\Phi</code>. To illustrate, suppose that <code class="reqn">\Phi</code> is composed of three asf: asf1 * asf2 * asf3; and suppose that <code class="reqn">\Phi</code> is logically equivalent to <code class="reqn">\Phi'</code>: asf1 * asf2. In that case, asf3 makes no difference to the behavior of the factors in <code class="reqn">\Phi</code> and <code class="reqn">\Phi'</code>; it is structurally redundant and, accordingly, must not be causally interpreted. For more details see the package vignette (<code>vignette("cna")</code>) or Baumgartner and Falk (2023).
</p>
<p>The function <code>redundant</code> takes a character vector <code>cond</code> composed of csf as input an tests for each element of <code>cond</code> whether it is structurally redundant or not. As a test for structural redundancies amounts to a test of logical equivalencies, it must be conducted relative to all logically possible configurations of the factors in <code>cond</code>. That space of logical possibilities is generated by <code>full.ct(cond)</code> in case of <code>x =  NULL</code>, and by <code>full.ct(x)</code> otherwise. If all factors in <code>cond</code> are binary, <code>x</code> is optional and without influence on the output of <code>redundant</code>. If some factors in <code>cond</code> are multi-value, <code>redundant</code> needs to be given the range of these values. <code>x</code> can be a data frame or <code>configTable</code> listing all possible value configurations or a list of the possible values for each factor in <code>cond</code>.
</p>
<p>If <code>redundant</code> returns <code>TRUE</code> for a csf, that csf must not be causally interpreted but further processed by <code>minimalizeCsf</code>. As of version 3.0 of the <span class="pkg">cna</span> package, standard calls of the <code>cna</code> and <code>csf</code> functions automatically eliminate all structurally redundant asf.
</p>


<h3>Value</h3>

<p>A list of logical vectors or a logical matrix.
</p>
<p>If all <code>csf</code> in <code>cond</code> have the same number of <code>asf</code> and <code>simplify = TRUE</code>,  the result is a logical matrix with <code>length(cond)</code> rows and the number of columns corresponds to the number of <code>asf</code> in each <code>csf</code>. In all other cases, a list of logical vectors of the same length as <code>cond</code> is returned.
</p>


<h3>Contributors</h3>

<p>Falk, Christoph: identification and solution of the problem of structural redundancies
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. “Boolean Difference-Making: A Modern Regularity Theory of Causation”. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>


<h3>See Also</h3>

<p><code>condition</code>, <code>full.ct</code>, <code>is.inus</code>, <code>csf</code>, <code>minimalizeCsf</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Binary factors.
cond1 &lt;- c("(f + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(c + a*E &lt;-&gt; F)", "f + a*D &lt;-&gt; C")
redundant(cond1)

edu.sol &lt;- csf(cna(d.educate), inus.only = FALSE)$condition
redundant(edu.sol, d.educate)

redundant(edu.sol, d.educate, simplify = FALSE)


# Default application of csf() with automatic elimination of structural redundancies.
ct.pban &lt;- configTable(d.pban)
cna.pban &lt;- cna(ct.pban, con = .75, cov = .75)
csf.pban &lt;- csf(cna.pban)
# check for structural redundancies in the csf:
redund.pban &lt;- redundant(csf.pban$condition, ct.pban) 
# show result for the first few:
head(redund.pban)  
# verify that no solutions with structural redundancies are returned
any(unlist(redund.pban))  # FALSE - no redundancies

# Non-default application of csf() without automatic elimination of structural redundancies.
csf.pban &lt;- csf(cna.pban, inus.only = FALSE)
redund.pban &lt;- redundant(csf.pban$condition, ct.pban)
head(redund.pban)
# various solutions with structural redundancies are returned:
table(apply(redund.pban, 1, any)) # each TRUE corresponds to a csf with struct. redundancies


# If no x is specified defining the factors' value ranges, the space of
# logically possible configurations is limited to the factor values contained in
# cond, resulting in structural redundancies that disappear as soon as x is specified.
cond2 &lt;- "(C=0*F=0 + G=1&lt;-&gt; T=2)*(T=2 + G=2 &lt;-&gt; P=1)"
redundant(cond2)
redundant(cond2, list(C=0:2, F=0:2, G=0:3, T=0:2, P=0:2))

</code></pre>


</div>