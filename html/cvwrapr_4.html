<div class="container">

<table style="width: 100%;"><tr>
<td>computeError</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute CV statistics from a prediction matrix</h2>

<h3>Description</h3>

<p>Compute CV statistics from a matrix of predictions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">computeError(
  predmat,
  y,
  lambda,
  foldid,
  type.measure,
  family,
  weights = rep(1, dim(predmat)[1]),
  grouped = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>predmat</code></td>
<td>
<p>Array of predictions. If 'y' is univariate, this has
dimensions 'c(nobs, nlambda)'. If 'y' is multivariate with 'nc'
levels/columns (e.g. for 'family = "multionmial"' or
'family = "mgaussian"'), this has dimensions 'c(nobs, nc, nlambda)'.
Note that these should be on the same scale as 'y' (unlike in the
glmnet package where it is the linear predictor).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response variable. Either a vector or a matrix, depending on the
type of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Lambda values associated with the errors in 'predmat'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>Vector of values identifying which fold each observation is
in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.measure</code></td>
<td>
<p>Loss function to use for cross-validation. See
'availableTypeMeasures()' for possible values for 'type.measure'. Note that
the package does not check if the user-specified measure is appropriate
for the family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Model family; used to determine the correct loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouped</code></td>
<td>
<p>This is an experimental argument, with default 'TRUE',
and can be ignored by most users. For all models except 'family = "cox"',
this refers to computing 'nfolds' separate statistics, and then using
their mean and estimated standard error to describe the CV curve. If
'FALSE', an error matrix is built up at the observation level
from the predictions from the 'nfolds' fits, and then summarized (does
not apply to 'type.measure="auc"'). For the "cox" family,
'grouped=TRUE' obtains the CV partial likelihood for the Kth fold by
<em>subtraction</em>; by subtracting the log partial likelihood evaluated on
the full dataset from that evaluated on the on the (K-1)/K dataset. This
makes more efficient use of risk sets. With 'grouped=FALSE' the log
partial likelihood is computed only on the Kth fold.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that for the setting where 'family = "cox"' and
'type.measure = "deviance"' and 'grouped = TRUE', 'predmat' needs to have
a 'cvraw' attribute as computed by 'buildPredMat()'. This is because the
usual matrix of pre-validated fits does not contain all the information
needed to compute the model deviance for this setting.
</p>


<h3>Value</h3>

<p>An object of class "cvobj".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The values of lambda used in the fits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p>The mean cross-validated error: a vector of length
'length(lambda)'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvsd</code></td>
<td>
<p>Estimate of standard error of 'cvm'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>Upper curve = 'cvm + cvsd'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>Lower curve = 'cvm - cvsd'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>Value of 'lambda' that gives minimum 'cvm'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>Largest value of 'lambda' such that the error is within
1 standard error of the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>A one-column matrix with the indices of 'lambda.min' and
'lambda.1se' in the sequence of coefficients, fits etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>A text string indicating the loss function used (for plotting
purposes).</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
x &lt;- matrix(rnorm(500), nrow = 50)
y &lt;- rnorm(50)
cv_fit &lt;- kfoldcv(x, y, train_fun = glmnet::glmnet,
                  predict_fun = predict, keep = TRUE)
mae_err &lt;- computeError(cv_fit$fit.preval, y, cv_fit$lambda,
                        cv_fit$foldid, type.measure = "mae",
                        family = "gaussian")

</code></pre>


</div>