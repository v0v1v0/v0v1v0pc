<div class="container">

<table style="width: 100%;"><tr>
<td>morrisCI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Analytical confidence intervals using the Morris (1988) algorithm</h2>

<h3>Description</h3>

<p>Analytical confidence intervals for CIR and IR, using the recursive algorithm by Morris (1988), equation (4.3), for ordered-binomial point estimates. Optionally, the intervals are narrowed further using a backup pointwise interval estimate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">morrisCI(
  y,
  n,
  phat = y/n,
  conf = 0.9,
  narrower = TRUE,
  alternate = wilsonCI,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>integer or numeric vector, the pointwise Binomial counts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer or numeric vector, the pointwise sample sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phat</code></td>
<td>
<p>numeric vector, the point estimates. Defaults to <code>y/n</code>, but when called by <code>isotInterval</code> is overridden by the actual CIR/IR point estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>narrower</code></td>
<td>
<p>logical, if the <code>alternate</code>-produced interval is narrower at any point, should it replace the Morris result? Also, can we enforce straightforward monotonocity to narrow the bounds? Default <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternate</code></td>
<td>
<p>function to use for alternate pointwise interval. Default <code>wilconCI</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passed on to <code>alternate</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The default for backup is Wilson's (<code>wilconCI</code>). Also available are Jeffrys' (<code>jeffCI</code>) and Agresti-Coull (<code>agcouCI</code>).
</p>


<h3>Value</h3>

<p>A two-column matrix with the same number of rows as <code>length(phat)</code>, containing the calculated lower and upper bounds, respectively.
</p>


<h3>Note</h3>

<p>This function found and corrected a typo in equation (4.3), namely the use of G_(j+1) in the recursion. The recursion cannot start in this way. Rather, it is the use of theta_(j+1) that delivers information from adjacent doses. Or perhaps in other words, there is only one G function rather than a different one for each dose. The correction has been verified by reproducing the numbers in the Morris (1988) example (Table 1), and also approved by the original author.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Morris, M., 1988. Small-sample confidence limits for parameters under inequality constraints with application to quantal bioassay. Biometrics 44, 1083-1092.
</p>


<h3>See Also</h3>

<p><code>isotInterval</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
slow1=cirPAVA(dat,full=TRUE)
# Default interval (Morris+Wilson); same as you get by directly calling 'quickIsotone'
int1=isotInterval(slow1)
# Morris without Wilson; the 'narrower=FALSE' argument is passed on to 'morrisCI'
int1_0=isotInterval(slow1,narrower=FALSE)
# Wilson without Morris
int2=isotInterval(slow1,intfun=wilsonCI)
# Agresti=Coull (the often-used "plus 2")
int3=isotInterval(slow1,intfun=agcouCI)
# Jeffrys (Bayesian-inspired) is also available
int4=isotInterval(slow1,intfun=jeffCI)

### Showing the data and the intervals
par(mar=c(3,3,4,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat,ylim=c(0,0.65),refsize=4,las=1,main="Forward-Estimation CIs") # uses plot.doseResponse()

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(0,7,0.1),pweibull(seq(0,7,0.1),shape=1.1615,scale=8.4839),col=4)

lines(int1$ciLow,lty=2,col=2,lwd=2) 
lines(int1$ciHigh,lty=2,col=2,lwd=2) 

lines(int1_0$ciLow,lty=2) 
lines(int1_0$ciHigh,lty=2) 

lines(int2$ciLow,lty=2,col=3) 
lines(int2$ciHigh,lty=2,col=3) 
# Plotting the remaining 2 is skipped, as they are very similar to Wilson.

# Note how the default (red) boundaries take the tighter of the two options everywhere, 
# except for one place (dose 1 upper bound) where they go even tighter thanks to monotonicity 
# enforcement. This can often happen when sample size is uneven; since bounds tend to be 
# conservative it is rather safe to do.

legend('topleft',pch=c(NA,'X',NA,NA,NA),lty=c(1,NA,2,2,2),col=c(4,1,2,1,3),lwd=c(1,1,2,1,1),legend
=c('True Curve','Observations','Morris+Wilson (default)','Morris only','Wilson only'),bty='n')

</code></pre>


</div>