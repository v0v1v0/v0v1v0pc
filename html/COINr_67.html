<div class="container">

<table style="width: 100%;"><tr>
<td>Impute.coin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute a data set in a coin</h2>

<h3>Description</h3>

<p>This imputes any <code>NA</code>s in the data set specified by <code>dset</code>
by invoking the function <code>f_i</code> and any optional arguments <code>f_i_para</code> on each column at a time (if
<code>impute_by = "column"</code>), or on each row at a time (if <code>impute_by = "row"</code>), or by passing the entire
data frame to <code>f_i</code> if <code>impute_by = "df"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'coin'
Impute(
  x,
  dset,
  f_i = NULL,
  f_i_para = NULL,
  impute_by = "column",
  use_group = NULL,
  group_level = NULL,
  normalise_first = NULL,
  out2 = "coin",
  write_to = NULL,
  disable = FALSE,
  warn_on_NAs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A coin class object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_i</code></td>
<td>
<p>An imputation function. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_i_para</code></td>
<td>
<p>Further arguments to pass to <code>f_i</code>, other than <code>x</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impute_by</code></td>
<td>
<p>Specifies how to impute: if <code>"column"</code>, passes each column (indicator) separately as a numerical
vector to <code>f_i</code>; if <code>"row"</code>, passes each <em>row</em> separately; and if <code>"df"</code> passes the entire data set (data frame) to
<code>f_i</code>. The function called by <code>f_i</code> should be compatible with the type of data passed to it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_group</code></td>
<td>
<p>Optional grouping variable name to pass to imputation function if this supports group
imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_level</code></td>
<td>
<p>A level of the framework to use for grouping indicators. This is only
relevant if <code>impute_by = "row"</code> or <code>"df"</code>. In that case, indicators will be split into their groups at the
level specified by <code>group_level</code>, and imputation will be performed across rows of the group, rather
than the whole data set. This can make more sense because indicators within a group are likely to be
more similar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise_first</code></td>
<td>
<p>Logical: if <code>TRUE</code>, each column is normalised using a min-max operation before
imputation. By default this is <code>FALSE</code> unless <code>impute_by = "row"</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out2</code></td>
<td>
<p>Either <code>"coin"</code> to return normalised data set back to the coin, or <code>df</code> to simply return a data
frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to</code></td>
<td>
<p>Optional character string for naming the data set in the coin. Data will be written to
<code>.$Data[[write_to]]</code>. Default is <code>write_to == "Imputed"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>disable</code></td>
<td>
<p>Logical: if <code>TRUE</code> will disable imputation completely and write the unaltered data set. This option is mainly useful
in sensitivity and uncertainty analysis (to test the effect of turning imputation on/off).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn_on_NAs</code></td>
<td>
<p>Logical: if <code>TRUE</code> will issue a warning if there are any <code>NA</code>s detected in the data frame
after imputation has been applied. Set <code>FALSE</code> to suppress these warnings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Clearly, the function <code>f_i</code> needs to be able to accept with the data class passed to it - if
<code>impute_by</code> is <code>"row"</code> or <code>"column"</code> this will be a numeric vector, or if <code>"df"</code> it will be a data
frame. Moreover, this function should return a vector or data frame identical to the vector/data frame passed to
it except for <code>NA</code> values, which can be replaced. The function <code>f_i</code> is not required to replace <em>all</em> <code>NA</code>
values.
</p>
<p>COINr has several built-in imputation functions of the form <code style="white-space: pre;">⁠i_*()⁠</code> for vectors which can be called by <code>Impute()</code>. See the
<a href="https://bluefoxr.github.io/COINr/articles/imputation.html#data-frames">online documentation</a> for more details.
</p>
<p>When imputing row-wise, prior normalisation of the data is recommended. This is because imputation
will use e.g. the mean of the unit values over all indicators (columns). If the indicators are on
very different scales, the result will likely make no sense. If the indicators are normalised first,
more sensible results can be obtained. There are two options to pre-normalise: first is by setting
<code>normalise_first = TRUE</code> - this is anyway the default if <code>impute_by = "row"</code>. In this case, you also
need to supply a vector of directions. The data will then be normalised using a min-max approach
before imputation, followed by the inverse operation to return the data to the original scales.
</p>
<p>Another approach which gives more control is to simply run <code>Normalise()</code> first, and work with the
normalised data from that point onwards. In that case it is better to set <code>normalise_first = FALSE</code>,
since by default if <code>impute_by = "row"</code> it will be set to <code>TRUE</code>.
</p>
<p>Checks are made on the format of the data returned by imputation functions, to ensure the
type and that non-<code>NA</code> values have not been inadvertently altered. This latter check is allowed
a degree of tolerance for numerical precision, controlled by the <code>sfigs</code> argument. This is because
if the data frame is normalised, and/or depending on the imputation function, there may be a very
small differences. By default <code>sfigs = 9</code>, meaning that the non-<code>NA</code> values pre and post-imputation
are compared to 9 significant figures.
</p>
<p>See also documentation for <code>Impute.data.frame()</code> and <code>Impute.numeric()</code> which are called by this function.
</p>


<h3>Value</h3>

<p>An updated coin with imputed data set at <code>.$Data[[write_to]]</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#' # build coin
coin &lt;- build_example_coin(up_to = "new_coin")

# impute raw data set using population groups
# output to data frame directly
Impute(coin, dset = "Raw", f_i = "i_mean_grp",
               use_group = "Pop_group", out2 = "df")

</code></pre>


</div>