<div class="container">

<table style="width: 100%;"><tr>
<td>MOCClassif</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MOC (Multi-Objective Counterfactual Explanations) for Classification Tasks</h2>

<h3>Description</h3>

<p>MOC (Dandl et. al 2020) solves a multi-objective optimization problem to find counterfactuals. The four objectives
to minimize are:
</p>

<ol>
<li> <p><code>dist_target</code>: Distance to <code>desired_prob</code> (classification tasks) or <code>desired_prob</code> (regression tasks).
</p>
</li>
<li> <p><code>dist_x_interest</code>: Dissimilarity to <code>x_interest</code> measured by Gower's dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p><code>no_changed</code>: Number of feature changes.
</p>
</li>
<li> <p><code>dist_train</code>: (Weighted) sum of dissimilarities to the <code>k</code> nearest data points in <code>predictor$data$X</code>.
</p>
</li>
</ol>
<p>For optimization, it uses the NSGA II algorithm (Deb et. al 2002) with mixed integer evolutionary
strategies (Li et al. 2013) and some tailored adjustments for the counterfactual search (Dandl et al. 2020).
Default values for the hyperparameters are based on Dandl et al. 2020.
</p>


<h3>Details</h3>

<p>Several population initialization strategies are available:
</p>

<ol>
<li> <p><code>random</code>: Feature values of new individuals are sampled from the feature value ranges in <code>predictor$data$X</code>.
Some features values are randomly reset to their initial value in <code>x_interest</code>.
</p>
</li>
<li> <p><code>sd</code>: Like <code>random</code>, except that the sample ranges of numerical features are limited to one standard
deviation from their initial value in <code>x_interest</code>.
</p>
</li>
<li> <p><code>icecurve</code>: As in <code>random</code>, feature values are sampled from the feature value ranges in <code>predictor$data$X</code>.
Then, however, features are reset with probabilities relative to their importance: the higher the importance
of a feature, the higher the probability that its values differ from its value in <code>x_interest</code>.
The feature importance is measured using ICE curves (Goldstein et al. 2015).
</p>
</li>
<li> <p><code>traindata</code>: Contrary to the other strategies, feature values are drawn from (non-dominated) data points
in <code>predictor$data$X</code>; if not enough non-dominated data points are available, remaining individuals
are initialized by random sampling. Subsequently, some features values are randomly reset to their initial value
in <code>x_interest</code> (as for <code>random</code>).
</p>
</li>
</ol>
<p>If <code>use_conditional_mutator</code> is set to TRUE, a conditional mutator samples
feature values from the conditional distribution given the other feature values
with the help of transformation trees (Hothorn and Zeileis 2017).
For details see Dandl et al. 2020.
</p>


<h3>Super classes</h3>

<p><code>counterfactuals::CounterfactualMethod</code> -&gt; <code>counterfactuals::CounterfactualMethodClassif</code> -&gt; <code>MOCClassif</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>optimizer</code></dt>
<dd>
<p>(OptimInstanceBatchMultiCrit) <br>
The object used for optimization.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MOCClassif-new"><code>MOCClassif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-plot_statistics"><code>MOCClassif$plot_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-get_dominated_hv"><code>MOCClassif$get_dominated_hv()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-plot_search"><code>MOCClassif$plot_search()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-clone"><code>MOCClassif$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href="../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print"><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodClassif" data-id="find_counterfactuals"><a href="../../counterfactuals/html/CounterfactualMethodClassif.html#method-CounterfactualMethodClassif-find_counterfactuals"><code>counterfactuals::CounterfactualMethodClassif$find_counterfactuals()</code></a></span></li>
</ul></details><hr>
<a id="method-MOCClassif-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>MOCClassif</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$new(
  predictor,
  epsilon = NULL,
  fixed_features = NULL,
  max_changed = NULL,
  mu = 20L,
  termination_crit = "gens",
  n_generations = 175L,
  p_rec = 0.71,
  p_rec_gen = 0.62,
  p_mut = 0.73,
  p_mut_gen = 0.5,
  p_mut_use_orig = 0.4,
  k = 1L,
  weights = NULL,
  lower = NULL,
  upper = NULL,
  init_strategy = "icecurve",
  use_conditional_mutator = FALSE,
  quiet = FALSE,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt>
<dd>
<p>(Predictor)<br>
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>epsilon</code></dt>
<dd>
<p>(<code>numeric(1)</code> | <code>NULL</code>)<br>
If not <code>NULL</code>, candidates whose prediction for the <code>desired_class</code> is farther away from the interval <code>desired_prob</code>
than <code>epsilon</code> are penalized. <code>NULL</code> (default) means no penalization.</p>
</dd>
<dt><code>fixed_features</code></dt>
<dd>
<p>(<code>character()</code> | <code>NULL</code>)<br>
Names of features that are not allowed to be changed. <code>NULL</code> (default) allows all features to be changed.</p>
</dd>
<dt><code>max_changed</code></dt>
<dd>
<p>(<code>integerish(1)</code> | <code>NULL</code>)<br>
Maximum number of feature changes. <code>NULL</code> (default) allows any number of changes.</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>(<code>integerish(1)</code>)<br>
The population size. Default is <code>20L</code>.</p>
</dd>
<dt><code>termination_crit</code></dt>
<dd>
<p>(<code>character(1)</code>|<code>NULL</code>)<br>
Termination criterion, currently, two criterions are implemented: "gens" (default),
which stops after <code>n_generations</code> generations,  and "genstag", which stops after
the hypervolume did not improve for <code>n_generations</code> generations
(the total number of generations is limited to 500).</p>
</dd>
<dt><code>n_generations</code></dt>
<dd>
<p>(<code>integerish(1)</code>)<br>
The number of generations. Default is <code>175L</code>.</p>
</dd>
<dt><code>p_rec</code></dt>
<dd>
<p>(<code>numeric(1)</code>)<br>
Probability with which an individual is selected for recombination. Default is <code>0.71</code>.</p>
</dd>
<dt><code>p_rec_gen</code></dt>
<dd>
<p>(<code>numeric(1)</code>)<br>
Probability with which a feature/gene is selected for recombination. Default is <code>0.62</code>.</p>
</dd>
<dt><code>p_mut</code></dt>
<dd>
<p>(<code>numeric(1)</code>)<br>
Probability with which an individual is selected for mutation. Default is <code>0.73</code>.</p>
</dd>
<dt><code>p_mut_gen</code></dt>
<dd>
<p>(<code>numeric(1)</code>)<br>
Probability with which a feature/gene is selected for mutation. Default is <code>0.5</code>.</p>
</dd>
<dt><code>p_mut_use_orig</code></dt>
<dd>
<p>(<code>numeric(1)</code>)<br>
Probability with which a feature/gene is reset to its original value in <code>x_interest</code> after mutation. Default is <code>0.4</code>.</p>
</dd>
<dt><code>k</code></dt>
<dd>
<p>(<code>integerish(1)</code>)<br>
The number of data points to use for the forth objective. Default is <code>1L</code>.</p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>(<code>numeric(1) | numeric(k)</code> | <code>NULL</code>)<br>
The weights used to compute the weighted sum of dissimilarities for the forth objective. It is either a single value
or a vector of length <code>k</code>. If it has length <code>k</code>, the i-th element specifies the weight of the i-th closest data point.
The values should sum up to <code>1</code>. <code>NULL</code> (default) means all data points are weighted equally.</p>
</dd>
<dt><code>lower</code></dt>
<dd>
<p>(<code>numeric()</code> | <code>NULL</code>)<br>
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt>
<dd>
<p>(<code>numeric()</code> | <code>NULL</code>)<br>
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>init_strategy</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
The population initialization strategy. Can be <code>icecurve</code> (default), <code>random</code>, <code>sd</code> or <code>traindata</code>. For more information,
see the <code>Details</code> section.</p>
</dd>
<dt><code>use_conditional_mutator</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Should a conditional mutator be used? The conditional mutator generates plausible feature values based
on the values of the other feature. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>quiet</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Should information about the optimization status be hidden? Default is <code>FALSE</code>.</p>
</dd>
<dt><code>distance_function</code></dt>
<dd>
<p>(<code style="white-space: pre;">⁠function()⁠</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br>
The distance function to be used in the second and fourth objective.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-MOCClassif-plot_statistics"></a>



<h4>Method <code>plot_statistics()</code>
</h4>

<p>Plots the evolution of the mean and minimum objective values together with the dominated hypervolume over
the generations. All values for a generation are computed based on all non-dominated individuals that emerged until
that generation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$plot_statistics(centered_obj = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>centered_obj</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Should the objective values be centered? If set to <code>FALSE</code>, each objective value is visualized in a separate plot,
since they (usually) have different scales. If set to <code>TRUE</code> (default), they are visualized in a single plot.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-MOCClassif-get_dominated_hv"></a>



<h4>Method <code>get_dominated_hv()</code>
</h4>

<p>Calculates the dominated hypervolume of each generation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$get_dominated_hv()</pre></div>



<h5>Returns</h5>

<p>A <code>data.table</code> with the dominated hypervolume of each generation.
</p>


<hr>
<a id="method-MOCClassif-plot_search"></a>



<h4>Method <code>plot_search()</code>
</h4>

<p>Visualizes two selected objective values of all emerged individuals in a scatter plot.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$plot_search(objectives = c("dist_target", "dist_x_interest"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objectives</code></dt>
<dd>
<p>(<code>character(2)</code>)<br>
The two objectives to be shown in the plot. Possible values are "dist_target", "dist_x_interest, "no_changed",
and "dist_train".</p>
</dd>
</dl>
</div>


<hr>
<a id="method-MOCClassif-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p>Dandl, S., Molnar, C., Binder, M., and Bischl, B. (2020).
"Multi-Objective Counterfactual Explanations". In: Parallel Problem
Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss,
André Deutz, Hao Wang, Carola Doerr, Michael Emmerich, and Heike Trautmann, 448–469,
Cham, Springer International Publishing, <a href="https://doi.org/10.1007/978-3-030-58112-1_31">doi:10.1007/978-3-030-58112-1_31</a>.
</p>
<p>Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. A. M. T. (2002).
"A fast and elitist multiobjective genetic algorithm: NSGA-II".
IEEE transactions on evolutionary computation, 6(2), 182-197.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E. (2015).
"Peeking Inside the Black Box: Visualizing
Statistical Learning with Plots of Individual Conditional Expectation".
Journal of Computational and Graphical Statistics 24 (1): 44–65.
<a href="https://doi.org/10.1080/10618600.2014.907095">doi:10.1080/10618600.2014.907095</a>.
</p>
<p>Gower, J. C. (1971). A general coefficient of similarity and some of its properties. Biometrics, 27, 623–637.
</p>
<p>Hothorn, T., Zeileis, A. (2017), "Transformation Forests".
Technical Report, <a href="https://arxiv.org/abs/1701.02110">arXiv 1701.02110</a>.
</p>
<p>Li, Rui, L., Emmerich, M. T. M., Eggermont, J. Bäck, T., Schütz, M., Dijkstra, J., Reiber, J. H. C. (2013).
"Mixed Integer Evolution Strategies for Parameter Optimization."
Evolutionary Computation 21 (1): 29–64. <a href="https://doi.org/10.1162/EVCO_a_00059">doi:10.1162/EVCO_a_00059</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require("randomForest")) {
 
  # Train a model
  rf = randomForest(Species ~ ., data = iris)
  # Create a predictor object
  predictor = iml::Predictor$new(rf, type = "prob")
  # Find counterfactuals for x_interest
  moc_classif = MOCClassif$new(predictor, n_generations = 15L, quiet = TRUE)
 
  cfactuals = moc_classif$find_counterfactuals(
    x_interest = iris[150L, ], desired_class = "versicolor", desired_prob = c(0.5, 1)
  )
  # Print the counterfactuals
  cfactuals$data
  # Plot evolution of hypervolume and mean and minimum objective values
  moc_classif$plot_statistics()
  
}

</code></pre>


</div>