<div class="container">

<table style="width: 100%;"><tr>
<td>blomCOPss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Blomqvist (Schmid–Schmidt) Betas of a Copula</h2>

<h3>Description</h3>

<p>Compute the <em>Blomqvist (Schmid–Schmidt) Betas</em> <code class="reqn">\beta^\diamond_\mathbf{C}</code> (Schmid and Schmidt, 2007) defined for arbitrary dimension <code class="reqn">d</code> of a copula <code class="reqn">\mathbf{C}_(u_1, \cdots, u_d; \Theta)</code> (<code>COP</code>) for parameters <code class="reqn">\Theta</code>. The copula survival function is <code class="reqn">\overline{\mathbf{C}}(u_1, \cdots, u_d; \Theta)</code> (<code>surfuncCOP</code>). The Beta, though the <span class="pkg">copBasic</span> package is built around bivariate copula only, is defined as
</p>
<p style="text-align: center;"><code class="reqn">\beta^\diamond_\mathbf{C} = h_d(\mathbf{u}, \mathbf{v})\bigl[
\bigl(\mathbf{C}(\mathbf{u}) + \overline{\mathbf{C}}(\mathbf{v})\bigr) - g_d(\mathbf{u}, \mathbf{v})
\bigr]\mbox{,}</code>
</p>

<p>where <code class="reqn">h_d</code> and <code class="reqn">g_d</code> are norming constants defined below. The superscript <code class="reqn">\diamond</code> (diamond) is chosen for <span class="pkg">copBasic</span> because of the alliteration to “dimension.” The bold face font for <code class="reqn">\mathbf{u}</code> and <code class="reqn">\mathbf{v}</code> shows these arguments as vectors of length <code class="reqn">d</code> reflecting “cutting points” on nonexceedance probabilities in each of the dimensions. The <code class="reqn">\mathbf{u}</code> functions as the arguments <code class="reqn">(u,v)</code> pair used in copula of this package and represents the first cutting point for a <code class="reqn">\mathrm{Pr}[U \le u, V \le v] = \mathbf{C}(u,v)</code>, and <code class="reqn">\mathbf{v}</code> functions as the arguments <code class="reqn">u,v</code> pair for this package and represents the second cutting point for a <code class="reqn">\mathrm{Pr}[U &gt; u, V &gt; v] = 1 - u - v + \mathbf{C}(u,v) = \overline{\mathbf{C}}(u,v)</code>. This notation of vectored (bold face) and nonvectored “u” and “v” is a little obtuse but as the properties of <code class="reqn">\beta^\diamond_\mathbf{C}</code> are summarized clarity for the reader is anticipated. In short, the <code class="reqn">\mathbf{u}</code> will reference the coordinate pairs in the lower right quadrant and the <code class="reqn">\mathbf{v}</code> will reference the coordinate pairs in the upper right quadrant.
</p>
<p>The norming constant <code class="reqn">h_d</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">h_d(\mathbf{u}, \mathbf{v}) = \frac{1}{\bigl( \mathrm{min}(u_1,   \cdots,   u_d) + \mathrm{min}(1-v_1, \cdots, 1-v_d) - g_d(\mathbf{u}, \mathbf{v})\bigr)}\mbox{,}</code>
</p>

<p>and <code class="reqn">g_d</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">g_d(\mathbf{u}, \mathbf{v}) = \prod^d_{i=1}u_i + \prod^d_{i=1}(1-v_i)\mbox{,}</code>
</p>

<p>where the cutting points <code class="reqn">\mathbf{u}</code> and <code class="reqn">\mathbf{v}</code> are in a domain <code class="reqn">D : \{(\mathbf{u}, \mathbf{v})\} \in [0,1]^{2d}</code> given <code class="reqn">\mathbf{u} \le \mathbf{v}</code> and <code class="reqn">\mathbf{u} &gt; 0</code> or <code class="reqn">\mathbf{v} &lt; \mathbf{1}</code>. The reader must careful remember that these <code class="reqn">\mathbf{u}</code> and <code class="reqn">\mathbf{v}</code> are vectors of probabilities.
</p>
<p>The norming constants provide for <code class="reqn">-1 \le \beta^\diamond_\mathbf{C} \le +1</code>. Using the function argument defaults for <code class="reqn">d=2</code> dimensions <code class="reqn">\mathbf{u} = (1,1)/2</code> for <code>uu</code> and <code class="reqn">\mathbf{v} = (1,1)/2</code> for <code>vv</code>, results in (1) <code class="reqn">\beta^\diamond_\mathbf{C} = 1</code> if <code class="reqn">\mathbf{C} = \mathbf{M}</code> <em>comonotonicity copula</em> (<code>M</code>) (<code>blomCOPss(cop=M) == 1</code>), (2) <code class="reqn">\beta^\diamond_\mathbf{C} = 0</code> if <code class="reqn">\mathbf{C} = \mathbf{P}</code> <em>independence copula</em> (<code>P</code>) (<code>blomCOPss(cop=P) == 0</code>), and (3) if <code class="reqn">\mathbf{C} = \mathbf{W}</code> <em>countermonotonicity copula</em> (<code>W</code>)<code class="reqn">\beta^\diamond_\mathbf{C} = 1</code> (<code>blomCOPss(cop=W) == -1</code>).
</p>
<p>Schmid and Schmidt (2007) list three important cases extending the <code class="reqn">\mathbf{M}</code> and <code class="reqn">\mathbf{P}</code> examples. First, <code class="reqn">\beta^\diamond_\mathbf{C}(\mathbf{1/2}, \mathbf{1/2}) = \beta_\mathbf{C}(1/2, 1/2)</code>, which is <em>Blomqvist Beta</em> (<code class="reqn">\beta_\mathbf{C}(1/2, 1/2)</code>) (<code>blomCOP</code>) and measures overall dependence.
</p>
<p>Second, <code class="reqn">\beta^\diamond_\mathbf{C}(\mathbf{u}, \mathbf{v})</code> with <code class="reqn">\mathbf{u} &lt; 1/2 &lt; \mathbf{v}</code>, which measures dependence in the tail regions. (Note, the author of <span class="pkg">copBasic</span> thinks “regions” as a plural is need in the previous sentence; Schmid and Schmidt (2007) use the singular “region.” This is potentially important as seemingly simultaneous tail dependency in the lower and upper perspectives would be provided. More discussion is provided in <b>Examples</b>.)
</p>
<p>Third and presumably very important in practical applications, <code class="reqn">\mathrm{lim}_{p\downarrow 0}\, \beta^\diamond_\mathbf{C}(\mathbf{p}, \mathbf{1}) = \lambda^L_{\beta^\diamond_\mathbf{C}}</code> for <code class="reqn">\mathbf{p} = \mathbf{u} = (p,\cdots,p)</code> measures lower-tail dependence. This measure is equal to the <em>lower-tail dependence parameter</em> <code class="reqn">\lambda^L_\mathbf{C} = \lambda^L_{\beta^\diamond_\mathbf{C}}</code> without some of the computational nuances required as  <code class="reqn">\lambda^L_\mathbf{C}</code> is defined at <code>taildepCOP</code>.
</p>
<p>Schmid and Schmidt (2007) do not list how the <em>upper-tail dependence parameter</em> <code class="reqn">\lambda^U_\mathbf{C}</code> could be computed in terms of <code class="reqn">\beta^\diamond_\mathbf{C}</code>. The expression for study of the upper-tail dependency is <code class="reqn">\lambda^U_{\beta^\diamond_\mathbf{C}} = \beta^\diamond_\mathbf{C}(\mathbf{0}, \mathbf{p})</code> for <code class="reqn">\mathbf{p} = \mathbf{v} = (p,\cdots,p)</code> as <code class="reqn">p \rightarrow 0^+</code>, and <code class="reqn">\lambda^U_\mathbf{C} = \lambda^U_{\beta^\diamond_\mathbf{C}}</code> without some of the computational nuances required as <code class="reqn">\lambda^U_\mathbf{C}</code> is defined at <code>taildepCOP</code>. These tail dependencies are computed and compared in the <b>Examples</b> and confirmation of this function being used to estimate both tail-dependency parameters is confirmed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">blomCOPss(cop=NULL, para=NULL, uu=rep(0.5, 2), vv=rep(0.5, 2), trap.nan=TRUE,
          as.sample=FALSE, ctype=c("weibull", "hazen", "1/n",
                                   "bernstein", "checkerboard"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cop</code></td>
<td>
<p>A copula function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>Vector of parameters or other data structure, if needed, to pass to the copula;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uu</code></td>
<td>
<p>The vector for <code class="reqn">\mathbf{u}</code> and the defaults with <code>vv</code> as such for same operation as <code>blomCOP</code> (<code class="reqn">\beta^\diamond_\mathbf{C}(\mathbf{1/2}, \mathbf{1/2})</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vv</code></td>
<td>
<p>The vector for <code class="reqn">\mathbf{v}</code> and the defaults with <code>uu</code> as such for same operation as <code>blomCOP</code> (<code class="reqn">\beta^\diamond_\mathbf{C}(\mathbf{1/2}, \mathbf{1/2})</code>);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trap.nan</code></td>
<td>
<p>A logical to trigger 0 if <code class="reqn">(0,0)</code> is <code>NaN</code> or if <code class="reqn">(1,1)</code> is <code>NaN</code>. This feature is present on a package-specific purpose because the <code>PSP</code> copula deliberately retains edge <code>NaN</code> as a stress case;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.sample</code></td>
<td>
<p>A logical controlling whether an optional <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>data.frame</code> in <code>para</code> is used to compute the  <code class="reqn">\hat\beta^\diamond_\mathbf{C}</code> at which point the <code>ctype</code> argument will be passed to <code>EMPIRcop</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctype</code></td>
<td>
<p>Argument of the same as <code>EMPIRcop</code>; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to the copula.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The <code class="reqn">\beta^\diamond_\mathbf{C}</code> is returned.
</p>


<h3>Note</h3>

<p>Sample estimation of the <code class="reqn">\beta^\diamond_\mathbf{C}</code> is possible. The <code>as.sample</code> triggers internally a call to the <em>empirical copula</em> (<code class="reqn">\mathbf{C}_n</code>) (<code>EMPIRcop</code>) for the <code>ctype</code> for the copula and its survival function form. Expansive more details are provided by <code>taildepCOP</code> (section <b>Note</b>::<em>DEMONSTRATION (Tail Dependence)</em>). A comparison of the <code class="reqn">\hat\lambda^U_{\beta^\diamond_\mathbf{C}}</code> and <code class="reqn">\hat\lambda^U_{\beta^\diamond_\mathbf{C}}</code> is made.
</p>


<h3>Author(s)</h3>

<p>W.H. Asquith</p>


<h3>References</h3>

<p>Schmid, Friedrich, and Schmidt, Rafael, 2007, Nonparametric inference on multivariate versions of Blomqvist's beta and related measures of tail dependence: Metrika, v. 66, pp. 323–354, <a href="https://doi.org/10.1007/s00184-006-0114-3">doi:10.1007/s00184-006-0114-3</a>.
</p>


<h3>See Also</h3>

<p><code>blomCOP</code>, <code>blomatrixCOP</code>, <code>taildepCOP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">blomCOP(  cop=PSP) # [1] 0.3333333
blomCOPss(cop=PSP) # [1] 0.3333333

## Not run: 
# The calls below for blomCOPss() are technically the same for sample versions.
UV &lt;- simCOP(1000, cop=PSP, graphics=FALSE)  # HatBeta(0.1,0.9) = 0.277___
blomCOPss(para=UV, cop=EMPIRcop,   uu=c(0.1,0.1), vv=c(0.90,0.90))
blomCOPss(para=UV, as.sample=TRUE, uu=c(0.1,0.1), vv=c(0.90,0.90)) #
## End(Not run)

## Not run: 
set.seed(1)
para &lt;- c(3, 6) # define parameters of two-parameter GHcop
UV &lt;- simCOP(1000, cop=GHcop, para=para) # simulate to show general structure

# compute the tail dependencies from havling into the limits
taildepCOP(cop=GHcop, para=para, plot=TRUE)
# lower tail dependency = 0.96222
# upper tail dependency = 0.74008
# The two parameters influence how strongly the tail dependencies are.

# Schmid and Schmidt (2007, eq. 24) define the lower-tail dependency in terms of
# the Beta and p--&gt;0 Beta(c(p,p), c(1,1)). Lets compute these and produce content
# suitable to show on the tail-dependency plot that the assertion for the lower
# dependency by Beta() is correct, which it is and then extend to the upper-tail
# dependency parameter that the authors seem to not have defined.
usr &lt;- par()$usr[1:2]         # grab horizontal edges of the plot, and set up the
uuLO &lt;- rep(pnorm(usr[1]), 2) # the uu for the lower tail and the vv for the upper
vvUP &lt;- rep(pnorm(usr[2]), 2) # tail and then plot both with overplotting symbols
# lower-tail estimate and see how it plots along the value from taildepCOP()
SchmidsL &lt;- blomCOPss(cop=GHcop, para=para, uu=uuLO, vv=c(1,1))
points(usr[1], SchmidsL, col="darkgreen", cex=2, pch=1, lwd=2)
points(usr[1], SchmidsL, col="darkgreen", cex=2, pch=3, lwd=2)
points(usr[1], SchmidsL, col="darkgreen", cex=2, pch=4, lwd=2)
# upper-tail estimate and see how it plots along the value from taildepCOP()
SchmidsU &lt;- blomCOPss(cop=GHcop, para=para, uu=c(0,0), vv=vvUP)
points(usr[2], SchmidsU, col="darkgreen", cex=2, pch=1, lwd=2)
points(usr[2], SchmidsU, col="darkgreen", cex=2, pch=3, lwd=2)
points(usr[2], SchmidsU, col="darkgreen", cex=2, pch=4, lwd=2)
# SchmidsL lower tail dependency = 0.962224
# SchmidsU upper tail dependency = 0.740079
# The author has an expectation that the SchmidsL and SchmidsU values are
# more reliable than those stemming from taildepCOP() because of the limiting
# behavior (or its implementation therein) compared to direct computation by
# blomCOPss().

# Mow for sake of curiosity, let us see how the trajectory of the Blomqvist
# (Schmid--Schmidt) Betas at arriving at the tail dependencies as p--&gt;0|1.
# It is very informative that the trajectories of blomCOPss() and taildepCOP()
# as each hones towards the two dependency parameters are different and this
# highlights the fact that the computational underpinnings are different.
psl &lt;- pnorm(seq(0, usr[1], by=-diff(range(c(0, usr[1]))) / 1000))
lines(qnorm(psl), sapply(psl, function(p) {
              blomCOPss(cop=GHcop, para=para, uu=rep(p, 2), vv=c(1,1)) }),
      col="darkgreen", lty=2, lwd=2)
psu &lt;- pnorm(seq(0, usr[2], by= diff(range(c(0, usr[2]))) / 1000))
lines(qnorm(psu), sapply(psu, function(p) {
              blomCOPss(cop=GHcop, para=para, uu=c(0,0), vv=rep(p, 2)) }),
      col="darkgreen", lty=2, lwd=2) #
## End(Not run)
</code></pre>


</div>