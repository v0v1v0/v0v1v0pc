<div class="container">

<table style="width: 100%;"><tr>
<td>oneSE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Selecting tuning Parameters</h2>

<h3>Description</h3>

<p>Various functions for setting tuning parameters
</p>


<h3>Usage</h3>

<pre><code class="language-R">oneSE(x, metric, num, maximize)

tolerance(x, metric, tol = 1.5, maximize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data frame of tuning parameters and model results, sorted from
least complex models to the mst complex</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>a string that specifies what summary metric will be used to
select the optimal model. By default, possible values are "RMSE" and
"Rsquared" for regression and "Accuracy" and "Kappa" for classification. If
custom performance metrics are used (via the <code>summaryFunction</code> argument
in <code>trainControl</code>, the value of <code>metric</code> should match one
of the arguments. If it does not, a warning is issued and the first metric
given by the <code>summaryFunction</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num</code></td>
<td>
<p>the number of resamples (for <code>oneSE</code> only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximize</code></td>
<td>
<p>a logical: should the metric be maximized or minimized?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the acceptable percent tolerance (for <code>tolerance</code> only)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions can be used by <code>train</code> to select the "optimal"
model from a series of models. Each requires the user to select a metric
that will be used to judge performance. For regression models, values of
<code>"RMSE"</code> and <code>"Rsquared"</code> are applicable. Classification models
use either <code>"Accuracy"</code> or <code>"Kappa"</code> (for unbalanced class
distributions.
</p>
<p>More details on these functions can be found at
<a href="http://topepo.github.io/caret/model-training-and-tuning.html#custom">http://topepo.github.io/caret/model-training-and-tuning.html#custom</a>.
</p>
<p>By default, <code>train</code> uses <code>best</code>.
</p>
<p><code>best</code> simply chooses the tuning parameter associated with the largest
(or lowest for <code>"RMSE"</code>) performance.
</p>
<p><code>oneSE</code> is a rule in the spirit of the "one standard error" rule of
Breiman et al. (1984), who suggest that the tuning parameter associated with
the best performance may over fit. They suggest that the simplest model
within one standard error of the empirically optimal model is the better
choice. This assumes that the models can be easily ordered from simplest to
most complex (see the Details section below).
</p>
<p><code>tolerance</code> takes the simplest model that is within a percent tolerance
of the empirically optimal model. For example, if the largest Kappa value is
0.5 and a simpler model within 3 percent is acceptable, we score the other
models using <code>(x - 0.5)/0.5 * 100</code>. The simplest model whose score is
not less than 3 is chosen (in this case, a model with a Kappa value of 0.35
is acceptable).
</p>
<p>User-defined functions can also be used. The argument
<code>selectionFunction</code> in <code>trainControl</code> can be used to pass
the function directly or to pass the function by name.
</p>


<h3>Value</h3>

<p>a row index
</p>


<h3>Note</h3>

<p>In many cases, it is not very clear how to order the models on
simplicity. For simple trees and other models (such as PLS), this is
straightforward. However, for others it is not.
</p>
<p>For example, many of the boosting models used by <span class="pkg">caret</span> have parameters
for the number of boosting iterations and the tree complexity (others may
also have a learning rate parameter). In this implementation, we order
models on number of iterations, then tree depth. Clearly, this is arguable
(please email the author for suggestions though).
</p>
<p>For MARS models, they are orders on the degree of the features, then the
number of retained terms.
</p>
<p>RBF SVM models are ordered first by the cost parameter, then by the kernel
parameter while polynomial models are ordered first on polynomial degree,
then cost and scale.
</p>
<p>Neural networks are ordered by the number of hidden units and then the
amount of weight decay.
</p>
<p>k-nearest neighbor models are ordered from most neighbors to least (i.e.
smoothest to model jagged decision boundaries).
</p>
<p>Elastic net models are ordered first on the L1 penalty, then by the L2
penalty.
</p>


<h3>Author(s)</h3>

<p>Max Kuhn
</p>


<h3>References</h3>

<p>Breiman, Friedman, Olshen, and Stone. (1984)
<em>Classification and Regression Trees</em>. Wadsworth.
</p>


<h3>See Also</h3>

<p><code>train</code>, <code>trainControl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
# simulate a PLS regression model
test &lt;- data.frame(ncomp = 1:5,
                   RMSE = c(3, 1.1, 1.02, 1, 2),
                   RMSESD = .4)

best(test, "RMSE", maximize = FALSE)
oneSE(test, "RMSE", maximize = FALSE, num = 10)
tolerance(test, "RMSE", tol = 3, maximize = FALSE)

### usage example

data(BloodBrain)

marsGrid &lt;- data.frame(degree = 1, nprune = (1:10) * 3)

set.seed(1)
marsFit &lt;- train(bbbDescr, logBBB,
                 method = "earth",
                 tuneGrid = marsGrid,
                 trControl = trainControl(method = "cv",
                                          number = 10,
                                          selectionFunction = "tolerance"))

# around 18 terms should yield the smallest CV RMSE

## End(Not run)


</code></pre>


</div>