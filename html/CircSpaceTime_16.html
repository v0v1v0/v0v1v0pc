<div class="container">

<table style="width: 100%;"><tr>
<td>WrapSpTi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Samples from the posterior distribution of the Wrapped Normal spatial temporal model</h2>

<h3>Description</h3>

<p>The <code>WrapSpTi</code> function returns samples from the posterior distribution of the spatio-temporal Wrapped Gaussian Model
</p>


<h3>Usage</h3>

<pre><code class="language-R">WrapSpTi(x = x, coords = coords, times, start = list(alpha = c(2, 1),
  rho_sp = c(0.1, 0.5), rho_t = c(0.1, 1), sep_par = c(0.01, 0.1), k =
  sample(0, length(x), replace = T)), priors = list(alpha = c(pi, 1, -10,
  10), rho_sp = c(8, 14), rho_t = c(1, 2), sep_par = c(0.001, 1), sigma2 =
  c()), sd_prop = list(rho_sp = 0.5, rho_t = 0.5, sep_par = 0.5, sigma2 =
  0.5), iter = 1000, BurninThin = c(burnin = 20, thin = 10),
  accept_ratio = 0.234, adapt_param = c(start = 1, end = 1e+07, exp =
  0.9), n_chains = 1, parallel = FALSE, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>.
If they are not in <code class="reqn">[0,2\pi)</code>, the function will transform
the data into the right interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>an n vector with the times of the observations x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a vector with <code>n_chains</code> elements
</p>

<ul>
<li>
<p>     alpha the mean which value is in <code class="reqn">[0,2\pi)</code>
</p>
</li>
<li>
<p>  rho_sp the spatial decay parameter,
</p>
</li>
<li>
<p>  rho_t the temporal decay parameter,
</p>
</li>
<li>
<p>  sigma2 the process variance,
</p>
</li>
<li>
<p>  sep_par the separation parameter,
</p>
</li>
<li>
<p>  k the vector of <code>length(x)</code>  winding numbers
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list of 5 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha</dt>
<dd>
<p>a vector of 2 elements the mean and the variance of  a Gaussian distribution, default is  mean <code class="reqn">\pi</code> and variance 1,</p>
</dd>
<dt>rho_sp</dt>
<dd>
<p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>rho_t</dt>
<dd>
<p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>sep_par</dt>
<dd>
<p>a vector of 2 elements defining the two parameters of a beta distribution,</p>
</dd>
<dt>sigma2</dt>
<dd>
<p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_prop</code></td>
<td>
<p>list of 3 elements. To run the MCMC for the rho_sp and sigma2 parameters we use an adaptive metropolis and in sd_prop we build a list of initial guesses for these two parameters and the beta parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>iter number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt_param</code></td>
<td>
<p>a vector of 3 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) and it is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>it returns a list of <code>n_chains</code> lists each with elements
</p>

<dl>
<dt>
<code>alpha</code>, <code>rho_sp</code>, <code>rho_t</code>, <code>sep_par</code>, <code>sigma2</code>
</dt>
<dd>
<p>vectors with the thinned chains</p>
</dd>
<dt><code>k</code></dt>
<dd>
<p>a matrix with <code>nrow = length(x)</code> and <code>ncol = </code> the length of thinned chains</p>
</dd>
<dt><code>distribution</code></dt>
<dd>
<p>characters, always "WrapSpTi" </p>
</dd>
</dl>
<h3>Implementation Tips</h3>

<p>To facilitate the estimations, the observations x
are centered around pi,
and the prior and starting value of alpha are changed accordingly.
After the estimations, posterior samples of alpha are changed
back to the original scale
</p>


<h3>References</h3>

<p>G. Mastrantonio, G. Jona Lasinio,
A. E. Gelfand, "Spatio-temporal circular models with
non-separable covariance structure", TEST 25 (2016), 331â€“350.
</p>
<p>T. Gneiting,  "Nonseparable, Stationary Covariance Functions for Space-Time
Data", JASA 97 (2002), 590-600
</p>


<h3>See Also</h3>

<p><code>WrapKrigSpTi</code> for spatio-temporal prediction,
<code>ProjSpTi</code> to sample from the posterior distribution of the spatio-temporal
Projected Normal model and <code>ProjKrigSpTi</code> for spatio-temporal prediction under the same model
</p>
<p>Other spatio-temporal models: <code>ProjSpTi</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(CircSpaceTime)
## functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

######################################
## Simulation                       ##
######################################
set.seed(1)
n &lt;- 20
### simulate coordinates from a unifrom distribution
coords  &lt;- cbind(runif(n,0,100), runif(n,0,100)) #spatial coordinates
coordsT &lt;- sort(runif(n,0,100)) #time coordinates (ordered)
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho     &lt;- 0.05 #spatial decay
rhoT    &lt;- 0.01 #temporal decay
sep_par &lt;- 0.5 #separability parameter
sigma2  &lt;- 0.3 # variance of the process
alpha   &lt;- c(0.5)
#Gneiting covariance
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist/(rhoT * DistT^2 + 1)^(sep_par/2))

Y &lt;- rmnorm(1,rep(alpha, times = n), SIGMA) #generate the linear variable
theta &lt;- c()
## wrapping step
for(i in 1:n) {
  theta[i] &lt;- Y[i] %% (2*pi)
}
### Add plots of the simulated data

rose_diag(theta)
## use this values as references for the definition of initial values and priors
rho_sp.min &lt;- 3/max(Dist)
rho_sp.max &lt;- rho_sp.min+0.5
rho_t.min  &lt;- 3/max(DistT)
rho_t.max  &lt;- rho_t.min+0.5
val &lt;- sample(1:n,round(n*0.2)) #validation set
set.seed(100)
mod &lt;- WrapSpTi(
  x       = theta[-val],
  coords    = coords[-val,],
  times    = coordsT[-val],
  start   = list("alpha"      = c(.79, .74),
                 "rho_sp"     = c(.33,.52),
                 "rho_t"     = c(.19, .43),
                 "sigma2"    = c(.49, .37),
                 "sep_par"  = c(.47, .56),
                 "k"       = sample(0,length(theta[-val]), replace = TRUE)),
  priors   = list("rho_sp"      = c(0.01,3/4), ### uniform prior on this interval
                  "rho_t"      = c(0.01,3/4), ### uniform prior on this interval
                  "sep_par"  = c(1,1), ### beta prior
                  "sigma2"    = c(5,5),## inverse gamma prior with mode=5/6
                  "alpha" =  c(0,20) ## wrapped gaussian with large variance
  )  ,
  sd_prop   = list( "sigma2" = 0.1,  "rho_sp" = 0.1,  "rho_t" = 0.1,"sep_par"= 0.1),
  iter    = 7000,
  BurninThin    = c(burnin = 3000, thin = 10),
  accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1000, exp = 0.5),
  n_chains = 2 ,
  parallel = FALSE,
  n_cores = 1
)
check &lt;- ConvCheck(mod,startit = 1 ,thin = 1)
check$Rhat ## convergence has been reached
## when plotting chains remember that alpha is a circular variable
par(mfrow = c(3,2))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))

#### move to the prediction step with WrapKrigSpTi
</code></pre>


</div>