<div class="container">

<table style="width: 100%;"><tr>
<td>ereduce</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find all minimal disjunctive normal forms (DNF) of an input DNF</h2>

<h3>Description</h3>

<p><code>ereduce</code> builds all minimal disjunctive normal forms corresponding to an input DNF. It is similar to <code>rreduce</code>, which, however, only builds one minimal DNF at random.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ereduce(cond, x = full.ct(cond), full = !missing(x), 
        simplify2constant = TRUE, maxCombs = 1e7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>

<p>A character string specifying a disjunctive normal form (DNF); can be either crisp-set or multi-value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A 
<code>configTable</code> or <code>data.frame</code>; can be either crisp-set or multi-value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>

<p>Logical; if <code>TRUE</code>, redundancies are eliminated relative to <code>full.ct(x)</code>, otherwise relative to <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify2constant</code></td>
<td>

<p>Logical; if <code>TRUE</code> (the default), a tautologous or contradictory <code>cond</code> is reduced to a constant <code>"1"</code> or <code>"0"</code>, respectively. If <code>FALSE</code>, a minimal tautology or contradiction, i.e. <code>"A+a"</code> or <code>"A*a"</code>, will result.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxCombs</code></td>
<td>

<p>Maximal number of iterations that will be ran in the most time-consuming step. If the number of necessary iterations exceeds <code>maxCombs</code>, <code>ereduce</code> will stop executing and return an error message stating the necessary number of iterations. Early termination can then be avoided by increasing <code>maxCombs</code> accordingly.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>ereduce</code> eliminates conjuncts and disjuncts from a DNF <code>cond</code> as long as the result of <code>condition(cond, x)</code> remains the same. The only required argument is <code>cond</code>. If <code>x</code> is not provided, redundancies are eliminated relative to <code>full.ct(cond)</code>. 
</p>
<p><code>ereduce</code> generates all redundancy-free forms of <code>cond</code>, while <code>rreduce</code> only returns one randomly chosen one. <code>rreduce</code> is faster than <code>ereduce</code>, but often incomplete. In a nutshell,  <code>ereduce</code> searches for minimal hitting sets in <code>cond</code> preventing <code>cond</code> from being false in data <code>x</code>.
</p>


<h3>Value</h3>

<p>A vector of redundancy-free disjunctive normal forms (DNF).
</p>


<h3>See Also</h3>

<p><code>rreduce</code>, <code>full.ct</code>, <code>conCovOpt</code>, <code>DNFbuild</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Logical redundancies.
cond1 &lt;- "A*b + a*B + A*C + B*C"
ereduce(cond1)
rreduce(cond1) # repeated calls generate different outputs
cond2 &lt;- "A*b + a*B + A*B + a*b"
ereduce(cond2)
ereduce(cond2, simplify2constant = FALSE)

# Redundancy elimination relative to simulated cs data.
dat1 &lt;- data.frame(
  A = c(0, 0, 0, 0, 1, 1, 0, 1), 
  B = c(0, 1, 0, 1, 1, 0, 0, 0), 
  C = c(1, 1, 0, 1, 1, 0, 1, 1), 
  D = c(0, 0, 0, 0, 0, 1, 1, 1))
cco1 &lt;- conCovOpt(dat1, "D")
best1 &lt;- selectMax(cco1)
(formula1 &lt;- DNFbuild(best1, outcome = "D", reduce = FALSE))
# ereduce
ereduce(formula1, dat1, full = FALSE)
# rreduce
rreduce(formula1, dat1, full = FALSE)

# Redundancy elimination relative to simulated mv data.
dat2 &lt;- data.frame(
  A = c(3,2,1,1,2,3,2,2,2,1,1,2,3,2,2,2,1,2,3,3,3,1,1,1,3,1,2,1,2,3,3,2,2,2,1,2,2,3,2,1,2,1,3,3),
  B = c(1,2,3,2,1,1,2,1,2,2,3,1,1,1,2,3,1,3,3,3,1,1,3,2,2,1,1,3,3,2,3,1,2,1,2,2,1,1,2,2,3,3,3,3),
  C = c(1,3,3,3,1,1,1,2,2,3,3,1,1,2,2,2,3,1,1,2,1,2,2,3,3,1,2,2,2,3,2,1,1,2,2,2,1,1,1,2,2,1,1,2),
  D = c(3,1,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,1,1,1,1,1,2,2,2,2,2,3,1,1,1,1,1,2,2,2,2,2,3,3,3),
  E = c(3,2,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3)
)
cco2 &lt;- conCovOpt(dat2, "D=3")
best2 &lt;- selectMax(cco2)
(formula2 &lt;- DNFbuild(best2, outcome = "D=3", reduce = FALSE))
# ereduce
ereduce(formula2, dat2, full = FALSE)
# rreduce
rreduce(formula2, dat2, full = FALSE)

# Any Boolean expressions.
cond &lt;- "!(A*B*C)*!(a*b*c)" # or "A + B*!(D + e) &lt;-&gt; C" 
x &lt;- selectCases(cond) 
(cond &lt;- cna:::getCond(x)) # returns a DNF equivalent to cond, but with many redundancies
ereduce(cond)
rreduce(cond)
</code></pre>


</div>