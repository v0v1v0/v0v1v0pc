<div class="container">

<table style="width: 100%;"><tr>
<td>async_generator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct an async generator</h2>

<h3>Description</h3>

<p>An async generator constructs iterable functions that are also
awaitables. They support both the <code>yield()</code> and <code>await()</code> syntax.
An async iterator can be looped within async functions and
iterators using <code>await_each()</code> on the input of a <code>for</code> loop.
</p>
<p>The iteration protocol is derived from the one described in
<code>iterator</code>. An async iterator always returns a
promise. When the iterator is exhausted, it returns a resolved
promise to the exhaustion sentinel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">async_generator(fn)

await_each(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>An anonymous function describing an async generator
within which <code>await()</code> calls are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An awaitable value, i.e. a promise.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A generator factory. Generators constructed with this
factory always return <code>promises::promise()</code>.
</p>


<h3>See Also</h3>

<p><code>async()</code> for creating awaitable functions;
<code>async_collect()</code> for collecting the values of an async iterator;
<code>coro_debug()</code> for step-debugging.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Creates awaitable functions that transform their inputs into a stream
generate_stream &lt;- async_generator(function(x) for (elt in x) yield(elt))

# Maps a function to a stream
async_map &lt;- async_generator(function(.i, .fn, ...) {
  for (elt in await_each(.i)) {
    yield(.fn(elt, ...))
  }
})

# Example usage:
if (interactive()) {
  library(magrittr)
  generate_stream(1:3) %&gt;% async_map(`*`, 2) %&gt;% async_collect()
}
</code></pre>


</div>