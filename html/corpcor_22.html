<div class="container">

<table style="width: 100%;"><tr>
<td>pseudoinverse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pseudoinverse of a Matrix</h2>

<h3>Description</h3>

<p>The standard definition for the inverse of a matrix fails 
if the matrix is not square or singular. However, one can
generalize the inverse using singular value decomposition.
Any rectangular real matrix M can be decomposed as
</p>
<p style="text-align: center;"><code class="reqn">M = U D V^{'},</code>
</p>

<p>where U and V are orthogonal, V' means V transposed, and 
D is a diagonal matrix containing only the positive singular values
(as determined by <code>tol</code>, see also <code>fast.svd</code>). 
</p>
<p>The pseudoinverse, also known as Moore-Penrose or generalized inverse
is then obtained as
</p>
<p style="text-align: center;"><code class="reqn">iM = V D^{-1} U^{'}</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">pseudoinverse(m, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance - singular values larger than
tol are considered non-zero (default value:
<code>tol = max(dim(m))*max(D)*.Machine$double.eps</code>)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

  
<p>The pseudoinverse has the property that the sum of the squares of all
the entries in <code>iM %*% M - I</code>, where I is an appropriate
identity matrix, is minimized. For non-singular matrices the
pseudoinverse is equivalent to the standard inverse.
</p>


<h3>Value</h3>

<p>A matrix (the pseudoinverse of m).
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code>solve</code>, <code>fast.svd</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># load corpcor library
library("corpcor")

# a singular matrix
m = rbind(
c(1,2),
c(1,2)
)

# not possible to invert exactly
try(solve(m))

# pseudoinverse
p = pseudoinverse(m)
p

# characteristics of the pseudoinverse
zapsmall( m %*% p %*% m )  ==  zapsmall( m )
zapsmall( p %*% m %*% p )  ==  zapsmall( p )
zapsmall( p %*% m )  ==  zapsmall( t(p %*% m ) )
zapsmall( m %*% p )  ==  zapsmall( t(m %*% p ) )


# example with an invertable matrix
m2 = rbind(
c(1,1),
c(1,0)
)
zapsmall( solve(m2) ) == zapsmall( pseudoinverse(m2) )
</code></pre>


</div>