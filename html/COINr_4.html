<div class="container">

<table style="width: 100%;"><tr>
<td>Aggregate.purse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate indicators</h2>

<h3>Description</h3>

<p>Aggregates indicators following the structure specified in <code>iMeta</code>, for each coin inside the purse.
See <code>Aggregate.coin()</code>, which is applied to each coin, for more information
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'purse'
Aggregate(
  x,
  dset,
  f_ag = NULL,
  w = NULL,
  f_ag_para = NULL,
  dat_thresh = NULL,
  write_to = NULL,
  by_df = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A purse-class object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_ag</code></td>
<td>
<p>The name of an aggregation function, a string. This can either be a single string naming
a function to use for all aggregation levels, or else a character vector of function names of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure. In this latter case, a different aggregation function may be used for each level
in the index: the first in the vector will be used to aggregate from Level 1 to Level 2, the second from Level 2 to Level 3, and
so on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>An optional data frame of weights. If <code>f_ag</code> does not require accept weights, set to <code>"none"</code>. Alternatively, can be the
name of a weight set found in <code>.$Meta$Weights</code>. This can also be specified as a list specifying the aggregation weights for each
level, in the same way as the previous parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_ag_para</code></td>
<td>
<p>Optional parameters to pass to <code>f_ag</code>, other than <code>x</code> and <code>w</code>. As with <code>f_ag</code>, this can specified to have different
parameters for each aggregation level by specifying as a nested list of length <code>n-1</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat_thresh</code></td>
<td>
<p>An optional data availability threshold, specified as a number between 0 and 1. If a row
within an aggregation group has data availability lower than this threshold, the aggregated value for that row will be
<code>NA</code>. Data availability, for a row <code>x_row</code> is defined as <code>sum(!is.na(x_row))/length(x_row)</code>, i.e. the
fraction of non-<code>NA</code> values. Can also be specified as a vector of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure, to specify different data availability thresholds by level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Aggregated"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_df</code></td>
<td>
<p>Controls whether to send a numeric vector to <code>f_ag</code> (if <code>FALSE</code>, default) or a data frame (if <code>TRUE</code>) - see
details. Can also be specified as a logical vector of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An updated purse with new treated data sets added at <code>.$Data[[write_to]]</code> in each coin.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># build example purse up to normalised data set
purse &lt;- build_example_purse(up_to = "Normalise", quietly = TRUE)

# aggregate using defaults
purse &lt;- Aggregate(purse, dset = "Normalised")

</code></pre>


</div>